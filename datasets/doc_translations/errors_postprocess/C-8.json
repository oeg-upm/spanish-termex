{
    "id": "C-8",
    "original_text": "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications. The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions. The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements. Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms. After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution. In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm. The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3. The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions. We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications. Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1. INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4]. In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16]. To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems. The soundness of the theoretical foundation for OT is crucial in this process. One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution. However, the theory of causality is inadequate to capture essential OT conditions for correct transformation. The limitation of the causality theory had caused correctness problems from the very beginning of OT. The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent. However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation. Another condition is that the two concurrent operations must be defined on the same document state. In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22]. This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms. The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors. The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations. In fact, the causality relation is not defined for inverse operations (see Section 2). Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21]. After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution. In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm. The rest of this paper is organized as follows. First, we define causal-dependency/-independency and briefly describe their limitations in Section 2. Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3. In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties. Then, these transformation properties and their pre-conditions are discussed in Section 5. The COT solutions to these transformation properties are presented in Section 6. Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7. Finally, major contributions of this work are summarized in Section 8. 2. LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms. Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23]. Definition 1. Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2. Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23]. To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1. There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1. According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation. In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23]. This term is introduced to differentiate this special transformation function from other steps involved in a transformation process. Figure 1: A real-time group editing scenario. The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle. Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state. When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state. In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly. The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22]. From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g. O1, O2 and O3) directly generated by users, but not for transformed operations (e.g. O1). Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23]. Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations. The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2. The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e. O1 and O3) [21]. To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution. However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3. If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect. Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3. OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined. The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same. In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2). When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1. O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state. When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2. O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle. As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context. In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations. Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations. For any operation O, its inverse is denoted by O. Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O. If O is an original operation, then org(O) = O. Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation. In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document. These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]). We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state. Definition 3. Document state representation A document state can be represented by DS as follows: 1. The initial document state is represented by DS = {}. 2. After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations. Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated. To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O). According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O). More precisely, the context of an operation is defined blow. Definition 4. The context of an operation 1. For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2. For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3. For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations. For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1. According to Definition 4-Item 2, we have C(O2) = {O2}. From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type. Definition 5. Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed). This is because any operation has a context, but only original operations can be included in a context. Definition 6. Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob. In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution. CC1 ensures that O is always executed after the contextdependent operations included in C(O). In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O. When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22]. When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21]. CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS. CC2 ensures that O is transformed against all contextindependent operations in DS before its execution. It can be shown that, for any Ox in DS − C(O), it must be that Ox c O. When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22]. When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21]. CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS. CC3 is required for correctly executing operations. CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob). CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3). CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob. CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob. It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob. CC6 is required for correctly applying IT functions. In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation. These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way. For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation. Let Oij be an original normal operation generated at site i with a sequence number j. If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4. Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations. All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation. Each original inverse operation directly or indirectly corresponds to exactly one original normal operation. For example, inverse operation O may be generated to undo O, and O may be generated to undo O. Both O and O correspond to the same normal operation O. Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation. Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group. For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2. In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group. Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group. Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations. The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i. If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7. Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4]. The vector representation of operation context can also be used as the vector representation of the document state. As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1. Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}. This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3). Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations. Due to space limitation, these technical details are omitted in this paper. 4. THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far. This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations. We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy. In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O). When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation. The set of operations in C(O) can be easily determined from DS based on the information in CV (O). The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo. Both parts share the same core context-based transformation procedure. Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation. COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS. Algorithm 1. COT-DO(O, DS) 1. transform(O, DS − C(O)); 2. Execute O; DS := DS ∪ {org(O)}. Procedure 1. transform(O, CD) Repeat until CD = { }: 1. Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2). This is to upgrade the context of O to DS. In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2). The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined. This procedure repeats the following three steps until CD becomes empty: 1. Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4). An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2. The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5). This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3. After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3). To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1. Consider the operation executions at site 0, with the initial document state DS0 = { }. 1. After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2. When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}. Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}. Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3. When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}. Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle. In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}. Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1). After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user. How to generate the undo command for selecting any operation to undo is part of the undo policy [21]. This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context. In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself. COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation. Algorithm 2. COT-UNDO(O, DS) 1. O := makeInverse(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O. For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}. First, O2 and C(O2) = {O2} are created. Then, COT-DO is invoked with parameters O2 and DS. Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}. This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations. This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations. The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime. Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5. TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions. Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters. Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system. Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components. Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21]. Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses. The makeInverse(O) procedure directly follows these definitions. 1. Convergence Property 1 (CP1)3 . Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2. Convergence Property 2 (CP2). Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3. Inverse Property 2 (IP2)4 . Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4. Inverse Property 3 (IP3). Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa. The above transformation properties are important discoveries of past research, but they are not unconditionally required. The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature. To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1. PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2. PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3. PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4. PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties. Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3. Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11]. IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7). Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole. In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6. COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5). With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3. The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part). Procedure 2. transform(O, CD) 1. If CD = { }, ensure TPsafety(O, CD); 2. Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedure 3. ensure TPsafety(O, CD) 1. Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2. Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3. Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD). Procedure 4. make IP3safe Inverse(O, CD) 1. O := makeInverse(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4. O := makeInverse(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()). If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order. Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2. It should be noted that CD becomes an ordered set after the sorting. The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2. A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations. There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12]. The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2. This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD. An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O. Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3. The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2). This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD. The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7. DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21]. In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined. This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders. There was no explicit representation of an operation context. Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21]. In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined. This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set. Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured. Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context. The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well. Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations. However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations. The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime. The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3. The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole. COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions. The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3. In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21]. An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution. Under this scheme, inverse operations are not explicitly represented in the history buffer. When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair. To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21]. However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations. In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated. Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage. These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme. In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21]. Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function. In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy. This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level. We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group. When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement. If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version. Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage. By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence. COT is not the first OT algorithm that buffers and uses original operations for transformation. Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations. COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research. In this section, we provide our observations and opinions on some important OT correctness issues. OT is a complex system with multiple interrelated components. A system-oriented approach is needed for addressing OT issues. An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions. Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results. The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system. In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails. In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design. Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions. Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined. In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification. A systematic approach is needed in conducting both experimental and theoretic OT research. Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete. For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21]. A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them. On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component. For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult. However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them. Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components. Caution must be taken in interpreting correctness results. For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems. In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems. They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21]. They are unnecessary if the pre-conditions for requiring them have been broken. For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23]. CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12]. One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations. An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties. This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23]. It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2. In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well. For alternative views and approaches to this problem, the reader is referred to [8, 11, 5]. The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios. In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions. Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8. CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm. The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems. The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions. The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24]. Real-world applications provide exciting opportunities and challenges to future OT research. The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications. Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9. REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer. Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. A calculus for concurrent update. In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu. Generalizing operational transformation to the standard general markup language. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs. Concurrency control in groupware systems. In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang. Consistency maintenance based on the mark & retrace technique in groupware systems. In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari. On the consistency problem in mobile distributed computing. In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002. ACM. [7] C. Ignat and M.C. Norrie. Customizable collaborative editor relying on treeOPT algorithm. In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch. Proving correctness of transformation functions in real-time groupware. In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport. Time, clocks, and the ordering of events in a distributed system. Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li. Transparent sharing and interoperation of heterogeneous single-user applications. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li. Preserving operation effects relation in group editors. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun. A time interval based consistency control algorithm for interactive groupware applications. In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack. Proof of correctness of Ressels adOPTed algorithm. Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack. Operation transforms for a distributed shared spreadsheet. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister. A framework for undoing actions in collaborative systems. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins. Automating semantics-based reconciliation for mobile databases. In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal. Logical time: capturing causality in distributed systems. IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser. Reducing the problems of group undo. In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser. An integrating, transformation-oriented approach to concurrency control and undo in group editors. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun. A flexible notification framework for collaborative systems. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun. Undo as concurrent inverse in group editors. ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis. Operational transformation in real-time group editors: issues, algorithms, and achievements. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen. Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems. ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai. Transparent adaptation of single-user applications for multi-user real-time collaboration. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen. Operational transformation for collaborative word processing. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman. Copies convergence in a distributed real-time collaborative environment. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen. A collaborative table editing technique based on transparent adaptation. In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen. Object-associated telepointer for real-time collaborative document editing systems. In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen. Leveraging single-user applications for multi-user collaboration: the CoWord approach. In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288",
    "original_translation": "Operación contexto y transformación operativa basada en el contexto División de informática David Sun, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Nanyang Universidad Tecnológica Singapur czsun@ntu.edu.sg Abstract Operational Transformación (OT) es una técnica para el mantenimiento de consistencia y la deshacer del grupo, y se aplica a un número creciente de aplicaciones de colaboración. La base teórica para OT es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es inadecuado capturar los requisitos de corrección esenciales. Investigaciones anteriores habían inventado varios parches para resolver este problema, lo que resultó en algoritmos OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos OT, reflexionamos sobre lo que se había aprendido y nos propusimos desarrollar un nuevo marco teórico para una mejor comprensión y resolución de problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en el contexto). El algoritmo COT es capaz de admitir tanto DO y deshacer cualquier operación en cualquier momento, sin requerir funciones de transformación para preservar la propiedad de reversibilidad, Convergencia Propiedad 2, Propiedades inversas 2 y 3. El algoritmo COT no solo es más simple y más eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo usamos para soportar una gama de aplicaciones de colaboración novedosas. Categorías y descriptores de sujetos c.2.4 [Redes de comunicación por computadora]: aplicaciones distribuidas de sistemas distribuidos;H.5.3 [Interfaces de información y presentación]: Interfaces de grupo y organización Computación colaborativa;Algoritmos de términos generales de interacción sincrónica, diseño, teoría 1. Introducción La transformación operativa (OT) se inventó originalmente para el mantenimiento de consistencia en editores de grupos de texto simple [4]. En más de 15 años, OT ha evolucionado para respaldar un número creciente de aplicaciones, incluida la deshacer de grupos [15, 19, 18, 21], la conciencia de grupo [28], la notificación de operación y la compresión [20], la hoja de cálculo y las aplicaciones centradas en la mesa[14, 27], html/xml y edición de documentos estructurados en árbol [3, 7], procesamiento de textos y creación de diapositivas [29, 25, 24], intercambio de aplicaciones transparentes y heterogéneos [1, 10, 24] y móviles y móvilesSistemas de computación y base de datos replicados [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos continuar mejorando la capacidad y la calidad de OT para resolver problemas antiguos y nuevos. La solidez de la base teórica para OT es crucial en este proceso. Una base teórica de todos los algoritmos OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal;Las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es inadecuada para capturar condiciones de OT esenciales para la transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el comienzo de OT. El algoritmo DOPT fue el primer algoritmo OT y se basó únicamente en las relaciones de concurrencia entre las operaciones [4]: un par de operaciones son transformables siempre que sean concurrentes. Sin embargo, la investigación posterior descubrió que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben definirse en el mismo estado de documento. De hecho, el fracaso para cumplir con la segunda condición fue la raíz del Dopt-Puzzle [22]. Este rompecabezas se resolvió de varias maneras, pero la teoría de la causalidad y su limitación fueron heredadas por todos los algoritmos de seguimiento. La limitación de la teoría de la causalidad se volvió aún más prominente cuando se aplicó OT para resolver el problema de deshacer en los editores grupales. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer de nivel meta) y otras operaciones de edición normales. De hecho, la relación de causalidad no se define para las operaciones inversas (ver Sección 2). Se inventaron varios parches para resolver este problema, lo que resultó en algoritmos OT más intrincados complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos OT de mayor complejidad, reflexionamos sobre lo que se había aprendido y nos propusimos desarrollar un marco teórico uniformado para comprender y resolver problemas de OT, reducir su complejidad y 279 que respaldan suevolución continua. En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en el contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos dependencia causal/independencia y describimos brevemente sus limitaciones en la Sección 2. Luego, presentamos los elementos clave de la teoría del contexto de la operación, incluida la definición del contexto de la operación, las relaciones de dependencia de contexto/independencia, las condiciones basadas en el contexto y los vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para soportar el mantenimiento de consistencia (DO) y el grupo deshacer bajo el supuesto de que las funciones de transformación subyacentes pueden preservar algunas propiedades de transformación importantes. Luego, estas propiedades de transformación y sus pre-condiciones se discuten en la Sección 5. Las soluciones COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo OT previo, los problemas de corrección y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8. 2. Limitaciones de la causalidad La teoría de la causalidad es fundamental para la computación distribuida y el diseño de todos los algoritmos OT existentes. Después de Lamport [9], las relaciones causales de dependencia/independencia entre las operaciones de edición se pueden definir en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones OA y OB, generadas en los Sitios I y J, OB depende causal de OA, denotado por OA → OB, IFF: (1) I = J y la generación de OA ocurrió antes de la generaciónde ob;o (2) i = j y la ejecución de OA en el sitio j ocurrió antes de la generación de OB;o (3) existe una operación de buey, de modo que OA → Ox y Ox → Ob.2 Definición 2. Relación de independencia causal dadas dos operaciones OA y OB, OA y OB son causalinables u concurrentes, denotadas por OA OB, si no ni OA → OB, ni OB → OA.2 Así como los relojes lógicos vectoriales se utilizan para capturar la casualidad en los sistemas distribuidos [17], los vectores estatales se han utilizado para capturar relaciones causales entre las operaciones y representar los estados de documentos en los sistemas OT [4, 19, 23]. Para ilustrar las relaciones causales entre las operaciones, considere una sesión de edición grupal en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (el comando deshacer deshacer (O2) y su relación con otras operaciones se explicará más adelante): O1 generado en el Sitio 0, y O2 y O3 generados en el Sitio 1. De acuerdo con las definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes de la generación de O3;O1 O2 y O1 O3 Debido a que para cada par, ninguna de las operaciones ocurrió antes de la generación de otras operaciones. En la siguiente discusión, utilizaremos el término ittransform para significar el uso de la función de TI (transformación de inclusión): IT (OA, OB), que transforma la operación OA contra la operación OB de tal manera que el impacto de OB se incluye efectivamenteen OA [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición grupal en tiempo real. El escenario en la Figura 1 (sin el comando deshacer) a menudo se ha utilizado para ilustrar el dopt-huzzle. Bajo el algoritmo DOPT [4], cuando O2 llega al Sitio 0, se informará contra O1 desde O2 O1;Esto es correcto porque O2 y O1 se definen en el mismo estado de documento (inicial). Cuando O3 llega al Sitio 0, también se transformará contra O1 desde O3 O1;Pero esto es incorrecto porque O3 se define en el estado del documento que contiene el efecto de O2, mientras que O1 se define en el estado de documento inicial. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, pueden no ser transformados correctamente. La solución a este rompecabezas es la primera en la transformación de TI O1 contra O2 para producir O1, que se define en el estado del documento, incluido el efecto de O2 (el mismo estado en el que se define O3), y luego a la transformación de IT O3 contra O1[22]. De las definiciones 1 y 2, está claro que la relación causalDependencia solo se define para las operaciones originales (p. Ej. O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (p. O1). Además, la relación de concurrencia no captura la condición esencial para la transformación correcta de TI: las dos operaciones de entrada deben definirse en el mismo estado de documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar las condiciones de OT para las operaciones inversas. El comando deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto de deshacer correcto para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe tratarse como una operación definida en el estado del documento, incluido el efecto de O2 pero no O1 y O3, de modo que O2 se pueda transformar contra O1 y O3 antes de su ejecución. Sin embargo, de acuerdo con la relación de lamports antes de la relación [9], deshacer (O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de deshacer (O2), entonces se trataría efectivamente como una operación definida en el estado del documento con los efectos de las tres operaciones O1, O2 y O3, lo que prohibiría que O2 se transforme contraCualquier operación, por lo que no logró el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado correctamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales.3. Contexto de operación 3.1 Concepto básico Conceptualmente, cada operación O se asocia con un contexto, denotado por C (O), que corresponde al estado del documento 280 en el que se define la operación. La importancia del contexto de operación es doble: (1) una operación se puede ejecutar correctamente solo si su contexto y el estado del documento actual son los mismos;y (2) una operación se puede hacer correctamente en otra operación solo si los contextos de estas dos operaciones son los mismos. En la Figura 1, tanto O1 como O2 se definen en el mismo documento inicial, por lo que están asociados con el mismo contexto;O3 se define en el estado del documento que incluye el efecto de O2, por lo que C (O3) es diferente de C (O1) o C (O2). Cuando O2 llega al Sitio 0, no se puede ejecutar como está ya que C (O2) no coincide con el estado de documento actual en el Sitio 0, que incluye el efecto de O1. O2 puede transformarse correctamente contra O1 ya que sus contextos corresponden al mismo estado de documento inicial. Cuando el O3 llega al Sitio 0, no se puede ejecutar como es, ya que C (O3) no coincide con el estado del documento actual en el Sitio 0, lo que incluye los efectos de O1 y O2. O3 no se puede transformar correctamente contra O1 ya que sus contextos son diferentes, que es la raíz del dopt-ruzzle. Como se discutió en la Sección 2, el deshacer (O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de O2 solamente.3.2 Representación del establecimiento del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para la ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, hay dos tipos diferentes de operaciones: operaciones originales generadas por usuarios y operaciones transformadas que son los resultados de algunas transformaciones. Las operaciones originales se pueden dividir en dos clases: operaciones normales que se generan para hacer algo y las operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inverso se denota por O. Dado que cada operación transformada debe provenir de una operación original, utilizamos la orgia de notación (O) para denotar la operación original de O. Si o es una operación original, entonces org (o) = O. Dado que el contexto de una operación corresponde al estado del documento en el que se define la operación, el problema de la representación del contexto puede reducirse al problema de la representación del estado del documento. En un editor de grupos basado en OT, cada estado de documento puede representarse de manera única por el conjunto de operaciones originales ejecutadas hasta ahora en el documento. Estas operaciones originales pueden ejecutarse en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado de documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar un estado de documento. Definición 3. Representación del estado del documento Un estado de documento puede estar representado por DS de la siguiente manera: 1. El estado del documento inicial está representado por ds = {}.2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org (O)}.2 Esta presentación no especifica qué forma de ejecución se deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documento son iguales y para derivar sus diferencias en términos de origen original.operaciones. Según la representación del estado del documento, el contexto de una operación normal original debe ser el mismo que la representación del estado del documento a partir del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento ds = c (o) ∪ {o}, que es el estado después de ejecutar la operación original O en el estado c (o). De acuerdo con la definición de la función IT [23], una operación transformada o, donde o = it (o, ox), debe definirse en el estado del documento ds = c (o) ∪ {org (ox)}, que esEl estado se puede lograr ejecutando buey en el estado c (o). Más precisamente, el contexto de una operación se define un golpe. Definición 4. El contexto de una operación 1. Para una operación normal original O, C (O) = DS, donde DS es la representación del estado del documento desde el cual se generó O.2. Para una operación inversa original O, C (O) = C (O) ∪ {O}, donde O es la operación que se deshará.3. Para una operación transformada O, C (O) = C (O) ∪ {org (ox)}, donde o = it (o, ox).2 Según la definición anterior, el contexto de cualquier tipo de operación puede representarse como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos c (o1) = {}, x (o2) = {} y co3) = {o2} según la definición 4-ítem 1. De acuerdo con la definición 4-ítem 2, tenemos C (O2) = {O2}. De o2 = it (o2, o1), tenemos c (o2) = {o1} de acuerdo con la definición 4-ítem 3. 3.3 dependencia de contexto/independencia definimos la relación de-dependencia/independencia de contexto entre operaciones en términos deSi se incluye una operación original en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto C → Dada una operación original OA y una operación OB de cualquier tipo, OB depende del contexto en OA, denotado por OA C → OB, IFF: (1) OA ∈ C (OB);o (2) existe una operación original de buey, de modo que oa ∈ C (ox) y ox ∈ C (OB).2 Cabe señalar que la relación de dependencia de contexto se define solo entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden incluirse en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales OA y OB, OA y OB son independientes del contexto, denotadas por OA C OB, si no se otorgan o OB, ni Ob C → OA.2 Se puede demostrar que si tanto OA como OB son operaciones normales originales, entonces OA C → OB es equivalente a OA → OB;y OA C OB es equivalente a OA OB. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación contexto-dependencia/independencia.3.4 Condiciones basadas en el contexto Las siguientes condiciones basadas en el contexto (CC) capturan requisitos esenciales para la ejecución y transformación de la operación en sistemas OT: 281 CC1: C (O) ⊆ DS es una condición necesaria para que una operación original O se transforme en el documentoEstado DS para la ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C (O). En otras palabras, para cualquier operación original Ox, si Ox C → O, entonces OX debe ejecutarse antes de O. Cuando O es una operación normal original, todas las operaciones que son causalmente antes de O deben incluirse en C (O) (de acuerdo con la Definición 1 y la Definición 5), por lo que CC1 conserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C (O) debe incluir la operación que se deshacerá por O (ver definición 4-ítem 2), por lo que CC1 conserva el orden de do-into entre las operaciones normales e inversas [21]. CC2: DS - C (O) 1 es el conjunto de operaciones con las que O debe transformarse antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforme en todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier buey en ds - c (o), debe ser que buey c o. Cuando O es una operación normal original, DS - C (O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe transformarse contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe transformarse en todas las operaciones que se ejecutan después de que O [21] deba deshacer la operación. CC3: C (O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. Se requiere CC3 para ejecutar correctamente las operaciones. CC4: C (OA) ⊆ C (OB) es una condición necesaria para que OA sea transformable al nuevo contexto dado por C (OB). Se requiere cc4 porque si c (oa) ⊆ c (ob), entonces debe haber una operación ox ∈ C (OA) pero ox ∈ C (OB), lo que significa que OA no puede transformarse al nuevo contexto C (OB) Dado que la transformación de IT no puede eliminar este buey de C (OA) (ver definición 4-item3). CC5: C (OB)-C (OA) es el conjunto de operaciones en las que OA debe transformarse antes de que se transformara contra OB. CC5 asegura que la OA se transforme en contra de las operaciones independientes de contextación en C (OB) antes de transformarse contra OB. Se puede demostrar que, para cualquier buey en C (OB)-C (OA), debe ser que Ox C Oa, CC6: C (OA) = C (OB) sea una condición necesaria para que OA se transforme encontra OB. Se requiere CC6 para aplicar correctamente las funciones. En resumen, se requieren CC1 y CC4 para garantizar el orden correcto de la ejecución/transformación de la operación;CC2 y CC5 son necesarios para seleccionar las operaciones de destino de transformación correctas;y se requieren CC3 y CC6 para garantizar la ejecución/transformación de operación correcta. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS-C (O) es la diferencia establecida entre DS y C (O).3.5 Vector de contexto Un elemento importante de la teoría del contexto de la operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para una comodidad de notación, suponemos que una sesión de edición colaborativa consiste en n sitios de colaboración, identificados por 0, 1 ,..., N - 1. 3.5.1 que representan operaciones normales originales de operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (SID, NS), donde Sid es el identificador del sitio y NSes el número de secuencia local de esta operación. Deje que Oij sea una operación normal original generada en el Sitio I con un número de secuencia j. Si OIJ se incluye en un contexto C (O), entonces Oi1, Oi2 ,..., Oij - 1 también debe incluirse en C (O) de acuerdo con la definición 3 y la definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden caracterizarse suficientemente por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos de acuerdo con sus sitios de generación, por lo que se necesitan N enteros para representar operaciones normales originales en un contexto.3.5.2 Representación de operaciones inversas originales Se puede generar una operación inversa original para deshacer una operación normal original, o para rehacer una operación sin hacer. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede generarse para deshacer, y se puede generar para deshacer O. Tanto O como O corresponden a la misma operación normal O. Según esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso para cada operación normal original deshecho. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más mediante un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene la secuencia número 1, y O tiene la secuencia número 2. En general, un inverso puede identificarse mediante un triple (SID, NS, IS), donde SID y NS son el identificador del sitio y el número de secuencia del funcionamiento normal correspondiente, y IS es el número de secuencia inversa dentro del grupo. Dado que los inversos se ejecutan secuencialmente, el número de secuencia más grande en el grupo se puede usar para representar todos los inversos en el grupo. Los grupos inversos pueden dividirse adicionalmente en n grupos inversos de acuerdo con los identificadores del sitio de sus operaciones normales correspondientes. El grupo inverso en el sitio I - icicano se expresará de la siguiente manera: ICI = [(NS0, IS0), (NS1, IS1) ,..., (NSK - 1, ISK - 1)], donde cada par (NSJ, ISJ), 0 ≤ J <k, representa un grupo inverso con operaciones inversas ISJ correspondientes a la operación normal original con el número de secuencia NSJ en el sitio i. Si no se ha deshecho el funcionamiento normal en el sitio I, ICI está vacío.3.5.3 Representando las operaciones normales e inversas para representar un contexto de operación con operaciones normales e inversas originales, un vector de contexto N-dimensional se define a continuación.282 Definición 7. Vector de contexto Dada una operación O, su contexto C (O) puede representarse mediante el siguiente vector de contexto CV (O): CV (O) = [(NS0, IC0), (NS1, IC1) ,..., (NSN - 1, ICN - 1)], donde, para 0 ≤ i ≤ n - 1, 1. NSI representa todas las operaciones normales originales generadas en el Sitio I, y 2. ICI = [(NS0, IS0), (NS1, IS1) ,..., (NSK - 1, ISK - 1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el Sitio I, donde (NSJ, ISJ), 0 ≤ J <k, representa un grupo inverso con inversos ISJ relacionados con la operación normal conNúmero de secuencia NSJ.2 En ausencia de operaciones inversas en el contexto de operación, todo ICI, 0 ≤ I ≤ n - 1, estaría vacío y un vector de contexto se reduciría a un vector de estado [4]. La representación vectorial del contexto de operación también se puede utilizar como la representación vectorial del estado del documento. Como ejemplo, considere el estado del documento después de interpretar el comando deshacer deshacer (O2) en la Figura 1. Dado que UNDO (O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (transformado) O2 será ds = {o1, o2, o3, o2}. Este estado de documento no puede ser representado por un vector de estado, pero puede representarse como un vector de contexto de la siguiente manera: CV (DS) = [(1, []), (2, [(1, 1)]]. Según la definición 7, es sencillo derivar el esquema para mantener la representación vectorial para el estado del documento después de ejecutar cada operación (según la definición 3). Además, la representación vectorial del contexto de operación también se puede utilizar para detectar eficientemente las relaciones de dependencia/independencia. Debido a la limitación del espacio, estos detalles técnicos se omiten en este documento.4. El algoritmo COT básico en el algoritmo COT básico, suponemos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas SO-FAR. Esto es diferente del log o los esquemas de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos deliberadamente la estructura de datos internos de DS no especificados para mantener el algoritmo COT independiente de la estrategia de almacenamiento de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C (O), en lugar de la representación del vector de contexto CV (O). Sin embargo, cuando una operación O se propaga del sitio local a sitios remotos, es el vector de contexto, no el conjunto de contexto, el que en realidad está respaldado en O para la propagación. El conjunto de operaciones en C (O) se puede determinar fácilmente a partir de DS en función de la información en CV (O). El algoritmo COT tiene dos partes: la parte COT-DO para soportar el mantenimiento de consistencia (DO) y la parte Cotondo para soportar deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT.4.1 COT -DO COT -DO toma dos parámetros: o - una operación original que se ejecutará, y ds - la representación actual del estado del documento. COT-DO se invoca solo si C (O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya se hayan ejecutado en DS. Algoritmo 1. Cot-do (o, ds) 1. transformación (o, ds-c (o));2. Ejecutar o;Ds: = ds ∪ {org (o)}. Procedimiento 1. Transformar (O, CD) Repita hasta CD = {}: 1. Retire el buey de Cd, donde c (ox) ⊆ c (o);2. transformar (ox, c (o) - c (ox));3. O: = it (o, ox);C (o): = c (o) ∪ {org (ox)}. COT-DO Invoca primero la transformación del procedimiento () para transformar O contra operaciones en DS-C (O) (CC2). Esto es para actualizar el contexto de O a DS. En el paso 2, debe ser que C (O) = DS (CC3), por lo que O se ejecuta como está, y el original de O se agrega a DS (de acuerdo con la definición 3-ítem 2). El corazón de Cot-Do es la transformación (O, CD), cuya tarea es transformar O contra las operaciones en CD, lo que representa la diferencia de contexto entre C (O) y un nuevo contexto en el que se debe definir O. Este procedimiento repite los siguientes tres pasos hasta que el CD se vacíe: 1. Retire una operación de buey de CD, donde C (Ox) ⊆ C (O) (CC4). Se puede determinar una operación de buey que cumple con esta condición si todas las operaciones en CD se clasifican en el orden de su ejecución y se recuperan secuencialmente.2. La transformación del procedimiento () se invoca recursivamente para transformar OX contra operaciones en C (O) −C (OX) (CC5). Esto es para actualizar el buey al contexto de O, para que puedan usarse para la transformación de TI en el siguiente paso.3. Después de la llamada recursiva para transformar (), debe ser que c (o) = c (ox) (cc6), también se transforma contra buey, y el contexto de o se actualiza agregando el original de buey (segúna la definición 4-ítem 3). Para mostrar cómo funciona Cot-Do, examinamos cómo resuelve el dopt-Puzzle en la Figura 1. Considere las ejecuciones de operación en el Sitio 0, con el estado del documento inicial DS0 = {}.1. Después de la generación de O1, desde C (O1) = DS0, O1 se ejecuta como-IS y DS0 se actualiza a DS1 = {O1}.2. Cuando O2 llega con C (O2) = {}, se llama transformar (O2, ds1− c (o2)), donde ds1 - c (o2) = {o1}. Inside Transform (O2, {O1}), ya que c (o1) = c (o2), tenemos o2: = it (o2, o1) y c (o2) = {o1}. Volviendo de la transformación (O2, {O1}), tenemos c (o2) = ds1, por lo que O2 se ejecuta, y ds1 se actualiza a ds2 = {o1, o2}, donde o2 = org (o2).3. Cuando O3 llega con C (O3) = {O2}, se llama transformar (O3, ds2− c (o3)), donde ds2 - c (o3) = {o1}. La transformación interna (O3, {O1}), Transform (O1, C (O3) −c (O1)) se llama recursivamente, con C (O3) - C (O1) = {O2}, que es el paso clave para detectarEl dopt-huzzle. En la transformación recursiva (O1, {O2}), ya que c (o2) = c (o1), tenemos o1: = it (o1, o2) y c (o1) = {o2}. Volviendo de la recursión, tenemos c (o1) = c (o3), entonces c (o3): = it (o3, o1) (el dopt-sumorz resuelto aquí) y c (o3) = {o1, o2}, donde o1 = org (O1). Después de regresar de Transform (O3, {O1}), C (O3) = DS2;Entonces se ejecuta O3, y DS2 se actualiza a ds3 = {o1, o2, o3}, donde o3 = org (o3).283 4.2 COT-UNDO para deshacer una operación O, un usuario debe emitir un comando de deshielo de meta-nivel (o). Cómo generar el comando deshacer para seleccionar cualquier operación para deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, deshacer (O) se interpreta como una O inversa, que depende del contexto en las operaciones en C (O) y O en sí. COT-UNDO toma dos parámetros de entrada: o es la operación seleccionada para deshacerse, que puede ser cualquier operación realizada SOFAR, y DS es la representación actual del estado del documento. Algoritmo 2. Cot-UNDO (O, DS) 1. O: = makeinverse (o);C (o): = c (o) ∪ {o};2. Cot-do (O, DS). Cot-UNDO funciona primero creando una O inversa invocando makeinverse (o) 2, con su contexto c (o): = c (o) ∪ {o} (de acuerdo con la definición 4-item 2), y luego invocando cotdo amanejar O. Por ejemplo, para interpretar deshacer (O2) en la Figura 1, Cotundo se invoca con parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C (O2) = {O2}. Luego, Cot-Do se invoca con parámetros O2 y DS. Se invocará COT-DO, transformar (O2, Ds-C (O2)), y O2 se transformará correctamente contra O1 y O3 ya que CD = DS-C (O2) = {O1, O3}. Este ejemplo muestra que Cot-Do puede manejar una operación inversa de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables a las operaciones normales e inversas. El algoritmo BASIC COT es simple pero poderoso, capaz de hacer y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de Goto y AnyUndo (denominado Goto-Anyundo) tiene capacidades similares [22, 21].5. Propiedades de transformación COT es un algoritmo de control de alto nivel responsable de determinar qué operación debe transformarse contra otras operaciones y en qué orden de acuerdo con las condiciones basadas en el contexto. Otro componente importante de un sistema OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones de acuerdo con sus tipos y parámetros. Investigaciones anteriores han identificado una gama de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema OT. Los diferentes sistemas OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-AYUNDO, el algoritmo COT básico no usa funciones ET (transformación de exclusión) [21], evitando así el requisito de la propiedad de reversibilidad (RP) entre las funciones de TI y ET [21]. Similar a GOTO-ALYUNDO, el algoritmo COT básico supone que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 El lector se remite [25] para definiciones precisas de tres operaciones primitivasInserte, elimine y actualice y sus inversos correspondientes. El procedimiento MakeInverse (O) sigue directamente estas definiciones.1. Propiedad de convergencia 1 (CP1) 3. Dado un estado de documento ds, y operaciones OA, OB, si OA = it (OA, OB) y OB = it (OB, OA), entonces debe ser: DS ◦ [OA, OB] = DS ◦ [Ob,OA], lo que significa que [OA, OB] y [OB, OA] son equivalentes con respecto al efecto en el estado del documento DS.2. Propiedad de convergencia 2 (CP2). Dadas tres operaciones o, oa y ob, si oa = it (oa, ob) y ob = it (ob, oa), entonces debe ser: it (it (o, oa), ob) = it (o, Ob), oa), lo que significa que [OA, Ob] y [Ob, OA] son equivalentes con respecto al efecto en la transformación.3. Propiedad inversa 2 (IP2) 4. Dado cualquier operación de buey y un par de operaciones [O, O], debe ser: it (it (ox, o), o) = it (ox, i) = ox, lo que significa que [o, o] y yoson equivalentes con respecto al efecto en la transformación.4. Propiedad inversa 3 (IP3). Dadas dos operaciones oa y ob, si oa: = it (oa, ob), ob: = it (ob, oa), y oa: = it (oa, ob), entonces debe ser: oa = oa, lo que significaLa operación inversa transformada OA es igual al inverso de la operación transformada OA. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son necesarias incondicionalmente. Sin embargo, las pre-condiciones para requerirlos nunca se declararon explícitamente en sus especificaciones, lo que desafortunadamente ha causado cierta conceptos erróneos en la literatura OT. Para explorar soluciones alternativas a estas propiedades, establecemos explícitamente las condiciones previas (PC) para CP1, CP2, IP2 y IP3 de la siguiente manera: 1. PC-CP1: CP1 solo se requiere si el sistema OT permite ejecutar el mismo grupo de operaciones independientes de contexto en diferentes órdenes.2. PC-CP2: CP2 solo se requiere si el sistema OT permite que una operación se transforme en el mismo grupo de operaciones independientes del contexto en diferentes órdenes.3. PC-IP2: se requiere IP2 solo si el sistema OT permite que una operación OX se transforme contra un par de operaciones DO y deshacer (O y O) uno por uno.4. PC-IP3: IP3 solo se requiere si el sistema OT permite que una operación inversa OA se transforme en otra operación OB que sea independiente del contexto de OA.3 Propiedad de convergencia 1 y 2 en este documento (y en [21]) son las mismas que la propiedad de transformación 1 y 2 en [19].4 Hay otra propiedad inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionado con las funciones de TI.284 Generalmente hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades;El otro es diseñar algoritmos de control capaces de romper las condiciones previas para requerir estas propiedades. Investigaciones anteriores han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial para diseñar y probar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Las contraexemples que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas temprano se pueden encontrar en [23, 21, 8, 11]. Las funciones capaces de preservar IP2 e IP3 se han ideado en el contexto de AnyUndo [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son intrincadas e ineficientes rápidas (se puede encontrar más análisis en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel de algoritmo de control tiene el beneficio de simplificar el diseño de funciones de transformación y el sistema OT en su conjunto. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel de algoritmo de control.6. Las soluciones de COT a CP2, IP2 e IP3, una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transformación (O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el contexto en el contexto-Difrado parámetro CD (calculado mediante las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, podemos organizar correctamente estas operaciones para romper las condiciones previas para CP2, IP2 e IP3.6.1 Procedimiento de transformación extendida () Extendemos la transformación del procedimiento central (O, CD) para aprovechar el conocimiento global de las operaciones en el CD del parámetro ContextDiFference para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida (), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el paso 1 (asegurar tpSafety ()) y en el paso 2- (c) (la parte if-then). Procedimiento 2. Transformar (O, CD) 1. Si cd = {}, asegúrese de tpSafety (o, cd);2. Repita hasta que cd = {}: (a) Retire la primera operación OX de CD;(b) transformación (ox, c (o) - c (ox));(c) Si el ox es un par de do-into, entonces c (o): = c (o) ∪ {org (ox), org (ox)};más o: = it (o, ox);C (o): = c (o) ∪ {org (ox)}. Procedimiento 3. Asegúrese de TPSafety (O, CD) 1. Asegúrese de que la seguridad CP2: clasifique las operaciones en CD en un orden total que respeta su orden de dependencia de contexto.2. Asegúrese de que la seguridad IP2: para cualquier ox ∈ Cd, si ox ∈ Cd, entonces marque el buey como un par de do-into, elimine el buey de la CD.3. Asegúrese de que la seguridad IP3: si O está inversa, el Invoke hace que IP3Safe inverse (O, CD). Procedimiento 4. Realice IP3Safe Inverse (O, CD) 1. O: = makeinverse (o);C (o): = c (o) - {o};2. NCD: = {ox |Ox ∈ Cd y ox c o};3. Transformar (O, NCD);4. O: = makeinverse (o);C (o): = c (o) ∪ {o};5. CD: = CD - NCD.6.2 Romper la condición previa para CP2 La solución COT a CP2 es ordenar todas las operaciones en CD en un orden total que respeta su orden de dependencia de contexto (en el paso 1 de garantizar tpSafety ()). Si una operación O se transforma en el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar (O, CD), este grupo de operaciones debe incluirse en CD y ordenarse en el mismo orden total. Por lo tanto, O nunca se puede transformar en el mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe señalar que el CD se convierte en un conjunto ordenado después de la clasificación. El primer buey en CD debe cumplir con la condición c (ox) ⊆ c (o) en el paso 2 (a) de transformación (o, cd) (procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el procedimiento 2. Un orden total correcto para romper PCCP2 se puede determinar convenientemente utilizando las relaciones contextables de dependencia entre todas las operaciones más los identificadores del sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema Got (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en la secuencia global) [26], El sistema agradable (por un notificador central basado en la transformación) [20], y el sistema Tibot (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT a CP2 es única y evita el uso de cualquier secuestro/secuenciación global/sincronización global.6.3 Romper la condición previa para IP2 La idea básica de la solución COT a IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de OD y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) Paso 2 de garantizar las operaciones de parejas de TPSafety (CD) con sus inversos correspondientes si todos están incluidos en el CD de diferencia de contexto y eliminar estos inversos de CD;(2) En el paso 2- (c) de transformación (), si se encuentra que el buey es un par de do-intodo, se omite la transformación IT de O contra el buey (tratando efectivamente este par como una operación de identidad) y laEl contexto de O se actualiza agregando dos operaciones: {org (ox), org (ox)}.6.4 Romper la condición previa para IP3 La solución COT a IP3 está encapsulada en el procedimiento, hace que IP3Safe inverse (O, CD), lo que hace que O sea un inverso seguro IP3 con respecto a la diferencia de contexto de CD. Una O inversa es Safe IP3 con respecto al CD si está hecha de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de la COT, la O inversa segura de IP3 nunca se transformará contra operaciones que son independientes del contexto de O, rompiendo así la PC-IP3. El procedimiento inverso de fabricación de IP3S funciona de la siguiente manera: (1) Crear operación O (la inversa de O) y C (O) = C (O) - 285 {O};(2) Seleccione todas las operaciones de CD que son contextores independientes de O y creen una nueva diferencia de contexto NCD;(3) transformar O contra operaciones en NCD (invocando recursivamente transform ());(4) crear un nuevo inverso a partir de la O transformada;y (5) crear un nuevo CD restando NCD del CD anterior (el nuevo CD debe mantener el orden total según sea necesario para resolver CP2). Esta nueva O inversa O debe ser Safe IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. La O inverse segura de IP3 nunca se transformará en las operaciones en NCD ya que estas operaciones se han eliminado del nuevo CD en el paso (5).7. Discusiones 7.1 La teoría del contexto de operación La noción de contexto de operación se propuso por primera vez en el algoritmo Got [23] y se usó junto con la teoría de la causalidad en los algoritmos de seguimiento y cualquier sindodo [22, 21]. En el trabajo previo, el contexto de una operación O se definió como una secuencia de operaciones transformadas que se pueden ejecutar para llevar el documento de su estado inicial al estado en el que se define O. Esta definición está directamente acoplada a la estrategia de almacenamiento de historial secuencial, que guarda operaciones ejecutadas en sus formularios y órdenes de ejecución. No hubo representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición del amortiguador de la historia entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado de documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Según la representación establecida del contexto de operación, las condiciones de OT esenciales (CC1 - CC6) se han capturado de precisión y concisión. Además, se ha diseñado el vector de contexto para representar eficientemente las operaciones normales e inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas informáticos distribuidos también. Según la teoría de la causalidad, los algoritmos OT anteriores han utilizado vectores estatales para capturar relaciones de dependencia causal entre las operaciones normales originales y representar estados de documentos en términos de operaciones normales originales. Sin embargo, las relaciones de dependencia causal no se definen para operaciones inversas o transformadas, y los vectores estatales no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar condiciones de OT esenciales (CC1 - CC6) para todo tipo de operación: operaciones originales y transformadas, normales e inversas.7.2 COT versus Goto-AYUNDO Tanto Cot como Goto-Anyundo son capaces de hacer y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin usar funciones ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir funciones para preservar CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de funciones de transformación y el sistema OT en su conjunto. COT es más simple que GOTO-ALYUNDO (y algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una sola teoría del contexto de operación para capturar todasoperación y la concisión de estas condiciones basadas en el contexto. El sistema basado en COT es más eficiente que el sistema basado en Gotoanyundo para resolver IP2 e IP3. En GoToanyUndo, el Do-Part (una operación normal) y el Undepart (una operación inversa) deben acoplarse con el fin de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento ansiosa: una operación inversa se combina con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historia. Sin embargo, cuando se debe ejecutar una operación normal, es posible que deba transformarse solo contra la parte de deshacer de una pareja de do-intodo. Para hacer frente a este problema, se debe usar un esquema adicional de decouple-goto-recouple para desacoplar un par de do-indoto antes de invocar a GOTO y luego recuperarlos después [21]. Sin embargo, la implementación de este esquema de recepción decouple reveló que era bastante complejo y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-Udo están integrados sin problemas. Las operaciones inversas se representan explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de do-into se produce inmediatamente después de ejecutar cada inverso, sino solo cuando tanto el DO-Part como el deshacer aparecen enEl mismo proceso de transformación en alguna etapa tardía. Estas estrategias ayudan a evitar transformaciones generales causadas por el esquema de acoplamiento ansioso y el esquema de recepción decouple. En el sistema basado en GOTO-ALYUNDO, la solución a IP3 se encapsula en una función de preservación de IT de IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, lo que puede invocar el costoso algoritmo GOTO para garantizar RP con la función IT correspondiente. Por el contrario, la solución COT a IP3 se encapsula en el procedimiento de alto nivel, hace que IP3SAFE inverse (O, CD), que es más eficiente ya que (1) evita la conversión de O a O de ida y vuelta varias veces para cada ox ∈ NCD ((si se usaron IP3P-IT (O, OX) en su lugar);y (2) el procedimiento Transform () es mucho más barato que GOTO.7.3 Estrategias de amortiguación OT Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento de operaciones subyacente. Esto no solo ha resultado en una estructura lógica más limpia y simple para el algoritmo en sí, sino que también permitió una gama de optimizaciones de rendimiento en el nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en búfer en la que no solo se pueden guardar operaciones originales, sino también versiones transformadas;y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original en el nivel de algoritmo COT, se busca al grupo de versiones correspondiente una versión que coincida con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, guardando así la sobrecarga para transformar la operación original en esta versión. Bajo esta estructura de amortiguación, se pueden usar varias heurísticas para guardar selectivamente versiones transformadas para maximizar su reutilización y minimizar su uso de espacio. Mediante la experimentación, hemos identificado algunas heurísticas útiles que son 286 efectivas para ahorrar transformaciones para una serie de patrones comunes de secuencia de operación. COT no es el primer algoritmo OT que amortigua y usa operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluidos CCU [2], adoptados [19] y Gotoanyundo [21], también han amortiguado las operaciones originales. COT es único en su forma de amortiguar y usar operaciones originales y transformadas.7.4 OT Corrección La corrección es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado resolución de detección de rompecabezas, se ha utilizado comúnmente para explorar y refinar las soluciones OT. Los rompecabezas son escenarios sutiles pero representativos en los que se pueden violar ciertas propiedades/condiciones de OT y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los rompecabezas conocidos es una condición necesaria y un indicador importante de la solidez de un sistema OT. En la literatura de investigación, los escenarios simples de rompecabezas a menudo se usan para ilustrar las razones clave por las cuales un sistema OT funciona o falla. Sin embargo, en el diseño del sistema OT real, una implementación real y casos de prueba integrales basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección se han entendido bien y los criterios de verificación y las condiciones de contorno han sido bien definidas. En este sentido, los métodos experimentales como la resolución de la detección de rompecabezas pueden desempeñar un papel importante en la obtención de los conocimientos necesarios sobre los problemas de corrección real y establecer criterios y condiciones adecuados para la verificación formal. Se necesita un enfoque sistemático para realizar investigaciones OT experimentales y teóricas. Muchos componentes y problemas de OT están íntimamente relacionados, y es poco probable que una solución a un problema, si se examina de forma aislada, sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de consistencia (DO) puede fallar cuando se consideran los problemas de DO y Deshacer;y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución al mantenimiento de consistencia [21]. Una solución OT completa para los problemas de hacer y deshacer es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente OT puede resolverse fácilmente o evitarse por completo, si este problema se aborda desde un componente OT diferente. Por ejemplo, se sabe que diseñar y probar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades se pueden evitar diseñando algoritmos de control (como cot) capaces de romper las condiciones previas para requerir estas propiedades;También es más fácil demostrar que un algoritmo de control es capaz de romper las condiciones previas para estas propiedades, que probar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 eran necesarios y suficientes para que los sistemas basados en adopción converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas OT. De hecho, CP1 y CP2 no son suficientes ni necesarios para muchos sistemas OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades/condiciones adicionales, como IP2, IP3 y las resumidas en [21]. Son innecesarios si se han roto las pre-condiciones para requerirlas. Por ejemplo, ni CP1 ni CP2 se requieren en el sistema Redido en función del algoritmo Got para garantizar la convergencia [23]. CP2 tampoco es requerido por los sistemas OT basados en COT o algunos algoritmos OT anteriores [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de la violación de CP2, es el problema de los falsos corbatas: cuando dos (o más) las operaciones con la misma posición se transforman entre sí, el empate de posición puede serFalso si no era original pero causado por transformaciones anteriores. Un sistema OT puede no producir resultados correctos si la regla de ruptura de unión normal (por ejemplo, basada en los identificadores del sitio) se usa para romper los falsos. Este problema se descubrió durante mucho tiempo en el trabajo temprano de OT y se ilustra un escenario concreto relacionado con este problema en la Fig. 6 de [23]. Está más allá del alcance de este documento discutir las soluciones a este problema, pero vale la pena señalar que el problema de los falsos tintes es diferente del problema de violación de CP2: puede ocurrir una falsificación sin violar CP2. En nuestra opinión, el problema de la falsa empanada es un problema en el nivel de función de transformación y su solución podría y también debería localizarse a este nivel. Para puntos de vista y enfoques alternativos de este problema, se hace referencia al lector [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un conjunto de pruebas integral que cubre todos los escenarios de rompecabezas OT conocidos. En este artículo, se han utilizado análisis informales y escenarios simples de rompecabezas para mostrar la corrección de la cuna con respecto a diversas propiedades/condiciones de transformación. La verificación formal de la corrección de la cuna con respecto a estas propiedades/condiciones, y el análisis cuantitativo del tiempo y la complejidad del espacio de la COT, se informará en una versión de revista de este documento.8. Conclusiones Hemos contribuido con la teoría del contexto de operación y el algoritmo COT (OT basado en el contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todos los tipos de operación en un sistema OT;Proporciona una nueva base para una mejor comprensión y resolución de problemas de OT. El algoritmo COT proporciona soluciones uniformadas tanto para el mantenimiento de consistencia como para los problemas de deshacer;Es más simple y más eficiente que los algoritmos de control OT anteriores con capacidades similares;y simplifica significativamente el diseño de funciones de transformación. El algoritmo COT se ha implementado en un motor de colaboración genérico y utilizado para soportar una gama de aplicaciones de colaboración nuevas [24]. Las aplicaciones del mundo real brindan oportunidades y desafíos emocionantes para futuras investigaciones de OT. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y revisores anónimos por sus valiosos comentarios y sugerencias que han ayudado a mejorar la presentación del documento.287 9. Referencias [1] J. Begole, M. Rosson y C. Shaffer. Transparencia de colaboración flexible: respaldo de la independencia del trabajador en sistemas replicados de intercambio de aplicaciones. ACM Trans.En la interacción humana de la computadora, 6 (2): 95-132, 1999. [2] G. Cormack. Un cálculo para la actualización concurrente. En Informe de investigación CS-95-06, Departamento de Informática, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizar la transformación operativa al lenguaje de marcado general estándar. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de grupos. En Proc.de la ACM conf.sobre gestión de datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q.Zhang. Mantenimiento de consistencia basado en la técnica de Mark & Ratrice en los sistemas de grupos. En Proc.de acm conf.sobre el trabajo grupal de apoyo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre principios de informática móvil, páginas 51-57, Nueva York, Octo 2002. Acm[7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que depende del algoritmo Treeopt. En Proc.del conf. Europeo.de trabajo cooperativo respaldado por computadora, páginas 315-324, septiembre de 2003. [8] A. IMine, P. Molli, G. Oster y M. Rusinowitch. Probar corrección de las funciones de transformación en el grupo de grupos en tiempo real. En Proc.del conf. Europeo.en el trabajo cooperativo respaldado por computadora, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el pedido de eventos en un sistema distribuido. Comunicación de ACM, 21 (7): 558-565, 1978. [10] D. Li y R. Li. Compartir e interoperación transparentes de aplicaciones heterogéneas de un solo usuario. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservar la relación de efectos de operación en editores grupales. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en un intervalo de tiempo para aplicaciones interactivas de Groupware. En Proc.de la conferencia internacional sobre sistemas paralelos y distribuidos, páginas 429-436, julio.2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adoptado. Cartas de procesamiento de información, (86): 303-310, 2003. [14] C. Palmer y G. Cormack. La operación se transforma para una hoja de cálculo compartida distribuida. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas de colaboración. ACM Trans.En Interaction-Human Interaction, 4 (1): 295-330, diciembre de 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatizar la reconciliación basada en la semántica para bases de datos móviles. En Actas de la 3ta Conferencia Francaise Sur Les Systems Dexploitation, Octo 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: captura de causalidad en sistemas distribuidos. IEEE Computer Magazine, 29 (2): 49-56, febrero de 1996. [18] M. Ressel y R. Gunzenh¨auser. Reducción de los problemas de deshacer grupo. En Proc.de la ACM conf.en el trabajo grupal de apoyo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenh¨auser. Un enfoque integrador orientado a la transformación para el control de la concurrencia y deshacer en los editores de grupos. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inverso concurrente en editores grupales. ACM Trans.En Interaction-Human Interaction, 9 (4): 309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operativa en editores de grupos en tiempo real: problemas, algoritmos y logros. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Lograr la convergencia, la preservación de la causalidad y la preservación de la intención en los sistemas de edición cooperativa en tiempo real. ACM Trans.En Interaction-Human Interaction, 5 (1): 63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans.En Interaction-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun y D. Chen. Transformación operativa para el procesamiento de textos colaborativos. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferri´e y M. Suleiman. Copias Convergencia en un entorno colaborativo distribuido en tiempo real. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 171-180, diciembre de 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición de tabla colaborativa basada en la adaptación transparente. En Proc.de la Conf. Internacional.en Cooperative Information Systems, LNCS vol.3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. TelePointer asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc.del IEEE conf.Sobre la computación colaborativa: redes, aplicaciones y trabajadores, diciembre de 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración de usuarios múltiples: el enfoque Coword. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 162-171, noviembre de 2004. 288",
    "original_sentences": [
        "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
        "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
        "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
        "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
        "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
        "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
        "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
        "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
        "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
        "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
        "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
        "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
        "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
        "The soundness of the theoretical foundation for OT is crucial in this process.",
        "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
        "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
        "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
        "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
        "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
        "Another condition is that the two concurrent operations must be defined on the same document state.",
        "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
        "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
        "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
        "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
        "In fact, the causality relation is not defined for inverse operations (see Section 2).",
        "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
        "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
        "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
        "The rest of this paper is organized as follows.",
        "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
        "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
        "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
        "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
        "The COT solutions to these transformation properties are presented in Section 6.",
        "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
        "Finally, major contributions of this work are summarized in Section 8. 2.",
        "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
        "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
        "Definition 1.",
        "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
        "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
        "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
        "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
        "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
        "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
        "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
        "Figure 1: A real-time group editing scenario.",
        "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
        "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
        "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
        "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
        "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
        "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
        "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
        "O1).",
        "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
        "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
        "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
        "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
        "O1 and O3) [21].",
        "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
        "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
        "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
        "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
        "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
        "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
        "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
        "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
        "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
        "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
        "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
        "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
        "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
        "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
        "For any operation O, its inverse is denoted by O.",
        "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
        "If O is an original operation, then org(O) = O.",
        "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
        "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
        "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
        "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
        "Definition 3.",
        "Document state representation A document state can be represented by DS as follows: 1.",
        "The initial document state is represented by DS = {}. 2.",
        "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
        "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
        "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
        "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
        "More precisely, the context of an operation is defined blow.",
        "Definition 4.",
        "The context of an operation 1.",
        "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
        "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
        "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
        "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
        "According to Definition 4-Item 2, we have C(O2) = {O2}.",
        "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
        "Definition 5.",
        "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
        "This is because any operation has a context, but only original operations can be included in a context.",
        "Definition 6.",
        "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
        "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
        "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
        "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
        "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
        "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
        "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
        "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
        "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
        "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
        "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
        "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
        "CC3 is required for correctly executing operations.",
        "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
        "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
        "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
        "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
        "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
        "CC6 is required for correctly applying IT functions.",
        "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
        "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
        "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
        "Let Oij be an original normal operation generated at site i with a sequence number j.",
        "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
        "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
        "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
        "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
        "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
        "Both O and O correspond to the same normal operation O.",
        "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
        "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
        "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
        "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
        "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
        "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
        "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
        "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
        "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
        "The vector representation of operation context can also be used as the vector representation of the document state.",
        "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
        "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
        "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
        "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
        "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
        "Due to space limitation, these technical details are omitted in this paper. 4.",
        "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
        "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
        "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
        "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
        "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
        "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
        "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
        "Both parts share the same core context-based transformation procedure.",
        "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
        "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
        "Algorithm 1.",
        "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
        "Execute O; DS := DS ∪ {org(O)}.",
        "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
        "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
        "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
        "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
        "This is to upgrade the context of O to DS.",
        "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
        "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
        "This procedure repeats the following three steps until CD becomes empty: 1.",
        "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
        "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
        "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
        "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
        "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
        "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
        "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
        "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
        "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
        "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
        "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
        "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
        "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
        "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
        "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
        "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
        "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
        "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
        "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
        "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
        "Algorithm 2.",
        "COT-UNDO(O, DS) 1.",
        "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
        "COT-DO(O, DS).",
        "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
        "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
        "First, O2 and C(O2) = {O2} are created.",
        "Then, COT-DO is invoked with parameters O2 and DS.",
        "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
        "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
        "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
        "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
        "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
        "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
        "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
        "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
        "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
        "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
        "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
        "The makeInverse(O) procedure directly follows these definitions. 1.",
        "Convergence Property 1 (CP1)3 .",
        "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
        "Convergence Property 2 (CP2).",
        "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
        "Inverse Property 2 (IP2)4 .",
        "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
        "Inverse Property 3 (IP3).",
        "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
        "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
        "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
        "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
        "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
        "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
        "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
        "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
        "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
        "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
        "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
        "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
        "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
        "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
        "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
        "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
        "Procedure 2. transform(O, CD) 1.",
        "If CD = { }, ensure TPsafety(O, CD); 2.",
        "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
        "Procedure 3. ensure TPsafety(O, CD) 1.",
        "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
        "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
        "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
        "Procedure 4. make IP3safe Inverse(O, CD) 1.",
        "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
        "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
        "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
        "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
        "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
        "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
        "It should be noted that CD becomes an ordered set after the sorting.",
        "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
        "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
        "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
        "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
        "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
        "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
        "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
        "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
        "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
        "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
        "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
        "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
        "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
        "There was no explicit representation of an operation context.",
        "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
        "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
        "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
        "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
        "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
        "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
        "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
        "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
        "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
        "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
        "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
        "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
        "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
        "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
        "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
        "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
        "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
        "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
        "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
        "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
        "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
        "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
        "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
        "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
        "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
        "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
        "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
        "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
        "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
        "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
        "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
        "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
        "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
        "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
        "In this section, we provide our observations and opinions on some important OT correctness issues.",
        "OT is a complex system with multiple interrelated components.",
        "A system-oriented approach is needed for addressing OT issues.",
        "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
        "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
        "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
        "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
        "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
        "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
        "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
        "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
        "A systematic approach is needed in conducting both experimental and theoretic OT research.",
        "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
        "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
        "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
        "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
        "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
        "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
        "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
        "Caution must be taken in interpreting correctness results.",
        "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
        "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
        "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
        "They are unnecessary if the pre-conditions for requiring them have been broken.",
        "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
        "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
        "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
        "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
        "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
        "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
        "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
        "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
        "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
        "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
        "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
        "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
        "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
        "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
        "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
        "Real-world applications provide exciting opportunities and challenges to future OT research.",
        "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
        "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
        "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
        "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
        "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
        "A calculus for concurrent update.",
        "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
        "Generalizing operational transformation to the standard general markup language.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
        "Concurrency control in groupware systems.",
        "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
        "Consistency maintenance based on the mark & retrace technique in groupware systems.",
        "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
        "On the consistency problem in mobile distributed computing.",
        "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
        "ACM. [7] C. Ignat and M.C.",
        "Norrie.",
        "Customizable collaborative editor relying on treeOPT algorithm.",
        "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
        "Proving correctness of transformation functions in real-time groupware.",
        "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
        "Time, clocks, and the ordering of events in a distributed system.",
        "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
        "Transparent sharing and interoperation of heterogeneous single-user applications.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
        "Preserving operation effects relation in group editors.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
        "A time interval based consistency control algorithm for interactive groupware applications.",
        "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
        "Proof of correctness of Ressels adOPTed algorithm.",
        "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
        "Operation transforms for a distributed shared spreadsheet.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
        "A framework for undoing actions in collaborative systems.",
        "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
        "Automating semantics-based reconciliation for mobile databases.",
        "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
        "Logical time: capturing causality in distributed systems.",
        "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
        "Reducing the problems of group undo.",
        "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
        "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
        "A flexible notification framework for collaborative systems.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
        "Undo as concurrent inverse in group editors.",
        "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
        "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
        "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
        "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
        "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
        "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
        "Operational transformation for collaborative word processing.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
        "Copies convergence in a distributed real-time collaborative environment.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
        "A collaborative table editing technique based on transparent adaptation.",
        "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
        "Object-associated telepointer for real-time collaborative document editing systems.",
        "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
        "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
        "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
    ],
    "error_count": 0,
    "keys": {
        "operational transformation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based <br>operational transformation</br> David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT <br>operational transformation</br> (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION <br>operational transformation</br> (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing <br>operational transformation</br> to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "<br>operational transformation</br> in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "<br>operational transformation</br> for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Operación Contexto y \"Transformación operativa\" basada en el contexto División de Ciencias de la Computación de David Sun, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Nanyang Universidad Tecnológica Singapur czsun@ntu.edu.sg Resumen \"Operacional\" operacional \"La transformación \"(OT) es una técnica para el mantenimiento de consistencia y la deshacer del grupo, y se aplica a un número creciente de aplicaciones de colaboración.",
                "Introducción \"Transformación operativa\" (OT) se inventó originalmente para el mantenimiento de consistencia en editores de grupos de texto simple [4].",
                "Generalizar la \"transformación operativa\" al lenguaje de marcado general estándar.",
                "\"Transformación operativa\" en editores grupales en tiempo real: problemas, algoritmos y logros.",
                "\"Transformación operativa\" para el procesamiento de textos colaborativos."
            ],
            "translated_text": "",
            "candidates": [
                "transformación operativa",
                "Transformación operativa",
                "Operacional",
                "La transformación ",
                "transformación operativa",
                "Transformación operativa",
                "transformación operativa",
                "transformación operativa",
                "transformación operativa",
                "Transformación operativa",
                "transformación operativa",
                "Transformación operativa"
            ],
            "error": []
        },
        "cot": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the <br>cot</br> (Context-based OT) algorithm.",
                "The <br>cot</br> algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The <br>cot</br> algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the <br>cot</br> algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the <br>cot</br> (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic <br>cot</br> algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The <br>cot</br> solutions to these transformation properties are presented in Section 6.",
                "Comparison of the <br>cot</br> work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the <br>cot</br> algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC <br>cot</br> ALGORITHM In the basic <br>cot</br> algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the <br>cot</br> algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The <br>cot</br> algorithm has two parts: the <br>cot</br>-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole <br>cot</br> algorithm. 4.1 <br>cot</br>-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "<br>cot</br>-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "<br>cot</br>-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "<br>cot</br>-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of <br>cot</br>-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how <br>cot</br>-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 <br>cot</br>-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In <br>cot</br>-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "<br>cot</br>-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "<br>cot</br>-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "<br>cot</br>-DO(O, DS).",
                "<br>cot</br>-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, <br>cot</br>-DO is invoked with parameters O2 and DS.",
                "Inside <br>cot</br>-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by <br>cot</br>-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic <br>cot</br> algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES <br>cot</br> is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic <br>cot</br> algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic <br>cot</br> algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic <br>cot</br> algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "<br>cot</br> SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of <br>cot</br> is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The <br>cot</br> solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The <br>cot</br> solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the <br>cot</br> solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The <br>cot</br> solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of <br>cot</br>, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 <br>cot</br> versus GOTO-ANYUNDO Both <br>cot</br> and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that <br>cot</br> achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "<br>cot</br> is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The <br>cot</br>-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the <br>cot</br> algorithm, <br>cot</br>-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the <br>cot</br> solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the <br>cot</br> algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the <br>cot</br> algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "<br>cot</br> is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "<br>cot</br> is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like <br>cot</br>) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on <br>cot</br> or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The <br>cot</br> algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of <br>cot</br> with respect to various transformation properties/conditions.",
                "Formal verification of <br>cot</br> correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of <br>cot</br>, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the <br>cot</br> (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The <br>cot</br> algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The <br>cot</br> algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the <br>cot</br> algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo \"COT\" (OT basado en el contexto).",
                "El algoritmo \"COT\" es capaz de admitir tanto DO y deshacer cualquier operación en cualquier momento, sin requerir funciones de transformación para preservar la propiedad de reversibilidad, Convergencia Propiedad 2, Propiedades inversas 2 y 3.",
                "El algoritmo \"COT\" no solo es más simple y más eficiente que los algoritmos de control OT anteriores, sino que también simplifica el diseño de funciones de transformación.",
                "Hemos implementado el algoritmo \"COT\" en un motor de colaboración genérico y lo usamos para soportar una gama de aplicaciones de colaboración novedosas.",
                "En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo \"COT\" (OT basado en el contexto).",
                "En la Sección 4, presentamos el algoritmo básico de \"COT\" para soportar el mantenimiento de consistencia (DO) y el grupo deshacer bajo el supuesto de que las funciones de transformación subyacentes pueden preservar algunas propiedades de transformación importantes.",
                "Las soluciones de \"cot\" a estas propiedades de transformación se presentan en la Sección 6.",
                "Comparación del trabajo de \"cot\" con el trabajo previo al trabajo OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7.",
                "Estas condiciones basadas en el contexto forman la base para el algoritmo \"COT\" que se presentará en la Sección 4 y la Sección 6. 1 DS-C (O) es la diferencia establecida entre DS y C (O).3.5 Vector de contexto Un elemento importante de la teoría del contexto de la operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente.",
                "El algoritmo básico de \"cot\" en el algoritmo básico \"cot\", suponemos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas SO-FAR."
            ],
            "translated_text": "",
            "candidates": [
                "cuna",
                "COT",
                "Cot",
                "COT",
                "cuna",
                "COT",
                "cuna",
                "COT",
                "cuna",
                "COT",
                "cuna",
                "COT",
                "Cot",
                "cot",
                "COT",
                "cot",
                "cuna",
                "COT",
                "cuna",
                "cot",
                "cot"
            ],
            "error": []
        },
        "context-based ot": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (<br>context-based ot</br>) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (\"OT basado en el contexto\").",
                "En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (\"OT basado en el contexto\").",
                "Conclusiones Hemos contribuido con la teoría del contexto de operación y el algoritmo COT (\"OT\" OT basado en el contexto \")."
            ],
            "translated_text": "",
            "candidates": [
                "OT basado en el contexto",
                "OT basado en el contexto",
                "OT basado en el contexto",
                "OT basado en el contexto",
                "OT basado en el contexto",
                "OT"
            ],
            "error": []
        },
        "causal-dependency": {
            "translated_key": "Dependencia causal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define <br>causal-dependency</br>/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], <br>causal-dependency</br>/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "<br>causal-dependency</br> relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the <br>causal-dependency</br>/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture <br>causal-dependency</br> relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, <br>causal-dependency</br> relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Primero, definimos la \"dependencia causal\"/-independencia y describimos brevemente sus limitaciones en la Sección 2.",
                "Después de Lamport [9], las relaciones de independencia de \"dependencia causal\"/-entre las operaciones de edición se pueden definir en términos de sus secuencias de generación y ejecución [4, 23].",
                "Relación de \"dependencia causal\" → dadas dos operaciones OA y OB, generadas en los Sitios I y J, OB depende de OA, denotado por OA → OB, Iff: (1) I = J y la generación de OA ocurrió antesla generación de OB;o (2) i = j y la ejecución de OA en el sitio j ocurrió antes de la generación de OB;o (3) existe una operación de buey, de modo que OA → Ox y Ox → Ob.2 Definición 2.",
                "En otras palabras, la relación de \"dependencia causal\"/-de independencia es un caso especial de la relación contexto-dependencia/independencia.3.4 Condiciones basadas en el contexto Las siguientes condiciones basadas en el contexto (CC) capturan requisitos esenciales para la ejecución y transformación de la operación en sistemas OT: 281 CC1: C (O) ⊆ DS es una condición necesaria para que una operación original O se transforme en el documentoEstado DS para la ejecución.",
                "Según la teoría de la causalidad, los algoritmos OT anteriores han utilizado vectores estatales para capturar relaciones de \"dependencia causal\" entre las operaciones normales originales y para representar estados de documentos en términos de operaciones normales originales.",
                "Sin embargo, las relaciones de \"dependencia causal\" no se definen para operaciones inversas o transformadas, y los vectores estatales no pueden representar estados de documentos con operaciones inversas originales."
            ],
            "translated_text": "",
            "candidates": [
                "Dependencia causal",
                "dependencia causal",
                "dependencia causal",
                "dependencia causal",
                "Dependencia causal",
                "dependencia causal",
                "dependencia causal",
                "dependencia causal",
                "dependencia causal",
                "dependencia causal",
                "dependencia causal",
                "dependencia causal"
            ],
            "error": []
        },
        "concurrency condition": {
            "translated_key": "condición de concurrencia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the <br>concurrency condition</br> alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Sin embargo, la investigación posterior descubrió que la \"condición de concurrencia\" por sí sola no es suficiente para garantizar la corrección de la transformación."
            ],
            "translated_text": "",
            "candidates": [
                "condición de concurrencia",
                "condición de concurrencia"
            ],
            "error": []
        },
        "concurrency relation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the <br>concurrency relation</br> does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Además, la \"relación concurrencia\" no captura la condición esencial para la transformación de TI correcta: las dos operaciones de entrada deben definirse en el mismo estado de documento [23]."
            ],
            "translated_text": "",
            "candidates": [
                "relación de concurrencia",
                "relación concurrencia"
            ],
            "error": []
        },
        "inverse operation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an <br>inverse operation</br> (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an <br>inverse operation</br> O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an <br>inverse operation</br> like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original <br>inverse operation</br> O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original <br>inverse operation</br> O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original <br>inverse operation</br>, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an <br>inverse operation</br>, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original <br>inverse operation</br> can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original <br>inverse operation</br> directly or indirectly corresponds to exactly one original normal operation.",
                "For example, <br>inverse operation</br> O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an <br>inverse operation</br> can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed <br>inverse operation</br> Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an <br>inverse operation</br> Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an <br>inverse operation</br>) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an <br>inverse operation</br> is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El concepto de causalidad no es adecuado para capturar las relaciones entre una \"operación inversa\" (como una interpretación de un comando de deshacer de nivel meta) y otras operaciones de edición normales.operación inversa",
                "El comando deshacer (O2) en la Figura 1 se interpreta como una \"operación inversa\" O2.operación inversa",
                "Además, después de ejecutar una \"operación inversa\" como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales.3. Operación inversa",
                "Para lograr el efecto deshacer en [21], se debe definir una \"operación inversa\" original en el estado del documento ds = c (o) ∪ {o}, que es el estado después de ejecutar la operación original O en el estado c (O).operación inversa",
                "Para una \"operación inversa\" original o, c (o) = c (o) ∪ {o}, donde o es la operación a deshacer.3. Operación inversa",
                "Cuando O es una \"operación inversa\" original, C (O) debe incluir la operación que se deshacerá por O (ver definición 4-item 2), por lo que CC1 conserva el orden de do-into entre las operaciones normales e inversas [21].operación inversa",
                "Cuando O es una \"operación inversa\", CC2 cubre la condición de que O debe transformarse contra todas las operaciones que se ejecutan después de la operación que se deshará por O [21].operación inversa",
                "Todas las operaciones normales originales en un contexto se pueden dividir en N grupos de acuerdo con sus sitios de generación, por lo que se necesitan N enteros para representar operaciones normales originales en un contexto.3.5.2 Representación de operaciones inversas originales Se puede generar una \"operación inversa\" original para deshacer una operación normal original, o para rehacer una operación sin hacer.operación inversa",
                "Cada \"operación inversa\" original corresponde directa o indirectamente a exactamente una operación normal original.operación inversa",
                "Por ejemplo, se puede generar \"operación inversa\" o para deshacer, y se puede generar para deshacer la operación inversa"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "document state": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same <br>document state</br>.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) <br>document state</br>.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the <br>document state</br> that contains the effect of O2, whereas O1 is defined on the initial <br>document state</br>.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the <br>document state</br> including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same <br>document state</br> [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the <br>document state</br> including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the <br>document state</br> with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the <br>document state</br> can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current <br>document state</br> are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the <br>document state</br> which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current <br>document state</br> at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial <br>document state</br>.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current <br>document state</br> at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the <br>document state</br> with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the <br>document state</br> on which the operation is defined, the problem of context representation can be reduced into the problem of <br>document state</br> representation.",
                "In an OT-based group editor, each <br>document state</br> can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same <br>document state</br> must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a <br>document state</br>.",
                "Definition 3.",
                "<br>document state</br> representation A <br>document state</br> can be represented by DS as follows: 1.",
                "The initial <br>document state</br> is represented by DS = {}. 2.",
                "After executing an operation O of any type on the <br>document state</br> represented by DS, the new <br>document state</br> is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the <br>document state</br> representation, the context of an original normal operation should be the same as the representation of the <br>document state</br> from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the <br>document state</br> DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the <br>document state</br> DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the <br>document state</br> from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the <br>document state</br> DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the <br>document state</br> DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the <br>document state</br> DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the <br>document state</br>.",
                "As an example, consider the <br>document state</br> after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the <br>document state</br> after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This <br>document state</br> cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the <br>document state</br> after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a <br>document state</br> DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current <br>document state</br> representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial <br>document state</br> DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current <br>document state</br> representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a <br>document state</br> DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the <br>document state</br> DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the <br>document state</br> on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Otra condición es que las dos operaciones concurrentes deben definirse en el mismo \"estado de documento\".Estado del documento",
                "Bajo el algoritmo DOPT [4], cuando O2 llega al Sitio 0, se informará contra O1 desde O2 O1;Esto es correcto porque O2 y O1 se definen en el mismo \"estado de documento\" (inicial).Estado del documento",
                "Cuando O3 llega al Sitio 0, también se transformará contra O1 desde O3 O1;Pero esto es incorrecto porque O3 se define en el \"estado del documento\" que contiene el efecto de O2, mientras que O1 se define en el \"estado del documento\" inicial.Estado del documento",
                "La solución a este rompecabezas es la primera en la transformación de TI O1 contra O2 para producir O1, que se define en el \"estado del documento\", incluido el efecto de O2 (el mismo estado en el que se define O3), y luego a la transformación de IT3 O3contra O1 [22].Estado del documento",
                "Además, la relación concurrencia no captura la condición esencial para la transformación correcta de TI: las dos operaciones de entrada deben definirse en el mismo \"estado de documento\" [23].Estado del documento",
                "Para lograr este efecto, O2 debe tratarse como una operación definida en el \"estado del documento\", incluido el efecto de O2 pero no O1 y O3, de modo que O2 se pueda transformar contra O1 y O3 antes de su ejecución.Estado del documento",
                "Si O2 heredara la relación causal de UNDO (O2), entonces se trataría efectivamente como una operación definida en el \"estado del documento\" con los efectos de las tres operaciones O1, O2 y O3, lo que prohibiría ser O2transformado contra cualquier operación, por lo que no logró el efecto de deshacer correcto.Estado del documento",
                "Además, después de ejecutar una operación inversa como O2, el \"estado del documento\" ya no puede ser representado correctamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales.3. Estado del documento",
                "La importancia del contexto de operación es doble: (1) una operación se puede ejecutar correctamente solo si su contexto y el \"estado de documento\" actual son los mismos;y (2) una operación se puede hacer correctamente en otra operación solo si los contextos de estas dos operaciones son los mismos.Estado del documento",
                "En la Figura 1, tanto O1 como O2 se definen en el mismo documento inicial, por lo que están asociados con el mismo contexto;O3 se define en el \"estado del documento\" que incluye el efecto de O2, por lo que C (O3) es diferente de C (O1) o C (O2).Estado del documento"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "original operation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an <br>original operation</br>, we use the notation org(O) to denote the <br>original operation</br> of O.",
                "If O is an <br>original operation</br>, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the <br>original operation</br> O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an <br>original operation</br> is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an <br>original operation</br> Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an <br>original operation</br> Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an <br>original operation</br> O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any <br>original operation</br> Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an <br>original operation</br> to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same <br>original operation</br> are organized in the same version group.",
                "When an <br>original operation</br> is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the <br>original operation</br> in the transformation process, thus saving the overhead to transform the <br>original operation</br> into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Dado que cada operación transformada debe provenir de una \"operación original\", utilizamos la organización de notación (O) para denotar la \"operación original\" de O. Operación original",
                "Si o es una \"operación original\", entonces org (O) = O. Operación original",
                "Para lograr el efecto deshacer en [21], se debe definir una operación inversa original O en el estado del documento ds = c (o) ∪ {o}, que es el estado después de ejecutar la \"operación original\" o en el estado c (O).operación original",
                "De o2 = it (o2, o1), tenemos c (o2) = {o1} de acuerdo con la definición 4-ítem 3. 3.3 dependencia de contexto/independencia definimos la relación de-dependencia/independencia de contexto entre operaciones en términos deSi se incluye una \"operación original\" en el contexto de otra operación de cualquier tipo.operación original",
                "Relación de dependencia de contexto C → Dada una \"operación original\" OA y una operación OB de cualquier tipo, OB depende del contexto en OA, denotado por OA C → OB, IFF: (1) OA ∈ C (OB);o (2) existe una \"operación original\" ox, de modo que oa ∈ C (ox) y ox ∈ C (OB).2 Cabe señalar que la relación de dependencia de contexto se define solo entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada).operación original",
                "En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación contexto-dependencia/independencia.3.4 Condiciones basadas en el contexto Las siguientes condiciones basadas en el contexto (CC) capturan requisitos esenciales para la ejecución y transformación de la operación en sistemas OT: 281 cc1: c (o) ⊆ ds es una condición necesaria para que una \"operación original\" se transformeEl documento estado DS para la ejecución.operación original",
                "En otras palabras, para cualquier buey de \"operación original\", si ox c → o, entonces buey debe ejecutarse antes de O. operación original",
                "El contexto de operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT.4.1 COT -DO COT -DO toma dos parámetros: O - una \"operación original\" para ser ejecutada, y DS - la representación actual del estado del documento.operación original",
                "Hemos ideado e implementado una estructura de almacenamiento en búfer en la que no solo se pueden guardar operaciones originales, sino también versiones transformadas;y todas las operaciones transformadas de la misma \"operación original\" están organizadas en el mismo grupo de versiones.operación original",
                "Cuando se requiere una \"operación original\" en el nivel de algoritmo COT, se busca al grupo de versiones correspondiente para una versión que coincida con el requisito de contexto.operación original"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "transformed operation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every <br>transformed operation</br> must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a <br>transformed operation</br> O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a <br>transformed operation</br> O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the <br>transformed operation</br> Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a <br>transformed operation</br> whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Dado que cada \"operación transformada\" debe provenir de una operación original, utilizamos la organización de notación (O) para denotar la operación original de O. Operación transformada",
                "De acuerdo con la definición de la función IT [23], una \"operación transformada\" o, donde o = it (o, ox), debe definirse en el estado del documento ds = c (o) ∪ ∪ {org (ox)},que es el estado que se puede lograr ejecutando buey en el estado c (o).operación transformada",
                "Para una \"operación transformada\" o, c (o) = c (o) ∪ {org (ox)}, donde o = it (o, ox).2 Según la definición anterior, el contexto de cualquier tipo de operación puede representarse como un conjunto de operaciones originales.operación transformada",
                "Dadas dos operaciones oa y ob, si oa: = it (oa, ob), ob: = it (ob, oa), y oa: = it (oa, ob), entonces debe ser: oa = oa, lo que significaLa operación inversa transformada OA es igual al inverso de la \"operación transformada\" OA.operación transformada",
                "Esta nueva O inversa O debe ser Safe IP3 porque se crea a partir de una \"operación transformada\" cuyo contexto ha incluido todas las operaciones en NCD.operación transformada"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "inverse cluster": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The <br>inverse cluster</br> at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El \"clúster inverso\" en el sitio i - icican se expresará de la siguiente manera: ici = [(NS0, IS0), (NS1, IS1) ,..., (NSK - 1, ISK - 1)], donde cada par (NSJ, ISJ), 0 ≤ J <k, representa un grupo inverso con operaciones inversas ISJ correspondientes a la operación normal original con el número de secuencia NSJ en el sitio i.grupo inverso"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "vector representation of operation context": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The <br>vector representation of operation context</br> can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the <br>vector representation of operation context</br> can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La \"representación vectorial del contexto de operación\" también se puede utilizar como la representación vectorial del estado del documento.Representación vectorial del contexto de operación",
                "Además, la \"representación vectorial del contexto de operación\" también puede usarse para detectar eficientemente las relaciones de dependencia/independencia del contexto.Representación vectorial del contexto de operación"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "operation context vector representation": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "history buffer": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the <br>history buffer</br> (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the <br>history buffer</br> position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the <br>history buffer</br>.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Esto es diferente del registro o los esquemas \"Buffer de historia\" (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas.búfer de historia",
                "Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición del \"amortiguación de la historia\" entre las operaciones [23, 21].búfer de historia",
                "Según este esquema, las operaciones inversas no se representan explícitamente en el \"búfer de historia\".búfer de historia"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "exclusion transformation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (<br>exclusion transformation</br>) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "A diferencia de GOTO-AYUNDO, el algoritmo COT básico no usa funciones ET (\"Transformación de exclusión\") [21], evitando así el requisito de la propiedad de reversibilidad (RP) entre las funciones de TI y ET [21].transformación de exclusión"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "operation context": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>operation context</br> and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the <br>operation context</br> theory, including the definition of <br>operation context</br>, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "<br>operation context</br> 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of <br>operation context</br> is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of <br>operation context</br> To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent <br>operation context</br>.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the <br>operation context</br> theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an <br>operation context</br> can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an <br>operation context</br> with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the <br>operation context</br>, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of <br>operation context</br> can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of <br>operation context</br> can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "<br>operation context</br> and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of <br>operation context</br> The notion of <br>operation context</br> was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an <br>operation context</br>.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of <br>operation context</br> is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of <br>operation context</br> is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of <br>operation context</br>, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of <br>operation context</br> for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the <br>operation context</br>, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of <br>operation context</br> and the COT (Context-based OT) algorithm.",
                "The theory of <br>operation context</br> is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of <br>operation context</br> and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "\"Contexto de operación\" y transformación operativa basada en el contexto División de Informática David Sun, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Nanyang Universidad Tecnológica Singapur czsun@ntu.edu.sg Resumen Operacional Transformación(OT) es una técnica para el mantenimiento de consistencia y la deshacer del grupo, y se aplica a un número creciente de aplicaciones de colaboración.contexto de operación",
                "En este artículo, informamos los principales resultados de este esfuerzo: la teoría del \"contexto de operación\" y el algoritmo COT (OT basado en el contexto).contexto de operación",
                "En este artículo, informamos los principales resultados de este esfuerzo: la teoría del \"contexto de operación\" y el algoritmo COT (OT basado en el contexto).contexto de operación",
                "Luego, presentamos los elementos clave de la teoría del \"contexto de la operación\", incluida la definición de \"contexto de operación\", relaciones de dependencia de contexto/independencia, condiciones basadas en contexto y vectores de contexto en la Sección 3. Contexto de operación",
                "\"Contexto de operación\" 3.1 Concepto básico conceptualmente, cada operación O se asocia con un contexto, denotado por C (O), que corresponde al estado del documento 280 en el que se define la operación.contexto de operación",
                "La importancia del \"contexto de operación\" es doble: (1) una operación se puede ejecutar correctamente solo si su contexto y el estado del documento actual son los mismos;y (2) una operación se puede hacer correctamente en otra operación solo si los contextos de estas dos operaciones son los mismos.contexto de operación",
                "Como se discutió en la Sección 2, el deshacer (O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de O2 solamente.3.2 Establecer representación del \"contexto de operación\" Para facilitar la comparación y la manipulación de los contextos de operación para la ejecución y transformación correctas, es necesario representar explícitamente el \"contexto de operación\".contexto de operación",
                "Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS-C (O) es la diferencia establecida entre DS y C (O).3.5 Vector de contexto Un elemento importante de la teoría del \"contexto de la operación\" es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente.contexto de operación",
                "Según esta observación, todas las operaciones inversas originales en un \"contexto de operación\" pueden agruparse por sus correspondientes operaciones normales originales: un grupo inverso para cada operación normal original deshecho.contexto de operación",
                "Si no se ha deshecho el funcionamiento normal en el sitio I, ICI está vacío.3.5.3 Representando las operaciones normales e inversas para representar un \"contexto de operación\" con operaciones normales e inversas originales, un vector de contexto N-dimensional se define a continuación.282 Definición 7. Contexto de operación"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "ot": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (<br>ot</br>) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for <br>ot</br> is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior <br>ot</br> systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated <br>ot</br> algorithms.",
                "After having designed, implemented, and experimented with a series of <br>ot</br> algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving <br>ot</br> problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based <br>ot</br>) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior <br>ot</br> control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (<br>ot</br>) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, <br>ot</br> has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of <br>ot</br> in solving both old and new problems.",
                "The soundness of the theoretical foundation for <br>ot</br> is crucial in this process.",
                "One theoretical underpinning of all existing <br>ot</br> algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential <br>ot</br> conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of <br>ot</br>.",
                "The dOPT algorithm was the first <br>ot</br> algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up <br>ot</br> algorithms.",
                "The causality theory limitation became even more prominent when <br>ot</br> was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated <br>ot</br> algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of <br>ot</br> algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving <br>ot</br> problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based <br>ot</br>) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior <br>ot</br> work, <br>ot</br> correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing <br>ot</br> algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in <br>ot</br> systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing <br>ot</br> conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In <br>ot</br> systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an <br>ot</br>-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in <br>ot</br> systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior <br>ot</br> algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior <br>ot</br> systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an <br>ot</br> system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an <br>ot</br> system.",
                "Different <br>ot</br> systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in <br>ot</br> literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the <br>ot</br> system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the <br>ot</br> system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the <br>ot</br> system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the <br>ot</br> system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an <br>ot</br> system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the <br>ot</br> system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior <br>ot</br> systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential <br>ot</br> conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior <br>ot</br> algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential <br>ot</br> conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the <br>ot</br> system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior <br>ot</br> algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 <br>ot</br> buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first <br>ot</br> algorithm that buffers and uses original operations for transformation.",
                "Several prior <br>ot</br> algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 <br>ot</br> correctness <br>ot</br> correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important <br>ot</br> correctness issues.",
                "<br>ot</br> is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing <br>ot</br> issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining <br>ot</br> solutions.",
                "Puzzles are subtle but representative scenarios in which certain <br>ot</br> properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an <br>ot</br> system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an <br>ot</br> system works or fails.",
                "In real <br>ot</br> system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify <br>ot</br> correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic <br>ot</br> research.",
                "Many <br>ot</br> components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete <br>ot</br> solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one <br>ot</br> component may be resolved easily, or avoided altogether, if this issue is addressed from a different <br>ot</br> component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different <br>ot</br> systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all <br>ot</br> systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many <br>ot</br> systems.",
                "They are insufficient because an <br>ot</br> system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by <br>ot</br> systems based on COT or some prior <br>ot</br> algorithms [26, 20, 12].",
                "One <br>ot</br> correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An <br>ot</br> system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early <br>ot</br> work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known <br>ot</br> puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based <br>ot</br>) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an <br>ot</br> system; it provides a new foundation for better understanding and resolving <br>ot</br> problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior <br>ot</br> control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future <br>ot</br> research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging <br>ot</br> applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Operación contexto y transformación operativa basada en el contexto División de Informática de David Sun, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapur czsun@ntu.edu.sg Transformación operativa abstracta (\"(\"OT \") es una técnica para el mantenimiento de consistencia y la deshacer del grupo, y se aplica a un número creciente de aplicaciones de colaboración.Antiguo Testamento",
                "La base teórica para \"OT\" es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones.Antiguo Testamento",
                "La teoría de la causalidad ha sido la base de todos los sistemas \"OT\" anteriores, pero es inadecuado capturar los requisitos de corrección esenciales.Antiguo Testamento",
                "Investigaciones anteriores habían inventado varios parches para resolver este problema, lo que resultó en algoritmos \"OT\" cada vez más intrincados y complicados.Antiguo Testamento",
                "Después de haber diseñado, implementado y experimentado con una serie de algoritmos \"OT\", reflexionamos sobre lo que se había aprendido y nos propusimos desarrollar un nuevo marco teórico para una mejor comprensión y resolución de problemas de \"OT\", reduciendo su complejidad y apoyando suevolución continua.Antiguo Testamento",
                "En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (\"OT\" basado en el contexto).Antiguo Testamento",
                "El algoritmo COT no solo es más simple y más eficiente que los algoritmos de control \"OT\" anteriores, sino que también simplifica el diseño de funciones de transformación.Antiguo Testamento",
                "Introducción La transformación operativa (\"OT\") se inventó originalmente para el mantenimiento de consistencia en editores de grupos de texto simple [4].Antiguo Testamento",
                "En más de 15 años, \"OT\" ha evolucionado para respaldar un número creciente de aplicaciones, incluida la deshacer de grupo [15, 19, 18, 21], la conciencia grupal [28], la notificación de operación y la compresión [20], la hoja de cálculo y la tabla-Aplicaciones céntricas [14, 27], HTML/XML y edición de documentos estructurados en árbol [3, 7], procesamiento de palabras y creación de diapositivas [29, 25, 24], intercambio de aplicaciones transparentes y heterogéneos [1, 10, 24],y sistemas de base de datos y computación replicada móviles [6, 16].Antiguo Testamento",
                "Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos continuar mejorando la capacidad y la calidad de \"OT\" para resolver problemas antiguos y nuevos.Antiguo Testamento"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "context-base ot": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "consistency maintenance": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for <br>consistency maintenance</br> and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for <br>consistency maintenance</br> in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting <br>consistency maintenance</br> (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting <br>consistency maintenance</br> (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for <br>consistency maintenance</br> (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to <br>consistency maintenance</br> [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both <br>consistency maintenance</br> and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "<br>consistency maintenance</br> based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Operación contexto y transformación operativa basada en el contexto División de informática David Sun, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Nanyang Universidad Tecnológica Singapur czsun@ntu.edu.sg Abstract Operational Transformación (OT) es una técnica para el \"mantenimiento de consistencia\" y la deshacer del grupo, y se aplica a un número creciente de aplicaciones colaborativas.mantenimiento de consistencia",
                "Introducción La transformación operativa (OT) se inventó originalmente para \"mantenimiento de consistencia\" en editores de grupos de texto simple [4].mantenimiento de consistencia",
                "En la Sección 4, presentamos el algoritmo COT básico para apoyar el \"mantenimiento de consistencia\" (DO) y el grupo deshacer bajo el supuesto de que las funciones de transformación subyacentes pueden preservar algunas propiedades de transformación importantes.mantenimiento de consistencia",
                "El algoritmo COT tiene dos partes: la parte COT-DO para soportar el \"mantenimiento de consistencia\" (DO) y la parte de Cotondo para soportar UNDO.mantenimiento de consistencia",
                "Por ejemplo, una solución que funciona bien para el \"mantenimiento de consistencia\" (DO), puede fallar cuando se consideran los problemas de DO y deshacer;y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución al \"mantenimiento de consistencia\" [21].mantenimiento de consistencia",
                "El algoritmo COT proporciona soluciones uniformadas tanto para \"mantenimiento de consistencia\" como para deshacer los problemas;Es más simple y más eficiente que los algoritmos de control OT anteriores con capacidades similares;y simplifica significativamente el diseño de funciones de transformación.mantenimiento de consistencia",
                "\"Mantenimiento de consistencia\" basado en la técnica de Mark & Ratrice en los sistemas de grupos.mantenimiento de consistencia"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "undo": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group <br>undo</br>, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and <br>undo</br> of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group <br>undo</br> [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the <br>undo</br> problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level <br>undo</br> command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group <br>undo</br> under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the <br>undo</br> command <br>undo</br>(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the <br>undo</br> command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The <br>undo</br>(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct <br>undo</br> effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], <br>undo</br>(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of <br>undo</br>(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct <br>undo</br> effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, <br>undo</br>(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to <br>undo</br> some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the <br>undo</br> effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-<br>undo</br> ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to <br>undo</br> an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to <br>undo</br> O, and O may be generated to <br>undo</br> O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the <br>undo</br> command <br>undo</br>(O2) in Figure 1.",
                "Since <br>undo</br>(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting <br>undo</br>.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-<br>undo</br> To <br>undo</br> an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the <br>undo</br> command for selecting any operation to <br>undo</br> is part of the undo policy [21].",
                "This paper is confined to the discussion of the <br>undo</br> mechanism, which determines how to <br>undo</br> the selected operation in a given context.",
                "In COT-<br>undo</br>, <br>undo</br>(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-<br>undo</br> takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-<br>undo</br>(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-<br>undo</br> works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret <br>undo</br>(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and <br>undo</br> operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct <br>undo</br> effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-<br>undo</br>-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-<br>undo</br>-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an <br>undo</br>/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any <br>undo</br>/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and <br>undo</br> operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-<br>undo</br>-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the <br>undo</br>-part of a do-<br>undo</br>-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-<br>undo</br>-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-<br>undo</br> are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-<br>undo</br>-pair occurs not immediately after executing each inverse, but only when both the do-part and the <br>undo</br>-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and <br>undo</br> problems are considered; and an <br>undo</br> solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and <br>undo</br> problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and <br>undo</br> problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group <br>undo</br>.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and <br>undo</br> in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "<br>undo</br> as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Operación contexto y transformación operativa basada en el contexto División de informática David Sun, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Nanyang Universidad Tecnológica Singapur czsun@ntu.edu.sg Abstract Operational Transformación (OT) es una técnica para el mantenimiento de la consistencia y el \"deshacer\" del grupo, y se aplica a un número creciente de aplicaciones colaborativas.deshacer",
                "El algoritmo COT es capaz de admitir tanto DO como \"deshacer\" de cualquier operación en cualquier momento, sin requerir funciones de transformación para preservar la propiedad de reversibilidad, Convergencia Propiedad 2, Inverse Propiedades 2 y 3. Deshacer",
                "En más de 15 años, OT ha evolucionado para respaldar un número creciente de aplicaciones, incluida la \"deshacer\" del grupo [15, 19, 18, 21], la conciencia del grupo [28], la notificación de operación y la compresión [20], la hoja de cálculo y la tabla-Aplicaciones céntricas [14, 27], HTML/XML y edición de documentos estructurados en árbol [3, 7], procesamiento de palabras y creación de diapositivas [29, 25, 24], intercambio de aplicaciones transparentes y heterogéneos [1, 10, 24],y sistemas de base de datos y computación replicada móviles [6, 16].deshacer",
                "La limitación de la teoría de la causalidad se volvió aún más prominente cuando se aplicó OT para resolver el problema de \"deshacer\" en los editores grupales.deshacer",
                "El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando \"deshacer\" de meta) y otras operaciones de edición normales.deshacer",
                "En la Sección 4, presentamos el algoritmo COT básico para soportar el mantenimiento de consistencia (DO) y el grupo \"deshacer\" bajo el supuesto de que las funciones de transformación subyacentes pueden preservar algunas propiedades de transformación importantes.deshacer",
                "Hay tres operaciones de edición en este escenario (el comando \"deshacer\" \"deshacer\" (O2) y su relación con otras operaciones se explicará más adelante): O1 generado en el Sitio 0, y O2 y O3 generados en el Sitio 1. Deshacer",
                "El escenario en la Figura 1 (sin el comando \"deshacer\") a menudo se ha utilizado para ilustrar el dopt-huzzle.deshacer",
                "El comando \"deshacer\" (O2) en la Figura 1 se interpreta como una operación inversa O2.deshacer",
                "El efecto de \"deshacer\" correcto para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, deshacer"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "group editor": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based <br>group editor</br>, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En un \"editor de grupos\" basado en OT, cada estado de documento puede estar representado de manera única por el conjunto de operaciones originales ejecutadas hasta ahora en el documento.editor de grupo"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "distribute application": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Operation Context and Context-based Operational Transformation David Sun Computer Science Division, EECS University of California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun School of Computer Engineering Nanyang Technological University Singapore CZSun@ntu.edu.sg ABSTRACT Operational Transformation (OT) is a technique for consistency maintenance and group undo, and is being applied to an increasing number of collaborative applications.",
                "The theoretical foundation for OT is crucial in determining its capability to solve existing and new problems, as well as the quality of those solutions.",
                "The theory of causality has been the foundation of all prior OT systems, but it is inadequate to capture essential correctness requirements.",
                "Past research had invented various patches to work around this problem, resulting in increasingly intricate and complicated OT algorithms.",
                "After having designed, implemented, and experimented with a series of OT algorithms, we reflected on what had been learned and set out to develop a new theoretical framework for better understanding and resolving OT problems, reducing its complexity, and supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The COT algorithm is capable of supporting both do and undo of any operations at anytime, without requiring transformation functions to preserve Reversibility Property, Convergence Property 2, Inverse Properties 2 and 3.",
                "The COT algorithm is not only simpler and more efficient than prior OT control algorithms, but also simplifies the design of transformation functions.",
                "We have implemented the COT algorithm in a generic collaboration engine and used it for supporting a range of novel collaborative applications.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed Applications; H.5.3 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing; Synchronous interaction General Terms Algorithms, Design, Theory 1.",
                "INTRODUCTION Operational Transformation (OT) was originally invented for consistency maintenance in plain-text group editors [4].",
                "In over 15 years, OT has evolved to support an increasing number of applications, including group undo [15, 19, 18, 21], group-awareness [28], operation notification and compression [20], spreadsheet and table-centric applications [14, 27], HTML/XML and tree-structured document editing [3, 7], word processing and slide creation [29, 25, 24], transparent and heterogenous application-sharing [1, 10, 24], and mobile replicated computing and database systems [6, 16].",
                "To effectively and efficiently support existing and new applications, we must continue to improve the capability and quality of OT in solving both old and new problems.",
                "The soundness of the theoretical foundation for OT is crucial in this process.",
                "One theoretical underpinning of all existing OT algorithms is causality/concurrency [9, 17, 4, 22]: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution.",
                "However, the theory of causality is inadequate to capture essential OT conditions for correct transformation.",
                "The limitation of the causality theory had caused correctness problems from the very beginning of OT.",
                "The dOPT algorithm was the first OT algorithm and was based solely on the concurrency relationships among operations [4]: a pair of operations are transformable as long as they are concurrent.",
                "However, later research discovered that the concurrency condition alone is not sufficient to ensure the correctness of transformation.",
                "Another condition is that the two concurrent operations must be defined on the same document state.",
                "In fact, the failure to meet the second condition was the root of the dOPT-puzzle [22].",
                "This puzzle was solved in various ways, but the theory of causality as well as its limitation were inherited by all follow-up OT algorithms.",
                "The causality theory limitation became even more prominent when OT was applied to solve the undo problem in group editors.",
                "The concept of causality is unsuitable to capture the relationships between an inverse operation (as an interpretation of a meta-level undo command) and other normal editing operations.",
                "In fact, the causality relation is not defined for inverse operations (see Section 2).",
                "Various patches were invented to work around this problem, resulting in more intricate complicated OT algorithms [18, 21].",
                "After having designed, implemented, and experimented with a series of OT algorithms of increased complexity, we reflected on what had been learned and set out to develop a uniformed theoretical framework for better understanding and resolving OT problems, reducing its complexity, and 279 supporting its continual evolution.",
                "In this paper, we report the main results of this effort: the theory of operation context and the COT (Context-based OT) algorithm.",
                "The rest of this paper is organized as follows.",
                "First, we define causal-dependency/-independency and briefly describe their limitations in Section 2.",
                "Then, we present the key elements of the operation context theory, including the definition of operation context, context-dependency/-independency relations, context-based conditions, and context vectors in Section 3.",
                "In Section 4, we present the basic COT algorithm for supporting consistency maintenance (do) and group undo under the assumption that underlying transformation functions are able to preserve some important transformation properties.",
                "Then, these transformation properties and their pre-conditions are discussed in Section 5.",
                "The COT solutions to these transformation properties are presented in Section 6.",
                "Comparison of the COT work to prior OT work, OT correctness issues, and future work are discussed in Section 7.",
                "Finally, major contributions of this work are summarized in Section 8. 2.",
                "LIMITATIONS OF CAUSALITY The theory of causality is central to distributed computing and to the design of all existing OT algorithms.",
                "Following Lamport [9], causal-dependency/-independency relations among editing operations can be defined in terms of their generation and execution sequences [4, 23].",
                "Definition 1.",
                "Causal-dependency relation → Given two operations Oa and Ob, generated at sites i and j, Ob is causal-dependent on Oa, denoted by Oa → Ob, iff: (1) i = j and the generation of Oa happened before the generation of Ob; or (2) i = j and the execution of Oa at site j happened before the generation of Ob; or (3) there exists an operation Ox, such that Oa → Ox and Ox → Ob. 2 Definition 2.",
                "Causal-independency relation  Given two operations Oa and Ob, Oa and Ob are causalindependent or concurrent, denoted by Oa Ob, iff neither Oa → Ob, nor Ob → Oa. 2 Just as Vector Logical Clocks are used for capturing casuality in distributed systems [17], State Vectors have been used for capturing causal relationships among operations and for representing document states in OT systems [4, 19, 23].",
                "To illustrate causal relations among operations, consider a real-time group editing session with two sites in Figure 1.",
                "There are three editing operations in this scenario (the undo command Undo(O2) and its relation with other operations shall be explained later): O1 generated at site 0, and O2 and O3 generated at site 1.",
                "According to Definitions 1 and 2, we have O2 → O3 because the generation of O2 happened before the generation of O3; O1 O2 and O1 O3 because for each pair, neither operations execution happened before the other operations generation.",
                "In the following discussion, we shall use the term ITtransform to mean the use of the IT (Inclusion Transformation) function: IT(Oa, Ob), which transforms operation Oa against operation Ob in such a way that the impact of Ob is effectively included in Oa [23].",
                "This term is introduced to differentiate this special transformation function from other steps involved in a transformation process.",
                "Figure 1: A real-time group editing scenario.",
                "The scenario in Figure 1 (without the undo command) has often been used to illustrate the dOPT-puzzle.",
                "Under the dOPT algorithm [4], when O2 arrives at site 0, it will be ITtransformed against O1 since O2 O1; this is correct because O2 and O1 are defined on the same (initial) document state.",
                "When O3 arrives at site 0, it will also be IT-transformed against O1 since O3 O1; but this is incorrect because O3 is defined on the document state that contains the effect of O2, whereas O1 is defined on the initial document state.",
                "In this case, the parameters of O3 and O1 are not comparable and hence may not be IT-transformed correctly.",
                "The solution to this puzzle is first to IT-transform O1 against O2 to produce O1, which is defined on the document state including the effect of O2 (the same state on which O3 is defined), and then to IT-transform O3 against O1 [22].",
                "From Definitions 1 and 2, it is clear that the causaldependency relation is only defined for original operations (e.g.",
                "O1, O2 and O3) directly generated by users, but not for transformed operations (e.g.",
                "O1).",
                "Furthermore, the concurrency relation does not capture the essential condition for correct IT-transformation: the two input operations must be defined on the same document state [23].",
                "Another major limitation of causality is its unsuitability for capturing OT conditions for inverse operations.",
                "The Undo(O2) command in Figure 1 is interpreted as an inverse operation O2.",
                "The correct undo effect for O2 is to eliminate the effect of O2 but retain the effects of other operations (i.e.",
                "O1 and O3) [21].",
                "To achieve this effect, O2 needs to be treated as an operation defined on the document state including the effect of O2 but not O1 and O3, so that O2 can be transformed against O1 and O3 before its execution.",
                "However, according to Lamports happen-before relation [9], Undo(O2) is causally dependent on O1, O2, and O3.",
                "If O2 was to inherit the causal relation of Undo(O2), then it would be effectively treated as an operation defined on the document state with the effects of all three operations O1, O2, and O3, which would prohibit O2 from being transformed against any operation, thus failing to achieve the correct undo effect.",
                "Moreover, after executing an inverse operation like O2, the document state can no longer be properly represented by the state vector, which is only capable of representing original normal editing operations. 3.",
                "OPERATION CONTEXT 3.1 Basic concept Conceptually, each operation O is associated with a context, denoted by C(O), which corresponds to the document 280 state on which the operation is defined.",
                "The significance of operation context is twofold: (1) an operation can be correctly executed only if its context and the current document state are the same; and (2) an operation can be correctly ITtransformed against another operation only if the contexts of these two operations are the same.",
                "In Figure 1, both O1 and O2 are defined on the same initial document so they are associated with the same context; O3 is defined on the document state which includes the effect of O2, so C(O3) is different from C(O1) or C(O2).",
                "When O2 arrives at site 0, it cannot be executed as-is since C(O2) does not match the current document state at site 0 which includes the effect of O1.",
                "O2 can be correctly IT-transformed against O1 since their contexts corresponds to the same initial document state.",
                "When O3 arrives at site 0, it cannot be executed as-is either since C(O3) does not match the current document state at site 0 which includes the effects of both O1 and O2.",
                "O3 cannot be correctly IT-transformed against O1 since their contexts are different, which is the root of the dOPT-puzzle.",
                "As discussed in Section 2, Undo(O2) should be interpreted as an inverse O2 defined on the document state with the effect of O2 only. 3.2 Set representation of operation context To facilitate comparison and manipulation of operation contexts for correct execution and transformation, it is necessary to explicitly represent operation context.",
                "In OT systems, there are two different kinds of operation: original operations which are generated by users, and transformed operations which are the outcomes of some transformations.",
                "Original operations can be further divided into two classes: normal operations which are generated to do something, and inverse operations which are generated to undo some executed operations.",
                "For any operation O, its inverse is denoted by O.",
                "Since every transformed operation must come from an original operation, we use the notation org(O) to denote the original operation of O.",
                "If O is an original operation, then org(O) = O.",
                "Since the context of an operation corresponds to the document state on which the operation is defined, the problem of context representation can be reduced into the problem of document state representation.",
                "In an OT-based group editor, each document state can be uniquely represented by the set of original operations executed so far on the document.",
                "These original operations may be executed in different orders or in different (original or transformed) forms at different sites, but the same document state must be achieved (according to the convergence requirement [23]).",
                "We use original (normal and inverse) operations, rather than their transformed versions, to represent a document state.",
                "Definition 3.",
                "Document state representation A document state can be represented by DS as follows: 1.",
                "The initial document state is represented by DS = {}. 2.",
                "After executing an operation O of any type on the document state represented by DS, the new document state is represented by DS = DS ∪ {org(O)}. 2 This presentation does not specify what execution forms the original operations in DS should take to bring the document to the current state, but it captures essential and sufficient information for detecting whether two document states are the same and for deriving their differences in terms of original operations.",
                "Based on the document state representation, the context of an original normal operation should be the same as the representation of the document state from which this operation was generated.",
                "To achieve the undo effect in [21], an original inverse operation O should be defined on the document state DS = C(O) ∪ {O}, which is the state after executing the original operation O on the state C(O).",
                "According to the definition of the IT function [23], a transformed operation O , where O = IT(O, Ox), should be defined on the document state DS = C(O)∪{org(Ox)}, which is the state achievable by executing Ox on the state C(O).",
                "More precisely, the context of an operation is defined blow.",
                "Definition 4.",
                "The context of an operation 1.",
                "For an original normal operation O, C(O) = DS, where DS is the representation of the document state from which O was generated. 2.",
                "For an original inverse operation O, C(O) = C(O) ∪ {O}, where O is the operation to be undone. 3.",
                "For a transformed operation O , C(O ) = C(O) ∪ {org(Ox)}, where O = IT(O, Ox). 2 According to the above definition, the context of any type of operation can be represented as a set of original operations.",
                "For the scenario in Figure 1, we have C(O1) = {}, C(O2) = {}, and C(O3) = {O2} according to Definition 4-Item 1.",
                "According to Definition 4-Item 2, we have C(O2) = {O2}.",
                "From O2 = IT(O2, O1), we have C(O2) = {O1} according to Definition 4-Item 3. 3.3 Context-dependency/-independency We define the context-dependency/-independency relation among operations in terms of whether an original operation is included in the context of another operation of any type.",
                "Definition 5.",
                "Context-dependency relation c → Given an original operation Oa and an operation Ob of any type, Ob is context-dependent on Oa, denoted by Oa c → Ob, iff: (1) Oa ∈ C(Ob); or (2) there exists an original operation Ox, such that Oa ∈ C(Ox) and Ox ∈ C(Ob). 2 It should be noted that the context-dependency relation is defined only between an original (either normal or inverse) operation and another operation of any type (original or transformed).",
                "This is because any operation has a context, but only original operations can be included in a context.",
                "Definition 6.",
                "Context-independency relation c Given two original operations Oa and Ob, Oa and Ob are context-independent, denoted by Oa c Ob, iff neither Oa c → Ob, nor Ob c → Oa. 2 It can be shown that if both Oa and Ob are original normal operations, then Oa c → Ob is equivalent to Oa → Ob; and Oa c Ob is equivalent to Oa Ob.",
                "In other words, the causal-dependency/-independency relation is a special case of the context-dependency/-independency relation. 3.4 Context-based conditions The following Context-based Conditions (CC) capture essential requirements for operation execution and transformation in OT systems: 281 CC1: C(O) ⊆ DS is a necessary condition for an original operation O to be transformed to the document state DS for execution.",
                "CC1 ensures that O is always executed after the contextdependent operations included in C(O).",
                "In other words, for any original operation Ox, if Ox c → O, then Ox must be executed before O.",
                "When O is an original normal operation, all operations which are causally before O must be included in C(O) (according to Definition 1 and Definition 5), so CC1 preserves the causal ordering among original normal operations [4, 22].",
                "When O is an original inverse operation, C(O) must include the operation to be undone by O (see Definition 4-Item 2), so CC1 preserves the do-undo ordering among normal and inverse operations [21].",
                "CC2: DS − C(O)1 is the set of operations that O must be transformed against before O is executed on the document state DS.",
                "CC2 ensures that O is transformed against all contextindependent operations in DS before its execution.",
                "It can be shown that, for any Ox in DS − C(O), it must be that Ox c O.",
                "When O is an original normal operation, DS − C(O) must include all executed operations which are concurrent with O, so CC2 covers the condition that O should be transformed against concurrent operations [4, 22].",
                "When O is an inverse operation, CC2 covers the condition that O should be transformed against all operations which are executed after the operation to be undone by O [21].",
                "CC3: C(O) = DS is a necessary condition for O to be executed on the document state DS.",
                "CC3 is required for correctly executing operations.",
                "CC4: C(Oa) ⊆ C(Ob) is a necessary condition for Oa to be IT-transformable to the new context given by C(Ob).",
                "CC4 is required because if C(Oa) ⊆ C(Ob), then there must be an operation Ox ∈ C(Oa) but Ox ∈ C(Ob), which means Oa cannot be IT-transformed to the new context C(Ob) since IT-transformation cannot remove this Ox from C(Oa) (see Definition 4-item3).",
                "CC5: C(Ob) − C(Oa) is the set of operations that Oa must be transformed against before IT-transformed against Ob.",
                "CC5 ensures that Oa is transformed against contextindependent operations in C(Ob) before IT-transformed against Ob.",
                "It can be shown that, for any Ox in C(Ob) − C(Oa), it must be that Ox c Oa, CC6: C(Oa) = C(Ob) is a necessary condition for Oa to be IT-transformed against Ob.",
                "CC6 is required for correctly applying IT functions.",
                "In summary, CC1 and CC4 are required for ensuring correct ordering of operation execution/transformation; CC2 and CC5 are required for selecting correct transformation target operations; and CC3 and CC6 are required for ensuring correct operation execution/transformation.",
                "These context-based conditions form the foundation for the COT algorithm to be presented in Section 4 and Section 6. 1 DS − C(O) is the set difference between DS and C(O). 3.5 Context vector An important element of the operation context theory is the context vector, which represents the set of operations of a context in an efficient way.",
                "For notational convenience, we assume that a collaborative editing session consists of N collaborating sites, identified by 0, 1, . . . , N − 1. 3.5.1 Representing original normal operations Original normal operations generated at each site are strictly sequential, so each of them can be uniquely identified by a pair of integers (sid, ns), where sid is the site identifier and ns is the local sequence number of this operation.",
                "Let Oij be an original normal operation generated at site i with a sequence number j.",
                "If Oij is included in a context C(O), then Oi1, Oi2, . . . , Oij−1 must also be included in C(O) according to Definition 3 and Definition 4.",
                "Therefore, all normal operations generated at the same site can be sufficiently characterized by the largest sequence number of these operations.",
                "All original normal operations in a context can be partitioned into N groups according to their generation sites, so N integers are needed for representing original normal operations in a context. 3.5.2 Representing original inverse operations An original inverse operation can be generated to undo an original normal operation, or to redo an undone operation.",
                "Each original inverse operation directly or indirectly corresponds to exactly one original normal operation.",
                "For example, inverse operation O may be generated to undo O, and O may be generated to undo O.",
                "Both O and O correspond to the same normal operation O.",
                "Based on this observation, all original inverse operations in an operation context can be grouped by their corresponding original normal operations: one inverse group for each undone original normal operation.",
                "Inverse operations in the same inverse group can be further differentiated by a sequence number based on their execution order within this group.",
                "For example, O and O are in the same inverse group corresponding to O, so O has the sequence number 1, and O has the sequence number 2.",
                "In general, an inverse can be identified by a triple (sid, ns, is), where sid and ns are the site identifier and sequence number of the corresponding normal operation, and is is the inverse sequence number within the group.",
                "Since inverses are sequentially executed, the largest sequence number in the group can be used to represent all inverses in the group.",
                "Inverse groups can be further partitioned into N inverse clusters according to the site identifiers of their corresponding normal operations.",
                "The inverse cluster at site i - icican be expressed as follows: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverse operations corresponding to the original normal operation with sequence number nsj at site i.",
                "If no normal operation at site i has been undone, ici is empty. 3.5.3 Representing normal and inverse operations To represent an operation context with both original normal and inverse operations, an N-dimensional context vector is defined below. 282 Definition 7.",
                "Context Vector Given an operation O, its context C(O) can be represented by the following context vector CV (O): CV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1) ], where, for 0 ≤ i ≤ N − 1, 1. nsi represents all original normal operations generated at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] represents all inverse operations for undoing normal operations generated at site i, where (nsj, isj), 0 ≤ j < k, represents an inverse group with isj inverses related to the normal operation with sequence number nsj. 2 In the absence of inverse operations in the operation context, all ici, 0 ≤ i ≤ N − 1, would be empty and a Context Vector would be reduced to a State Vector [4].",
                "The vector representation of operation context can also be used as the vector representation of the document state.",
                "As an example, consider the document state after interpreting the undo command Undo(O2) in Figure 1.",
                "Since Undo(O2) is interpreted as an inverse O2 (see Section 4.2), the document state after executing (the transformed) O2 shall be DS = {O1, O2, O3, O2}.",
                "This document state cannot be represented by a state vector but can be represented as a context vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].",
                "Based on Definition 7, it is straightforward to derive the scheme for maintaining the vector representation for the document state after executing each operation (according to Definition 3).",
                "Moreover, the vector representation of operation context can also be used to efficiently detect contextdependency/-independency relations.",
                "Due to space limitation, these technical details are omitted in this paper. 4.",
                "THE BASIC COT ALGORITHM In the basic COT algorithm, we assume each site maintains a document state DS, which contains the set of original operations executed so-far.",
                "This is different from the log or the History Buffer (HB) schemes in prior OT algorithms [4, 22, 23], which record a list of transformed operations.",
                "We deliberately leave the internal data structure of DS unspecified to keep the COT algorithm independent of the operation buffering strategy.",
                "In algorithm description, we shall use the context set representation C(O), rather than the context vector representation CV (O).",
                "When an operation O is propagated from the local site to remote sites, however, it is the context vector, not the context set, that is actually piggy-backed on O for propagation.",
                "The set of operations in C(O) can be easily determined from DS based on the information in CV (O).",
                "The COT algorithm has two parts: the COT-DO part for supporting consistency maintenance (do), and the COTUNDO part for supporting undo.",
                "Both parts share the same core context-based transformation procedure.",
                "Operation context and context-based conditions are central to the whole COT algorithm. 4.1 COT-DO COT-DO takes two parameters: O - an original operation to be executed, and DS - the current document state representation.",
                "COT-DO is invoked only if C(O) ⊆ DS (CC1), which ensures that all operations included in the context of O have already been executed on DS.",
                "Algorithm 1.",
                "COT-DO(O, DS) 1. transform(O, DS − C(O)); 2.",
                "Execute O; DS := DS ∪ {org(O)}.",
                "Procedure 1. transform(O, CD) Repeat until CD = { }: 1.",
                "Remove Ox from CD, where C(Ox) ⊆ C(O); 2. transform(Ox, C(O) − C(Ox)); 3.",
                "O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "COT-DO first invokes procedure transform() to transform O against operations in DS − C(O) (CC2).",
                "This is to upgrade the context of O to DS.",
                "In Step 2, it must be that C(O) = DS (CC3), so O is executed as-is, and the original of O is added to DS (according to Definition 3-Item 2).",
                "The heart of COT-DO is transform(O, CD), whose task is to transform O against operations in CD, which represents the context difference between C(O) and a new context on which O is to be defined.",
                "This procedure repeats the following three steps until CD becomes empty: 1.",
                "Remove an operation Ox from CD, where C(Ox) ⊆ C(O) (CC4).",
                "An operation Ox meeting this condition can be determined if all operations in CD are sorted in the order of their execution and sequentially retrieved. 2.",
                "The procedure transform() is recursively invoked to transform Ox against operations in C(O)−C(Ox) (CC5).",
                "This is to upgrade Ox to the context of O, so that they can be used for IT transformation in the next step. 3.",
                "After the recursive call to transform(), it must be that C(O) = C(Ox) (CC6), so O is IT-transformed against Ox, and the context of O is updated by adding the original of Ox (according to Definition 4-Item 3).",
                "To show how COT-DO works, we examine how it resolves the dOPT-puzzle in Figure 1.",
                "Consider the operation executions at site 0, with the initial document state DS0 = { }. 1.",
                "After the generation of O1, since C(O1) = DS0, O1 is executed as-is and DS0 is updated to DS1 = {O1}. 2.",
                "When O2 arrives with C(O2) = {}, transform(O2, DS1− C(O2)) is called, where DS1 − C(O2) = {O1}.",
                "Inside transform(O2, {O1}), since C(O1) = C(O2), we have O2 := IT(O2, O1), and C(O2) = {O1}.",
                "Returning from transform(O2, {O1}), we have C(O2) = DS1, so O2 is executed, and DS1 is updated to DS2 = {O1, O2}, where O2 = org(O2). 3.",
                "When O3 arrives with C(O3) = {O2}, transform(O3, DS2− C(O3)) is called, where DS2 − C(O3) = {O1}.",
                "Inside transform(O3, {O1}), transform(O1, C(O3)−C(O1)) is recursively called, with C(O3) − C(O1) = {O2}, which is the key step in detecting the dOPT-puzzle.",
                "In the recursive transform(O1, {O2}), since C(O2) = C(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.",
                "Returning from the recursion, we have C(O1) = C(O3), so C(O3) := IT(O3, O1) (the dOPT-puzzle resolved here), and C(O3) = {O1, O2}, where O1 = org(O1).",
                "After returning from transform(O3, {O1}), C(O3) = DS2; so O3 is executed, and DS2 is updated to DS3 = {O1, O2, O3}, where O3 = org(O3). 283 4.2 COT-UNDO To undo an operation O, a meta-level undo command Undo(O) must be issued by a user.",
                "How to generate the undo command for selecting any operation to undo is part of the undo policy [21].",
                "This paper is confined to the discussion of the undo mechanism, which determines how to undo the selected operation in a given context.",
                "In COT-UNDO, Undo(O) is interpreted as an inverse O, that is context-dependent on operations in C(O) and O itself.",
                "COT-UNDO takes two input parameters: O is the operation selected to be undone, which can be any operation done sofar, and DS is the current document state representation.",
                "Algorithm 2.",
                "COT-UNDO(O, DS) 1.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 2.",
                "COT-DO(O, DS).",
                "COT-UNDO works by first creating an inverse O by invoking makeInverse(O)2 , with its context C(O) := C(O) ∪ {O} (according to Definition 4-Item 2), and then invoking COTDO to handle O.",
                "For example, to interpret Undo(O2) in Figure 1, COTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.",
                "First, O2 and C(O2) = {O2} are created.",
                "Then, COT-DO is invoked with parameters O2 and DS.",
                "Inside COT-DO, transform(O2, DS − C(O2)) shall be invoked, and O2 shall be correctly transformed against O1 and O3 since CD = DS − C(O2) = {O1, O3}.",
                "This example shows that an inverse operation can be handled by COT-DO in the same way as other normal operations.",
                "This is because context-based conditions CC1 - CC6 are uniformly applicable to both normal and inverse operations.",
                "The basic COT algorithm is simple yet powerful - capable of doing and undoing any operations at anytime.",
                "Among all prior OT systems, only the combination of GOTO and ANYUNDO (referred as GOTO-ANYUNDO) has similar capabilities [22, 21]. 5.",
                "TRANSFORMATION PROPERTIES COT is a high-level control algorithm responsible for determining which operation should be transformed against other operations and in which order according to contextbased conditions.",
                "Another important component of an OT system is the low-level transformation functions responsible for transforming operations according to their types and parameters.",
                "Past research has identified a range of transformation properties/conditions that must be maintained for ensuring the correctness of an OT system.",
                "Different OT systems may have different control algorithms, different transformation functions, and different divisions of responsibilities among these components.",
                "Unlike GOTO-ANYUNDO, the basic COT algorithm does not use ET (Exclusion Transformation) functions [21], thus avoiding the requirement of the Reversibility Property (RP) between IT and ET functions [21].",
                "Similar to GOTO-ANYUNDO, the basic COT algorithm assumes that underlying transformation functions are capable of preserving the following properties [4, 15, 19, 23, 21]: 2 The reader is referred to [25] for precise definitions of three primitive operations Insert, Delete and Update and their corresponding inverses.",
                "The makeInverse(O) procedure directly follows these definitions. 1.",
                "Convergence Property 1 (CP1)3 .",
                "Given a document state DS, and operations Oa, Ob, if Oa = IT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect on the document state DS. 2.",
                "Convergence Property 2 (CP2).",
                "Given three operations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob = IT(Ob, Oa), then it must be: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), which means that [Oa, Ob] and [Ob, Oa] are equivalent with respect to the effect in transformation. 3.",
                "Inverse Property 2 (IP2)4 .",
                "Given any operation Ox and a pair of operations [O, O], it must be: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, which means that [O, O] and I are equivalent with respect to the effect in transformation. 4.",
                "Inverse Property 3 (IP3).",
                "Given two operations Oa and Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and Oa := IT(Oa, Ob), then it must be: Oa = Oa, which means the transformed inverse operation Oa is equal to the inverse of the transformed operation Oa.",
                "The above transformation properties are important discoveries of past research, but they are not unconditionally required.",
                "The pre-conditions for requiring them, however, were never explicitly stated in their specifications, which has unfortunately caused quite some misconceptions in OT literature.",
                "To explore alternative solutions to these properties, we explicitly state the Pre-Conditions (PC) for CP1, CP2, IP2, and IP3 as follows: 1.",
                "PC-CP1: CP1 is required only if the OT system allows the same group of context-independent operations to be executed in different orders. 2.",
                "PC-CP2: CP2 is required only if the OT system allows an operation to be transformed against the same group of context-independent operations in different orders. 3.",
                "PC-IP2: IP2 is required only if the OT system allows an operation Ox to be transformed against a pair of do and undo operations (O and O) one-by-one. 4.",
                "PC-IP3: IP3 is required only if the OT system allows an inverse operation Oa to be transformed against another operation Ob that is context-independent of Oa. 3 Convergence Property 1 & 2 in this paper (and in [21]) are the same as Transformation Property 1 & 2 in [19]. 4 There is another Inverse Property 1 (IP1) that is required in an OT system for achieving the correct undo effect [21], but IP1 is not related to IT functions. 284 There are generally two ways to achieve OT correctness with respect to these transformation properties: one is to design transformation functions capable of preserving these properties; the other is to design control algorithms capable of breaking the pre-conditions for requiring these properties.",
                "Past research has shown that it is relatively easy to design transformation functions capable of preserving CP1, but non-trivial to design and formally prove transformation functions capable of preserving CP2, IP2 and IP3.",
                "Counterexamples illustrating the violation of these properties in some early published transformation functions can be found in [23, 21, 8, 11].",
                "IT functions capable of preserving IP2 and IP3 had been devised in the context of ANYUNDO [21], but our experience in implementing these functions revealed that those solutions are quick intricate and inefficient (more analysis can be found in Section 7).",
                "Clearly, solving CP2, IP2 and IP3 at the control algorithm level has the benefit of simplifying the design of transformation functions and the OT system as a whole.",
                "In the following section, we extend the basic COT algorithm to provide simple and efficient solutions to CP2, IP2 and IP3 at the control algorithm level. 6.",
                "COT SOLUTIONS TO CP2, IP2, AND IP3 A distinctive feature of COT is that in every transformation process (i.e. an invocation of transform(O, CD)), the whole set of transformation target operations are determined in advance, and available in the context-difference parameter CD (calculated by using context-based conditions CC2 and CC5).",
                "With the knowledge of all operations involved in the transformation process, we are able to properly arrange these operations to break the pre-conditions for CP2, IP2, and IP3. 6.1 Extended transform() procedure We extend the core procedure transform(O, CD) to take advantage of the global knowledge of operations in the contextdifference parameter CD for breaking PC-CP2, PC-IP2 and PC-IP3.",
                "The extended transform(), as shown in Procedure 2, retains the structure and main elements of Procedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1 (ensure TPsafety()) and in Step 2-(c) (the if-then part).",
                "Procedure 2. transform(O, CD) 1.",
                "If CD = { }, ensure TPsafety(O, CD); 2.",
                "Repeat until CD = { }: (a) Remove the first operation Ox from CD; (b) transform(Ox, C(O) − C(Ox)); (c) If Ox is a do-undo-pair, then C(O) := C(O) ∪ {org(Ox), org(Ox)}; else O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}.",
                "Procedure 3. ensure TPsafety(O, CD) 1.",
                "Ensure CP2-safety: sort operations in CD in a total order that respects their context-dependency order. 2.",
                "Ensure IP2-safety: for any Ox ∈ CD, if Ox ∈ CD, then mark Ox as a do-undo-pair, remove Ox from CD. 3.",
                "Ensure IP3-safety: if O is inverse, the invoke make IP3safe Inverse(O, CD).",
                "Procedure 4. make IP3safe Inverse(O, CD) 1.",
                "O := makeInverse(O); C(O) := C(O) − {O}; 2.",
                "NCD := {Ox | Ox ∈ CD and Ox c O}; 3. transform(O, NCD); 4.",
                "O := makeInverse(O); C(O) := C(O) ∪ {O}; 5.",
                "CD := CD − NCD. 6.2 Breaking the pre-condition for CP2 The COT solution to CP2 is to sort all operations in CD in a total order which respects their context-dependency order (in Step 1 of ensure TPsafety()).",
                "If an operation O is transformed against the same group of context-independent operations in multiple invocations to transform(O, CD), this group of operations must be included in CD and sorted in the same total order.",
                "Therefore, O can never be transformed against the same group of operations in different orders, thus breaking PC-CP2.",
                "It should be noted that CD becomes an ordered set after the sorting.",
                "The first Ox in CD must meet the condition C(Ox) ⊆ C(O) in Step 2(a) of transform(O, CD) (Procedure 1), so this condition is no longer explicitly specified in Procedure 2.",
                "A correct total order for breaking PCCP2 can be conveniently determined by using the contextdependency relations among all operations plus the site identifiers of context-independent operations.",
                "There have been several prior OT systems capable of breaking PC-CP2, including the GOT system (by an undo/redo scheme based on total ordering) [23], the SOCT4 system (by a control strategy based on global sequencing) [26], the NICE system (by a central transformation-based notifier) [20], and the TIBOT system (by a distributed synchronization protocol based on time-internal) [12].",
                "The COT solution to CP2 is unique and avoids the use of any undo/redo or global sequencing/synchronization. 6.3 Breaking the pre-condition for IP2 The basic idea of the COT solution to IP2 is to make sure that an operation is never transformed against a pair of do and undo operations one by one, thus breaking PCIP2.",
                "This solution consists of two parts: (1) Step 2 of ensure TPsafety(CD) couples operations with their corresponding inverses if they are all included in the context difference CD, and remove these inverses from CD; (2) In Step 2-(c) of transform(), if Ox is found to be a do-undo-pair, the IT-transformation of O against Ox is skipped (effectively treating this pair as an identity operation) and the context of O is updated by adding two operations: {org(Ox), org(Ox)}. 6.4 Breaking the pre-condition for IP3 The COT solution to IP3 is encapsulated in the procedure make IP3safe Inverse(O, CD), which makes O an IP3-safe inverse with respect to the context difference CD.",
                "An inverse O is IP3-safe with respect to CD if it is made from a transformed version of O, which has included all operations in CD that are context-independent of O.",
                "Under the control of COT, the IP3-safe inverse O shall never be transformed against operations that are context-independent of O, thus breaking PC-IP3.",
                "The make IP3safe Inverse procedure works as follows: (1) create operation O (the inverse of O) and C(O) = C(O) − 285 {O}; (2) select all operations from CD which are contextindependent of O and create a new context difference NCD; (3) transform O against operations in NCD (by recursively invoking transform()); (4) create a new inverse from the transformed O; and (5) create a new CD by subtracting NCD from the old CD (the new CD must maintain the total order as required for solving CP2).",
                "This new inverse O must be IP3-safe because it is created from a transformed operation whose context has included all operations in NCD.",
                "The IP3-safe inverse O shall never be transformed against the operations in NCD since these operations have been removed from the new CD in Step (5). 7.",
                "DISCUSSIONS 7.1 The theory of operation context The notion of operation context was first proposed in the GOT algorithm [23] and used in conjunction with the theory of causality in follow-up GOTO and ANYUNDO algorithms [22, 21].",
                "In prior work, the context of an operation O was defined as a sequence of transformed operations which can be executed to bring the document from its initial state to the state on which O is defined.",
                "This definition is directly coupled to the sequential history buffering strategy, which saves executed operations in their execution forms and orders.",
                "There was no explicit representation of an operation context.",
                "Context relationships among operations are derived from the causality relationships plus the history buffer position relationships among operations [23, 21].",
                "In this paper, the concept of operation context is defined as a set of original operations corresponding to the document state on which this operation is defined.",
                "This new concept of operation context is independent of the underlying operation buffering strategy and is explicitly represented as an operation set.",
                "Based on the set representation of operation context, essential OT conditions (CC1 - CC6) have been precisely and concisely captured.",
                "Moreover, the context vector has been devised to efficiently represent both normal and inverse operations in a context.",
                "The context vector is more general than the state vector and potentially applicable to other distributed computing systems as well.",
                "Based on the theory of causality, prior OT algorithms have used state vectors to capture causal-dependency relationships among original normal operations and to represent document states in terms of original normal operations.",
                "However, causal-dependency relationships are not defined for inverse or transformed operations, and state vectors cannot represent document states with original inverse operations.",
                "The theory of causality is unable to capture essential OT conditions (CC1 - CC6) for all types of operation - original and transformed, normal and inverse operations. 7.2 COT versus GOTO-ANYUNDO Both COT and GOTO-ANYUNDO are capable of doing and undoing any operations at anytime.",
                "The main difference is that COT achieves this capability without using ET functions (thus eliminating the RP requirement for IT functions), and without requiring IT functions to preserve CP2, IP2 and IP3.",
                "The avoidance of RP, CP2, IP2, and IP3 has significantly simplified the design of transformation functions and the OT system as a whole.",
                "COT is simpler than GOTO-ANYUNDO (and prior OT algorithms based on the causality theory) because of the use of a single theory of operation context for capturing all OTrelated conditions (CC1-CC6), the uniformity of contextbased conditions for treating all types of operation, and the conciseness of these context-based conditions.",
                "The COT-based system is more efficient than the GOTOANYUNDO-based system in solving IP2 and IP3.",
                "In GOTOANYUNDO, the do-part (a normal operation) and the undopart (an inverse operation) need to be coupled for the purpose of preserving IP2 [21].",
                "An eager coupling strategy was adopted: an inverse operation is coupled with its corresponding normal operation immediately after its execution.",
                "Under this scheme, inverse operations are not explicitly represented in the history buffer.",
                "When a normal operation is to be executed, however, it may need to be transformed against only the undo-part of a do-undo-pair.",
                "To cope with this problem, an extra DeCouple-GOTO-ReCouple scheme has to be used to decouple a do-undo-pair before invoking GOTO and then recouple them afterwards [21].",
                "However, the implementation of this decouple-recouple scheme revealed it was rather intricate and causing many repeated transformations.",
                "In the COT algorithm, COT-DO and COT-UNDO are seamlessly integrated.",
                "Inverse operations are explicitly represented in the operation context, and a lazy coupling strategy is adopted: the coupling of a do-undo-pair occurs not immediately after executing each inverse, but only when both the do-part and the undo-part appear in the same transformation process at some late stage.",
                "These strategies help to avoid overhead transformations caused by the eager coupling scheme and the decouple-recouple scheme.",
                "In the GOTO-ANYUNDO-based system, the solution to IP3 is encapsulated in an IP3-preserving IT function, called IP3P-IT [21].",
                "Inside this function, an extended ET function has to be used, which may invoke the expensive GOTO algorithm to ensure RP with the corresponding IT function.",
                "In contrast, the COT solution to IP3 is encapsulated in the high-level procedure make IP3safe Inverse(O, CD), which is more efficient since (1) it avoids converting O to O back and forth multiple times for each Ox ∈ NCD (if IP3P-IT(O, Ox) were used instead); and (2) the transform() procedure is much cheaper than GOTO. 7.3 OT buffering strategies Another distinctive feature of the COT algorithm is the separation of the algorithm from the underlying operation buffering strategy.",
                "This has not only resulted in a cleaner and simpler logical structure to the algorithm itself, but also allowed a range of performance optimizations at the operation buffering level.",
                "We have devised and implemented a buffering structure in which not only original operations but also transformed versions can be saved; and all transformed operations from the same original operation are organized in the same version group.",
                "When an original operation is required at the COT algorithm level, the corresponding version group is searched for a version that matches the context requirement.",
                "If such a version already exists, it is used to represent the original operation in the transformation process, thus saving the overhead to transform the original operation into this version.",
                "Under this buffering structure, various heuristics can be used to selectively save transformed versions to maximize their reuse and minimize their space usage.",
                "By experimentation, we have identified some useful heuristics that are 286 effective in saving transformations for a number of common patterns of operation sequence.",
                "COT is not the first OT algorithm that buffers and uses original operations for transformation.",
                "Several prior OT algorithms, including CCU [2], adOPTed [19], and GOTOANYUNDO [21], have also buffered original operations.",
                "COT is unique in its way of buffering and using original, as well as transformed, operations. 7.4 OT correctness OT correctness is a central topic of discussion in OT research.",
                "In this section, we provide our observations and opinions on some important OT correctness issues.",
                "OT is a complex system with multiple interrelated components.",
                "A system-oriented approach is needed for addressing OT issues.",
                "An experimental method, called puzzle-detectionresolution, has commonly been used in exploring and refining OT solutions.",
                "Puzzles are subtle but representative scenarios in which certain OT properties/conditions may be violated and the system may produce incorrect results.",
                "The ability to solve all known puzzles is a necessary condition and an important indicator of the soundness of an OT system.",
                "In research literature, simple puzzle scenarios are often used to illustrate the key reasons why an OT system works or fails.",
                "In real OT system design, however, a real implementation and comprehensive testing cases based on complex puzzle scenarios are crucial in validating a design.",
                "Theoretical methods have also been used to formally verify OT correctness with respect to some identified transformation properties/conditions.",
                "Formal verification can be effective if the correctness issues have been well-understood and the verification criteria and boundary conditions have been well-defined.",
                "In this regard, experimental methods like puzzle-detection-resolution can play an important role in gaining the necessary insights into the real correctness issues, and establishing suitable criteria and conditions for formal verification.",
                "A systematic approach is needed in conducting both experimental and theoretic OT research.",
                "Many OT components and issues are intimately related, and a solution to one issue, if examined in isolation, is unlikely to be correct or complete.",
                "For example, a solution that works well for consistency maintenance (do), may fail when both do and undo problems are considered; and an undo solution (e.g. preserving IP2) may violate the solution to consistency maintenance [21].",
                "A complete OT solution to both do and undo problems is significantly more difficult to design than a partial solution to only one of them.",
                "On the other hand, a difficult issue in one OT component may be resolved easily, or avoided altogether, if this issue is addressed from a different OT component.",
                "For example, it is known that devising and proving transformation functions capable of preserving properties CP2, IP2, and IP3 are difficult.",
                "However, these difficulties can be avoided by devising control algorithms (like COT) capable of breaking the pre-conditions for requiring these properties; it is also easier to prove a control algorithm is capable of breaking the pre-conditions for these properties, than to prove transformation functions are capable of preserving them.",
                "Different OT systems may have different divisions of responsibility among their components and hence different correctness requirements for these components.",
                "Caution must be taken in interpreting correctness results.",
                "For example, CP1 and CP2 were proven to be necessary and sufficient for adOPTed-based systems to converge [19, 13], but this result cannot be generalized to all OT systems.",
                "In fact, CP1 and CP2 are neither sufficient nor necessary for many OT systems.",
                "They are insufficient because an OT system may need to preserve additional properties/conditions, such as IP2, IP3, and those summarized in [21].",
                "They are unnecessary if the pre-conditions for requiring them have been broken.",
                "For example, neither CP1 nor CP2 is required in the REDUCE system based on the GOT algorithm for ensuring convergence [23].",
                "CP2 is also not required by OT systems based on COT or some prior OT algorithms [26, 20, 12].",
                "One OT correctness issue, which is often discussed in relation to the CP2-violation problem, is the false-tie problem: when two (or more) insert operations with the same position are IT-transformed with each other, the position tie may be false if it was not original but caused by previous transformations.",
                "An OT system may fail to produce correct results if the normal tie-breaking rule (e.g. based on site identifiers) is used to break false-ties.",
                "This problem was long discovered in early OT work and a concrete scenario related to this problem was illustrated in Fig. 6 of [23].",
                "It is beyond the scope of this paper to discuss solutions to this problem, but it is worth pointing out that the false-tie problem is different from the CP2-violation problem: a false-tie may occur without violating CP2.",
                "In our view, the false-tie problem is an issue at the transformation function level and its solution could and should be localized at this level as well.",
                "For alternative views and approaches to this problem, the reader is referred to [8, 11, 5].",
                "The COT algorithm has been implemented and validated by a comprehensive testing suite covering all known OT puzzle scenarios.",
                "In this paper, informal analysis and simple puzzle scenarios have been used to show the correctness of COT with respect to various transformation properties/conditions.",
                "Formal verification of COT correctness with respect to these properties/conditions, and quantitative analysis of the time and space complexity of COT, shall be reported in a journal version of this paper. 8.",
                "CONCLUSIONS We have contributed the theory of operation context and the COT (Context-based OT) algorithm.",
                "The theory of operation context is capable of capturing essential relationships and conditions for all types of operation in an OT system; it provides a new foundation for better understanding and resolving OT problems.",
                "The COT algorithm provides uniformed solutions to both consistency maintenance and undo problems; it is simpler and more efficient than prior OT control algorithms with similar capabilities; and it significantly simplifies the design of transformation functions.",
                "The COT algorithm has been implemented in a generic collaboration engine and used for supporting a range of novel collaborative applications [24].",
                "Real-world applications provide exciting opportunities and challenges to future OT research.",
                "The theory of operation context and the COT algorithm shall serve as new foundations for addressing the technical challenges in existing and emerging OT applications.",
                "Acknowledgments The authors are grateful to Bo Begole and anonymous reviewers for their valuable comments and suggestions which have helped improve the presentation of the paper. 287 9.",
                "REFERENCES [1] J. Begole, M. Rosson, and C. Shaffer.",
                "Flexible collaboration transparency: supporting worker independence in replicated application-sharing systems.",
                "ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.",
                "A calculus for concurrent update.",
                "In Research Report CS-95-06, Dept. of Computer Science, University of Waterloo, Canada, 1995. [3] A. Davis, C. Sun, and J. Lu.",
                "Generalizing operational transformation to the standard general markup language.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 58 - 67, Nov. 2002. [4] C. A. Ellis and S. J. Gibbs.",
                "Concurrency control in groupware systems.",
                "In Proc. of the ACM Conf. on Management of Data, pages 399-407, May 1989. [5] N. Gu, J. Yang, and Q.Zhang.",
                "Consistency maintenance based on the mark & retrace technique in groupware systems.",
                "In Proc. of ACM Conf. on Supporting Group Work, pages 264-273, Nov. 2005. [6] R. Guerraoui and Corine Hari.",
                "On the consistency problem in mobile distributed computing.",
                "In Proceedings of the Second ACM International Workshop on Principles of Mobile Computing, pages 51-57, New York, Octo 2002.",
                "ACM. [7] C. Ignat and M.C.",
                "Norrie.",
                "Customizable collaborative editor relying on treeOPT algorithm.",
                "In Proc. of the European Conf. of Computer-supported Cooperative Work, pages 315-324, Sept. 2003. [8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.",
                "Proving correctness of transformation functions in real-time groupware.",
                "In Proc. of the European Conf. on Computer-Supported Cooperative Work, Sept. 2003. [9] L. Lamport.",
                "Time, clocks, and the ordering of events in a distributed system.",
                "Communication of ACM, 21(7):558-565, 1978. [10] D. Li and R. Li.",
                "Transparent sharing and interoperation of heterogeneous single-user applications.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 246-255, Nov. 2002. [11] D. Li and R. Li.",
                "Preserving operation effects relation in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 457-466, Nov. 2004. [12] R. Li, D. Li, and C. Sun.",
                "A time interval based consistency control algorithm for interactive groupware applications.",
                "In Proc. of International Conference on Parallel and Distributed Systems, pages 429-436, July. 2004. [13] B. Lushman and G. Cormack.",
                "Proof of correctness of Ressels adOPTed algorithm.",
                "Information Processing Letters, (86):303-310, 2003. [14] C. Palmer and G. Cormack.",
                "Operation transforms for a distributed shared spreadsheet.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 69-78, Nov. 1998. [15] A. Prakash and M. Knister.",
                "A framework for undoing actions in collaborative systems.",
                "ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dec. 1994. [16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.",
                "Automating semantics-based reconciliation for mobile databases.",
                "In Proceedings of the 3th Conference Francaise sur les Systems dExploitation, Octo 2003. [17] M. Raynal and M. Singhal.",
                "Logical time: capturing causality in distributed systems.",
                "IEEE Computer Magazine, 29(2):49-56, Feb. 1996. [18] M. Ressel and R. Gunzenh¨auser.",
                "Reducing the problems of group undo.",
                "In Proc. of the ACM Conf. on Supporting Group Work, pages 131-139, Nov. 1999. [19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.",
                "An integrating, transformation-oriented approach to concurrency control and undo in group editors.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 288-297, Nov. 1996. [20] H.F. Shen and C. Sun.",
                "A flexible notification framework for collaborative systems.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 77-86, Nov. 2002. [21] C. Sun.",
                "Undo as concurrent inverse in group editors.",
                "ACM Trans. on Computer-Human Interaction, 9(4):309-361, December 2002. [22] C. Sun and C. A. Ellis.",
                "Operational transformation in real-time group editors: issues, algorithms, and achievements.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 59-68, Nov. 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.",
                "Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems.",
                "ACM Trans. on Computer-Human Interaction, 5(1):63-108, March 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and W. Cai.",
                "Transparent adaptation of single-user applications for multi-user real-time collaboration.",
                "ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, and D. Chen.",
                "Operational transformation for collaborative word processing.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 437-446, Nov. 2004. [26] N. Vidot, M. Cart, J. Ferri´e, and M. Suleiman.",
                "Copies convergence in a distributed real-time collaborative environment.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 171-180, Dec. 2000. [27] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "A collaborative table editing technique based on transparent adaptation.",
                "In Proc. of the International Conf. on Cooperative Information Systems, LNCS Vol. 3760, Springer Verlag, pages 576-592, Nov. 2005. [28] S. Xia, D. Sun, C. Sun, and D. Chen.",
                "Object-associated telepointer for real-time collaborative document editing systems.",
                "In Proc. of the IEEE Conf. on Collaborative Computing: Networking, Applications and Worksharing, Dec. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.",
                "Leveraging single-user applications for multi-user collaboration: the CoWord approach.",
                "In Proc. of the ACM Conf. on Computer-Supported Cooperative Work, pages 162-171, Nov. 2004. 288"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        }
    }
}