{
    "id": "I-38",
    "original_text": "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions. However, most of the existing winner determination algorithms for combinatorial auctions are centralized. The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer). It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation. It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary. PAUSE establishes the rules the bidders must obey. However, it does not tell us how the bidders should calculate their bids. We have developed a couple of bidding algorithms for the bidders in a PAUSE auction. Our algorithms always return the set of bids that maximizes the bidders utility. Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search. In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm. Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems. General Terms Algorithms, Performance. 1. INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years. In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items. Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue. This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10]. Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed. The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2]. Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem. Thus, several approaches and algorithms have been proposed to address the winner determination problem. However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners. Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12]. We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer. The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders. PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them. However, it is not concerned with how the bidders determine what they should bid. In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility. Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. THE PAUSE AUCTION A PAUSE auction for m items has m stages. Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items. At the end of this state we will know what the highest bid for each individual item is and who placed that bid. Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less. The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions. Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset. At the end of each stage k all agents know the best bid for every subset of size k or less. Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted. Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset. Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items. That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation. However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution. Our test results provide an answer to this question. The PAUSE auction makes the job of the auctioneer very easy. All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid. The computational problem shifts from one of winner determination to one of bid generation. Each agent must search over the space of all bidsets which contain at least one of its bids. The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset. Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose). Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2]. We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer. That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid. The agents would have an incentive to perform their computation as it will increase their expected utility. Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids). Namely, the only one that can increase an agents bid value is the agent itself. Anyone claiming a higher value for some other agent is lying. The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3. PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid). The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage. At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids. This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items. Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items. If the agent is not winning any items then its utility is zero. The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction. Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero). That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4. BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items. In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item. Our algorithms focus on the subsequent stages: k > 1. When k > 1, agents have to find g∗ i . This can be done by performing a complete search on B. However, this approach is computationally expensive since it produces a large search tree. Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree. Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B. We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later). Similarly, we set their-bids to be the rest of the bids from B. Finally, the agents search list is simply the concatenation of my-bids and their-bids. Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9). The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids. This branch and bound search is implemented by pbsearch (Figure 2). Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree. The bound we use is the maximum utility that the agent can expect to receive from a given set of bids. We call it u∗ . Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility. If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21). Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase. For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W). The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch. Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item. This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid. To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent. Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic. A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7). The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility. However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price. Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ . If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation. However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids. There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution. We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search. However it repeats the whole search at every stage. We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction. It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time. The problem is the same; the agent i has to find g∗ i . We note that g∗ i is a bidset that contains at least one bid of the agent i. Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i). That is, gS i is is best bidset for all items which includes a bid from i for all S items. In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility. That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0. We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details. Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B. Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage. Initially C-Table has one row or entry for each set S for which vi(S) > 0. We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3). Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider. We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8). But how do we know that the gS in C-Table[S] is still the best solution for S? There are only two cases when we are not sure about that and we need to do a search to update C-Table[S]. These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S]. We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid. In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S. Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it. We build the list bids that contains only those bids. However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed. Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19). The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch. The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1). Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23). We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS . Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii). We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26). When we reach line 27 in cachedpausebid, we are sure that we have the right gS . However, agent is bids in gS are still set to his own valuation and not to the lowest possible price. If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS . As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items. In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38). The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one. It assumes that W and B remains constant during its execution. 698 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5. TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other. In order to do our tests we had to generate value functions for the agents1 . The algorithm we used is shown in Figure 5. The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks. For example, imagine a set of robots which must pick up and deliver items to different locations. Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle. Their costs for the item bundles are subadditive, which means that their preferences are superadditive. The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents. It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms. We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation. That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid. This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue. Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations. Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items. We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10. We ran both algorithms 100 times for each combination. When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6). The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items. If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed. For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item. If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed. We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases. For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items. In a few instances our algorithms find different solutions this is due to the different The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order. We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower? To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS. We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7. However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage. Again, this difference is produced by the order of the search. In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%. The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree. For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms. As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8). However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes. For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes. Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items. For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 . Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations. As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items. We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows. We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations. We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm. As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6. RELATED WORK A lot of research has been done on various aspects of combinatorial auctions. We recommend [2] for a good review. However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new. One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution. The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation. This algorithm also fails to converge to a solution for most cases. In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem. Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered. This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts. Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier. Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best. As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7. CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders. The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions. With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer. However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids. We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction. Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids. Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution. The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items. As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster. As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid. We also found that the revenue generated by our algorithms increases as function of the number of items in the auction. Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm. Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation. Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8. REFERENCES [1] P. J. Brewer. Decentralized computation procurement and computational robustness in a smart market. Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors. Combinatorial Auctions. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham. Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches. In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg. A combinatorial auction with multiple winners for universal service. Management Science, 46(4):586-596, 2000. [5] A. Land, S. Powell, and R. Steinberg. PAUSE: A computationally tractable combinatorial auction. In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham. Towards a universal test suite for combinatorial auction algorithms. In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal. Algorithms for distributed winner determination in combinatorial auctions. In LNAI volume of AMEC/TADA. Springer, 2006. [8] S. Park and M. H. Rothkopf. Auctions with endogenously determined allowable combinations. Technical report, Rutgets Center for Operations Research, January 2001. RRR 3-2001. [9] D. C. Parkes and J. Shneidman. Distributed implementations of vickrey-clarke-groves auctions. In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad. Computationally manageable combinational auctions. Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm. An algorithm for winner determination in combinatorial auctions. Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine. CABOB: a fast optimal algorithm for winner determination in combinatorial auctions. Management Science, 51(3):374-391, 2005. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701",
    "original_translation": "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems canser resuelto a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos de determinación del ganador existente para las subastas combinatorias están centralizados. La subasta de pausa es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible deshacerse del subastador). Es una subasta combinatoria de precios cada vez mayor que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tienen un incentivo para realizar el cálculo. Se puede usar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. Pausa establece las reglas que los postores deben obedecer. Sin embargo, no nos dice cómo los postores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de licitación para los postores en una subasta de pausa. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los licitantes. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en la cantidad de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este artículo presentamos nuestros algoritmos de licitación, discutimos sus virtudes y inconvenientes, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación del ganador. Categorías y descriptores de sujetos I.2.11 [Metodologías de computación]: agentes de inteligencia artificial-inteligencia distribuida, sistemas multiagentes. Algoritmos de términos generales, rendimiento.1. Introducción Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los licitadores pueden realizar ofertas en combinaciones de artículos, llamados paquetes o ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximicen los ingresos de los subastadores. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-HARD [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para los tamaños y estructuras de problemas que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: asignación del despegue del aeropuerto y espacios de tiempo de aterrizaje, adquisición de servicios de transporte de carga, adquisición de servicios de transporte público y adquisiciones industriales [2]. Debido a su amplia aplicabilidad, uno no puede esperar un algoritmo de determinación del ganador general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos de determinación del ganador existente para las subastas combinatorias están centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son Cass [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deben estudiarse, ya que ofrecen un mejor ajuste para algunas aplicaciones, ya que, por ejemplo, los agentes no quieren revelar sus valoraciones al subastador. La subasta de pausa (entorno de selección de usuario adaptativo progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. Pausa establece las reglas que los participantes tienen que adherirse para que el trabajo se distribuya entre ellas. Sin embargo, no se preocupa por cómo los postores determinan lo que deben ofertar. En este documento presentamos dos algoritmos, Pausebid y CachedPauseBid, que permiten a los agentes en una subasta de pausa para encontrar el bido que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de la utilidad miope y están garantizados para encontrar el beque que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado.PAUSEBID realiza una rama y una búsqueda vinculada completamente desde cero cada vez que se llama.CachedPauseBid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones.694 978-81-904262-7-5 (RPS) C 2007 Ifaamas 2. La subasta de pausa Una subasta de pausa para m ítems tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente y durante esta etapa los postores solo pueden colocar ofertas en artículos individuales. Al final de este estado, sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva K = 2, 3 ,..., M consiste en una subasta de precios ascendente donde los licitadores deben presentar ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser para k ítems o menos. Los postores pueden usar ofertas que otros agentes han colocado en rondas anteriores al construir sus bidsets, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo bidset debe tener una suma de precios de oferta que sea más grande que el del bestet actualmente ganador. Al final de cada etapa K, todos los agentes conocen la mejor oferta por cada subconjunto de tamaño K o menos. Además, en cualquier momento después de que la etapa 1 haya terminado, hay un bidto permanente cuyo valor aumenta monotónicamente a medida que se presentan los nuevos bidsets. Dado que en la ronda final, todos los agentes consideran todos los bidsets posibles, sabemos que el bidset ganador final será uno de los que ningún agente puede proponer un mejor bidto. Sin embargo, tenga en cuenta que no se garantiza que este banco sea el que maximice los ingresos, ya que estamos utilizando una subasta de precios ascendente, por lo que la oferta ganadora para cada conjunto será solo un poco más grande que la segunda oferta más alta para el conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los elementos a los postores que se encuentran en una subasta de pausa es la misma que la solución de maximización de ingresos. Los resultados de nuestra prueba proporcionan una respuesta a esta pregunta. La subasta de pausa hace que el trabajo del subastador sea muy fácil. Todo lo que tiene que hacer es asegurarse de que cada nuevo bidset tenga un ingreso más grande que el bidset ganador actual, así como para asegurarse de que cada oferta en un bidset de agentes que no sea suya corresponde a otros agentes anteriores. El problema computacional cambia de una de la determinación del ganador a una de la generación de ofertas. Cada agente debe buscar sobre el espacio de todos los bidsets que contienen al menos una de sus ofertas. La búsqueda se hace más fácil por el hecho de que el agente debe considerar solo las mejores ofertas actuales y solo quiere ofertas en los que su propia utilidad sea más alta que en el bidset ganador actual. Cada agente también tiene un incentivo claro para realizar este cálculo, a saber, su utilidad solo aumenta con cada bidset que propone (por supuesto, podría disminuir con los bidsets que otros proponen). Finalmente, se ha demostrado que la subasta de pausa es libre de envidia, ya que al concluir la subasta, ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar completamente eliminar el subastador y, en cambio, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de las mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar su cálculo, ya que aumentará su utilidad esperada. Además, cualquier mentira sobre otras ofertas de agentes se descubre fácilmente realizando un seguimiento de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). A saber, el único que puede aumentar el valor de oferta de un agente es el agente mismo. Cualquiera que reclame un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcula el bidset de maximización de utilidad para cada agente.3. Formulación del problema Una oferta B está compuesta por tres elementos bitems (el conjunto de artículos que la oferta ha terminado), bagent (el agente que colocó la oferta) y bvalue (el valor o el precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de elementos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un set W ⊆ B de las ofertas actualmente ganadoras. Este es el conjunto de ofertas que cubre todos los elementos y actualmente maximiza los ingresos, donde los ingresos de W están dados por R (W) = b∈W BValue.(1) El agente es la función de valor viene dada por vi (s) ∈ donde s es un conjunto de elementos. Dada una función de valor de los agentes y el bidset ganador actual w, podemos calcular la utilidad de los agentes a partir de w como ui (w) = b∈W |bagent = i vi (bitems) - bvalue.(2) Es decir, la utilidad de los agentes para un bidset w es el valor que recibe por los artículos que gana en w menos el precio que debe pagar por esos artículos. Si el agente no está ganando ningún elemento, entonces su utilidad es cero. El objetivo de los agentes de licitación en la subasta de pausa es maximizar su utilidad, sujeto a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos más grande que los ingresos actuales, donde está el incremento más pequeño permitido en la subasta. Formalmente, dado que W es el bateador ganador actual, agente, debo encontrar una g ∗ i tal que r (g ∗ i) ≥ r (w) + y g ∗ i = arg max g⊆2b ui (g), (3)donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈G (b ∈ B) o (bagent = i y bvalue> b (bitems) y tamaño (bitems) ≤ k), y donde b (elementos)El valor de la oferta en B para los elementos establecidos (si no hay oferta para esos elementos, devuelve cero). Es decir, cada oferta B en G debe satisfacer al menos una de las dos condiciones siguientes.1) B ya está en B, 2) B es una oferta de tamaño ≤ k en la que el agente I oferta más alto que el precio de los mismos artículos en B. 4. Algoritmos de licitación Según la subasta de pausa, durante la primera etapa solo tenemos varias subastas en inglés, y los postores presentan ofertas en artículos individuales. En este caso, una estrategia dominante de agentes es una oferta más alta que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas posteriores: K> 1. Cuando K> 1, los agentes tienen que encontrar G ∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un gran árbol de búsqueda. Nuestros algoritmos representan enfoques alternativos para superar esta costosa búsqueda.4.1 El algoritmo de pausa en el algoritmo de pausa (que se muestra en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores quieren maximizar su utilidad y que en cualquier punto dado es probable que solo hay unas pocas ofertas dentro de B que el sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 695 pausebid (i, k) 1 my-bids ← ∅ 2 sus-bids ← ∅ 3 para b ∈ B 4 do si bagent = i o vi (bitems)> bvalue 5luego my-bids ← my-bids +nueva oferta (bitems, i, vi (bitems)) 6 más sus-bids ← sus-bids +b 7 para s ∈ Subsets de k o menos elementos tal que vi (s)> 0y ¬∃b∈Bbitems = s 8 do my-bids ← my-bids + new bid (s, i, vi (s)) 9 ofertas ← my-bids + sus-bids 10 g ∗ ← ∅ £ Variable global 11 u∗ ← ui (w) £ variable global 12 pbsearch (ofertas, ∅) 13 excedente ← b∈G ∗ |bagent = i bvalue-b (bitems) 14 si excedente = 0 15 entonces regrese g ∗ 16 my-payment ← vi (g ∗)-u ∗ 17 para b ∈ G ∗ |bagent = i 18 do si mi pago ≤ 0 19 entonces bvalue ← b (bitems) 20 más bvalue ← b (bitems) + my-pago · bvalue −b (bitems) excedente 21 retorno g ∗ Figura 1: el algoritmo de pausa queImplementa una rama y una búsqueda unida.I es el agente y k es la etapa actual de la subasta, para k ≥ 2. El agente puede dominar, comenzamos por definir los my-bids para ser la lista de ofertas para las cuales la valoración de los agentes es más alta que la mejor oferta actual,como se da en B. Establecemos el valor de estas ofertas para ser la verdadera valoración de los agentes (pero no necesariamente estamos ofertando una valoración verdadera, como explicamos más adelante). Del mismo modo, establecemos que sus clientes sean el resto de las ofertas de B. Finalmente, la lista de búsqueda de los agentes es simplemente la concatenación de los my-bids y sus vajillas. Tenga en cuenta que las propias ofertas de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (PAUSEBIDE LINE 3 a 9). El agente ahora puede realizar una rama y una búsqueda vinculada en el árbol de ramas en las cervezas producidas por estas ofertas. PBSearch (Figura 2) implementa esta búsqueda de rama y límite. Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que usamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Inicialmente, U ∗ se establece en UI (W) (PAUSeBid Line 11) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si PBSearch alguna vez se encuentra con una solución parcial en la que la utilidad máxima que el agente puede esperar es menor que U ∗, entonces ese subárbol está podado (PBSearch Line 21). Tenga en cuenta que podemos determinar la utilidad máxima solo después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están primero en la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente es el ganador asíLa utilidad de los agentes ya no aumentará. Por ejemplo, pbsearch (ofertas, g) 1 si ofertas = ∅ ∅ ∅ ∅ ∅ ∅ ∅ ∅ ∅ ∅ luego returación 2 b ← primero (ofertas) 3 ofertas ← ofertas −b 4 g ← g + b 5 ¯ig ← elementos no en g 6 si g no contiene unoferta de i 7 y luego regrese 8 Si g incluye todos los elementos 9 y luego el pago min ← max (0, r (w) +-(r (g)-ri (g)), b∈G | bagent = i b (bitems)) 10 Máx-Utilidad ← VI (G)-Mínimo Pago 11 Si R (G)> R (W) y Máx-Utilidad ≥ U ∗ 12, entonces G ∗ ← G 13 U ∗ ← Máx-Utilidad 14 PBSEARK (BIDS, g-b) £ b está fuera 15 más max-ingresos ← r (g) + max (h (¯ig), hi (¯ig)) 16 Si max-venue ≤ r (w) 17 entonces pbsearch (ofertas,g-b) £ b está fuera 18 elseif bagent = i 19 entonces pagado minel(g)-Min-pago 21 Si max-utilidad> u ∗ 22 entonces pbsearch ({x ∈ Bids | xItems ∩ bitems = ∅}, g) £ b está en 23 pbsearch (ofertas, g-b) £ b está fuera24 más 25 pbsearch ({x ∈ Bids | xItems ∩ bitems = ∅}, g) £ b está en 26 pbsearch (ofertas, g - b) £ b está fuera 27 return figura 2: el procedimiento recursivo de pbsearch donde las ofertas son el conjunto del conjuntode las ofertas disponibles y G es la solución parcial actual.Si un agente solo tiene una oferta en My-Bids, entonces la utilidad máxima que puede esperar es igual a su valor para los elementos en esa oferta, menos el pago mínimo posible que podemos hacer para esos artículos y aún se les ocurre un conjunto de ofertas quetiene ingresos mayores que R (W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y la línea 9 para el caso en el que tenemos una solución completa en PBSearch. Tenga en cuenta que para calcular el pago min para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer para cada artículo. Este límite superior es proporcionado por h (s) = s∈S max b∈B |s∈Bitems tamaño de bvalue (bitems).(4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada elemento individual en s un valor igual al máximo de oferta en B dividido por el número de elementos en esa oferta. Para podar las ramas que no pueden conducir a una solución con ingresos mayores que el W actual, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones del 696 el Sexto INTL. Conf.en agentes autónomos y agentes de sistemas de múltiples agentes (AAMAS 07). Del mismo modo a (4) definimos hi (s, k) = s∈S max s |tamaño (s) ≤k y s∈S y vi (s)> 0 vi (s) tamaño (s) (5) que asigna a cada elemento individual s en s el valor máximo producido por la valoración de S dividida por el tamañode S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene S, y su tamaño es menor o igual que k.El algoritmo utiliza la heurística H y HI (líneas 15 y 19 de PBSearch), para podar las ramas recién mencionadas de la misma manera que un algoritmo A ∗ usa su heurística. Una técnica de poda final implementada por el algoritmo es ignorar las ramas donde el agente no tiene ofertas en la respuesta actual G y no hay más ofertas de los agentes en la lista (PBSearch Lines 6 y 7). El G ∗ resultante encontrado por PBSearch es, por lo tanto, el conjunto de ofertas que tienen ingresos mayores que R (W) y maximiza el agente es la utilidad. Sin embargo, el agente es ofertas en G ∗ todavía se establecen en su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausa son responsables de establecer los pagos de los agentes para que pueda lograr su utilidad máxima u ∗. Si el agente solo tiene una oferta en G ∗, entonces es simplemente una cuestión de reducir el pago de esa oferta por U ∗ desde el máximo actual de los agentes Valoración verdadera. Sin embargo, si el agente tiene más de una oferta, entonces enfrentamos el problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos elegido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de elementos.Pausebid supone que el conjunto de las mejores ofertas B y el mejor bidset ganador actual W permanece constante durante su ejecución, y devuelve los agentes miopes de utilidad miope que maximiza el bidset (si hay una) usando una rama y una búsqueda unida. Sin embargo, repite toda la búsqueda en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores.4.2 El algoritmo CachedPauseBid El algoritmo CachedPauseBid (que se muestra en la Figura 3) es nuestro segundo enfoque para resolver el problema de licitación en la subasta de pausa. Se basa en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar hacer una búsqueda completa cada vez. El problema es el mismo;El agente que tengo que encontrar G ∗ i. Observamos que G ∗ I es un bidset que contiene al menos una oferta del agente i. Sea s un conjunto de elementos para los cuales el agente I tiene una valoración de tal manera que vi (s) ≥ b (s)> 0, que gs sea un bidto sobre s tal que r (gs i) ≥ r (w) +y gs i = arg max g⊆2b ui (g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈G (b ∈ B) o (bagent = i y bvalue> b (bitems)) y (∃b∈Gbitems = sy bagent = i). Es decir, GS I es el mejor BIDSE para todos los elementos que incluyen una oferta de I por todos los artículos. En la subasta de pausa no podemos ofertar por conjuntos de artículos con un tamaño mayor que k.Entonces, si tenemos para cada conjunto de elementos s para los cuales vi (s)> 0 y tamaño (s) ≤ k su GS I I BS I entonces G ∗ I es el GS I que maximiza la utilidad de los agentes. Eso es g ∗ i = arg max {s |vi (s)> 0∧Size (s) ≤k} ui (gs i).(7) Cada agente I implementa una tabla de hash C-Table de tal manera que la tabla C [S] = GS para todos los S que VI (S) ≥ B (S)> 0. Podemos almacenar en caché (i, k, k-cambiado) 1 para cada s en la tabla C 2 si vi (s) <b (s) 3 y luego retire S de la table C 4 de lo contrario si K-cambiado y tamaño (s) = k 5 Entonces b ← b + nueva oferta (i, s, vi (s)) 6 g ∗ ← ∅ 7 u ∗ ← ui (w) 8 para cada s con tamaño (s) ≤ k en c-table 9do ¯s ← items-s 10 GS ← C-Table [S] £ Variable global 11 min- Pagment ← Max (R (W) +, B∈Gs B (Bitems)) 12 US ← R (GS)-Min-Pago £ Variable global 13 if (k-cambiado y tamaño (s) = k) o (∃b∈B bitems ⊆ ¯s y bagent = i) 14 entonces b ← {b ∈ B | bitems ⊆ ¯s} 15 ofertas ←B +{b ∈ B | bitems ⊆ ¯s y b /∈ B} 16 para b ∈ Bids 17 do si vi (bitems)> bvalue 18 entonces bagent ← i 19 bvalue ← vi (bitems) 20 si k cambió y tamaño(S) = k 21 Entonces n ← Tamaño (ofertas) 22 US ← 0 23 más n ← Tamaño (b) 24 g ← ∅ + nuevas ofertas (S, I, VI (s)) 25 CpbSearch (BIDS, G, N) 26 C-Table [S] ← GS 27 Si us> u ∗ y r (gs) ≥ r (w) + 28 entonces excedente ← b∈Gs |bagent = i bvalue-b (bitems) 29 Si excedente> 0 30 entonces my-payment ← vi (gs)-ui (gs) 31 para b ∈ Gs |bagent = i 32 do si mi pago ≤ 0 33 entonces bvalue ← b (bitems) 34 más bvalue ← b (bitems)+ my-pago · bvalue −b (bitems) excedente 35 u ∗ ← ui (gs) 36 g ∗← GS 37 más Si us ≤ 0 y VI (S) <b (s) 38, retire S de la Tabla C 39 return G ∗ Figura 3: El algoritmo de CacheDpauseBid que implementa una búsqueda basada en el almacenamiento en caché para encontrar un banqueto que maximice la utilidadpara el agente i.K es la etapa actual de la subasta (para K ≥ 2), y K-Changed es un booleano que es cierto justo después de que la subasta se movió a la siguiente etapa. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 697 cpbSearch (ofertas, g, n) 1 Si ofertas = ∅ ∅ o n ≤ 0, entonces returación 2 b ← primero (ofertas) 3 ofertas ← BIDS −B 4 G ← G +b 5 ¯ig ← Los elementos no en G 6 Si G incluye todos los elementos 7, entonces pagador minero ← Max (0, R (W) +-(R (G)-Ri (G)), B∈G | Bagent = IB (bitems)) 8 max-utilidad ← vi (g)-Mínimo pago 9 Si R (G)> R (W) y Máx-Utilidad ≥ US 10, entonces GS ← G 11 US ← Máx-Utilidad 12 CpbSearch (BIDS, g-b, n-1) £ b está fuera 13 más max-ingresos ← r (g) + max (h (¯ig), hi (¯ig)) 14 si max-venue ≤ r (w) 15 entoncescpBSearch (BIDS, G-B, N-1) £ B está fuera 16 Elseif Bagent = I 17 Entonces, pago mínimo ← (R (W) +)-(R (G)-Ri (G))-H (¯Ig) 18 max-utilidad ← vi (g)-Min-pago 19 Si max-utilidad> us 20 entonces cpBSearch ({x ∈ Bids | xitems ∩ bitems = ∅}, g, n + 1) £ b está en 21 cpbsearch(ofertas, g - b, n - 1) £ b está fuera 22 más 23 cpbSearch ({x ∈ Bids | XItems ∩ bitems = ∅}, g, n + 1) £ b está en 24 cpbsearch (ofertas, g - b, n - 1) £ b está disponible 25 retorno Figura 4: El procedimiento recursivo de CPBSearch donde las ofertas son el conjunto de ofertas disponibles, G es la solución parcial actual y N es un valor que indica cuán profundo en las ofertas de la lista tiene que hacer el algoritmobuscar.Luego encuentre G ∗ buscando el GS, almacenado en C-Table [S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos con tamaño (s) ≤ k.El problema sigue siendo el mantenimiento de la tabla C actualizada y evitando buscar cada GS cada vez.CachedPauseBid trata con este y otros detalles. Sea B el conjunto de ofertas que contengan las nuevas ofertas mejores, es decir, B contiene las ofertas agregadas recientemente a B y las ofertas que han cambiado el precio (siempre más alto), el postor o ambas y ya estaban en B. Sea ¯s = items - s el complemento de S (el conjunto de elementos no incluidos en S).CachedPauseBid toma tres parámetros: i el agente, k la etapa actual de la subasta y K cambió de un booleano que es cierto justo después de que la subasta se movió a la siguiente etapa. Inicialmente, C-Table tiene una fila o entrada para cada conjunto S para el que vi (S)> 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual VI (S) <B (S) de C-Table (línea 3). Luego, en el caso de que K-Changed sea verdadero, para cada conjunto S con tamaño (s) = k, agregamos a B una oferta para ese conjunto con un valor igual a VI (S) y agente de postor I (línea 5);Esta es una oferta que ahora se le permite considerar al agente. Luego buscamos G ∗ entre el GS almacenado en C-Table, para esto solo necesitamos considerar los conjuntos con tamaño (s) ≤ K (línea 8). Pero, ¿cómo sabemos que el GS en C-Table [S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros de eso y necesitamos hacer una búsqueda para actualizar C-Table [s]. Estos casos son: i) Cuando el cambio de K es verdadero y el tamaño (s) ≤ k, ya que no había GS almacenado en C-table para este S. ii) cuando existe al menos una oferta en B para el conjunto de elementos¯s o un subconjunto presentado por un agente diferente al I, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en C-Table [S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de CachedPauseBid. En ambos casos, dado que GS debe contener una oferta para S, necesitamos encontrar un bidset que cubra los elementos faltantes, es decir. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de elementos ¯s o para un subconjunto de ello. Creamos las ofertas de la lista que contienen solo esas ofertas. Sin embargo, colocamos las ofertas de B al comienzo de las ofertas (línea 14) ya que ellos son las que han cambiado. Luego, reemplazamos las ofertas en ofertas que tienen un precio más bajo que la valoración que el agente que tiene para esos mismos elementos con una oferta del agente I por esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo CPBSearch, llamado en la línea 25 de CachedPauseBid y que se muestra en la Figura 4, es el que encuentra el nuevo GS.CPBSearch es una versión ligeramente modificada de nuestra rama y búsqueda vinculada implementada en PBSearch. La primera modificación es que tiene un tercer parámetro n que indica cuán profundo en las ofertas de la lista queremos buscar, ya que deja de buscar cuando N menos o igual a cero y no solo cuando las ofertas de la lista están vacías (línea 1). Cada vez que hay una llamada recursiva de CPBSearch n se reduce en una cuando una oferta de ofertas se descarta o afuera (líneas 12, 15, 21 y 24) y N permanece igual (líneas 20 y 23). Establecemos el valor de N antes de llamar a CPBSearch, para que sea el tamaño de las ofertas de la lista (CachedPauseBid Line 21) en el caso I), ya que queremos que CPBSearch busque en todas las ofertas;Y establecemos que N es el número de ofertas de B incluidas en las ofertas (CachedPauseBid Line 23) en el caso II), ya que sabemos que solo esas primeras N BIDS en las ofertas cambiaron y pueden afectar nuestra GS actual. Otra diferencia con PBSearch es que el límite en CpBSearch es nosotros que establecemos como 0 (línea cachedpausida 22) cuando en el caso i) y r (gs)-min-pago (línea cachedpausebida 12) cuando en el caso ii). Llamamos a CPBSearch con G que ya contiene una oferta para S. Después de ejecutar CPBSearch, estamos seguros de que tenemos el GS correcto, por lo que la almacenamos en la Table C correspondiente [S] (CachedPauseBid Line 26). Cuando llegamos a la línea 27 en CachedPauseBid, estamos seguros de que tenemos el GS correcto. Sin embargo, el agente es las ofertas en GS todavía están establecidas en su propia valoración y no al precio más bajo posible. Si EE. UU. Es mayor que el U ∗ actual, las líneas 31 a 34 en CachedPauseBid son responsables de establecer los pagos de los agentes para que pueda lograr su utilidad máxima en los Estados Unidos. Como en pausa, hemos elegido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de elementos. En el caso de que nosotros menos o igual a cero y la valoración que el agente I tiene para el conjunto de elementos s es más bajo que el valor actual de la oferta en b para el mismo conjunto de elementos, eliminamos la mesa C correspondiente[S] Dado que sabemos que no vale la pena mantenerlo en la tabla de caché (CachedPauseBid Line 38). La función CachedPauseBid se llama cuando K> 1 y devuelve los agentes miopes de utilidad miope Bidset, si hay uno. Se supone que W y B permanecen constantes durante su ejecución.698 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) GenerateValues (i, elementos) 1 para x ∈ Items 2 Do VI (x) = exp (.01) 3 para n ← 1...(Números-Bids-ítems) 4 do S1, S2 ← Dos conjuntos aleatorios de elementos con valores.5 VI (S1 ∪ S2) = VI (S1) + VI (S2) + exp (.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorio.Expd (x) Devuelve un número aleatorio tomado de una distribución exponencial con media 1/x.0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (y-eje), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, como función del número de elementos en la subasta.5. Prueba y comparación Hemos implementado ambos algoritmos y realizamos una serie de experimentos para determinar cómo su solución se compara con la solución de maximización de ingresos y cómo sus tiempos se comparan entre sí. Para hacer nuestras pruebas, tuvimos que generar funciones de valor para los agentes1. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden reunir ciertos subconjuntos de tareas. Por ejemplo, imagine un conjunto de robots que deben recoger y entregar elementos a diferentes ubicaciones. Dado que cada robot está en una ubicación diferente y tiene diferentes habilidades, cada uno tendrá diferentes preferencias sobre cómo agrupar. Sus costos para los paquetes de artículos son subadititivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la 1 nota adecuada de que no podíamos usar gatos [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si le dijeran el conjunto de ofertas colocadas en una subasta combinatoria, pero no quién colocó cada oferta o incluso cuántas personas colocaron ofertas, y luego pidió que determine la función de valor de cada participante en la subasta.0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmosEn relación con los ingresos máximos (eje y) como función del número de elementos en la subasta.funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos como se encuentra por CASS cuando se les da un conjunto de ofertas que corresponden a la verdadera valoración de los agentes. Es decir, para cada agente I y cada conjunto de elementos s para los cuales vi (s)> 0 generamos una oferta. Este conjunto de ofertas se alimentó a CASS que implementa un algoritmo de determinación del ganador centralizado para encontrar la solución que maximiza los ingresos. Sin embargo, tenga en cuenta que los ingresos de la subasta de pausa en todas las subastas siempre son más pequeños que los ingresos de la solución que maximiza los ingresos cuando los agentes ofertan sus verdaderas valoraciones. Dado que Pause utiliza subastas en inglés, los precios finales (aproximadamente) representan la segunda valoración más alta, además, para ese conjunto de artículos. Arreglamos el número de agentes a ser de 5 años y experimentamos con un número diferente de elementos, a saber, de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución de maximización de ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de elementos que la solución de maximización de ingresos (como se muestra en la Figura 6). Los casos en que nuestros algoritmos no lograron llegar a la distribución de la solución de maximización de ingresos son aquellos donde había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución de maximización de ingresos contiene la oferta (o ofertas) utilizando esta mayor valoración, entonces es imposible que la subasta de pausa encuentre esta solución porque esa oferta (esas ofertas) nunca se coloca. Por ejemplo, si el agente I tiene VI (1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces solo necesito hacer una oferta de 11 para ganar ese artículo. Si la solución de maximización de ingresos requiere que se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se colocará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen a la solución maximizadora de ingresos disminuyen a medida que aumenta el número de elementos. Para 2 ítems es casi el 100%, pero disminuye un poco menos del 1 por ciento a medida que aumentan los elementos, por lo que este porcentaje promedio de convergencia es de alrededor del 90% para 10 ítems. En algunos casos, nuestros algoritmos encuentran diferentes soluciones, esto se debe a los diferentes INTL. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + + + + + + + + + ++ Figura 8: Número promedio de nodos expandidos (eje y) como función de los elementos en la subasta.ordenar de las ofertas en la lista de ofertas que los hacen buscar en diferentes orden. Sabemos que los ingresos generados por la subasta de pausa son generalmente más bajos que los ingresos de la solución de ingresos por ingreso, pero ¿cuánto más bajo? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos otorgados por nuestros algoritmos en relación con los ingresos dados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio del 2.7% a medida que aumenta el número de elementos, como se muestra en la Figura 7. Sin embargo, descubrimos que CachedPauseBid genera un ingreso más alto que Pausebid (4.3% más alto en promedio), excepto las subastas con 2 ítems donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 ítems, ambos algoritmos producen en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 ítems), CachedPauseBid produjo en promedio una proporción de ingresos del 91.5%, mientras que Pausebid produjo en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos se puede determinar contando el número de nodos expandidos en el árbol de búsqueda. Para esto, contamos la cantidad de veces que se invoca pbsearch por cada vez que se llama pausa y la cantidad de veces que se invoca fastpauseBidSearch por cada vez que caquedpausebido, respectivamente para cada uno de nuestros algoritmos. Como se esperaba, ya que este es un problema np-cudo, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que los resultados de los supuestos de CachedPauseBid pausbid, ya que se expande en promedio de menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos se expandió cuando 2 elementos es cero para CachedPauseBid, mientras que para Pausebid es 2;y en los otros extremos (10 ítems) CachedPauseBid se expande en promedio solo 633 nodos, mientras que Pausbido se expande en promedio de 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta como función del número de elementos, el número real de nodos es mucho más pequeño que el peor de los casos de nn, donde n es el número de elementos. Por ejemplo, para 10 ítems nos expandimos ligeramente más de 103 nodos para el caso de pausa y menos que para el caso de la cachepause 0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de elementos CacheDPauseBid 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 33 3 3 3 3 3 3 PAUSEBID + + + + + + + + + + Figura 9: Tiempo promedio en segundos que se necesitan para terminar una subasta (eje y) como función del número de elementos en la subasta.oferta que son números mucho más pequeños que 1010. Observe también que nuestro algoritmo de generación de valor (Figura 5) genera una serie de ofertas que son exponenciales en el número de elementos, como podría esperarse en muchas situaciones. Como tal, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan exponencialmente en función del número de ofertas, pero permanezca aproximadamente constante a medida que crece el número de elementos. Queríamos asegurarnos de que los nodos menos expandidos correspondan a una ejecución más rápida, especialmente porque nuestros algoritmos ejecutan operaciones diferentes. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, una PC portátil Intel Centrino 2.0 GHz con 1 GB de RAM y un disco duro de 7200 RMP 60 GB, y calculó el tiempo promedio que lleva finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, CachedPauseBid es más rápida que PAUSEBID, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos.6. Trabajo relacionado Se ha realizado una gran cantidad de investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena revisión. Sin embargo, el estudio de los algoritmos de determinación del ganador distribuido para las subastas combinatorias sigue siendo relativamente nuevo. Los algoritmos dan un enfoque para distribuir el problema de determinación del ganador en las subastas combinatorias presentadas en [7], pero estos algoritmos suponen que las entidades computacionales son los elementos que se venden y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación del ganador distribuido en la subasta combinatoria, pero supone que las ofertas en sí tienen el cálculo. Este algoritmo tampoco converge a una solución para la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos de VCG en un problema de diseño de mecanismo. Su mecanismo equivale aproximadamente a que cada agente calcule los pagos para otros dos agentes y los entreguen a un 700 el sexto INTL. Conf.En los agentes autónomos y el servidor central de los sistemas de múltiples agentes (AAMAS 07) que luego verifica para asegurarse de que los resultados de todos los pares estén de acuerdo, de lo contrario se ordena un re-calculación. Esta idea general, que llaman el principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se da en [8] cuando los agentes de licitación priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo de determinación del ganador centralizado debe considerar, lo que facilita ese problema. Finalmente, en la subasta de reloj de obtención de cálculo [1], los agentes reciben un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Como tal, supone que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores según lo asumido por la subasta de pausa.7. Conclusiones Creemos que las soluciones distribuidas al problema de determinación del ganador deben estudiarse, ya que ofrecen un mejor ajuste para algunas aplicaciones como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entrelos postores. La subasta de pausa es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en las subastas combinatorias. Con esta subasta, incluso podemos imaginar completamente eliminar completamente el subastador y, en cambio, hacer que cada agente realice la tarea del subastador. Sin embargo, aunque Pause establece las reglas que los postores deben obedecer, no nos dice cómo los postores deben calcular sus ofertas. Hemos presentado dos algoritmos, Pausebid y CachedPauseBid, que los agentes de los postor pueden usar para participar en una subasta de pausa. Ambos algoritmos implementan una estrategia de maximización de la utilidad miope que está garantizada para encontrar el bidto que maximiza la utilidad de los agentes dado el conjunto de las mejores ofertas pendientes en un momento dado, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayoría de las veces, la misma distribución de elementos que la solución de maximización de ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos donde había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Como es un problema difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa.PAUSEBID realiza una rama y una búsqueda vinculada completamente desde cero cada vez que se invoca.CachedPauseBid Caches soluciones parciales y realiza una rama y una búsqueda unida solo en las pocas porciones afectadas por los cambios en las ofertas entre tiempos consecutivos.CachedPauseBid tiene un mejor rendimiento, ya que explora menos nodos (menos de la mitad) y es más rápido. Como se esperaba, los ingresos generados por una subasta de pausa son más bajos que los ingresos de una solución de maximización de ingresos encontrada por un algoritmo de determinación de ganador centralizado, sin embargo, encontramos que CachedPauseBid genera en promedio 4.7% de ingresos más altos que PAUSeBid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan como función del número de elementos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas limitaciones de coordinación respaldadas por subastas combinatorias sin tener que recurrir a un algoritmo de determinación del ganador centralizado. Además, debido al diseño de la subasta de pausa, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de licitación pueden ser utilizados por cualquier sistema multiagente que use subastas combinatorias para la coordinación, pero prefiere no implementar un subastador centralizado.8. Adquisición descentralizada de cálculo y robustez computacional en un mercado inteligente. Economic Theory, 13 (1): 41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown e Y. Shoham. Domestica la complejidad computacional de las subastas combinatorias: enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Management Science, 46 (4): 586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. Pausa: una subasta combinatoria computacionalmente manejable. En Cramton et al.[2], Capítulo 6, páginas 139-157.[6] K. Leyton-Brown, M. Pearson e Y. Shoham. Hacia un suite de prueba universal para algoritmos de subasta combinatoria. En Actas de la 2da Conferencia ACM sobre Comercio Electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu.[7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación del ganador distribuido en subastas combinatorias. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas endógenamente determinadas. Informe técnico, Rutgets Center for Operations Research, enero de 2001. RRR 3-2001.[9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Conjunta Internacional sobre Agentes Autónomos y Sistemas Multiagentes, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinacionales manejables computacionalmente. Management Science, 44 (8): 1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Artificial Intelligence, 135 (1-2): 1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo rápido para la determinación del ganador en subastas combinatorias. Management Science, 51 (3): 374-391, 2005. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 701",
    "original_sentences": [
        "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
        "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
        "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
        "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
        "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
        "PAUSE establishes the rules the bidders must obey.",
        "However, it does not tell us how the bidders should calculate their bids.",
        "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
        "Our algorithms always return the set of bids that maximizes the bidders utility.",
        "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
        "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
        "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
        "General Terms Algorithms, Performance. 1.",
        "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
        "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
        "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
        "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
        "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
        "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
        "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
        "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
        "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
        "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
        "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
        "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
        "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
        "However, it is not concerned with how the bidders determine what they should bid.",
        "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
        "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
        "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
        "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
        "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
        "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
        "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
        "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
        "At the end of each stage k all agents know the best bid for every subset of size k or less.",
        "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
        "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
        "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
        "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
        "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
        "Our test results provide an answer to this question.",
        "The PAUSE auction makes the job of the auctioneer very easy.",
        "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
        "The computational problem shifts from one of winner determination to one of bid generation.",
        "Each agent must search over the space of all bidsets which contain at least one of its bids.",
        "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
        "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
        "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
        "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
        "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
        "The agents would have an incentive to perform their computation as it will increase their expected utility.",
        "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
        "Namely, the only one that can increase an agents bid value is the agent itself.",
        "Anyone claiming a higher value for some other agent is lying.",
        "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
        "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
        "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
        "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
        "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
        "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
        "If the agent is not winning any items then its utility is zero.",
        "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
        "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
        "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
        "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
        "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
        "Our algorithms focus on the subsequent stages: k > 1.",
        "When k > 1, agents have to find g∗ i .",
        "This can be done by performing a complete search on B.",
        "However, this approach is computationally expensive since it produces a large search tree.",
        "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
        "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
        "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
        "Similarly, we set their-bids to be the rest of the bids from B.",
        "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
        "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
        "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
        "This branch and bound search is implemented by pbsearch (Figure 2).",
        "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
        "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
        "We call it u∗ .",
        "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
        "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
        "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
        "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
        "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
        "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
        "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
        "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
        "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
        "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
        "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
        "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
        "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
        "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
        "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
        "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
        "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
        "However it repeats the whole search at every stage.",
        "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
        "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
        "The problem is the same; the agent i has to find g∗ i .",
        "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
        "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
        "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
        "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
        "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
        "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
        "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
        "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
        "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
        "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
        "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
        "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
        "But how do we know that the gS in C-Table[S] is still the best solution for S?",
        "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
        "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
        "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
        "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
        "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
        "We build the list bids that contains only those bids.",
        "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
        "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
        "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
        "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
        "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
        "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
        "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
        "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
        "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
        "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
        "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
        "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
        "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
        "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
        "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
        "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
        "In order to do our tests we had to generate value functions for the agents1 .",
        "The algorithm we used is shown in Figure 5.",
        "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
        "For example, imagine a set of robots which must pick up and deliver items to different locations.",
        "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
        "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
        "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
        "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
        "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
        "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
        "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
        "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
        "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
        "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
        "We ran both algorithms 100 times for each combination.",
        "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
        "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
        "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
        "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
        "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
        "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
        "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
        "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
        "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
        "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
        "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
        "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
        "Again, this difference is produced by the order of the search.",
        "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
        "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
        "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
        "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
        "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
        "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
        "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
        "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
        "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
        "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
        "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
        "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
        "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
        "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
        "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
        "We recommend [2] for a good review.",
        "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
        "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
        "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
        "This algorithm also fails to converge to a solution for most cases.",
        "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
        "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
        "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
        "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
        "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
        "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
        "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
        "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
        "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
        "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
        "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
        "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
        "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
        "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
        "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
        "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
        "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
        "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
        "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
        "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
        "REFERENCES [1] P. J.",
        "Brewer.",
        "Decentralized computation procurement and computational robustness in a smart market.",
        "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
        "Combinatorial Auctions.",
        "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
        "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
        "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
        "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
        "A combinatorial auction with multiple winners for universal service.",
        "Management Science, 46(4):586-596, 2000. [5] A.",
        "Land, S. Powell, and R. Steinberg.",
        "PAUSE: A computationally tractable combinatorial auction.",
        "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
        "Towards a universal test suite for combinatorial auction algorithms.",
        "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
        "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
        "Algorithms for distributed winner determination in combinatorial auctions.",
        "In LNAI volume of AMEC/TADA.",
        "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
        "Auctions with endogenously determined allowable combinations.",
        "Technical report, Rutgets Center for Operations Research, January 2001.",
        "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
        "Distributed implementations of vickrey-clarke-groves auctions.",
        "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
        "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
        "Computationally manageable combinational auctions.",
        "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
        "An algorithm for winner determination in combinatorial auctions.",
        "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
        "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
        "Management Science, 51(3):374-391, 2005.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
    ],
    "error_count": 0,
    "keys": {
        "distributed allocation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT <br>distributed allocation</br> and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Algoritmos de licitación para una subasta combinatoria distribuida Benito Mendoza ∗ y Jos´e M. Vidal Informática e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu Resumen \"Allocación distribuida\" y coordinación multiagenteLos problemas se pueden resolver a través de subastas combinatorias.asignación distribuida"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "combinatorial auction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed <br>combinatorial auction</br> Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price <br>combinatorial auction</br> that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a <br>combinatorial auction</br> bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional <br>combinatorial auction</br> where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a <br>combinatorial auction</br> but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in <br>combinatorial auction</br> but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A <br>combinatorial auction</br> with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable <br>combinatorial auction</br>.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for <br>combinatorial auction</br> algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Algoritmos de licitación para una \"subasta combinatoria\" distribuida Benito Mendoza ∗ y Jos´e M. Vidal Informática e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, viDal@sc.edu Resumen Allocación distribuida y coordinación multiagente MultiagenteLos problemas se pueden resolver a través de subastas combinatorias.subasta combinatoria",
                "Es una \"subasta combinatoria\" de precio creciente que naturalmente distribuye el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo.subasta combinatoria",
                "En una \"subasta combinatoria\", los licitadores pueden realizar ofertas en combinaciones de artículos, llamados paquetes o ofertas, en lugar de solo artículos individuales.subasta combinatoria",
                "Es decir, los precios finales no serán los mismos que los precios en una \"subasta combinatoria\" tradicional donde todos los postores ofertan su verdadera valoración.subasta combinatoria",
                "Es como si le dijeran el conjunto de ofertas colocadas en una \"subasta combinatoria\", pero no quién colocó cada oferta o incluso cuántas personas colocaron ofertas, y luego pidió que determine la función de valor de cada participante en la subasta.0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmosEn relación con los ingresos máximos (eje y) como función del número de elementos en la subasta.funcionamiento de nuestros algoritmos.subasta combinatoria",
                "El algoritmo VSA [3] es otra forma de realizar la determinación del ganador distribuido en la \"subasta combinatoria\", pero supone que las ofertas en sí realizan el cálculo.subasta combinatoria",
                "Una \"subasta combinatoria\" con múltiples ganadores para el servicio universal.subasta combinatoria",
                "Pausa: una \"subasta combinatoria\" computacionalmente manejable.subasta combinatoria",
                "Hacia una suite de prueba universal para algoritmos de \"subasta combinatoria\".subasta combinatoria"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "coordination": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent <br>coordination</br> problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex <br>coordination</br> constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for <br>coordination</br> but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Algoritmos de licitación para una subasta combinatoria distribuida Benito Mendoza ∗ y Jos´e M. Vidal Informática e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, viDal@sc.edu Resumen Asignación distribuida y \"coordinación multiagente\"Los problemas se pueden resolver a través de subastas combinatorias.coordinación",
                "Nuestros algoritmos han demostrado que es factible implementar las complejas limitaciones de \"coordinación\" respaldadas por subastas combinatorias sin tener que recurrir a un algoritmo de determinación de ganador centralizado.coordinación",
                "Nuestros algoritmos de licitación pueden ser utilizados por cualquier sistema multiagente que utilizaría subastas combinatorias para la \"coordinación\", pero prefiere no implementar un subastador centralizado.8. Coordinación"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "task and resource allocation": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "bidding algorithm": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of <br>bidding algorithm</br>s for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our <br>bidding algorithm</br>s, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our <br>bidding algorithm</br>s can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Hemos desarrollado un par de \"algoritmo de licitación\" para los postores en una subasta de pausa.algoritmo de licitación",
                "En este artículo presentamos nuestros \"algoritmos de licitación\", discutimos sus virtudes y inconvenientes, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo de determinación de ganador centralizado.algoritmo de licitación",
                "Nuestro \"algoritmo de licitación\" puede ser utilizado por cualquier sistema multiagente que utilizaría subastas combinatorias para la coordinación, pero prefiere no implementar un subastador centralizado.8. Algoritmo de licitación"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "revenue-maximizing solution": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the <br>revenue-maximizing solution</br> found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the <br>revenue-maximizing solution</br>, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the <br>revenue-maximizing solution</br> and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the <br>revenue-maximizing solution</br> as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the <br>revenue-maximizing solution</br> when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the <br>revenue-maximizing solution</br>, we realized that they do not always find the same distribution of items as the <br>revenue-maximizing solution</br> (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the <br>revenue-maximizing solution</br> are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the <br>revenue-maximizing solution</br> contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the <br>revenue-maximizing solution</br> requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the <br>revenue-maximizing solution</br> decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the <br>revenue-maximizing solution</br>.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a <br>revenue-maximizing solution</br> found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En este artículo presentamos nuestros algoritmos de licitación, discutimos sus virtudes y inconvenientes, y comparamos las soluciones obtenidas por ellos con la \"solución de maximización de ingresos\" encontrada por un algoritmo de determinación de ganador centralizado.Solución de maximización de ingresos",
                "Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) GenerateValues (i, elementos) 1 para x ∈ Items 2 Do VI (x) = exp (.01) 3 para n ← 1...(Números-Bids-ítems) 4 do S1, S2 ← Dos conjuntos aleatorios de elementos con valores.5 VI (S1 ∪ S2) = VI (S1) + VI (S2) + exp (.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorio.Expd (x) Devuelve un número aleatorio tomado de una distribución exponencial con media 1/x.0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (y-eje), que es el porcentaje de veces que nuestros algoritmos convergen a la \"solución de maximización de ingresos\", como función del número de elementos en la subasta.5. Solución de maximización de ingresos",
                "Prueba y comparación Hemos implementado ambos algoritmos y realizamos una serie de experimentos para determinar cómo su solución se compara con la \"solución de maximización de ingresos\" y cómo sus tiempos se comparan entre sí.Solución de maximización de ingresos",
                "Luego comparamos las soluciones encontradas por ambos con la \"solución de maximización de ingresos\" como se encuentra por CASS cuando se les da un conjunto de ofertas que corresponden a la verdadera valoración de los agentes.Solución de maximización de ingresos",
                "Sin embargo, tenga en cuenta que los ingresos de la subasta de pausa en todas las subastas son siempre más pequeños que los ingresos de la \"solución de maximización de ingresos\" cuando los agentes ofertan sus verdaderas valoraciones.Solución de maximización de ingresos",
                "Cuando comparamos las soluciones de nuestros algoritmos con la \"solución de maximización de ingresos\", nos dimos cuenta de que no siempre encuentran la misma distribución de elementos que la \"solución de maximización de ingresos\" (como se muestra en la Figura 6).Solución de maximización de ingresos",
                "Los casos en que nuestros algoritmos no lograron llegar a la distribución de la \"solución de maximización de ingresos\" son aquellos donde había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos.Solución de maximización de ingresos",
                "Si la \"solución de maximización de ingresos\" contiene la oferta (o ofertas) utilizando esta valoración más alta, entonces es imposible que la subasta de pausa encuentre esta solución porque esa oferta (esas ofertas) nunca se coloca.Solución de maximización de ingresos",
                "Si la \"solución de maximización de ingresos\" requiere que se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se colocará.Solución de maximización de ingresos",
                "También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen a la \"solución de maximización de ingresos\" disminuye a medida que aumenta el número de elementos.Solución de maximización de ingresos"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "combinatorial optimization problem": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a <br>combinatorial optimization problem</br> and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Este problema, conocido como el problema de determinación del ganador, es un \"problema de optimización combinatoria\" y es NP-Hard [10].Problema de optimización combinatoria"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "agent": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no <br>agent</br> can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each <br>agent</br> must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the <br>agent</br> needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each <br>agent</br> also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every <br>agent</br> perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an <br>agent</br> receives a bid from another <br>agent</br> it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every <br>agent</br> (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the <br>agent</br> itself.",
                "Anyone claiming a higher value for some other <br>agent</br> is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each <br>agent</br>. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the <br>agent</br> that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) <br>agent</br> is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the <br>agent</br> is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, <br>agent</br> i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the <br>agent</br> i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the <br>agent</br> and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The <br>agent</br> can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the <br>agent</br> can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the <br>agent</br> currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the <br>agent</br> can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the <br>agent</br> is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an <br>agent</br> has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) <br>agent</br>.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the <br>agent</br> has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the <br>agent</br> has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes <br>agent</br> is utility.",
                "However, <br>agent</br> is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the <br>agent</br> has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the <br>agent</br> has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the <br>agent</br> i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the <br>agent</br> i.",
                "Let S be a set of items for which the <br>agent</br> i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each <br>agent</br> i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the <br>agent</br> i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the <br>agent</br>, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder <br>agent</br> i (line 5); this a bid that the <br>agent</br> is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an <br>agent</br> different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the <br>agent</br> i has for those same items with a bid from <br>agent</br> i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, <br>agent</br> is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the <br>agent</br> i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each <br>agent</br> i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if <br>agent</br> i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each <br>agent</br> calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center <br>agent</br> that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every <br>agent</br> performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Dado que en la ronda final, todos los agentes consideran todos los bidsets posibles, sabemos que el bidset ganador final será uno de los que ningún \"agente\" puede proponer un mejor bidset.agente",
                "Cada \"agente\" debe buscar sobre el espacio de todos los bidsets que contienen al menos una de sus ofertas.agente",
                "La búsqueda se hace más fácil por el hecho de que el \"agente\" debe considerar solo las mejores ofertas actuales y solo quiere bidsets donde su propia utilidad sea más alta que en el binte ganador actual.agente",
                "Cada \"agente\" también tiene un incentivo claro para realizar este cálculo, a saber, su utilidad solo aumenta con cada bidset que propone (por supuesto, podría disminuir con los bidsets que otros proponen).agente",
                "Incluso podemos imaginar completamente eliminar el subastador y, en cambio, hacer que cada \"agente\" realice la tarea del subastador.agente",
                "Es decir, todas las ofertas se transmiten y cuando un \"agente\" recibe una oferta de otro \"agente\", actualiza el conjunto de las mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual.agente",
                "Además, cualquier mentira sobre otras ofertas de agentes se descubre fácilmente realizando un seguimiento de las ofertas enviadas por cada \"agente\" (el conjunto de las mejores ofertas).agente",
                "A saber, el único que puede aumentar el valor de oferta de un agente es el \"agente\" en sí.agente",
                "Cualquier persona que reclame un valor más alto para algún otro \"agente\" está mintiendo.agente",
                "Lo único que falta es un algoritmo que calcula el bidset de maximización de utilidad para cada \"agente\".3. Agente"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "progressive adaptive user selection environment": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (<br>progressive adaptive user selection environment</br>) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La subasta de pausa (\"Entorno de selección de usuario adaptativo progresivo\") [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores.entorno de selección de usuarios adaptativos progresivos"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "branch and bound search": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a <br>branch and bound search</br> completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a <br>branch and bound search</br>. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a <br>branch and bound search</br> on the branch-on-bids tree produced by these bids.",
                "This <br>branch and bound search</br> is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a <br>branch and bound search</br>.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our <br>branch and bound search</br> implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a <br>branch and bound search</br> completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a <br>branch and bound search</br> only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Nuestros algoritmos implementan una estrategia de maximización de la utilidad miope y están garantizados para encontrar el beque que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado.PAUSEBID realiza una \"búsqueda de rama y encuadernación\" completamente desde cero cada vez que se llama.CachedPauseBid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones.694 978-81-904262-7-5 (RPS) C 2007 Ifaamas 2. Búsqueda de rama y encuadernación",
                "Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 695 pausebid (i, k) 1 my-bids ← ∅ 2 sus-bids ← ∅ 3 para b ∈ B 4 do si bagent = i o vi (bitems)> bvalue 5luego my-bids ← my-bids +nueva oferta (bitems, i, vi (bitems)) 6 más sus-bids ← sus-bids +b 7 para s ∈ Subsets de k o menos elementos tal que vi (s)> 0y ¬∃b∈Bbitems = s 8 do my-bids ← my-bids + new bid (s, i, vi (s)) 9 ofertas ← my-bids + sus-bids 10 g ∗ ← ∅ £ Variable global 11 u∗ ← ui (w) £ variable global 12 pbsearch (ofertas, ∅) 13 excedente ← b∈G ∗ |bagent = i bvalue-b (bitems) 14 si excedente = 0 15 entonces regrese g ∗ 16 my-payment ← vi (g ∗)-u ∗ 17 para b ∈ G ∗ |bagent = i 18 do si mi pago ≤ 0 19 entonces bvalue ← b (bitems) 20 más bvalue ← b (bitems) + my-pago · bvalue −b (bitems) excedente 21 retorno g ∗ Figura 1: el algoritmo de pausa queImplementa una \"búsqueda de rama y encuadernación\".I es el agente y k es la etapa actual de la subasta, para k ≥ 2. El agente puede dominar, comenzamos por definir los my-bids para ser la lista de ofertas para las cuales la valoración de los agentes es más alta que la mejor oferta actual,como se da en B. Rama y Búsqueda de Bound",
                "El agente ahora puede realizar una \"búsqueda de rama y encuadernación\" en el árbol de ramas en las ganancias producidas por estas ofertas.Búsqueda de rama y encuadernación",
                "PBSearch (Figura 2) implementa esta \"Rama y Bido Bound\".Búsqueda de rama y encuadernación",
                "Hemos elegido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de elementos.Pausebid supone que el conjunto de las mejores ofertas B y el mejor bidset ganador actual W permanece constante durante su ejecución, y devuelve los agentes miopes de utilidad miope Bidset (si hay una) usando una \"búsqueda de rama y unión\".Búsqueda de rama y encuadernación",
                "El procedimiento recursivo CPBSearch, llamado en la línea 25 de CachedPauseBid y que se muestra en la Figura 4, es el que encuentra el nuevo GS.CPBSearch es una versión ligeramente modificada de nuestra \"Búsqueda de rama y límite\" implementada en PBSearch.Búsqueda de rama y encuadernación",
                "Como es un problema difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa.PAUSEBID realiza una \"búsqueda de rama y unida\" completamente desde cero cada vez que se invoca.CachedPauseBid Caches soluciones parciales y realiza una \"búsqueda de rama y unida\" solo en las pocas porciones afectadas por los cambios en las ofertas entre tiempos consecutivos.CachedPauseBid tiene un mejor rendimiento, ya que explora menos nodos (menos de la mitad) y es más rápido.Búsqueda de rama y encuadernación"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "pause auction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The <br>pause auction</br> is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a <br>pause auction</br>.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a <br>pause auction</br> to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE <br>pause auction</br> A <br>pause auction</br> for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a <br>pause auction</br> is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The <br>pause auction</br> makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the <br>pause auction</br> has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the <br>pause auction</br> is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the <br>pause auction</br>, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the <br>pause auction</br>.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the <br>pause auction</br> we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the <br>pause auction</br> on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the <br>pause auction</br> to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the <br>pause auction</br> is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the <br>pause auction</br>. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The <br>pause auction</br> is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a <br>pause auction</br>.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a <br>pause auction</br> is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the <br>pause auction</br>, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La \"subasta de pausa\" es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible deshacerse del subastador).subasta de pausa",
                "Hemos desarrollado un par de algoritmos de licitación para los postores en una \"subasta de pausa\".subasta de pausa",
                "En este artículo presentamos dos algoritmos, Pausebid y CachedPauseBid, que permiten a los agentes en una \"subasta de pausa\" para encontrar el bido que maximiza su utilidad.subasta de pausa",
                "La \"subasta de pausa\" una \"subasta de pausa\" para M items tiene m etapas.subasta de pausa",
                "Sin embargo, queda la pregunta abierta de si la distribución final de los elementos a los postores que se encuentran en una \"subasta de pausa\" es la misma que la solución de maximización de ingresos.subasta de pausa",
                "La \"subasta de pausa\" hace que el trabajo del subastador sea muy fácil.subasta de pausa",
                "Finalmente, se ha demostrado que la \"subasta de pausa\" es libre de envidia, ya que al final de la subasta, ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2].subasta de pausa",
                "El objetivo de los agentes de licitación en la \"subasta de pausa\" es maximizar su utilidad, sujeto a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total al menos más grande que los ingresos actuales, donde está el incremento más pequeño permitido enla subasta.subasta de pausa",
                "Algoritmos de licitación De acuerdo con la \"subasta de pausa\", durante la primera etapa solo tenemos varias subastas en inglés, y los postores presentan ofertas en artículos individuales.subasta de pausa",
                "Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores.4.2 El algoritmo CachedPauseBid El algoritmo CachedPauseBid (que se muestra en la Figura 3) es nuestro segundo enfoque para resolver el problema de licitación en la \"subasta de pausa\".subasta de pausa"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "search tree": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large <br>search tree</br>.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the <br>search tree</br>.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the <br>search tree</br>.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the <br>search tree</br>.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Sin embargo, este enfoque es computacionalmente costoso ya que produce un gran \"árbol de búsqueda\".árbol de búsqueda",
                "Nuestros algoritmos representan enfoques alternativos para superar esta costosa búsqueda.4.1 El algoritmo de pausa en el algoritmo de pausa (que se muestra en la Figura 1) implementamos algunas heurísticas para podar el \"árbol de búsqueda\".árbol de búsqueda",
                "Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del \"árbol de búsqueda\".árbol de búsqueda",
                "La escalabilidad de nuestros algoritmos se puede determinar contando el número de nodos expandidos en el \"Árbol de búsqueda\".árbol de búsqueda"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "branch-on-bid tree": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        }
    }
}