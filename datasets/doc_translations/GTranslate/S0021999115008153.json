{
    "original_text": "As discussed above, proper inclusion of these interactions requires segment synchronization after every iteration. In order to minimize simulation errors due to incorrect values of the interactions potential, segments are synchronized after every iteration. Although relatively long communication times between remote processors may hinder this process in typical parallel computers, this is not the case for GPGPU architectures. Still, full recalculation of the interaction potential after each iteration is time consuming. Instead, the algorithm corrects the current potential by adding dipole contributions for every nearby charge that hopped during the previous iteration. Full updates of the interaction potential are only required for the grid points that are related to charges that hopped during the last iteration. Accumulative rounding errors that arise due to repetitive addition and subtraction are solve this by rounding all interaction potentials to a uniformly spaced range of floating point numbers.",
    "original_translation": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
    "error_count": 0,
    "keys": {
        "adding dipole contributions": {
            "translated_key": "agregar contribuciones dipolo",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al \"agregar contribuciones dipolo\" para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "algorithm": {
            "translated_key": "algoritmo",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el \"algoritmo\" corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "corrects the current potential": {
            "translated_key": "corrige el potencial actual",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo \"corrige el potencial actual\" al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "GPGPU architectures": {
            "translated_key": "arquitecturas GPGPU",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las \"arquitecturas GPGPU\".Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "interaction potential": {
            "translated_key": "potencial de interacción",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del \"potencial de interacción\" después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del \"potencial de interacción\" solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los \"potencial de interacción\" s a un rango uniformemente espaciado de números de puntos flotantes.",
            "errors": ""
        },
        "minimize simulation errors": {
            "translated_key": "minimizar los errores de simulación",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para \"minimizar los errores de simulación\" debido a los valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "parallel computers": {
            "translated_key": "computadoras paralelas",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las \"computadoras paralelas\" típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "processors": {
            "translated_key": "procesadores",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre \"procesadores\" remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "proper inclusion of these interactions": {
            "translated_key": "inclusión adecuada de estas interacciones",
            "translated_annotated_text": "Como se discutió anteriormente, la \"inclusión adecuada de estas interacciones\" requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "recalculation of the interaction potential": {
            "translated_key": "recalculación completo del potencial de interacción",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, el \"recalculación completo del potencial de interacción\" después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "segments are synchronized after every iteration": {
            "translated_key": "segmentos se sincronizan después de cada iteración",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere sincronización del segmento después de cada iteración.Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los \"segmentos se sincronizan después de cada iteración\".Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        },
        "segment synchronization after every iteration": {
            "translated_key": "sincronización del segmento después de cada iteración",
            "translated_annotated_text": "Como se discutió anteriormente, la inclusión adecuada de estas interacciones requiere \"sincronización del segmento después de cada iteración\".Para minimizar los errores de simulación debido a valores incorrectos del potencial de interacciones, los segmentos se sincronizan después de cada iteración.Aunque los tiempos de comunicación relativamente largos entre procesadores remotos pueden obstaculizar este proceso en las computadoras paralelas típicas, este no es el caso de las arquitecturas GPGPU.Aún así, la recalculación total del potencial de interacción después de cada iteración lleva mucho tiempo.En cambio, el algoritmo corrige el potencial actual al agregar contribuciones dipolares para cada carga cercana que saltó durante la iteración anterior.Las actualizaciones completas del potencial de interacción solo se requieren para los puntos de la cuadrícula que están relacionados con las cargas que saltaron durante la última iteración.Los errores acumulativos de redondeo que surgen debido a la adición repetitiva y la resta resuelven esto al redondear todos los potenciales de interacción a un rango de puntos de punto flotante uniformemente espaciado.",
            "errors": ""
        }
    }
}