{
    "id": "I-45",
    "original_text": "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust. Instead, messages are provided as a primitive building block. In this paper we consider one approach for modelling agent interactions: the commitment machines framework. This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions. We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages. The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1. INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems. Consequently, design and implementation of agent interaction is an important research topic. The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML. It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents. Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility). On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust. Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2]. There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11]. However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions. Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages. Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction. This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation. The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic. This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19]. In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN. We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this. We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2. BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches. A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state. This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional. A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p). This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question. For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid). A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true. For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid). The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time. For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true. In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14]. In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q). An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists. A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state. A final state is one that has no base-level commitments. One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM. For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt. The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made. As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans. Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances. One of these is chosen and is executed. We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL). This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16]. Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs. An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body. The plan body is built up from the following constructs. We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e). These can be sequenced (P; P). C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2. This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16]. The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set. In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}). More sophisticated belief management methods may be used, but are not considered here. We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention). We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ. Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q). The global message queue is a sequence of triplets of the form sender:recipient:message. A transition S0 −→ S1 specifies that executing S0 a single step yields S1. We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration. The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion. Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans. This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3. IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role). We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act. In section 4 we relax these assumptions. Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X. For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to. Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m). Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled. Handling the event involves sending a message to the other agent, and then doing nothing until a response is received. C: ı : true ← +accept; ↑sendAccept. M: ↓sendAccept : true ← +accept; ı. If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4). For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓sendReceipt : pay ← +receipt; ı. C: ↓sendReceipt : ¬pay ← . . . report error . . . . In addition to these plans, we also need plans to start and finish the interaction. An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . . An interaction is started by setting up an agents initial beliefs, and then having it begin to interact. Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file. A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction. Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı. Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol. For conciseness the error reporting plans are omitted. We now turn to refining the context conditions. There are three refinements that we consider. Firstly, we need to prevent performing actions that have no effect on the interaction state. Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold. For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property. Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely. For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action. For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO. For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı. Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı. Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı. Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4). When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions. One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans. This is clearly safe, since actions are not prevented, just considered in a different order. The third refinement of context conditions concerns the plans that terminate the interaction. In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue). However, only some of these final states are desirable final states. Which final states are considered to be desirable depends on the domain and the desired interaction outcome. In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt). In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done. Figure 4 shows the plans that are changed from figure 3. In order to support the realisation of CMs, we need to change SAAPL in a number of ways. These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive. We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language. The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO. Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt. Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics. Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g. Jason, 3APL, CAN). However, other agent platforms do require an extension. For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested. In the case of 3APL no change is needed to support this. Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15]. In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions. For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true. Similar rules apply for conditional commitments. These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5. The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules. For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact). The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2. To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)). B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added. Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments. The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5. For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment. One aspect that doesnt require a change is linking commitments and actions. This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments. Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 . In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator. There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done. One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages. In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event. However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6]. Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event. One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once. In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4. BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7]. In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption! For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept). The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act! Figure 7 shows the FSM for NetBill with alternating initiative. A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment. A general solution is to track whose turn it is to act. This can be done by working out which agents have actions that are able to be performed in the current state. If there is only a single active agent, then it is clearly that agents turn to act. However, if more than one agent is active then somehow the agents need to work out who should act next. Working this out by negotiation is not a particularly good solution for two reasons. Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this. Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule. It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts. An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section. The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states. This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM. The two specific issues that need to be addressed are: 1. Can agents end up in different final states? 2. Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message? We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions). By actions commute we mean that the state resulting from performing a sequence of actions A1 . . . An is the same, regardless of the order in which the actions are performed. This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions. This addresses the issue of ending up in different final states. We return to the possibility of errors occurring shortly. Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments. A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]). This assumes that both actions can be performed. However, it is possible for the performance of A1 to disable A2 from being done. For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order. We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false. Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ). This is because only P is used to determine whether another agent is able to perform the action. Thus monotonic CMs with preconditions that do not contain negations have actions that commute. However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic. If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic. Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic. Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state. Furthermore, no errors can occur. Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order. The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions. Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B. Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic. Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B. Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C? Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 . From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done. This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute). This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster. This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical. Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı. One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact. However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions. Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5. DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic. The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language. As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions. We have already discussed STAPLE [9, 10]. Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2]. Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3]. However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed. Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.) TCP. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation. However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents. Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself. Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation. Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated. Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed. Finally, there is a need to perform empirical evaluation. There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4]. It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6. REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors. Multi-Agent Programming: Languages, Platforms and Applications. Springer, 2005. [2] C. Cheong and M. Winikoff. Hermes: Designing goal-oriented agent interactions. In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff. Hermes: Implementing goal-oriented agent interactions. In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff. Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches. Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque. Teamwork. Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum. Communication for goal directed agents. In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk. Towards a testbed for multi-party dialogues. In Advances in Agent Communication, pages 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores. Using a performative subsumption lattice to support commitment-based conversations. In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121. ACM Press, 2005. [9] S. Kumar and P. R. Cohen. STAPLE: An agent programming language based on the joint intention theory. In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391. ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen. Representing and executing protocols as joint actions. In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002. ACM Press. [11] M. Tambe and W. Zhang. Towards flexible teamwork in persistent teams: Extended report. Journal of Autonomous Agents and Multi-agent Systems, 2000. Special issue on Best of ICMAS 98. [12] M. Winikoff. An AgentSpeak meta-interpreter and its applications. In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff. Designing commitment-based agent interactions. In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff. Implementing flexible and robust agent interactions using distributed commitment machines. Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland. Enhancing commitment machines. In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah. Declarative & procedural goals in intelligent agent systems. In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum. Towards design tools for protocol development. In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105. ACM Press, 2005. [18] P. Yolum and M. P. Singh. Flexible protocol specification and execution: Applying event calculus planning using commitments. In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh. Reasoning about commitments in the event calculus: An approach for specifying and executing protocols. Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)",
    "original_translation": "Implementación de interacciones basadas en el compromiso ∗ Michael Winikoff School of Computer Science y la universidad de TI Melbourne, Australia Michael.winikoff@rmit.edu.au Resumen Aunque la interacción de los agentes juega un papel vital en MAS, y los enfoques mensajeros para la interacción de los agentes tienen sus inconvenientes, presente presenteLos lenguajes de programación orientados al agente no brindan soporte para implementar la interacción del agente que sea flexible y robusto. En su lugar, los mensajes se proporcionan como un bloque de construcción primitiva. En este artículo consideramos un enfoque para las interacciones de modelado de agentes: el marco de máquinas de compromiso. Este marco apoya las interacciones de modelado en un nivel superior (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo se pueden implementar interacciones basadas en compromiso en los lenguajes de programación orientados a agentes convencionales. Las contribuciones de este documento son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI;extensiones a la semántica de los lenguajes de programación BDI;y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de giro y condiciones de carrera) y soluciones a estos problemas. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: sistemas artificiales de inteligencia artificiales distribuidos;I.2.5 [Inteligencia artificial]: lenguajes de programación y software Términos generales Diseño 1. Los agentes de introducción son sociales, y la interacción de agentes juega un papel vital en los sistemas multiagentes. En consecuencia, el diseño y la implementación de la interacción del agente es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agente es MessageCentric: las interacciones se definen mediante protocolos de interacción que proporcionan las secuencias permitidas de mensajes, especificadas utilizando anotaciones como máquinas de estado finitas, redes de Petri o agente UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es una buena coincidencia para los agentes inteligentes. Los agentes inteligentes deben exhibir la capacidad de persistir en lograr sus objetivos frente al fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitada: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de interacciones se limita a aquellas opciones que proporcionó el diseñador de protocolos, y en la práctica, un diseño centrado en el mensajeLos procesos no tienden a conducir a protocolos que son flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones de agentes, se han propuesto varios enfoques en los últimos años que se alejan de los protocolos de interacción centrados en el mensaje y, en su lugar, consideran diseñar interacciones de agentes utilizando conceptos de nivel superior como los compromisos sociales [8,10, 18] o objetivos de interacción [2]. También ha habido trabajo en formas de interacción más ricas en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo para diseñar interacciones de agentes flexibles y robustos, prácticamente no ha habido trabajo para proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados al agente actual (AOPLS) no brindan soporte para implementar interacciones de agente flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los AOPL modernos [1], prácticamente sin excepciones, proporcionan solo el envío simple de mensajes como base para implementar la interacción del agente. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que admite la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer idioma de este tipo, se propuso un elemento básico, hace unos años [9], pero no se describe en detalle, y podría decirse que no es práctico para el uso de los no especialistas, debido a su base lógica y una gran dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender las AOPL similares a BDI para admitir la implementación directa de las interacciones de los agentes que están diseñadas con el marco de la máquina de compromiso Yolum & Singhs (CM) [19]. En el resto de este documento, revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de BDI aopls que se encuentra en el subconjunto común de idiomas como Jason, 3APL y Can. Luego presentamos un esquema para traducir máquinas de compromiso a este idioma e indicamos cómo el idioma debe extenderse para respaldar esto. Luego ampliamos nuestro esquema para abordar una variedad de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera.2. Antecedentes 2.1 Máquinas de compromiso El objetivo del marco de la máquina de compromiso es permitir la definición de interacciones que son más flexibles que los enfoques tradicionales centrados en los mensajes. Una máquina de compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de interacción. Este estado de interactuar consiste en fluentes (predica que cambian el valor con el tiempo), pero también los compromisos sociales, tanto a nivel de base como condicional. Un compromiso social a nivel base es una empresa por parte del deudor A al acreedor B para lograr la condición P, denotó C (A, B, P). Esto a veces se abrevia a C (P), donde no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del Cliente C con el comerciante M para hacer que el pago con fluidez sea verdadero se escribiría como C (C, M, pagado). Un compromiso social condicional es una empresa por parte del deudor A al acreedor B que debería condicionar Q se hace realidad, y luego se comprometerá a lograr la condición p.Esto se denota por CC (A, B, Q, P), y, donde la identidad de las entidades involucradas no es importante (u obvio), se abrevia a CC (Q P) donde la flecha es un recordatorio del vínculo causal entre Qconvertirse en verdad y la creación de un compromiso para hacer que P sea verdad. Por ejemplo, un compromiso de hacer que el pago sea verdadero con fluidez una vez que se hayan recibido bienes se escribieran CC (bienes pagados). La semántica de los compromisos (tanto a nivel de base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C (P) (o CC (Q P)) se descarga cuando P se vuelve verdadero;y el compromiso CC (Q P) es reemplazado por C (P) cuando Q se hace realidad. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformalizada por [14]. En resumen, estas semánticas se ocupan de una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se mantienen: si P se mantiene cuando CC (P Q) está destinado a ser creado, entonces se crea C (Q) en lugar de CC (p q). Se define una interacción especificando las entidades involucradas, el posible contenido del estado de interacción (tanto fluidos como compromisos) y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y los efectos de cada acción, especificadas como ADD yEliminar listas. Una máquina de compromiso (CM) define un rango de posibles interacciones que cada uno comienza en algún estado1 y realiza acciones hasta alcanzar un estado final. Un estado final es uno que no tiene compromisos de nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estado finito correspondiente al CM. Por ejemplo, la Figura 1 proporciona el FSM2 correspondiente a la máquina de compromiso de NetBill [18]: un CM simple donde un cliente (c) y comerciante (M) intentan comerciar utilizando las siguientes acciones3: 1 A diferencia de los protocolos de interacción estándar o las máquinas de estado finitas, no hay un estado inicial designado para la interacción.2 La máquina de estado finito está generada por software: los nodos y las conexiones se calcularon mediante una implementación de los axiomas (disponibles en http://www.winikoff.net/cm) y luego fueron presentados por GraphViz (http: // www.GraphViz.org/).3 Usamos la notación A (x): p ⇒ e para indicar que la acción A es realizada por Entity X, tiene condición previa p (con: P omitida si está vacía) y efecto E. • SendRequest (c) ⇒ Solicitud • SendQuote (M) ⇒ Oferta donde oferta ≡ prometygoods ∧ promisereceipt y promesagoods ≡ cc (m, c, acepta, bienes) y promisereceipt ≡ cc (m, c, pay, recibo) • Sendacept (c) ⇒ Aceptar donde acepte ≡ Cc (C, M, bienes, pagos) • SendGoods (M) ⇒ Promisereceipt ∧ Bienes donde Promisereceipt ≡ CC (M, C, Pay, Recibo) • SendEpo (C): Bienes ⇒ PAGO • SendReceipt (M): Pague ⇒ Recibo. El compromiso de aceptar es que los clientes prometen pagar una vez que se han enviado los bienes, prometen los comerciantes que prometen enviar los bienes una vez que el cliente acepta, y Promisereceipt es la promesa de los comerciantes de enviar un recibo una vez que se ha realizado el pago. Como se ve en la Figura 1, las máquinas de compromiso pueden soportar una gama de secuencias de interacción.2.2 Un agente abstracto Programing Language Agent Langua de programación en la tradición BDI (por ejemplo, DMARS, JAM, PRS, UM-PRS, Jack, AgentsPeak (L), Jason, 3APL, Can, Jadex) definen el comportamiento del agente en términos de planes activados por eventos,Cuando cada plan especifica por qué se desencadena, bajo qué situaciones se puede considerar aplicable (definida utilizando una llamada condición de contexto) y un cuerpo del plan: una secuencia de pasos que puede incluir eventos de publicación que a su vez desencadena aún másplanes. Dada una colección de planes y un evento E que se ha publicado, el agente primero recopila todos los tipos de planes que se desencadenan por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de estos es elegido y se ejecuta. Ahora definimos brevemente la sintaxis formal y la semántica de un lenguaje de programación de agente resumen simple (BDI) (SAAPL). Este idioma está destinado a ser una abstracción que se encuentra en el subconjunto común de idiomas como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y Can [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete a un mecanismo particular para tratar con la falla del plan, ya que diferentes AOPL utilizan diferentes mecanismos. Un programa de agente (denotado por π) consiste en una colección de cláusulas de plan de la Forma E: C ← P donde E es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan está construido a partir de las siguientes construcciones. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente n (↑ n m) y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). C :: = b |C ∧ C |C ∨ C |¬C |∃x.c p :: = |+B |−B |E |↑ n m |PAG;P Se da semántica formal para este idioma en la Figura 2. Esta semántica se basa en la semántica para AgentsPeak dada por [12], que a su vez se basa en la semántica para la lata [16]. La semántica está al estilo de la semántica operacional estructural de Plotkins, y supone que existen operaciones que verifican si una condición 4 usamos ↓ n m como mano corta para el evento correspondiente a recibir el mensaje M del agente N. 874 el sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) Figura 1: Máquina de estado finito para NetBill (sombreado = estados finales) se deduce de un conjunto de creencias, que agrega una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias son un conjunto de átomos terrestres, estas operaciones son respectivamente verificación de consecuencia (b | = c), y establecer adición (b ∪ {b}) y deleción (b \\ {b}). Se pueden usar métodos de gestión de creencias más sofisticados, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia 5 donde los mensajes se agregan en un extremo y se eliminan del otro extremo), n es el nombre del agente, B es las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde, en lugar de un solo plan de plan, hay un conjunto de instancias de plan, γ. Finalmente, un MAS completo es un par Q, a partir de una cola de mensajes global y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de trillizos del remitente de formulario: destinatario: mensaje. Una transición S0 - → S1 especifica que la ejecución de S0 un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración MAS. La relación de transición se define utilizando reglas de la forma S - → S o de la forma S - → Sr S - → Sr;Estos últimos son condicionales con la parte superior (numerador) que es la premisa y la parte inferior (denominador) es la conclusión. Tenga en cuenta que no hay determinismo en SAAPL, p.La elección del plan para ejecutar desde un conjunto de planes aplicables. Esto se resuelve mediante el uso de funciones de selección: por lo que selecciona una de las instancias del plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias del plan que se puede ejecutar deben ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación..3. Implementación de interacciones basadas en compromiso en esta sección Presentamos una asignación de una máquina de compromiso a una colección de programas SAAPL (una para cada rol). Comenzamos considerando el caso simple de dos agentes que interactúan, y 5 el operador + se usa para denotar la concatenación de secuencia.Suponga que los agentes se turnan para actuar. En la Sección 4 relajamos estos supuestos. Cada acción a (x): p ⇒ e se asigna a varios planes: hay un plan (para el agente x) con la condición de contexto P que realiza la acción (es decir, aplica los efectos e a las creencias de los agentes) y envía un mensajeal otro agente y un plan (para el otro agente) que actualiza su estado cuando se recibe un mensaje de X. Por ejemplo, dada la acción sendacept (c) ⇒ Aceptar, tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Tenga en cuenta que cuando la identificación del remitente (respectivamente destinatario) es obvia, es decir, el otro agente, abreviamos ↑ n m a ↑ m (resp. ↓ n m a ↓ m). La toma de turnos se captura a través del evento ı (abreviatura de Interact): el agente que está activo tiene un evento que se está manejando. Manejar el evento implica enviar un mensaje al otro agente, y luego no hacer nada hasta que se reciba una respuesta. C: ı: verdadero ← +Aceptar;↑ sendaccept. M: ↓ Sendaccept: verdadero ← +Aceptar;i. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el destinatario: uno para realizar la acción (si es posible), y otro para informar un error si la condición previa de las acciones no se mantiene (volvemos a esto en la Sección 4). Por ejemplo, la acción sendReceipt (m): paga ⇒ recibo genera los siguientes planes: m: ı: paga ← +recibo;↑ sendReceipt. C: ↓ SendReceipt: PAGO ← +recibo;i. C: ↓ SendReceipt: ¬Pay ←...Error de informe.... Además de estos planes, también necesitamos planes para comenzar y terminar la interacción. Se puede completar una interacción siempre que no haya compromisos de nivel base, por lo que ambos agentes tienen los siguientes planes: ı: ¬∃p.c (p) ← ↑ Hecho.↓ Hecho: ¬∃p.c (P) ←.↓ Hecho: ∃p.c (P) ←...Error de informe.... Se inicia una interacción estableciendo creencias iniciales de los agentes y luego hacer que comience a interactuar. Exactamente cómo hacer esto depende de la plataforma de agente: p.La plataforma de agente en cuestión puede ofrecer una forma simple de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes init, cada uno del sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 875 Q, N, B, +B Basic-→ Q, N, B ∪ {B}, Q, N, B, −B Básico-→ Q, N, B\\ {b}, Δ = {piθ | (ti: ci ← pi) ∈ π ∧ tiθ = e ∧ b | = ciθ} q, n, b, e básico - → q, n, b, so (Δ) q, N, B, P1 Básico - → Q, N, B, P Q, N, B, P1;P2 Básico - → Q, N, B, P;P2 Q, N, B ,;P BASIC - → Q, N, B, P Q, N, B, ↑ NB M BASIC - → Q + N: NB: M, N, B, Q = Na: N: M + Q Q, N, B, γ Agente- → q, n, b, γ ∪ {↓ na m} p = si (γ) q, n, b, p básico - → q, n, b, p q, n, b, agente γ - → q, n, B, (γ \\ {p}) ∪ {p} p = si (γ) p = q, n, b, γ agente - → q, n, b, (γ \\ {p}) n, b, γ= Sa (as) q, n, b, agente γ - → q, n, b, γ q, como mas - → q, (como ∪ {n, b, γ}) \\ {n, b, γ} figura2: Semántica operativa para SAAPL que contiene una creencia a agregar;y luego envíe a uno de los agentes un mensaje de inicio que comienza la interacción. Por lo tanto, ambos agentes tienen los siguientes dos planes: ↓ Init (b): Verdadero ← +b.↓ Inicio: Verdadero ← ı. La Figura 3 ofrece los programas SAAPL tanto para comerciante como para el cliente que implementan el protocolo NetBill. Para la concisión se omiten los planes de informes de errores. Ahora recurrimos a refinar las condiciones de contexto. Hay tres refinamientos que consideramos. En primer lugar, necesitamos evitar realizar acciones que no tengan ningún efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben realizarse a menos que se mantengan condiciones adicionales. Por ejemplo, es posible que el cliente no desee aceptar la oferta de los comerciantes a menos que los bienes tengan un cierto precio o propiedad. En tercer lugar, las condiciones de contexto de los planes que terminan la interacción deben refinarse para evitar terminar la interacción prematuramente. Para cada plan de la forma ı: P ← +E;↑ m Reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P es cualquier condición adicional que el agente desea imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (suponiendo que no hay condiciones adicionales, es decir, no P): ı: bienes ∧ ¬ PAY ← +PAGO;↑ sendepo. Para cada plan de la forma ↓ M: P ← +E;Podríamos agregar ¬E a la condición previa, pero esto es redundante, ya que el artista de la acción ya lo verifica, y si la acción no tiene efecto, entonces los clientes planes: ı: verdadero ← +solicitud;↑ sendRequest.ı: Verdadero ← +Aceptar;↑ sendaccept.ı: bienes ← +pago;↑ sendepo.↓ SendQuote: Verdadero ← +PromiseGoods;+Promisereceipt;i.↓ SendGoods: True ← +Promisereceipt;+bienes;i.↓ SendReceipt: Pay ← +recibo;i. Planes de comerciantes: ı: Verdadero ← +promesagoods;+Promisereceipt;↑ sendQuote.ı: Verdadero ← +Promisereceipt;+bienes;↑ sendgoods.ı: Pague ← +recibo;↑ sendReceipt.↓ sendRequest: verdadero ← +solicitud;i.↓ Sendaccept: verdadero ← +Aceptar;i.↓ SendEpo: bienes ← +PAGO;i. Planes compartidos (es decir, planes de ambos agentes): ı: ¬∃p.c (p) ← ↑ Hecho.↓ Hecho: ¬∃p.c (P) ←.↓ Init (B): Verdadero ← +b.↓ Inicio: Verdadero ← ı. Donde acepte ≡ CC (Page de bienes) PromiseGoods ≡ CC (Aceptar bienes) Promisereceipt ≡ CC (Recibo de pago) Oferta ≡ PromiseDgoods ∧ Promisereceipt Figura 3: Implementación de SAAPL de NetBill El remitente no lo realizará y enviará el mensaje (ver también la discusión en la sección4). Al especificar las condiciones adicionales (P), se debe tener cuidado para evitar situaciones en las que no se pueden realizar el progreso porque las únicas acciones posibles se evitan por condiciones adicionales. Una forma de indicar la preferencia entre las acciones (en muchas plataformas de agentes) es reordenar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se evitan, solo se consideran en un orden diferente. El tercer refinamiento de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la máquina de compromiso, cualquier estado que no tenga ningún compromiso de nivel base es final, ya que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Que los estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es uno en el que los bienes han sido enviados y pagados, y un recibo emitido (es decir, bienes ∧ ∧ ∧ recibo). Para evitar que un agente termine la interacción demasiado temprano, agregamos esto como una condición previa al plan de terminación: ı: bienes ∧ paga ∧ recibo ∧ ¬∃p.c (p) ← ↑ ↑ Hecho. La Figura 4 muestra los planes que se cambian de la Figura 3. Para apoyar la realización de CMS, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se analizan a continuación, se pueden aplicar a los idiomas BDI existentes para que la máquina de compromiso sea de apoyo. Presentamos los tres cambios, explicamos en qué implican y para cada cambio explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado al agente 3APL. Los tres cambios son: 1. Extender las creencias del agente para que puedan contener compromisos;876 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) Planes de clientes: ı: ¬ Request ← +solicitud;↑ sendRequest.ı: ¬acept ← +aceptar;↑ sendaccept.ı: bienes ∧ ¬Pay ← +PAGO;↑ sendepo. Planes de comerciantes: ı: ¬offer ← +PromiseGoods;+Promisereceipt;↑ sendQuote.ı: ¬ (Promisereceipt ∧ bienes) ← +Promisereceipt;+bienes;↑ sendgoods.ı: paga ∧ ¬Receipt ← +recibo;↑ sendReceipt. Donde acepte ≡ CC (Page de bienes) PromiseGoods ≡ CC (Aceptar bienes) Promisereceipt ≡ CC (Recibo de pago) Oferta ≡ PromiseDgoods ∧ Promisereceipt Figura 4: Implementación de SAAPL de Netbill con condiciones de contexto refinadas (solo planes modificados) 2. Cambiar la definición de |= abarcar compromisos implícitos;y 3. Cada vez que se agrega una creencia, actualizando los compromisos existentes, de acuerdo con las reglas de dinámica de compromiso. Extender la noción de creencias para abarcar compromisos de hecho no requiere cambios en las plataformas de agentes que sean como un prólogo y de apoyo a los términos como creencias (p. Jason, 3APL, Can). Sin embargo, otras plataformas de agentes requieren una extensión. Por ejemplo, Jack, que es una extensión de Java, requeriría cambios para apoyar los compromisos que pueden anidarse. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cada vez que una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita por las creencias de los agentes (b | = c) debe tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar un compromiso para seguir un conjunto de creencias B si el compromiso está en el conjunto de creencias (c ∈ B), pero también en otras condiciones. Por ejemplo, se puede considerar que un compromiso de pagar C (pago) está implícito en un conjunto de creencias que contiene el pago porque el compromiso puede haber mantenido y dado de alta cuando el pago se hizo cierto. Reglas similares se aplican para los compromisos condicionales. Estas reglas, que se introdujeron en [15], se reformalizaron posteriormente en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la Figura 5. El cambio que debe hacerse a SAAPL para admitir implementaciones de la máquina de compromiso es extender la definición de | = para incluir estas cuatro reglas. Para 3APL, esto se realizó al hacer que cada agente incluya las siguientes cláusulas de Prolog: Holds (x):- cláusula (x, verdadero).Holds (C (P)):- Holds (P).Holds (c (p)):- cláusula (cc (q, p), verdadero), Holds (Q).Holds (CC (_, Q)):- Holds (Q).Holds (CC (_, Q)):- Holds (C (Q)). La primera cláusula simplemente dice que cualquier cosa se mantiene si es en las creencias de los agentes (cláusula (x, verdadera) es verdadero si x es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para usar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, CC (M, C, Pay, Recibo) escribamos Holds (CC (M, C, Pay, Recibo)). B = norma (b ∪ {b}) q, n, b, +b - → q, n, b, norma de función (b) b ← b para cada b ∈ B do si b = c (p) ∧ b |= p entonces b ← b \\ {b} elseif b = cc (p q) entonces si b | = q entonces b ← b \\ {b} elseif b | = p entonces b ← (b \\ {b}) ∪ ∪ {c (q)} elseif b | = c (q) entonces b ← b \\ {b} endif endif endfor return b Función final b | = P b | = c (p) c1 cc (q p) ∈ B b | = q b | = p c2B | = CC (P Q) B | = Q CC1 B | = C (Q) B | = CC (P Q) CC2 Figura 5: Nuevo semántico operativo El cambio final es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias para que aplique un algoritmo para actualizar los compromisos. La regla y el algoritmo modificados (que refleja la definición de norma en [14]) se puede encontrar en la parte superior de la Figura 5. Para 3APL, este cambio final se logró insertando manualmente la actualización () después de actualizar las creencias y definiendo las siguientes reglas para actualizar (): update () <- c (p) y posee (p) |{Deletec (p);update ()}, update () <- cc (p, q) y retiene (q) |{Deletecc (p, q);update ()}, update () <- cc (p, q) y retiene (p) |{Deletecc (p, q);AddC (q);update ()}, update () <- cc (p, q) y retiene (c (q)) |{Deletecc (p, q);update ()}, update () <- true |Omita donde Deletec y DeletecC eliminen respectivamente un compromiso de nivel base y condicional, y ADDC agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan las acciones directamente: pueden desencadenar acciones indirectamente, pero en general su efecto es evitar la finalización de una interacción mientras hay compromisos sobresalientes (nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso de NetBill6. Para ilustrar las diferentes interacciones posibles, el código se modificó para que cada agente seleccionado al azar de las acciones que podía realizar, y se realizaron varias ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostrados, 6 código fuente están disponibles en http://www.winikoff.net/cm el sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 877 Figura 6: La muestra se ejecuta desde la implementación de 3APL (giros alternos), incluida la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego realizado. Una diferencia menor entre la implementación 3APL y SAAPL se refiere a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPL), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que se recibió el mensaje [6]. Por lo tanto, en la implementación de 3APL tenemos reglas PG desencadenadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que debemos asegurarnos de que la creencia en cuestión se elimine una vez que se maneja, o que modificamos condiciones previas de planes para evitar manejarla más de una vez. En nuestra implementación, eliminamos estas creencias recibidas cuando se manejan, para evitar el manejo duplicado de los mensajes.4. Más allá de dos participantes que se generalizaran a más de dos participantes de interacción requieren revisar cómo se realiza la gestión de turnos, ya que ya no es posible asumir giros alternos [7]. De hecho, quizás sorprendentemente, incluso en el entorno de dos participantes, ¡una configuración de turno alterna es una suposición irrazonable! Por ejemplo, considere la ruta (en la Figura 1) del estado 1 al 15 (SendGoods) y luego al estado 12 (Sendaccept). El resultado, en una configuración de turno alterna, es un extremo muerto: solo hay una acción posible en el estado 12, a saber, SendEpo, pero esta acción lo realiza el cliente, ¡y es el recurro de los comerciantes para actuar! La Figura 7 muestra el FSM para NetBill con iniciativa alterna. Una solución a este problema que funciona en este ejemplo, pero no se generaliza7, es debilitar el régimen alterno de giro al permitir que un agente actúe dos veces seguidos si su segunda acción es impulsada por un compromiso. Una solución general es rastrear cuyo turno es actuar. Esto se puede hacer calculando qué agentes tienen acciones que se pueden realizar en el estado actual. Si solo hay un agente activo, entonces es claramente que los agentes recurren a actuar. Sin embargo, si más de un agente está activo, entonces de alguna manera los agentes necesitan determinar quién debe actuar a continuación. Trabajar esto por negociación no es una solución particularmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción donde más de un agente está activo (en el billete, esto se aplica a siete de cada dieciséis estados), por lo que es muy deseable tener un mecanismo de peso ligero para hacereste. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (usted va primero, no, primero,. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúa con preferencia al comerciante, o que cada agente tiene una prioridad numérica (tal vez determinada por el orden en que se unió a la interacción?) que determina quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no tratar de administrar la toma de giro.7 Considere las acciones A1 (c) ⇒ P, A2 (C) ⇒ Q y A3 (M): P ∧ Q ⇒ R.Figura 7: Netbill con iniciativa alterna en lugar de rastrear y controlar cuyo turno es, simplemente permitimos que los agentes actúen libremente y confíen en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que haremos precisa,y probar, en el resto de esta sección. El problema de que los agentes múltiples estén activos simultáneamente es que en lugar de que todos los agentes acuerden el estado de interacción actual, los agentes pueden estar en diferentes estados. Esto se puede visualizar como cada agente que tiene su propia copia del FSM que navega a través de donde es posible que los agentes sigan diferentes caminos a través del FSM. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales?2. ¿Puede un agente estar en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones viajan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (nuevamente, bajo ciertos supuestos). Por acciones viajan queremos decir que el estado resultante de realizar una secuencia de acciones A1... An es lo mismo, independientemente del orden en el que se realicen las acciones. Esto significa que incluso si los agentes toman diferentes caminos a través del FSM, todavía terminan en el mismo estado resultante, porque una vez que todos los mensajes se hayan procesado, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el tema de terminar en diferentes estados finales. Volvemos a la posibilidad de que ocurran errores en breve. Definición 1 (monotonicidad) Una acción es monotónica si no elimina 8 fluidos o compromisos. Una máquina de compromiso es 8 que se elimina directamente, está bien descargar compromisos agregando fluentes/compromisos.878 El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) monotónicos si todas sus acciones son monotónicas.(Adaptado de [14, definición 6]) Teorema 1 Si A1 y A2 son acciones monotónicas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1.(Adaptado de [14, Teorema 2]). Esto supone que ambas acciones se pueden realizar. Sin embargo, es posible que el rendimiento de A1 desactive A2. Por ejemplo, si A1 tiene el efecto +P, y A2 tiene condición previa ¬P, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no se pueden realizar en ninguno de los orden. Podemos evitar esto asegurando que las condiciones previas de las acciones no contengan negación (o implicación), ya que una acción monotónica no puede dar lugar a una condición previa que esté libre de negaciones. Tenga en cuenta que esta restricción solo se aplica a la condición previa de acción original, P, no a ninguna condición previa adicional impuesta por el agente (P). Esto se debe a que solo P se usa para determinar si otro agente puede realizar la acción. Por lo tanto, los CM monotónicos con condiciones previas que no contienen negaciones tienen acciones que viajan. Sin embargo, de hecho, la restricción a los CM monotónicos es innecesariamente fuerte: todo lo que se necesita es que cada vez que haya una opción de agente que pueda actuar, entonces las posibles acciones son monotónicas. Si solo hay un agente que puede actuar, entonces no se necesita restricción sobre las acciones: pueden o no ser monotónicos. Definición 2 (localmente monotónica) Una máquina de compromiso es localmente monotónica si para algún estado s (a) solo un agente solo tiene acciones que se pueden realizar;o (b) todas las acciones que se pueden realizar en S son monotónicas. Teorema 2 En un CM localmente monotónico, una vez que se hayan procesado todos los mensajes, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que se hayan procesado todos los mensajes, tenemos que todos los agentes habrán realizado el mismo conjunto de acciones, tal vez en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no tengan aún convergidos al mismo estado, todas las acciones deben ser monotónicas y, por lo tanto, que estas acciones conmutan, y no pueden deshabilitar ninguna otra acción. Considere el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo que otro agente (llamar XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitado, por lo que, dado que el CM es localmente monotónico, las acciones relevantes deben ser monotónicas. Por lo tanto, después de hacer A, la acción B aún debe estar habilitada, por lo que el mensaje para hacer B puede procesarse actualizando las creencias de los agentes receptores con los efectos de B. Además, debido a que las acciones monotónicas viajan, el resultado de hacer A antes de B es el mismo que hacer B antes de A: S A −−−−− → SA??YB B??y SB −−−− → A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Debido a que B está habilitado, y C no es realizado por el Agente XB (ver más abajo), debemos tener que C también sea monotónico y, por lo tanto, (a) el resultado de hacer A y B y C es el mismo independientemente del orden en queLas tres acciones se realizan;y (b) C no deshabilita B, por lo que B todavía se puede hacer después de C. S A −−−−− → Sa C −−−−−− → SAC??YB B??y b??y SB −−−−− → A SAB −−−−− → C SABC La razón por la cual C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada9. Desde la perspectiva de XB, la acción B se realizó antes de C y, por lo tanto, desde cualquier otra perspectiva de agentes, el mensaje que dice que B se realizó debe ser recibido (y procesado) antes de un mensaje que dice que C está hecho. Este argumento se puede extender para mostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en que convergen en un solo estado deben ser monotónicos y, por lo tanto, siempre es posible converger (porque las acciones no están deshabilitadas), por lo queLa interacción está libre de errores;y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monotónicas viajan). Este teorema ofrece una fuerte garantía teórica de que no hacer la gestión de turnos no conducirá al desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no conduciría a ningún accidente, y solo es posible porque los axiomas CM refinados son simétricos. Basado en este teorema, la transformación genérica de CM a código debería permitir que los agentes actúen libremente, lo que se logra simplemente cambiando ı: P ∧ P ∧ ¬E ← +E;↑ a a ı: P ∧ P ∧ ¬E ← +E;↑ a;ı Por ejemplo, en lugar de ı: ¬ Request ← +solicitud;↑ sendRequest tenemos ı: ¬ request ← +solicitud;↑ sendRequest;i. Una consecuencia del teorema es que no es necesario garantizar que los agentes procesen mensajes antes de continuar interactuando. Sin embargo, para evitar el paralelismo innecesario, lo que puede dificultar la depuración, aún puede ser deseable procesar mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones desde la implementación 3APL que se ha modificado para permitir la interacción libre, no alternativa.5. Discusión Hemos presentado un esquema para mapear las máquinas de compromiso en las plataformas BDI (usando SAAPL como un ejemplo), identificó tres cambios que debían realizarse a SAAPL para admitir la interacción basada en CM, y demostró que la gestión de turnos se puede evitar en la interacción CMBased,siempre que el CM sea localmente monotónico. Los tres cambios en SAAPL y el esquema de traducción de la máquina de compromiso a los planes BDI son aplicables a cualquier idioma BDI. Como hemos mencionado en la Sección 1, ha habido algo de trabajo para diseñar una interacción de agentes flexible y robusta, pero prácticamente no hay trabajo para implementar interacciones flexibles y robustas. Ya hemos discutido el grapas [9, 10]. Otro trabajo que es relevante es el trabajo de Cheong y Winikoff en su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmático, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar código de esqueleto que luego debe completarse. Además, no abordan el giro que está en problemas: cómo decidir qué agente actúa cuando más de un agente puede actuar.9 También suponemos que el medio de comunicación no entrega mensajes fuera de orden, que es el caso para (por ejemplo) TCP. El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 879 Figura 8: La muestra se ejecuta desde la implementación de 3APL (giros no alternativos) el trabajo de Kremer y Flores (por ejemplo [8]) también utiliza compromisos y se ocupa de la implementación. Sin embargo, proporcionan soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busca implementar agentes. Aunque hemos implementado la interacción NetBill usando 3APL, los cambios en la semántica se realizaron modificando nuestro programa NetBill 3APL, en lugar de modificar la implementación 3APL en sí. Claramente, sería deseable modificar la semántica de 3APL (o de otro idioma) directamente, cambiando la implementación. Además, aunque no lo hemos hecho, debe estar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para trabajos adicionales es observar cómo los supuestos necesarios para garantizar que las acciones viajen sean relajadas. Finalmente, es necesario realizar una evaluación empírica. Ya ha habido algo de trabajo para comparar Hermes con un enfoque convencional centrado en el mensaje para diseñar la interacción, y esto ha demostrado que el uso de Hermes da como resultado diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17].6. Referencias [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación de múltiples agentes: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseño de interacciones de agentes orientadas a objetivos. En Actas del 6to Taller Internacional sobre Ingeniería de Software Orientada a los Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementación de interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas de Multi-Agentes (PRoRAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nous, 25 (4): 487-512, 1991. [6] M. Dastani, J. van der Ham y F. dignum. Comunicación para los agentes dirigidos a objetivos. En Actas del Taller de lenguajes de comunicación y políticas de conversación de agentes, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un testbito para diálogos multipartidistas. En avances en la comunicación de agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una red de subsunción performativa para apoyar las conversaciones basadas en el compromiso. En F. dignum, V. dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, agentes autónomos y sistemas de múltiples agentes (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. Paple: un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Conjunta Internacional sobre Agentes Autónomos y Sistemas Multiagentes (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representar y ejecutar protocolos como acciones conjuntas. En Actas de la primera conferencia conjunta internacional sobre agentes autónomos y sistemas de múltiples agentes, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press.[11] M. Tambe y W. Zhang. Hacia el trabajo en equipo flexible en equipos persistentes: informe extendido. Revista de Agentes Autónomos y Sistemas de Multi-Agentes, 2000. Número especial en Best of ICMAS 98. [12] M. Winikoff. Un metabloqueo de AgentsPeak y sus aplicaciones. En el tercer taller internacional sobre programación de sistemas de agentes múltiples (PROMAS), páginas 123-138. Springer, LNCS 3862 (posterior al proceso, 2006), 2005. [13] M. Winikoff. Diseño de interacciones de agente basadas en compromiso. En Actas de la Conferencia Internacional IEEE/WIC/ACM de 2006 sobre tecnología de agentes inteligentes (IAT-06), 2006. [14] M. Winikoff. Implementación de interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuido. Multiagente y sistemas de cuadrícula, 2 (4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejora de las máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Lenguas y Tecnologías de Agentes Declarativos II, Número 3476 en Notas de conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y de procedimiento en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de representación y razonamiento del conocimiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo del protocolo. En F. dignum, V. dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, agentes autónomos y sistemas de múltiples agentes (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución de protocolo flexible: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la primera conferencia conjunta sobre agentes autónomos y sistemas multiagentes (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre los compromisos en el cálculo del evento: un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07)",
    "original_sentences": [
        "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
        "Instead, messages are provided as a primitive building block.",
        "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
        "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
        "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
        "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
        "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
        "Consequently, design and implementation of agent interaction is an important research topic.",
        "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
        "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
        "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
        "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
        "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
        "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
        "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
        "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
        "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
        "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
        "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
        "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
        "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
        "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
        "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
        "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
        "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
        "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
        "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
        "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
        "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
        "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
        "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
        "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
        "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
        "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
        "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
        "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
        "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
        "A final state is one that has no base-level commitments.",
        "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
        "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
        "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
        "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
        "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
        "One of these is chosen and is executed.",
        "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
        "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
        "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
        "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
        "The plan body is built up from the following constructs.",
        "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
        "These can be sequenced (P; P).",
        "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
        "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
        "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
        "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
        "More sophisticated belief management methods may be used, but are not considered here.",
        "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
        "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
        "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
        "The global message queue is a sequence of triplets of the form sender:recipient:message.",
        "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
        "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
        "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
        "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
        "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
        "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
        "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
        "In section 4 we relax these assumptions.",
        "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
        "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
        "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
        "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
        "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
        "C: ı : true ← +accept; ↑sendAccept.",
        "M: ↓sendAccept : true ← +accept; ı.",
        "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
        "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
        "C: ↓sendReceipt : pay ← +receipt; ı.",
        "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
        "In addition to these plans, we also need plans to start and finish the interaction.",
        "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
        "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
        "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
        "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
        "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
        "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
        "For conciseness the error reporting plans are omitted.",
        "We now turn to refining the context conditions.",
        "There are three refinements that we consider.",
        "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
        "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
        "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
        "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
        "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
        "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
        "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
        "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
        "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
        "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
        "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
        "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
        "This is clearly safe, since actions are not prevented, just considered in a different order.",
        "The third refinement of context conditions concerns the plans that terminate the interaction.",
        "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
        "However, only some of these final states are desirable final states.",
        "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
        "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
        "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
        "Figure 4 shows the plans that are changed from figure 3.",
        "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
        "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
        "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
        "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
        "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
        "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
        "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
        "Jason, 3APL, CAN).",
        "However, other agent platforms do require an extension.",
        "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
        "In the case of 3APL no change is needed to support this.",
        "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
        "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
        "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
        "Similar rules apply for conditional commitments.",
        "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
        "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
        "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
        "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
        "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
        "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
        "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
        "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
        "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
        "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
        "One aspect that doesnt require a change is linking commitments and actions.",
        "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
        "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
        "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
        "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
        "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
        "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
        "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
        "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
        "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
        "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
        "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
        "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
        "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
        "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
        "Figure 7 shows the FSM for NetBill with alternating initiative.",
        "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
        "A general solution is to track whose turn it is to act.",
        "This can be done by working out which agents have actions that are able to be performed in the current state.",
        "If there is only a single active agent, then it is clearly that agents turn to act.",
        "However, if more than one agent is active then somehow the agents need to work out who should act next.",
        "Working this out by negotiation is not a particularly good solution for two reasons.",
        "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
        "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
        "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
        "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
        "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
        "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
        "The two specific issues that need to be addressed are: 1.",
        "Can agents end up in different final states? 2.",
        "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
        "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
        "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
        "An is the same, regardless of the order in which the actions are performed.",
        "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
        "This addresses the issue of ending up in different final states.",
        "We return to the possibility of errors occurring shortly.",
        "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
        "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
        "This assumes that both actions can be performed.",
        "However, it is possible for the performance of A1 to disable A2 from being done.",
        "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
        "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
        "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
        "This is because only P is used to determine whether another agent is able to perform the action.",
        "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
        "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
        "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
        "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
        "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
        "Furthermore, no errors can occur.",
        "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
        "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
        "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
        "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
        "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
        "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
        "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
        "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
        "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
        "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
        "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
        "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
        "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
        "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
        "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
        "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
        "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
        "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
        "We have already discussed STAPLE [9, 10].",
        "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
        "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
        "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
        "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
        "TCP.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
        "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
        "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
        "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
        "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
        "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
        "Finally, there is a need to perform empirical evaluation.",
        "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
        "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
        "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
        "Multi-Agent Programming: Languages, Platforms and Applications.",
        "Springer, 2005. [2] C. Cheong and M. Winikoff.",
        "Hermes: Designing goal-oriented agent interactions.",
        "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
        "Hermes: Implementing goal-oriented agent interactions.",
        "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
        "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
        "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
        "Teamwork.",
        "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
        "Communication for goal directed agents.",
        "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
        "Towards a testbed for multi-party dialogues.",
        "In Advances in Agent Communication, pages 212-230.",
        "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
        "Using a performative subsumption lattice to support commitment-based conversations.",
        "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
        "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
        "STAPLE: An agent programming language based on the joint intention theory.",
        "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
        "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
        "Representing and executing protocols as joint actions.",
        "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
        "ACM Press. [11] M. Tambe and W. Zhang.",
        "Towards flexible teamwork in persistent teams: Extended report.",
        "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
        "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
        "An AgentSpeak meta-interpreter and its applications.",
        "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
        "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
        "Designing commitment-based agent interactions.",
        "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
        "Implementing flexible and robust agent interactions using distributed commitment machines.",
        "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
        "Enhancing commitment machines.",
        "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
        "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
        "Declarative & procedural goals in intelligent agent systems.",
        "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
        "Towards design tools for protocol development.",
        "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
        "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
        "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
        "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
        "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
        "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
    ],
    "error_count": 0,
    "keys": {
        "commitment-based interaction": {
            "translated_key": "interacción basada en compromiso",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "messagecentric approach": {
            "translated_key": "enfoque mensajero",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and <br>messagecentric approach</br>es to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Implementación de interacciones basadas en el compromiso ∗ Michael Winikoff School of Computer Science y la universidad de TI Melbourne, Australia Michael.winikoff@rmit.edu.au Resumen Aunque la interacción del agente juega un papel vital en MAS y el \"enfoque mensajero\" para la interacción del agente tiene suLos inconvenientes, los lenguajes de programación presentes orientados al agente no brindan soporte para la implementación de la interacción del agente que sea flexible y robusto."
            ],
            "translated_text": "",
            "candidates": [
                "enfoque mensajero",
                "enfoque mensajero"
            ],
            "error": []
        },
        "agent-oriented programming language": {
            "translated_key": "lenguaje de programación orientado al agente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present <br>agent-oriented programming language</br>s do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional <br>agent-oriented programming language</br>s.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Implementación de interacciones basadas en el compromiso ∗ Michael Winikoff School of Computer Science y la universidad de TI Melbourne, Australia Michael.winikoff@rmit.edu.au Resumen Aunque la interacción de los agentes juega un papel vital en MAS, y los enfoques mensajeros para la interacción de los agentes tienen sus inconvenientes, presente presenteEl \"lenguaje de programación orientado al agente\" no proporciona soporte para la implementación de la interacción del agente que sea flexible y robusto.",
                "Investigamos cómo se pueden implementar interacciones basadas en compromiso en el \"lenguaje de programación orientado al agente\" convencional."
            ],
            "translated_text": "",
            "candidates": [
                "lenguaje de programación orientado al agente",
                "lenguaje de programación orientado al agente",
                "lenguaje de programación orientado al agente",
                "lenguaje de programación orientado al agente"
            ],
            "error": []
        },
        "agent interaction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although <br>agent interaction</br> plays a vital role in MAS, and messagecentric approaches to <br>agent interaction</br> have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and <br>agent interaction</br> plays a vital role in multiagent systems.",
                "Consequently, design and implementation of <br>agent interaction</br> is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing <br>agent interaction</br>.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust <br>agent interaction</br> implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust <br>agent interaction</br>, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two <br>agent interaction</br> design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Implementación de interacciones basadas en el compromiso ∗ Michael Winikoff School of Computer Science y la universidad de TI Melbourne, Australia Michael.winikoff@rmit.edu.au Resumen Aunque la \"interacción del agente\" juega un papel vital en MAS y enfoques mensajeros para \"interacción de agente\"Sus inconvenientes, los lenguajes de programación presentes orientados al agente no brindan soporte para la implementación de la interacción del agente que sea flexible y robusto.",
                "Los agentes de introducción son sociales, y la \"interacción de agentes\" juega un papel vital en los sistemas multiagentes.",
                "En consecuencia, el diseño y la implementación de la \"interacción del agente\" es un tema de investigación importante.",
                "De hecho, los AOPL modernos [1], prácticamente sin excepciones, proporcionan solo el envío simple de mensajes como base para implementar la \"interacción del agente\".",
                "Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que admite la implementación de \"interacción de agentes\" de alto nivel, flexible y robusta.",
                "Como hemos mencionado en la Sección 1, ha habido algo de trabajo para diseñar una \"interacción de agente\" flexible y robusta, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas.",
                "Hermes versus Prometeo: una evaluación comparativa de dos enfoques de diseño de \"interacción de agente\"."
            ],
            "translated_text": "",
            "candidates": [
                "interacción de agente",
                "interacción del agente",
                "interacción de agente",
                "interacción de agente",
                "interacción de agentes",
                "interacción de agente",
                "interacción del agente",
                "interacción de agente",
                "interacción del agente",
                "interacción de agente",
                "interacción de agentes",
                "interacción de agente",
                "interacción de agente",
                "interacción de agente",
                "interacción de agente"
            ],
            "error": []
        },
        "commitment machine framework": {
            "translated_key": "Marco de la máquina de compromiso",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the <br>commitment machine framework</br> is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the <br>commitment machine framework</br> any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Antecedentes 2.1 Máquinas de compromiso El objetivo del \"Marco de la máquina de compromiso\" es permitir la definición de interacciones que son más flexibles que los enfoques tradicionales centrados en el mensaje.",
                "En el \"marco de la máquina de compromiso\", cualquier estado que no tenga un compromiso de nivel base es final, ya que la interacción puede terminar allí (o puede continuar)."
            ],
            "translated_text": "",
            "candidates": [
                "Marco de la máquina de compromiso",
                "Marco de la máquina de compromiso",
                "Marco de la máquina de compromiso",
                "marco de la máquina de compromiso"
            ],
            "error": []
        },
        "bdi-style plan": {
            "translated_key": "Plan de estilo BDI",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "social commitment": {
            "translated_key": "compromiso social",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level <br>social commitment</br> is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional <br>social commitment</br> is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un \"compromiso social\" de nivel base es una tarea del deudor A al acreedor B para lograr la condición P, denotar C (A, B, P).",
                "Un \"compromiso social\" condicional es una empresa por parte del deudor A al acreedor B que debería condicionar Q a ser verdadero, y luego se comprometerá a lograr la condición p.Esto se denota por CC (A, B, Q, P), y, donde la identidad de las entidades involucradas no es importante (u obvio), se abrevia a CC (Q P) donde la flecha es un recordatorio del vínculo causal entre Qconvertirse en verdad y la creación de un compromiso para hacer que P sea verdad."
            ],
            "translated_text": "",
            "candidates": [
                "compromiso social",
                "compromiso social",
                "compromiso social",
                "compromiso social"
            ],
            "error": []
        },
        "interaction goal": {
            "translated_key": "meta de interacción",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or <br>interaction goal</br>s [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones de agentes, se han propuesto varios enfoques en los últimos años que se alejan de los protocolos de interacción centrados en el mensaje y, en su lugar, consideran diseñar interacciones de agentes utilizando conceptos de nivel superior como los compromisos sociales [8,10, 18] o \"meta de interacción\" s [2]."
            ],
            "translated_text": "",
            "candidates": [
                "meta de interacción",
                "meta de interacción"
            ],
            "error": []
        },
        "turn tracking": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including <br>turn tracking</br> [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Luego ampliamos nuestro esquema para abordar una variedad de problemas relacionados con la distribución, incluido el \"seguimiento de turnos\" [7] y las condiciones de carrera.2."
            ],
            "translated_text": "",
            "candidates": [
                "Girar el seguimiento",
                "seguimiento de turnos"
            ],
            "error": []
        },
        "race condition": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and <br>race condition</br>s) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and <br>race condition</br>s. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Las contribuciones de este documento son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI;extensiones a la semántica de los lenguajes de programación BDI;y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de giro y \"condición de carrera\" y soluciones a estos problemas.",
                "Luego ampliamos nuestro esquema para abordar una variedad de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y la \"condición de carrera\" s.2."
            ],
            "translated_text": "",
            "candidates": [
                "condición de carrera",
                "condición de carrera",
                "Condición de la carrera",
                "condición de carrera"
            ],
            "error": []
        },
        "belief management method": {
            "translated_key": "Método de gestión de creencias",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated <br>belief management method</br>s may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Se pueden usar un \"método de gestión de creencias\" más sofisticado, pero no se consideran aquí."
            ],
            "translated_text": "",
            "candidates": [
                "Método de gestión de creencias",
                "método de gestión de creencias"
            ],
            "error": []
        },
        "herme design": {
            "translated_key": "diseño de HERME",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "netbill interaction": {
            "translated_key": "interacción netbill",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the <br>netbill interaction</br> using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Aunque hemos implementado la \"interacción NetBill\" utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa NetBill 3APL, en lugar de modificar la implementación 3APL en sí."
            ],
            "translated_text": "",
            "candidates": [
                "interacción netbill",
                "interacción NetBill"
            ],
            "error": []
        },
        "commitment machine": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a <br>commitment machine</br> to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs <br>commitment machine</br> (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the <br>commitment machine</br> framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A <br>commitment machine</br> (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A <br>commitment machine</br> (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given <br>commitment machine</br> is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] <br>commitment machine</br>: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a <br>commitment machine</br> to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the <br>commitment machine</br> framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them <br>commitment machine</br> supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support <br>commitment machine</br> implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A <br>commitment machine</br> is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A <br>commitment machine</br> is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from <br>commitment machine</br> to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Las contribuciones de este documento son: un mapeo de una \"máquina de compromiso\" a una colección de planes de estilo BDI;extensiones a la semántica de los lenguajes de programación BDI;y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de giro y condiciones de carrera) y soluciones a estos problemas.",
                "Este documento presenta un esquema para extender las AOPL similares a BDI para admitir la implementación directa de las interacciones de los agentes que están diseñadas con el marco de Yolum & Singhs \"Compiatment Machine\" (CM) [19].",
                "Antecedentes 2.1 Máquinas de compromiso El objetivo del marco de la \"máquina de compromiso\" es permitir la definición de interacciones que son más flexibles que los enfoques tradicionales centrados en el mensaje.",
                "Una \"máquina de compromiso\" (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de interacción.",
                "Una \"máquina de compromiso\" (CM) define un rango de posibles interacciones que comienzan en algún estado1 y realizan acciones hasta alcanzar un estado final.",
                "Una forma de visualizar las interacciones que son posibles con una \"máquina de compromiso\" dada es generar la máquina de estado finito correspondiente al CM.",
                "Por ejemplo, la Figura 1 proporciona el FSM2 correspondiente al NetBill [18] \"Máquina de compromiso\": un CM simple donde un cliente (C) y comerciante (M) intentan comerciar utilizando las siguientes acciones3: 1 a diferencia de los protocolos de interacción estándar, o finitos finitosMáquinas de estado, no hay un estado inicial designado para la interacción.2 La máquina de estado finito está generada por software: los nodos y las conexiones se calcularon mediante una implementación de los axiomas (disponibles en http://www.winikoff.net/cm) y luego fueron presentados por GraphViz (http: // www.GraphViz.org/).3 Usamos la notación A (x): p ⇒ e para indicar que la acción A es realizada por Entity X, tiene condición previa p (con: P omitida si está vacía) y efecto E. • SendRequest (c) ⇒ Solicitud • SendQuote (M) ⇒ Oferta donde oferta ≡ prometygoods ∧ promisereceipt y promesagoods ≡ cc (m, c, acepta, bienes) y promisereceipt ≡ cc (m, c, pay, recibo) • Sendacept (c) ⇒ Aceptar donde acepte ≡ Cc (C, M, bienes, pagos) • SendGoods (M) ⇒ Promisereceipt ∧ Bienes donde Promisereceipt ≡ CC (M, C, Pay, Recibo) • SendEpo (C): Bienes ⇒ PAGO • SendReceipt (M): Pague ⇒ Recibo.",
                "Implementación de interacciones basadas en el compromiso en esta sección presentamos un mapeo de una \"máquina de compromiso\" a una colección de programas SAAPL (uno para cada rol).",
                "En el marco de la \"máquina de compromiso\", cualquier estado que no tenga ningún compromiso de nivel base es final, ya que la interacción puede terminar allí (o puede continuar).",
                "Estos cambios, que se analizan a continuación, se pueden aplicar a los idiomas BDI existentes para que sean de \"máquina de compromiso\" de apoyo.",
                "El cambio que debe hacerse a SAAPL para admitir implementaciones de \"máquina de compromiso\" es extender la definición de | = para incluir estas cuatro reglas.",
                "Una \"máquina de compromiso\" es 8 que se elimina directamente, está bien descargar compromisos al agregar fluentes/compromisos.878 El sexto intl.",
                "Definición 2 (localmente monotónica) Una \"máquina de compromiso\" es localmente monotónica si para algún estado s (a) solo un agente solo tiene acciones que se pueden realizar;o (b) todas las acciones que se pueden realizar en S son monotónicas.",
                "Los tres cambios en SAAPL y el esquema de traducción de la \"máquina de compromiso\" a los planes BDI son aplicables a cualquier idioma BDI."
            ],
            "translated_text": "",
            "candidates": [
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "Compiatment Machine",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "Máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso",
                "máquina de compromiso"
            ],
            "error": []
        },
        "agent orient program language": {
            "translated_key": "Lenguaje del programa de Orient de agente",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "belief desire intention": {
            "translated_key": "creencia de deseo intención",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "bdi": {
            "translated_key": "bdi",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of <br>bdi</br>-style plans; extensions to the semantics of <br>bdi</br> programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending <br>bdi</br>-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of <br>bdi</br> AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the <br>bdi</br> tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (<br>bdi</br>) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing <br>bdi</br> languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to <br>bdi</br> platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to <br>bdi</br> plans are both applicable to any <br>bdi</br> language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using <br>bdi</br> platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Las contribuciones de este documento son: un mapeo de una máquina de compromiso a una colección de planes de estilo \"BDI\";extensiones a la semántica de los lenguajes de programación \"BDI\";y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de giro y condiciones de carrera) y soluciones a estos problemas.",
                "Este documento presenta un esquema para extender las AOPL \"BDI\" para admitir la implementación directa de las interacciones de agentes que están diseñadas con el marco de la máquina de compromiso Yolum & Singhs (CM) [19].",
                "En el resto de este documento, revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de \"BDI\" aopls que se encuentra en el subconjunto común de idiomas como Jason, 3APL y Can.",
                "Como se ve en la Figura 1, las máquinas de compromiso pueden soportar una gama de secuencias de interacción.2.2 Un agente abstracto Programing Language Agent Langua de programación en la tradición \"BDI\" (por ejemplo, DMARS, JAM, PRS, UM-PRS, Jack, AgentsPeak (L), Jason, 3APL, Can, Jadex) Definir el comportamiento del agente en términos de eventos activados por eventosPlanes, donde cada plan especifica por qué se desencadena, bajo qué situaciones se puede considerar aplicable (definida usando una llamada condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir eventos de publicación que a su vezdesencadena más planes.",
                "Ahora definimos brevemente la sintaxis formal y la semántica de un lenguaje de programación de agente resumen simple (\"BDI\") (SAAPL).",
                "Estos cambios, que se analizan a continuación, se pueden aplicar a los idiomas \"BDI\" existentes para que la máquina de compromiso de compromiso sea de apoyo.",
                "Discusión Hemos presentado un esquema para mapear máquinas de compromiso en plataformas \"BDI\" (usando SAAPL como ejemplar), identificó tres cambios que debían realizarse a SAAPL para admitir la interacción basada en CM, y demostró que la gestión de turnos se puede evitar en CMBasedinteracción, siempre que el CM sea localmente monotónico.",
                "Los tres cambios en SAAPL y el esquema de traducción de la máquina de compromiso a los planes \"BDI\" son aplicables a cualquier idioma \"BDI\".",
                "Aunque el enfoque principal de su trabajo es una metodología de diseño pragmático, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas \"BDI\" (específicamente Jadex) [3]."
            ],
            "translated_text": "",
            "candidates": [
                "bdi",
                "BDI",
                "BDI",
                "bdi",
                "BDI",
                "bdi",
                "BDI",
                "bdi",
                "BDI",
                "bdi",
                "BDI",
                "bdi",
                "BDI",
                "bdi",
                "BDI",
                "bdi",
                "BDI",
                "BDI",
                "bdi",
                "BDI"
            ],
            "error": []
        }
    }
}