Interfaz de servicio: una nueva abstracción para implementar y componer protocolos ∗ Olivier R¨utti Paweł T. Wojciechowski Andr´e Schiper Ecole Polytechnique F´ED´erale de Lausanne (EPFL) 1015 Lausanne, Switzerland {Olivier.rutti, Pawel.wojciechawski, yeRe, yeRe, yeReChowski..Schiper}@epfl.ch Resumen En este documento comparamos dos enfoques con el diseño de marcos de protocolo: herramientas para implementar protocolos de red modulares. El enfoque más común utiliza los eventos como la principal abstracción para una interacción local entre los módulos de protocolo. Argumentamos que un enfoque alternativo, que se basa en la abstracción del servicio, es más adecuado para expresar protocolos modulares. También facilita las características avanzadas en el diseño de protocolos, como la actualización dinámica de los protocolos distribuidos. Luego describimos una implementación experimental de un marco de protocolo basado en servicios en Java. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: Aplicaciones distribuidas 1. Introducción de los marcos de protocolo, tales cactus [5, 2], Appia [1, 16], Ensemble [12, 17], Eva [3], SDL [8] y Neko [6, 20], son herramientas de programación para desarrollar una red modularProtocolos. Permiten que los protocolos complejos se implementen descomponiéndolos en varios módulos que cooperan juntos. Este enfoque facilita la reutilización y personalización del código de los protocolos distribuidos para satisfacer las necesidades de diferentes aplicaciones. Además, los módulos de protocolo se pueden conectar al sistema dinámicamente. Todas estas características de los marcos de protocolo las convierten en una tecnología interesante para implementar sistemas adaptables [14], una clase importante de aplicaciones. La mayoría de los marcos de protocolo se basan en eventos (todos los marcos citados anteriormente se basan en esta abstracción). Los eventos se utilizan para la comunicación asincrónica entre diferentes módulos en la misma máquina. Sin embargo, el uso de eventos plantea algunos problemas [4, 13]. Por ejemplo, la composición de los módulos puede requerir conectores a eventos de ruta, lo que introduce una carga para un compositor de protocolo [4]. Los marcos de protocolo como APPIA y EVA amplían el enfoque basado en eventos con los canales. Sin embargo, en nuestra opinión, esta solución no es satisfactoria ya que la composición de pilas de protocolo complejos se vuelve más difícil. En este documento, proponemos un nuevo enfoque para construir protocolos modulares, que se basa en una abstracción de servicio. Comparamos este nuevo enfoque con el enfoque común basado en eventos. Mostramos que los marcos de protocolo basados en servicios tienen varias ventajas, p.Permitir una composición de protocolo bastante sencilla, implementación clara y un mejor soporte del reemplazo dinámico de protocolos distribuidos. Para validar nuestras afirmaciones, hemos implementado Samoa, un marco de protocolo experimental que se basa exclusivamente en el enfoque basado en servicios para la composición e implementación del módulo. El marco nos permitió comparar las implementaciones basadas en el servicio y los eventos de un middleware de comunicación de grupo adaptativo. El papel está organizado de la siguiente manera. La Sección 2 define las nociones generales. La Sección 3 presenta las características principales de los marcos basados en eventos y las características que son distintas para cada marco. La Sección 4 describe nuestro nuevo enfoque, que se basa en la abstracción del servicio. La Sección 5 analiza las ventajas de un marco de protocolo basado en servicios en comparación con un marco de protocolo basado en eventos. La descripción de nuestra implementación experimental se presenta en la Sección 6. Finalmente, concluimos en la Sección 7. 2. Marcos de protocolo En esta sección, describimos nociones que son comunes a todos los marcos de protocolo. Protocolos y módulos de protocolo. Un protocolo es un algoritmo distribuido que resuelve un problema específico en un sistema distribuido, p.Un protocolo TCP resuelve el problema de canal confiable. Un protocolo se implementa como un conjunto de módulos de protocolo idénticos ubicados en diferentes máquinas. Pilas de protocolo. Una pila es un conjunto de módulos de protocolo (de diferentes protocolos) que se encuentran en la misma máquina. Tenga en cuenta que, a pesar de su nombre, una pila no está estrictamente en capas, 691, es decir, un módulo de protocolo puede interactuar con todos los demás módulos de protocolo en la misma pila, no solo con los módulos de protocolo directamente arriba y abajo. En el resto de este documento, utilizamos los términos máquina y la pila intercambiable. Pila 1 S1 Q1 R1 P1 Red Figura 1: Ejemplo de una pila de protocolo En la Figura 1, mostramos una pila de protocolo de ejemplo. Representamos módulos de protocolo por letras mayúsculas indexadas con un número natural, p. P1, Q1, R1 y S1. Escribimos Pi para denotar el módulo de protocolo de un protocolo P en la pila i. Usamos esta notación en todo el papel. Los módulos se representan como cajas blancas. Las flechas muestran interacciones del módulo. Por ejemplo, el módulo de protocolo P1 interactúa con el módulo de protocolo Q1 y, por el contrario, (ver Fig. 1). Interacciones del módulo de protocolo. A continuación, definimos los diferentes tipos de interacción entre los módulos de protocolo.• Las solicitudes se emiten mediante módulos de protocolo. Una solicitud de un módulo de protocolo PI es una llamada asincrónica de PI de otro módulo de protocolo.• Las respuestas son los resultados de una solicitud. Una sola solicitud puede generar varias respuestas. Solo los módulos de protocolo que pertenecen al mismo protocolo que el módulo que ha emitido la solicitud se refiere a las respuestas correspondientes. Por ejemplo, una solicitud de PI genera respuestas que se refieren solo a los módulos de protocolo PJ.• Las notificaciones pueden ser utilizadas mediante un módulo de protocolo para informar (posiblemente muchos) módulos de protocolo en la misma pila sobre la aparición de un evento específico. Las notificaciones también pueden ser los resultados de una solicitud.3. Diseño del marco de protocolo basado en eventos La mayoría de los marcos de protocolo existentes están basados en eventos. Ejemplos son cactus [5, 2], Appia [1, 16] y conjunto [12, 17]. En esta sección, definimos la noción de un evento en los marcos de protocolo. También explicamos cómo se estructuran los módulos de protocolo en los marcos basados en eventos. Eventos. Un evento es un objeto especial para la comunicación indirecta entre los módulos de protocolo en la misma pila. Los eventos pueden transportar información, p.un mensaje de red o algunos otros datos. Con los eventos, la comunicación es indirecta, es decir, un módulo de protocolo que desencadena un evento no es consciente de los módulos que manejan el evento. Los eventos permiten una comunicación de uno a muchos dentro de una pila de protocolo. Activar un evento se puede realizar sincrónicamente o asincrónicamente. En el primer caso, el hilo que desencadena un evento E se bloquea hasta que todos los módulos de protocolo que manejen E hayan terminado el manejo del evento E.En el último caso, el hilo que desencadena el evento no está bloqueado. Módulos de protocolo. En los marcos de protocolo basados en eventos, un módulo de protocolo consiste en un conjunto de manejadores. Cada manejador está dedicado al manejo de un evento específico. Los manejadores del mismo módulo de protocolo pueden compartir datos. Los manejadores pueden estar dinámicamente vinculados a los eventos. Los manejadores también pueden estar descensurados dinámicamente. Al activar algún evento E, todos los manejadores unidos a E se ejecutan. Si no está atado ningún controlador, el comportamiento generalmente no se especifica. Pila 1 P1 Q1 R1 S1 Red F e GG Entrega Send H Figura 2: Ejemplo de una pila de protocolo basada en eventos en la Figura 2, mostramos un ejemplo de una pila basada en eventos. Los eventos están representados por letras pequeñas, p.E, F, ... El hecho de que un módulo de protocolo pueda activar un evento está representado por una flecha que comienza desde el módulo. Un trapezoide blanco dentro de un cuadro de módulo representa un controlador definido por el módulo de protocolo. Para marcar que algún controlador está obligado al evento E, usamos una flecha que apunta al controlador (la etiqueta de la flecha representa el evento E). Por ejemplo, el módulo de protocolo P1 desencadena el evento E y maneja el evento F (ver Fig. 2). Tenga en cuenta que la red se representa como un módulo de protocolo especial que maneja el evento de envío (para enviar un mensaje a otra máquina) y desencadena el evento de entrega (al recibir un mensaje de otra máquina). Características específicas. Algunos marcos de protocolo tienen características únicas. A continuación, presentamos las características que influyen en la composición e implementación de los módulos de protocolo. En Cactus [5, 2], el programador puede dar un número de prioridad a un controlador al vincularlo a un evento. Cuando se activa un evento, todos los manejadores se ejecutan después del orden de prioridad. Un controlador H también puede cancelar la ejecución de un desencadenante del evento: todos los manejadores que deben ejecutarse después de H de acuerdo con la prioridad no se ejecutan. Appia [1, 16] y Eva [3] introducen la noción de canales. Los canales permiten construir rutas de eventos en pilas de protocolos. Cada módulo de protocolo tiene que suscribirse a uno o muchos canales. Todos los eventos se activan especificando un canal al que pertenecen. Cuando un módulo de protocolo desencadena un evento E que especifica el Canal C, todos los manejadores unidos a E que forman parte de un protocolo que se suscribe a C (en el orden prescrito por la definición del canal C).4. Marco de protocolo basado en servicios En esta sección, describimos nuestro nuevo enfoque para implementar y componer protocolos que se basan en los servicios.692 mostramos en la Sección 5 las ventajas de los marcos de protocolo basados en servicios sobre los marcos de protocolo basados en eventos. Interfaz de servicio. En nuestro marco basado en servicios, los módulos de protocolo en la misma pila se comunican a través de objetos llamados interfaces de servicio. Las solicitudes, respuestas y notificaciones se emiten a las interfaces de servicio. Módulos de protocolo. Un módulo de protocolo es un conjunto de ejecutores, oyentes e interceptores. Los ejecutores manejan solicitudes. Un ejecutor puede estar vinculado dinámicamente a una interfaz de servicio. Puede ser desatado más tarde. Una solicitud emitida a una interfaz de servicio SI conduce a la ejecución del ejecutor vinculado a SI. Si ningún ejecutor está vinculado a SI, la solicitud se retrasa hasta que algún ejecutor está vinculado a SI. Contrariamente a los eventos, a lo sumo, un ejecutor en cualquier momento puede estar vinculado a una interfaz de servicio en cada máquina. Los oyentes manejan respuestas y notificaciones. Un oyente puede estar dinámicamente unido y sin consolidar hacia/desde una interfaz de servicio SI. Una notificación emitida a una interfaz de servicio SI es manejada por todos los oyentes unidos a SI en la pila local. Una respuesta emitida a una interfaz de servicio es manejada por un solo oyente. Para asegurarse de que un solo oyente maneje una respuesta, un módulo PI tiene que identificar, cada vez que emite una solicitud, el oyente para manejar la posible respuesta. Si la solicitud y la respuesta ocurren respectivamente, en Stack I y en Stack J, la interfaz de servicio SI en I Communicate a la interfaz de servicio SI en j El oyente que debe manejar la respuesta. Si el oyente que debe manejar la respuesta no existe, la respuesta se retrasa hasta que se crea el oyente. Pila 1 P1 Q1 R1 S1 Red T u Nt Figura 3: Ejemplo de una pila de protocolo basada en servicios en la Figura 3, mostramos un ejemplo de una pila basada en servicios. Denotamos una interfaz de servicio mediante una pequeña carta (por ejemplo, T, U y NT) en una caja hexagonal. El hecho de que un módulo PI pueda generar una solicitud a una interfaz de servicio SI está representado por una flecha negra discontinua que va de PI a Si. Del mismo modo, una flecha blanca discontinua que va del módulo Pi a la interfaz de servicio SI representa el hecho de que PI puede generar una respuesta o una notificación a SI. Representamos a los ejecutores con cajas blancas dentro de módulos de protocolo y oyentes con cajas blancas con un borde gris. Una línea de conexión entre una interfaz de servicio SI y un ejecutor E (resp. Un oyente l) muestra que E (resp. L) está vinculado a SI. En la Figura 3, el módulo Q1 contiene un ejecutor vinculado a la interfaz de servicio T y un oyente vinculado a la interfaz de servicio u.El módulo Q1 puede generar respuestas y notificaciones a la interfaz de servicio T y solicita a la interfaz de servicio u. Tenga en cuenta que la interfaz de servicio NT permite acceder a la red. P1 Q1 P1 Q1 T1T1 T T T Figura 4: Ejecución de interacciones de protocolo con interceptores Un interceptor juega un rˆole especial. De manera similar a los ejecutores, los interceptores pueden estar dinámicamente unidos o noándose a una interfaz de servicio. Se activan cada vez que se emite una solicitud, una respuesta o una notificación a la interfaz de servicio a la que están obligados. Esto se ilustra en la Figura 4. En la parte derecha de la figura, el interceptor del módulo de protocolo T1 está representado por un cuadro redondeado. El interceptor está obligado a la interfaz de servicio t.La parte izquierda de la figura muestra que un interceptor puede verse como un ejecutor más un oyente. Cuando P1 emite una solicitud REQ a la interfaz de servicio t, se ejecuta el ejecutor-interceptor de T1. Luego, el módulo T1 puede reenviar una solicitud REQ a la interfaz de servicio t, donde podemos tener REQ = REQ 1. Cuando el módulo Q1 emite una respuesta o una notificación, se utiliza un mecanismo similar, excepto que esta vez se ejecuta el inyectador-interceptor de T1. Tenga en cuenta que un módulo de protocolo TI, que tiene un interceptor vinculado a una interfaz de servicio, puede modificar solicitudes, respuestas y notificaciones. Según las solicitudes, si varios interceptores están vinculados a la misma interfaz de servicio, se ejecutan en el orden de enlace. Tras respuestas y notificaciones, el orden se invierte.5. Ventajas del diseño del marco de protocolo basado en servicios que mostramos en esta sección las ventajas de los marcos de protocolo basados en servicios sobre los marcos de protocolo basados en eventos. Estructuramos nuestra discusión en tres partes. En primer lugar, presentamos cómo se modelan las interacciones de protocolo en cada uno de los marcos de protocolo. Luego, discutimos la composición de los módulos de protocolo en cada uno de estos marcos. Finalmente, presentamos el problema del reemplazo de protocolo dinámico y las ventajas de las interfaces de servicio para implementarlo. La discusión se resume en la Tabla 1. 5.1 Interacciones del módulo de protocolo Un modelo natural de interacciones de protocolo (como se presenta en la Sección 2) facilita la implementación de módulos de protocolo. Para cada interacción del protocolo, mostramos cómo se modela en ambos marcos. También explicamos que un modelo inadecuado puede conducir a problemas. Peticiones. En los marcos basados en servicios, se genera una solicitud en una interfaz de servicio. Cada solicitud es manejada como máximo un ejecutor, ya que permitimos que solo un ejecutor esté vinculado a una interfaz de servicio en cualquier momento. Por otro lado, en los marcos basados en eventos, un módulo de protocolo emula una solicitud al activar un evento. No hay garantía 1 Las dos interfaces de servicio t en la parte izquierda de la Figura 4 representan la misma interfaz de servicio t.La duplicación es solo para que la figura sea legible.693 que este evento está ligado a un solo controlador, lo que puede conducir a errores de programación. Respuestas. Cuando un módulo de protocolo genera una respuesta en un marco basado en servicios, solo se ejecuta el oyente correcto (identificado en el momento en que se emitió la solicitud correspondiente). Esto asegura que una solicitud emitida por algún módulo de protocolo Qi, conduce a respuestas manejadas por módulos de protocolo QJ (es decir, módulos de protocolo del mismo protocolo). Este no es el caso en los marcos basados en eventos, como ahora mostramos. Considere el Módulo de Protocolo Q1 en la Figura 2 que desencadena el evento G para emular una solicitud. El módulo S1 maneja la solicitud. Cuando los módulos SI desencadenan el evento H para emular una respuesta (recuerde que puede ocurrir una respuesta en muchas pilas), tanto los módulos Qi como RI manejarán la respuesta (ambos contienen un controlador unido a H). Este comportamiento no es correcto: solo los módulos de protocolo Qi deben manejar la respuesta. Además, como los módulos RI no se implementan necesariamente para interactuar con los módulos Qi, este comportamiento puede conducir a errores. Existen soluciones para resolver este problema. Sin embargo, introducen una carga innecesaria en los programadores de protocolo y el compositor de pila. Por ejemplo, los canales permiten enrutar eventos para garantizar que los módulos manejen solo los eventos relacionados con ellos. Sin embargo, el programador de protocolo debe tener en cuenta los canales al implementar protocolos. Además, la composición de pilas complejas se vuelve más difícil debido al hecho de que el compositor tiene que crear muchos canales para garantizar que los módulos manejen los eventos correctamente. Una adición de módulos de protocolo especiales (conectores nombrados) para eventos de enrutamiento tampoco es satisfactoria, ya que requiere trabajo adicional del compositor e introduce gastos generales. Notificaciones. Al contrario de las solicitudes y respuestas, las notificaciones están bien modeladas en los marcos basados en eventos. La razón es que las notificaciones corresponden al esquema de comunicación de uno a muchos proporcionado por los eventos. En los marcos basados en servicios, las notificaciones también están bien modeladas. Cuando un módulo genera una notificación a una interfaz de servicio SI, todos los oyentes vinculados a S se ejecutan. Tenga en cuenta que en este caso, las interfaces de servicio proporcionan el mismo patrón de comunicación que los eventos.5.2 Las respuestas de composición del módulo de protocolo (y a veces las notificaciones) son los resultados de una solicitud. Por lo tanto, hay un vínculo semántico entre ellos. El compositor de módulos de protocolo debe preservar este enlace para componer pilas correctas. Explicamos ahora que los marcos basados en servicios proporcionan un mecanismo para preservar este enlace, mientras que en los marcos basados en eventos, la falta de dicho mecanismo conduce a una composición propensa a errores. En los marcos basados en servicios, las solicitudes, las respuestas y las notificaciones se emiten a una interfaz de servicio. Por lo tanto, una interfaz de servicio introduce un enlace entre estas interacciones. Para componer una pila correcta, el compositor tiene que limitar a un oyente a la interfaz de servicio SI para cada módulo que emite una solicitud a SI. Se debe hacer lo mismo para un ejecutor que forma parte de un módulo que emite respuestas o notificaciones. La aplicación de esta metodología simple asegura que cada solicitud emitida a una interfaz de servicio SI eventualmente resulte en varias respuestas o notificaciones emitidas a la misma interfaz de servicio SI. En los marcos basados en eventos, todas las interacciones de protocolo se emiten a través de diferentes eventos: no existe un enlace explícito entre un evento activado por las solicitudes y un evento activado en las respuestas correspondientes. Por lo tanto, el compositor de una pila de protocolo debe conocer el significado de cada evento para preservar el vínculo semántico entre las respuestas (y notificaciones) y las solicitudes. Además, nada evita que vincule un controlador que debería manejar una solicitud a un evento utilizado para emitir una respuesta. Tenga en cuenta que estos problemas pueden resolverse parcialmente escribiendo eventos y manejadores. Sin embargo, no evita los errores si hay varias instancias del mismo tipo de evento. Tenga en cuenta que la composición del protocolo es más clara en los marcos de protocolo que se basan en servicios, en lugar de en eventos. La razón es que varios eventos que se utilizan para modelar diferentes interacciones de protocolo pueden ser modelados por una sola interfaz de servicio.5.3 Reemplazo dinámico de protocolos Reemplazo dinámico de protocolos consiste en cambiar la marcha entre protocolos que resuelven el mismo problema. El reemplazo de un protocolo P por un nuevo protocolo NEWP significa que un módulo de protocolo PI es reemplazado por NewPI en cada pila i. Este reemplazo es problemático ya que los reemplazos locales (dentro de las pilas) deben sincronizarse para garantizar la corrección del protocolo [21, 18]. Q1 Q1 R1 P1 1P 1NEWP 1 REPLA DE REPLACIÓN - P1 REPLACIÓN REWP1 GG H H G T Figura 5: Reemplazo dinámico del protocolo P para los algoritmos de sincronización para funcionar, las interacciones del módulo se interceptan para detectar un momento en que PI debe ser reemplazado por NewPI.(Otras soluciones, por ejemplo, en [11], son más complejas). En la Fig. 5, mostramos cómo esta intercepción se puede implementar en marcos de protocolo que se basan en los servicios (en la parte izquierda de la figura) y los eventos (en la parte derecha de la figura). Las flechas de dos lados apuntan a los módulos de protocolo P1 y Newp1 que se conmutan. Se puede ver que el enfoque que utiliza el mecanismo de interfaz de servicio tiene ventajas. El módulo de interceptación replic-P1 tiene un interceptor vinculado a la interfaz de servicio T que intercepta todas las solicitudes manejadas por los módulos P1 y todas las respuestas y notificaciones emitidas por P1. Por lo tanto, el código del módulo P1 puede permanecer sin cambios. En los marcos basados en eventos, la solución es agregar un módulo intermedio REPL-P1 que intercepta las solicitudes emitidas a P1 y también las respuestas y notificaciones emitidas por P1. Aunque esta solución ad-hoc puede parecer similar al enfoque basado en el servicio, hay una diferencia importante. La solución basada en el evento requiere modificar ligeramente el módulo P1 ya que en lugar de manejar el evento G y activar el evento H, P1 ahora debe manejar diferentes eventos G y H (ver Fig. 5).6. Implementación Hemos implementado un marco de protocolo experimental basado en servicios (llamado Samoa) [7]. Nuestra implementación es liviana: consta de aproximadamente 1200 líneas de código en Java 1.5 (con genéricos). En esta sección, describimos las dos clases principales de nuestra implementación: servicio (codificación de la interfaz de servicio) y 694 interacción de protocolo basada en eventos basada en el servicio, una composición de protocolo de representación inadecuada de representación, reemplazo dinámico de complejo y propenso a errores, un complejo y un reemplazo dinámico propensoMecanismo integrado de soluciones AD-Hoc Tabla 1: Protocolo basado en servicios versus protocolo basado en eventos (módulos de protocolo de codificación). Finalmente, presentamos una pila de protocolo de ejemplo que hemos implementado para validar el enfoque basado en servicios. La clase de servicio. Un objeto de servicio se caracteriza por los argumentos de las solicitudes y los argumentos de las respuestas. Una respuesta es una respuesta o una notificación. Un argumento especial, llamado mensaje, determina el tipo de interacciones modeladas por la respuesta. Un mensaje representa una información enviada a través de la red. Cuando un módulo de protocolo emite una solicitud, puede dar un mensaje como argumento. El mensaje puede especificar el oyente que debe manejar la respuesta. Cuando un módulo de protocolo emite una respuesta a una interfaz de servicio, se emite una respuesta si uno de los argumentos de la respuesta es un mensaje que especifica a un oyente. De lo contrario, se emite una notificación. Los ejecutores, oyentes e interceptores están codificados como las clases intermedias de la clase de servicio. Esto permite proporcionar interacciones con protocolo a prueba de tipo. Por ejemplo, los ejecutores solo pueden estar vinculados al objeto de servicio, pertenecen. Por lo tanto, los parámetros pasados a las solicitudes (que se verifican estáticamente) siempre corresponden a los parámetros aceptados por los ejecutores correspondientes. El tipo de objeto de servicio está determinado por el tipo de argumentos de solicitudes y respuestas. Un objeto de servicio t es compatible con otro objeto de servicio si el tipo de argumentos de solicitudes (y respuestas) de t es un subtipo de los argumentos de solicitudes (y respuestas) de s.En la práctica, si un módulo de protocolo PI puede emitir una solicitud a un protocolo UDP, entonces también puede emitir una solicitud a TCP (compatible con UDP) debido a la relación de subtipo en los parámetros de los módulos de comunicación. La clase de protocolo. Un objeto de protocolo consta de tres conjuntos de componentes, un conjunto para cada tipo de componente (un oyente, un ejecutor y un interceptor). Los objetos de protocolo se caracterizan por nombres para recuperarlos fácilmente. Además, hemos agregado algunas características para unir y desabrochar a todos los ejecutores o interceptores hacia/desde los objetos de servicio correspondientes. Los objetos de protocolo se pueden cargar a una pila dinámicamente. Todas estas características facilitaron la implementación de un reemplazo dinámico de los protocolos de red. Implementación de la pila de protocolo. Para validar nuestras ideas, hemos desarrollado un middleware de comunicación grupal adaptativa (AGC), adoptando los enfoques basados en el servicio y los eventos. La figura 6 muestra las pilas correspondientes del middleware AGC. Ambas pilas permiten que el consenso y los protocolos de transmisión atómica se actualicen dinámicamente. La arquitectura de nuestro middleware, que se muestra en la Fig. 6, se basa en la pila de comunicación grupal descrita en [15]. Los módulos UDP y RP2P proporcionan un transporte punto a punto respectivamente, poco confiable y confiable. El módulo FD implementa un detector de falla;Suponemos que garantiza la pila 1 UDP1RP2P1 REPL CT1 1ABC. REPL CT1 ABC.1 Red FD1 GM1 RP2P NT UDP D F ABCAST CONSENSUS PISTA 1 REPL CT1 1ABC. REPL ABC.1 UDP1 FD1 RP2P1 CT1 RED 1GM Enviar entrega Figura 6: Middleware de comunicación de grupo adaptativo: Propiedades basadas en servicios (izquierda) versus eventos (derecha) del detector de falla 3S [9]. El módulo CT proporciona un servicio de consenso distribuido utilizando el algoritmo Chandratoueg [10]. El ABC.El módulo implementa la transmisión atómica: una comunicación grupal primitiva que entrega mensajes a todos los procesos en el mismo orden. El módulo GM proporciona un servicio de membresía grupal que mantiene datos de membresía consistentes entre los miembros del grupo (ver [19] para más detalles). El replic de ABC.y los módulos CT replican los algoritmos de reemplazo [18] para, respectivamente, el ABC.y los módulos de protocolo CT. Tenga en cuenta que cada flecha en la arquitectura basada en eventos representa un evento. No nombramos eventos en la figura para su legibilidad. La pila izquierda en la Figura 6 muestra la implementación de AGC con nuestro marco basado en servicios. La pila correcta muestra la misma implementación con un marco basado en eventos. Evaluación del desempeño. Para evaluar la sobrecarga de las interfaces de servicio, comparamos el rendimiento de las implementaciones de eventos de servicio y el Middleware AGC. La última implementación de AGC utiliza el marco del protocolo Cactus [5, 2]. En nuestro experimento, comparamos la latencia promedio de la transmisión atómica (ABCast), que se define de la siguiente manera. Considere un mensaje m enviado usando ABCast. Denotamos por ti (m) el tiempo entre el momento de enviar my el momento de entregar M en una máquina (pila) i. Definimos la latencia promedio de M como el promedio de Ti (M) para todas las máquinas (pilas) I dentro de un grupo de pilas. Se han realizado pruebas de rendimiento utilizando un clúster de PC que ejecutan Red Hat Linux 7.2, donde cada PC tiene un procesador Pentium III 766 MHz y 128 MB de RAM. Todas las PC están interconectadas por un concentrador Ethernet Duplex de 100 Base-TX. Nuestro experimento ha involucrado 7 máquinas (pilas) que ABCast Mensajes de 4 MB bajo una carga constante, donde una carga es una serie de mensajes por segundo. En la Figura 7, mostramos los resultados de nuestro experimento para diferentes cargas. Las latencias se muestran en el eje vertical, mientras que las cargas de mensajes se muestran en el eje horizontal. La línea continua muestra los resultados obtenidos con nuestro marco basado en servicios. La línea discontinua muestra los resultados obtenidos con el marco Cactus. El 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 Averagelatencia [MS] Carga [MSG/S] Marco basado en servicios Cactus Figura 7: Comparación entre nuestro marco basado en servicios y gastos generales de cactus de la cabeza basada en el servicioEl marco es de aproximadamente el 10%. Esto se puede explicar de la siguiente manera. En primer lugar, el marco basado en el servicio proporciona una abstracción de nivel superior, que tiene un pequeño costo. En segundo lugar, el AGC Middleware se implementó y optimizó inicialmente para el marco Cactus basado en eventos. Sin embargo, es posible optimizar el Middleware AGC para el marco basado en servicios.7. Conclusión En el documento, propusimos un nuevo enfoque para la composición del protocolo que se basa en la noción de interfaz de servicio, en lugar de eventos. Creemos que el marco basado en servicios tiene varias ventajas sobre los marcos basados en eventos. Nos permite: (1) modelar las interacciones de protocolo con precisión, (2) reducir el riesgo de errores durante la fase de composición y (3) simplemente implementar actualizaciones de protocolo dinámico. Una implementación prototipo nos permitió validar nuestras ideas.8. Referencias [1] El proyecto Appia. Documentación disponible electrónicamente en http://appia.di.fc.ul.pt/.[2] Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting y Wanda Chiu. Coyote: un sistema para construir servicios de comunicación configurables de grano fino. Transacciones ACM en sistemas informáticos, 16 (4): 321-366, noviembre de 1998. [3] Francisco Vilar Brasileiro, Fab´ıola Greve, Frederic Tronel, Michel Hurfin y Jean-Pierre Le Narzul. EVA: Un marco basado en eventos para desarrollar protocolos de comunicación especializados. En Actas del primer Simposio Internacional IEEE sobre computación y aplicaciones de redes (NCA 01), 2001. [4] Daniel C. B¨unzli, Sergio Mena y Uwe Nestmann. Marcos de composición del protocolo. Un modelo dirigido por encabezado. En Actas del 4to Simposio Internacional IEEE sobre Computación y Aplicaciones de Redes (NCA 05), julio de 2005. [5] El Proyecto Cactus. Documentación disponible electrónicamente en http://www.cs.arizona.edu/ cactus/.[6] El proyecto Neko. Documentación disponible electrónicamente en http://lsrwww.epfl.ch/neko/.[7] El proyecto Samoa. Documentación disponible electrónicamente en http://lsrwww.epfl.ch/samoa/.[8] El proyecto SDL. Documentación disponible electrónicamente en http://www.sdl-forum.org/sdl/.[9] Tushar Deepak Chandra, Vassos Hadzilacos y Sam Toueg. El detector de falla más débil para resolver el consenso. Journal of the ACM, 43 (4): 685-722, 1996. [10] Tushar Deepak Chandra y Sam Toueg. Detectores de fallas poco confiables para sistemas distribuidos confiables. Journal of the ACM, 43 (2): 225-267, 1996. [11] Wen-Ke Chen, Matti A. Hiltunen y Richard D. Schlichting. Construcción del software adaptativo en sistemas distribuidos. En Actas de la 21ª Conferencia Internacional IEEE sobre el Sistema de Computación Distribuido (ICDCS 01), abril de 2001. [12] El proyecto del conjunto. Documentación disponible electrónicamente en http://www.cs.cornell.edu/info/ proyects/ensemble/.[13] Richard Ekwall, Sergio Mena, Stefan Pleisch y Andr´e Schiper. Hacia la composición flexible de protocolo de estado finito-estatal. En Actas del 3er Simposio Internacional IEEE sobre Computación y Aplicaciones de Redes (NCA 04), agosto de 2004. [14] Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten y Betty H.C.Cheng. Componiendo software adaptativo. IEEE Computer, 37 (7): 56-64, 2004. [15] Sergio Mena, Andr´e Schiper y Pawel T. Wojciechowski. Un paso hacia una nueva generación de sistemas de comunicación grupal. En Actas de la 4ta Conferencia Internacional de Middleware ACM/IFIP/Usenix (Middleware 03), LNCS 2672, junio de 2003. [16] Hugo Miranda, Alexandre Pinto y Lu´ıs Rodrigues. Appia, un núcleo de protocolo flexible que admite múltiples canales coordinados. En Actas de la 21a Conferencia Internacional IEEE sobre Sistemas de Computación distribuida (ICDCS 01), abril de 2001. [17] Ohad Rodeh, Kenneth P. Birman, Mark Hayden, Zhen Xiao y Danny Dolev. La arquitectura y el rendimiento de los protocolos de seguridad en el sistema de comunicación del grupo conjunto. Informe técnico TR-98-1703, Departamento de Ciencias de la Computación, Universidad de Cornell, septiembre de 1998. [18] Olivier R¨utti, Pawel T. Wojciechowski y Andr´e Schiper. Actualización dinámica de protocolos de acuerdo distribuido. TR IC-2005-12, School of Computer and Communication Sciences, Ecole Polytechnique F´Ed´erale de Lausanne (EPFL), marzo de 2005. [19] Andr´e Schiper. Comunicación de grupo dinámico. Informe técnico IC-2003-27, School of Computer and Communication Sciences, Ecole Polytechnique F´Ed´erale de Lausanne (EPFL), abril de 2003. Aparecer en la computación distribuida ACM.[20] P´eter Urb´an, Xavier D´efago y Andr´e Schiper. Neko: un entorno único para simular y prototipos de algoritmos distribuidos. En Actas de la 15ª Conferencia Internacional sobre Redes de Información (ICOIN 01), febrero de 2001. [21] Pawel T. Wojciechowski y Olivier R¨utti. Sobre la corrección de la actualización del protocolo dinámico. En Actas de la 7ª Conferencia IFIP sobre métodos formales para sistemas distribuidos abiertos basados en objetos (FMoods 05), LNCS 3535. Springer, junio de 2005. 696