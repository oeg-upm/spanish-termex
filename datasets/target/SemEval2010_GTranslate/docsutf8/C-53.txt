Reckoning muerto sincronizado globalmente con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1College of Computer Science, Universidad de Zhejiang, Hangzhou 310027, P.R. China 2School of Computer Science e IT, Universidad de Nottingham, Nottingham Ng8 1BB, Reino Unido {M05zhangyi, Lingchen, chengc}@cs.zju.edu.cn abstracto de la reducción muerta (DR) es un método efectivo para mantener la coherencia para distribuidos continuos distribuidos continuosJuegos multijugador (CDMG). Dado que DR puede filtrar las actualizaciones de estado más innecesarias y mejorar la escalabilidad de un sistema, se usa ampliamente en CDMG comercial. Sin embargo, el DR no puede mantener una alta consistencia, y esto limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, el DR puede lograr una mayor consistencia, pero aún no puede eliminar antes de la inconsistencia. En este artículo, se presenta un método llamado DR sincronizado globalmente con retraso local (GS-DR-LL), que combina retraso local y DR sincronizado globalmente (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retraso. Categorías y descriptores de sujetos c.2.4 [Redes de comunicación por computadora]: sistemas distribuidos - aplicaciones distribuidas. Algoritmos de términos generales, rendimiento, experimentación.1. Introducción hoy en día, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de entidades cambian no solo por las operaciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos se denominan juegos multijugador distribuidos continuos (CDMG). Al igual que otras aplicaciones distribuidas, CDMG también sufre el problema de consistencia causado por el retraso de la transmisión de la red. Aunque nuevas técnicas de red (p. Ej. QoS) pueden reducir o al menos unirse al retraso, no pueden eliminarlo por completo, ya que existe la limitación de la velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso de la transmisión de la red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en la replicación, el retraso de la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar serios problemas, como reducir la equidad de un juego y conducir a situaciones paradójicas, etc. Para mantener la consistencia para los sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y la madera muerta (DR) son dos enfoques representativos. Mauve et al [1] propusieron retraso local para mantener una alta consistencia para aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de emitir una operación en el sitio local, retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por un retraso de transmisión de red excepcional, se propone un mecanismo basado en Warp Time para reparar el estado. El retraso local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operación, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operación solicita que todas las operaciones deben transmitirse de manera confiable, el filtrado de mensajes es difícil de implementar y la escalabilidad de un sistema es limitada. DR se basa en el mecanismo de transmisión de estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, una actualización de estado se transmitiría a todos los sitios y todos los modelos DR se corregirían. A través de la estimación de estado, el DR no solo puede mantener la consistencia sino también disminuir el número de actualizaciones de estado transmitidas. En comparación con el retraso local antes mencionado, el DR no puede mantener una alta consistencia. Debido al retraso de la transmisión de la red, cuando un sitio remoto recibe una actualización estatal de una entidad, el estado de la entidad podría haber cambiado en el sitio enviando la actualización del estado. Para hacer que DR mantenga una alta consistencia, Aggarwal et al [8] propusieron DR sincronizado globalmente (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega sellos de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización estatal disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización estatal a sitios remotos, lo que hace que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar después de la inconsistencia, pero no puede abordar antes de la inconsistencia [8]. En este artículo, proponemos un nuevo método llamado DR sincronizado globalmente con LAG local (GS-DR-LL), que combina LAG local y GS-DR.Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento se organiza de la siguiente manera: la Sección 2 da la definición de consistencia y métricas correspondientes;La causa de la inconsistencia de la DR se analiza en la Sección 3;La Sección 4 describe cómo funciona GS-DR-LL;La evaluación del rendimiento se presenta en la Sección 5;La Sección 6 concluye el documento.2. Definiciones y métricas de consistencia La consistencia de las aplicaciones replicadas ya se ha definido bien en el dominio discreto [9, 10, 11, 12], pero se han realizado pocos trabajos relacionados en el dominio continuo. Mauve et al [1] han dado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operación y es difícil para la definición describir los métodos basados en la transmisión del estado (p. Ej. DR). Aquí, presentamos una definición alternativa de consistencia en el dominio continuo, que se adapta bien a los métodos basados en la transmisión del estado. Dados dos sitios distintos I y J, que han replicado una entidad compartida e, en un momento t, los estados de E en los sitios I y J son SI (T) y SJ (T). Definición 1: Los estados de E en los Sitios I y J son consistentes en el tiempo t, Iff: de (i, j, t) = | si (t) - sj (t) |= 0 (1) Definición 2: Los estados de E en los Sitios I y J son consistentes entre el tiempo T1 y T2 (T1 <T2), Iff: De (I, J, T1, T2) = Dt |) t (S)T (S | T2 T1 Ji = 0 (2) En este documento, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre los sitios locales y remotos. Debido al retraso de la transmisión de la red, es difícil mantener los estados de entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de entidades compartidas entre sitios locales y remotos. De (I, J, T) se puede usar como una métrica para medir el grado de consistencia en un punto de tiempo determinado. Si de (i, j, t1)> de (i, j, t2), se puede afirmar que entre los sitios I y J, la consistencia de los estados de entidad E en el punto de tiempo T1 es menor que el en el punto de tiempo T2. Si de (i, j, t)> de (l, k, t), se puede afirmar que, en el punto de tiempo t, la consistencia de los estados de entidad e entre los sitios I y J es menor que la entre los sitios ly k.Del mismo modo, DE (I, J, T1, T2) se puede utilizar como métrica para medir el grado de consistencia en un período de tiempo determinado. Si de (i, j, t1, t2)> de (i, j, t3, t4) y | t1 - t2 |= | T3 - T4 |, se puede afirmar que entre los sitios I y J, la consistencia de los estados de entidad E entre los puntos de tiempo T1 y T2 es menor que el de los puntos de tiempo T3 y T4. Si de (i, j, t1, t2)> de (l, k, t1, t2), se puede afirmar que entre los puntos de tiempo T1 y T2, la consistencia de los estados de entidad E entre los sitios I y J es más bajoque eso entre los sitios L y K.En DR, los estados de entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dados dos sitios distintos I y J, que han replicado una entidad compartida e, en un punto de tiempo t, las posiciones de E en los sitios I y J son (XIT, YIT, ZIT) y (XJT, YJT, ZJT), DE(I, J, T) y D (i, J, T1, T2) podrían calcularse como: de (i, j, t) =) zz () yy () xx (jtit 2 jtit 2 jtit 2 (3)De (i, j, t1, t2) = dt) zz () yy () xx (2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se usan como métricas para medirLa consistencia de entidades compartidas entre sitios locales y remotos. 3. Inconsistencia en DR La inconsistencia en DR se puede dividir en dos secciones para el punto de tiempo cuando un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se denomina como la inconsistencia, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se denomina después de la inconsistencia. Antes de la inconsistencia y después de la inconsistencia son similares con los términos antes del error de exportación y después del error de exportación [8]. Después de que la inconsistencia es causada por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización del reloj físico, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones estatales, y puede eliminar después de la inconsistencia. Antes de que la inconsistencia sea causada por dos razones. La primera razón es el retraso de enviar actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso de la transmisión de red, ya que una entidad compartida se puede sincronizar solo después de los sitios remotos que reciben la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR.Por ejemplo, se supone que la velocidad de una entidad compartida es el único parámetro para predecir la posición de las entidades, y la posición actual de la entidad puede calcularse mediante su última posición y velocidad de corriente. Para simplificar la descripción, también se supone que solo hay dos sitios I y J en una sesión de juego, el sitio I actúa como 2 el quinto taller sobre el soporte de redes y sistemas para los juegos 2006 - NetGames 2006 Local Site y Site J actúan como remoto como remotoSitio, y T1 es el punto de tiempo que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra las rutas de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR.Al principio, las posiciones de la entidad compartida son las mismas en los sitios I y J y la velocidad de la entidad compartida es 0. Antes del punto de tiempo T0, los caminos de la entidad compartida en los Sitios I y J en X coordenadas son exactamente los mismos. En el punto de tiempo T0, el jugador en el sitio I emite una operación, que cambia la velocidad en el eje x a V0. Sitio I Primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, 0 en este caso, es mayor que un umbral predefinido. En el punto de tiempo T1, sitio que encuentro que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el punto de tiempo T1 y el punto de tiempo T1 también se adjunta como una marca de tiempo. En el punto de tiempo T2, la actualización de estado llega al sitio J, y el estado recibido y la desviación del tiempo entre los puntos de tiempo T1 y T2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio J actualiza su posición y velocidad de entidades replicadas, y las rutas de la entidad compartida en los Sitios I y J se superponen nuevamente. De la Figura 1, se puede ver que la inconsistencia posterior es 0, y la consistencia anterior está compuesta de dos partes, D1 y D2. D1 es DE (I, J, T0, T1) y es causado por el mecanismo de filtrado de estado de DR.D2 es DE (I, J, T1, T2) y es causado por el retraso de la transmisión de la red.4. DR sincronizado globalmente con un retraso local del análisis en la Sección 3, se puede ver que GS-DR puede eliminar después de la inconsistencia, pero no puede abordar de manera efectiva antes de la inconsistencia. Para disminuir antes de la inconsistencia, proponemos GS-DR-LL, que combina GS-DR con el retraso local y puede disminuir efectivamente antes de la inconsistencia. En GS-DR-LL, el estado de una entidad compartida en un punto de tiempo T se observa como S = (t, pos, par 1, par 2, ……, par n), en el que POS significa la posición de laentidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se supone que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son los mismos en sitios locales y remotos, con la misma posición P0 y parámetros PARS0 (PARS representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto SP-Remote y el último estado actualizado a la pizarra del sitio remoto. El sitio remoto mantiene solo un estado sremote, que es el verdadero estado de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego sreal = sp-remote = slate = sremote = (t0, p0, pars0). En GS-DR-LL, se supone que los relojes físicos de todos los sitios se sincronizan con una desviación de menos de 50 ms (usando NTP o reloj GPS). Además, es necesario hacer correcciones a un reloj físico de una manera que no resulte en disminuir el valor del reloj, por ejemplo, disminuyendo o deteniendo el reloj por un período de tiempo. Además, se supone que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms.N significa el valor de retraso utilizado por el retraso local, y T representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de problema. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de problema es entre t y t, en la pizarra para obtener la nueva pizarra, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de problema es entre t - (n + t) y t - n, en sreal para obtener el nuevo sreal. Además, el sitio local utiliza los métodos de predicción SP-Remote y correspondientes para estimar el nuevo SP-Remote. Después de calcular la nueva pizarra, Sreal y SP-Remote, el sitio local compara si la diferencia entre la nueva pizarra y el spremote excede el umbral predefinido. En caso afirmativo, el sitio local envía nueva pizarra al sitio remoto y SP-Remote se actualiza con una nueva pizarra. Tenga en cuenta que la marca de tiempo de la actualización del estado enviado es t.Después de eso, el sitio local usa Sreal para actualizar la escena local y elimina las operaciones, cuyo tiempo de emisión es menor que T - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo,Las tiendas de sitios remotas recibieron actualizaciones estatales en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones estatales cuyas marcas de tiempo son inferiores a T - n.Tenga en cuenta que T es el tiempo físico actual y aumenta durante la transmisión de actualizaciones de estado. En caso afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremote, de lo contrario, usan los métodos de predicción Sremote y correspondientes para estimar el nuevo Sremote. Después de eso, el sitio local usa Sremote para actualizar la escena local y elimina las actualizaciones del sate, cuyas marcas de tiempo son inferiores a T-n, de R. De la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-Ll es que GS-DR-LL usa las operaciones, cuyo tiempo de problema es menor que T-N, para calcular sreal. Eso significa que la escena vista por el jugador local son los resultados de las operaciones emitidas por un período de tiempo (es decir, hace). Mientras tanto, si los resultados de las operaciones emitidas marcan la diferencia entre Slate y SP-Remote exceden un umbral predefinido, las actualizaciones de estado correspondientes se envían a sitios remotos de inmediato. El mencionado anteriormente es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula la pizarra, el sreal y el sp-retremote para diferentes entidades compartidas respectivamente, si hay que transmitir múltiples pizarras, los paquetes del sitio local los paquete en una actualización de estado y luego envíeloa todos los sitios remotos. La Figura 2 ilustra las rutas de una entidad compartida en el sitio local y el sitio remoto mientras usa GS-DR y GS-DR-LL. Todas las condiciones son las mismas con las condiciones utilizadas en el ejemplo mencionado anteriormente que describe GS-DR. En comparación con T1, T2 y N, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el punto de tiempo T0, el jugador en el Sitio I emite una operación, que cambia la velocidad de la entidad compartida Formulario 0 a V0. Al usar GS-DR-LL, los resultados de la operación se actualizan a la escena local en el punto de tiempo T0 + N.Sin embargo, la operación se usa inmediatamente para calcular la pizarra, por lo tanto, a pesar de GS-DR o GS-DR-LL,, en el punto de tiempo T1, encuentro que la diferencia entre la posición precisa y la estimada es más grande que el umbral y envía unActualización estatal al sitio j. En el punto de tiempo T2, la actualización de estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización estatal es menor que T - N, el sitio J lo usa para actualizar la escena local de inmediato. El quinto taller sobre el soporte de red y sistema para los juegos 2006 - NetGames 2006 3 con GS -DR, el período de tiempo antes de la inconsistencia es (T2 - T1) + (T1 - T0), mientras que disminuye a (T2 - T1 - N)+ (T1-T0) con la ayuda de GS-DR-ll. Tenga en cuenta que T2 - T1 es causado por el retraso de la transmisión de la red y T1 - T0 es causado por el mecanismo de filtrado de estado de DR. Si N es más grande que T2-T1, GS-DR-Ll puede eliminar la inconsistencia anterior causada por el retraso de la transmisión de la red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral esté configurado en 0). En juegos altamente interactivos, que solicitan una alta consistencia y se puede emplear GS-DR-LL-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría antes de la inconsistencia es causada por el retraso de la transmisión de la red y GS-DR-LLL tiene la capacidad de eliminar tal antes de la inconsistencia. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retraso N es muy importante, y se deben considerar tanto el retraso de la transmisión de la red como los efectos del retraso local en la interacción. Según los resultados de las investigaciones relacionadas con HCI, los humanos no pueden percibir el retraso impuesto a un sistema cuando es más pequeño que un valor específico, y el valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, no se puede notar un retraso de aproximadamente 150 ms para la interacción del teclado y el umbral aumenta a 195 ms para la interacción del ratón [13], y un retraso de hasta 50 ms no es crítico para un juego de racción de automóviles[5]. Por lo tanto, si el retraso de la transmisión de la red es menor que el valor específico de un sistema de juego, N se puede establecer en el valor específico. De lo contrario, se puede establecer en términos de los efectos del retraso local en la interacción de un sistema [14]. En el caso de que se debe usar una N grande, algunos métodos HCI (por ejemplo, eco [15]) se pueden usar para aliviar los efectos negativos del retraso grande. En el caso de que N sea mayor que el retraso de la transmisión de la red, GS-DR-LL puede eliminar la mayoría de la inconsistencia. Las solicitudes de retraso locales tradicionales de que el valor de retraso debe ser mayor que el retraso típico de la transmisión de la red; de lo contrario, las reparaciones de estado inundarían el sistema. Sin embargo, GS-DR-LL permite que N sea más pequeño que el retraso típico de transmisión de red. En este caso, la inconsistencia anterior causada por el retraso de la transmisión de la red todavía existe, pero puede disminuir.5. Evaluación del rendimiento Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, habíamos implementado ambos métodos en un juego en red llamado SpaceShip [1]. La nave espacial es un juego de computadora en red muy simple, en el que los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar naves espaciales controladas por jugadores remotos con vigas láser. Si una nave espacial es golpeada por un haz láser, sus puntos de vida disminuyen uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que controla la nave espacial pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el lecho de prueba estaba compuesto por dos computadoras conectadas por Ethernet de 100 m, con una computadora actuada como sitio local y el otro actuó como sitio remoto. Para simular el retraso de la transmisión de la red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en términos de un valor de retraso predefinido. El objetivo principal de la evaluación del desempeño es estudiar los efectos de GS-DR-LL en disminución antes de la inconsistencia en un sistema de juego particular bajo diferentes umbrales, retrasos y retrasos en la transmisión de red. Se usaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados de desviación en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retraso de retraso y transmisión de red en la evaluación y podrían dividirse en dos categorías. En una categoría, el retraso se fijó en 300 ms y se utilizaron tres retrasos diferentes de transmisión de red (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de la transmisión de la red se fijó en 800 ms y se usaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Según los registros, se seleccionó una secuencia de suboperación, que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, los relojes físicos de las dos computadoras se sincronizaron primero. En diferentes entornos y enfoques de mantenimiento de consistencia, la secuencia de suboperación seleccionada se reprodujo en una computadora, y condujo las dos naves espaciales, una era local y la otra era remota, para moverse. Mientras tanto, las pistas de las naves espaciales en las dos computadoras se grabaron por separado y se llamaron como una pareja de pistas. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pista grabadas fue de 24. En el último paso, a cada pareja de pistas, se calculó la inconsistencia entre ellos, y la unidad de inconsistencia era píxel. Dado que los relojes físicos de las dos computadoras se sincronizaron, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un punto de tiempo particular era la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo las partes de los resultados, que duran aproximadamente 7 segundos, se usan en las siguientes figuras, y las cifras muestran casi las mismas partes de los resultados. Las Figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retraso se fija en 300 ms y los retrasos en la transmisión de la red son 100, 300 y 500 ms. Se puede ver que la inconsistencia existe, pero en la mayor parte del tiempo es 0. Además, la inconsistencia aumenta con el retraso de la transmisión de la red, pero disminuye con el umbral. En comparación con GS-DR, GS-DR-LL puede disminuir más inconsistencia, y elimina la mayor inconsistencia cuando el retraso de la transmisión de la red es de 100 ms y el umbral es de 4 píxeles o 5 grados.4 El quinto taller sobre soporte de red y sistema para los juegos 2006 - NetGames 2006 Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede eliminarse por completo si el umbral no es 0. Con las definiciones de la inconsistencia antes y después de la inconsistencia, se puede indicar que GS-DR y GS-DR-LL pueden eliminar después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia. Se puede prever que con retraso y umbral adecuados (por ejemplo, el retraso es más grande que el retraso de la transmisión de la red y el umbral es 0), GS-DR-Ll incluso puede eliminar antes de la inconsistencia.0 10 20 30 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Inconsistencia (segundos) (píxeles (píxeles) (píxeles) GS-DR-Ll GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de la transmisión de la red es de 100 ms y el retraso es de 300 ms.0 10 20 30 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Inconsistencia (segundos) (píxeles (píxeles) (píxeles) GS-DR-Ll GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de la transmisión de la red es de 300 ms y el retraso es de 300 ms.0 10 20 30 40 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Inconsistencia (segundos) (píxeles) GS-DR-Ll GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de la transmisión de la red es de 500 ms y el retraso es de 300 ms. Las Figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de la transmisión de la red se fija en 800 ms y el retraso es de 100, 300 y 500 ms. Se puede ver que con GS-DR-ll antes de la inconsistencia disminuye con el retraso. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de la transmisión de la red, de lo contrario, las reparaciones del estado inundarían el sistema. De los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retraso, con GS-DR-Ll, un sistema funcionaría bien incluso si el retraso es mucho más pequeño que el retraso de la transmisión de la red. El quinto taller sobre soporte de red y sistema para los juegos 2006-NetGames 2006 5 De todos los resultados anteriores, puede indicarse que GS-DR y GSDR-LL pueden eliminar después de la inconsistencia, y GS-DR-LLL puede disminuir efectivamente antes de la inconsistencia,y los efectos aumentan con el retraso.0 10 20 30 40 40 0.0 1.5 3.1 4.7 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) inconsistencia (píxeles (píxeles) GS-DR-Ll GS-DR El umbral es de 4 píxeles o 5 grados Figura 6. Inconsistencia cuando el retraso de la transmisión de la red es de 800 ms y el retraso es de 100 ms.0 10 20 30 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Inconsistencia (segundos) (píxeles (píxeles) (píxeles) GS-DR-Ll GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de la transmisión de la red es de 800 ms y el retraso es de 300 ms.0 10 20 30 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Inconsistencia (segundos) (píxeles (píxeles) (píxeles) GS-DR-Ll GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de la transmisión de la red es de 800 ms y el retraso es de 500 ms.6. Conclusiones en comparación con el DR tradicional, GS-DR puede eliminar después de la inconsistencia a través de la sincronización de los relojes físicos, pero no puede abordar antes de la inconsistencia, lo que influiría significativamente en la usabilidad y la equidad de un juego. En este documento, propusimos un método llamado GS-DR-LL, que combina retraso local y GS-DR, para disminuir antes de la inconsistencia al retrasar la actualización de los resultados de ejecución de las operaciones locales a la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retraso. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que el DR mejorado no solo puede eliminarse después de la inconsistencia, sino que también disminuirá 6 El 5º taller en el soporte de redes y sistemas para los juegos 2006-NetGames 2006 antes de la inconsistencia, con el retraso y el umbral adecuados, incluso eliminaría antes de la inconsistencia. Como resultado, la aplicación de DR se puede ampliar enormemente y podría usarse en los sistemas que solicitan una alta consistencia (por ejemplo, juegos altamente interactivos). En segundo lugar, GS-DR-LL muestra que al combinar retraso local y GSDR, se elimina la restricción de seleccionar el valor de retraso y se podría usar un retraso, que es más pequeño que el retraso de transmisión de red típico. Como resultado, la aplicación del retraso local se puede ampliar enormemente y podría usarse en los sistemas que tienen un gran retraso de transmisión de red típico (p. Ej. Juegos basados en Internet).7. Referencias [1] Mauve, M., Vogel, J., Hilt, V. y Effelsberg, W. Local-Lag y TimeWarp: proporcionando consistencia para aplicaciones continuas replicadas. Transacciones IEEE en Multimedia, vol.6, No.1, 2004, 47-57.[2] Li, F.W., Li, L.W. y Lau, R.W. Apoyo a la consistencia continua en los juegos en línea multijugador. En Proc.de ACM Multimedia, 2004, 388-391.[3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de cálculo muerto para los juegos. En Proc.de NetGames, 2002, 79-84.[4] Alhalabi, M.O., Horiguchi, S. y Kunifuji, S. Un estudio experimental sobre los efectos del retraso de la red en el entorno virtual háptico compartido cooperativo. Computadoras y gráficos, vol.27, No. 2, 2003, 205-213.[5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc.de Nossdav, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C. y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc.de IEEE VR, 2003, 141-148.[7] Bernier, Y.W. Métodos de compensación de latencia en el diseño y optimización del protocolo del cliente/servidor. En Proc.de la conferencia de desarrolladores de juegos, 2001. [8] Aggarwal, S., Banavar, H. y Khandelwal, A. Precisión en juegos de juego múltiples basados en la reducción muerta. En Proc.de NetGames, 2004, 161-165.[9] Raynal, M. y Schiper, A. Desde la consistencia causal hasta la consistencia secuencial en los sistemas de memoria compartida. En Proc.de la Conferencia sobre Fundamentos de la Tecnología de Software e Informática Teórica, 1995, 180-194.[10] Ahamad, M., Burns, J.E., Hutto, P.W. y Neiger, G. Memoria causal. En Proc.del taller internacional sobre algoritmos distribuidos, 1991, 9-30.[11] Herlihy, M. y Wing, J. Linealizabilidad: una condición de corrección para objetos concurrentes. Transacciones ACM en lenguajes y sistemas de programación, vol.12, No. 3, 1990, 463-492.[12] Misra, J. Axioms para el acceso a la memoria en sistemas de hardware asincrónicos. Transacciones ACM en lenguajes y sistemas de programación, vol.8, No. 1, 1986, 142-153.[13] Dabrowski, J.R. y Munson, E.V. Es 100 milisegundos demasiado rápido. En Proc.de la Conferencia Sigchi sobre Factores Humanos en Sistemas de Computación, 2001, 317-318.[14] Chen, H., Chen, L. y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Journal of Computer Science and Technology, vol.20, No. 3, 2005, 396-401.[15] Chen, L., Chen, H. y Chen, G.C. Echo: un método para mejorar la calidad de interacción de las CVE. En Proc.de IEEE VR, 2005, 269-270. El quinto taller sobre el soporte de redes y sistemas para los juegos 2006 - NetGames 2006 7