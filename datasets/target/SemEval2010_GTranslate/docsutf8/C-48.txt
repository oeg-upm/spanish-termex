Consultas de rango multidimensional en redes de sensores ∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ Resumen en muchas redes de sensores, datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: enumerar todos los eventos cuya temperatura se encuentra entre 50 ° y 60 °, y cuyos niveles de luz se encuentran entre 10 y 15. Dichas consultas son útiles para correlacionar los eventos que ocurren dentro de la red. En este documento, describimos el diseño de un índice distribuido que admite consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una nueva incrustación geográfica de una estructura de datos de índice clásico, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, Dims se escala bastante bien con el tamaño de la red (tanto la inserción como los costos de consulta como o (√ n)). En simulaciones detalladas, mostramos que en la práctica, los costos de inserción y consulta de otras alternativas son a veces un orden de magnitud más que los costos de los DIM, incluso para la red de tamaño moderado. Finalmente, los experimentos en un lecho de prueba a pequeña escala validan la viabilidad de los dims. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación informática]: sistemas distribuidos;C.3 [Sistemas de uso especial y basados en aplicaciones]: Sistemas integrados Términos generales Sistemas integrados, redes de sensores, almacenamiento 1. La introducción en redes de sensores inalámbricas, datos o eventos será nombrado por atributos [15] o representado como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, niveles de temperatura y luz, condiciones de humedad del suelo, etc. En estos sistemas, argumentamos, una forma natural de consultar para eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: enumere todos los eventos que tienen temperaturas entre 50 ° F y 60 ° F, y niveles de luz entre 10 y 20. Dichas consultas de rango se pueden usar de dos maneras distintas. Pueden ayudar a los usuarios a desestimar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y tal vez mapear el efecto combinado de la temperatura y la luz sobre el crecimiento de los microorganismos marinos. Más importante aún, el software de aplicación se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitat, un ave que se cae en su nido está indicado en una cierta gama de lecturas de sensores de termopil, y una cierta gama de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una mayor detección de confianza de losLlegada de una bandada de pájaros, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, tales consultas de rango son compatibles con índices precomputados. La compensación de índices algunos costos de precomputación inicial para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como el hecho de que el ancho de banda de acceso a este índice central será limitado, particularred). Más bien, creemos, habrá situaciones en las que sea más apropiado construir una estructura de datos distribuidas inneces para responder eficientemente consultas de rango multidimensional. En este artículo, presentamos tal estructura de datos, que llamamos un Dim1. Los DIM están inspirados en los índices de base de datos clásicos, y son esencialmente incrustaciones de tales índices dentro de la red de sensores. Dims aprovecha dos ideas clave: índice distribuido en la red 1 para datos multidimensionales.63 Almacenamiento centrado en datos y un nuevo hash geográfico que presenta la localidad (Sección 3). Dims traza su linaje a los sistemas de almacenamiento de datos datacénicos [23]. El mecanismo subyacente en estos sistemas permite que los nodos hash constantemente un evento en algún lugar dentro de la red, lo que permite una recuperación eficiente de eventos. Sobre la base de esto, los DIMS usan una técnica por la cual los eventos cuyos valores de atributos están cerca pueden almacenarse en los mismos nodos o cercanos. Los DIMS luego usan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para enrutar eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un algoritmos DIM, presentando la inserción y consulta de eventos, para mantener un DIM en caso de falla del nodo y para hacer que las DIMS sean robustas a los datos o la pérdida de paquetes (Sección 3). Luego evaluamos ampliamente los DIMS utilizando el análisis (Sección 4), la simulación (Sección 5) y la implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, Dims se escala bastante bien con el tamaño de la red (tanto la inserción como los costos de consulta como o (√ n)). En simulaciones detalladas, mostramos que en la práctica, la inserción del evento y la consulta de los costos de otras alternativas son a veces un orden de magnitud los costos de DIMS, incluso para una red de tamaño moderado. Los experimentos en un lecho de prueba a pequeña escala validan la viabilidad de los DIM (Sección 6). Queda mucho trabajo, incluido el soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que los DIMS serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única estructura de datos distribuida que respalda consultas eficientes en redes de sensores. Los DIMS formarán parte de un conjunto de tales sistemas que habilitan la extracción de características [7], consulta de rango simple [10], consultas de combate exacto [23] o consultas continuas [15, 18]. Es probable que todos estos sistemas se integren a un sistema de base de datos de red de sensores, como TinyDB [17]. Los diseñadores de aplicaciones podrían elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios usaría DIM para detectar los puntos de acceso, y luego usaría mecanismos que permitan consultas continuas [15, 18] para rastrear el progreso espacio-temporal de los puntos de acceso. Finalmente, observamos que los DIMS son aplicables no solo a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica).2. Trabajo relacionado El problema básico que aborda este documento, consultas de rango multidimensional, generalmente se resuelve en los sistemas de bases de datos utilizando técnicas de indexación. La comunidad de la base de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación esencialmente intercambian algunos costos de inserción de datos para permitir una consulta eficiente. La indexación ha sido, por mucho tiempo, un problema de investigación clásica en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índice de ramificación constante múltiple, ejemplificada por los árboles K-D [2], donde K representa la dimensionalidad del espacio de datos. Nuestro enfoque esencialmente representa una incrustación geográfica de tales estructuras en un campo de sensores. Hay una diferencia importante. Las estructuras de indexación clásica dependen de datos (al igual que algunos esquemas de indexación que utilizan hashes de preservación de la localidad y se desarrollan en la literatura teórica [14, 8, 13]). La estructura del índice se decide no solo por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de los datos. Finalmente, tangencialmente relacionado con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en la indexación distribuida, el problema no se ha explorado ampliamente. Existen índices distribuidos de un tipo restringido, que permiten consultas exactas de coincidencia de prefijo o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el sistema de nombres de dominio de Internet, y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet [4], Chord [24] y Can [19]. Nuestro trabajo es superficialmente similar a CAN en que ambos construyen una superposición basada en la zona sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CANS es puramente lógica, mientras que nuestra superposición es consistente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en los sistemas DHT [1, 12], pero no está claro si estos se traducen directamente en el contexto de la red de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos a las redes de sensores [9, 3, 18], y hay ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMS podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo aparta del trabajo anterior en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo, los datos generados en un nodo están hash (en general) a diferentes ubicaciones. Este hashing es la clave para escalar las búsquedas de rango multidimensional. En todos los otros sistemas descritos anteriormente, las consultas se inundan en toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una opción apropiada de hashing. Madden et al.[17] también describe un índice distribuido, llamado árboles de enrutamiento semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales, mientras que DIM admite múltiples atributos. En segundo lugar, SRT construye un árbol de enrutamiento basado en lecturas de sensores históricos y, por lo tanto, funciona bien solo para los valores del sensor lento. Finalmente, en las consultas SRT se emiten desde un nodo fijo, mientras que en las consultas DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en el enrutamiento centrado en los datos en las redes de sensores [15, 25], donde se supone que los datos generados en un nodo se almacenan en el nodo, y las consultas se inundan en toda la red [15], oCada fuente establece una superposición de toda la red que anuncia su presencia para que los sumideros móviles puedan encontrarse con fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas de larga vida. Finalmente, nuestro trabajo está más relacionado con los sistemas de almacenamiento centrado en datos [23], que incluyen tablas de hash geográficas (GHT) [20], dimensiones [7] y DIFS [10].Nombre a una ubicación dentro de la red, permitiendo una cita altamente eficiente. Los GHT se basan en el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar a un nodo más cercano a una ubicación determinada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos un hash que presenta la localidad para almacenar datos, permitiendo consultas eficientes de rango multidimensional. Se pueden considerar que las dimensiones y los difs usan el mismo conjunto de primitivas que la GHT (almacenamiento con hashing consistente), pero para diferentes extremos: las dimensiones permiten la búsqueda de características de Drill64 en una red de sensores, mientras que DIF permite consultas de rango en una sola clave en una sola clave enAdición a otras operaciones.3. El diseño de DIMS La mayoría de las redes de sensores se implementan para recopilar datos del entorno. En estas redes, los nodos (individualmente o en colaboración) generarán eventos. Un evento generalmente se puede describir como una tupla de valores de atributo, A1, A2, · · ·, AK, donde cada atributo AI representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente consultas de rango multidimensional de la forma: x1-y1, x2-y2, · · ·, xk-yk. Tal consulta devuelve todos los eventos cuyos valores de atributo caen en los rangos correspondientes. Observe que las consultas de puntos, es decir, consultas que solicitan eventos con valores especificados para cada atributo, son un caso especial de consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, particularmente a medida que el sistema escala, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviando todos los eventos a un nodo de almacenamiento externo, el enlace de acceso es un cuello de botella, especialmente si los nodos dentro de las consultas de problemas de red. Shenker et al.[23] también hacen argumentos similares con respecto a los esquemas de almacenamiento centrados en datos en general;Los DIM son una instancia de tales esquemas. El sistema que presentamos en este documento, el DIM, se basa en dos bases: un hash geográfico que presenta la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La información básica subyacente al DIM es que la localidad de datos se puede obtener mediante una función hash geográfica que presenta la localidad. Nuestra función de hash geográfica encuentra un mapeo de conservación de la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico en 2-D;Este mapeo está inspirado en los árboles K-D [2] y se describe más adelante. Además, cada nodo en la red se organiza autoorganizado para reclamar parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio se enrutan y almacenan en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMS utilizan un algoritmo de enrutamiento geográfico desarrollado previamente en la literatura para enrutar los eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], esencialmente permite la entrega de un paquete a un nodo en una ubicación específica. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío de modo codicioso. Cuando no existe tal vecino (como cuando existe un vacío en la red), el nodo inicia el paquete en un transversal de modo perimetral, utilizando la regla de mano derecha bien conocida para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido perimetral que se basan en algoritmos de planarización gráfica susceptibles de implementación distribuida. Para que todo esto funcione, los DIMS hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. En segundo lugar, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos se pueden determinar automáticamente por un sistema de localización o por otros medios. Aunque la idea básica de DIMS puede parecer directa, es un desafío diseñar una estructura de datos completamente distribuida que debe ser robusta para las pérdidas de paquetes y fallas de nodos, pero debe admitir una distribución eficiente de consultas y tratar con los vacíos y obstáculos de la comunicación. Ahora describimos el diseño completo de DIMS.3.1 Zonas La idea clave detrás de Dims, como hemos discutido, es un hash que presenta la localidad geográfica que mapea un evento de atributo múltiple a una zona geográfica. Intuitivamente, una zona es una subdivisión de la extensión geográfica de un campo de sensor. Una zona se define por el siguiente procedimiento constructivo. Considere un rectángulo R en el plano X-Y. Intuitivamente, R es el rectángulo delimitador que contiene todos los sensores con la red. Llamamos a un sub-rectángulo Z de R A Zone, si Z se obtiene dividiendo R K Times, K ≥ 0, utilizando un procedimiento que satisface la siguiente propiedad: después de la división I-Th, 0 ≤ I ≤ k, R esdividido en 2i rectángulos de igual tamaño. Si yo es un número impar (par), la división i-th es paralela al eje y (eje x). Es decir, el rectángulo rimerante R se subdivide primero en dos zonas en el nivel 0 por una línea vertical que divide R en dos piezas iguales, cada una de estas subzones se puede dividir en dos zonas en el nivel 1 por una línea horizontal,etcétera. Llamamos al entero no negativo K el nivel de la zona Z, es decir, el nivel (z) = k.Se puede identificar una zona por un código de código de zona (z) o mediante una dirección de dirección (z). El código del código (z) es una cadena de nivel de longitud de 0-1 (z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primero (desde la izquierda) de código (z) es 0, de lo contrario 1. Si Z se encuentra en la mitad inferior de R, el segundo bit de código (z) es 0, de lo contrario 1. Los bits de código restantes (z) se definen recursivamente en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dadas anteriormente, codificando divisiones de la geografía del campo del sensor por cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del Rectángulo R tiene un código de zona de 1111. Tenga en cuenta que los códigos de zona definen colectivamente un árbol de zona de tal manera que las zonas individuales están en las hojas de este árbol. La dirección de una zona Z, ADDR (Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) se pueden calcular a partir de la otra, suponiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son los mismos, excepto el último bit. Por ejemplo, si el código (Z1) = 01101 y el código (Z2) = 01100, entonces Z1 y Z2 son zonas de hermanos. El subárbol de hermanos de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol de hermanos de la zona está a la izquierda, la zona de respaldo es la zona más derecha en el subárbol de hermanos;De lo contrario, la zona de respaldo es la zona más izquierda en el subárbol de hermanos. Para una Zona Z, Sea P el primer nivel (z) - 1 dígitos de código (z). Deja que la copia de seguridad (z) sea la zona de respaldo de la zona Z. If código (z) = p1, código (copia de seguridad (z)) = P01 ∗ con el mayor número de 1s finales (∗ significa 0 o 1 ocurrencias). Si 65 código (z) = P0, código (copia de seguridad (z)) = P10 ∗ con la mayor cantidad de 0s finales.3.2 Zonas asociadas con nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo limitado) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo del sensor se divide lógicamente en zonas y cada zona se asigna a un solo nodo. Si la red de sensores se implementó de manera similar a la red (es decir, muy regular), entonces es fácil ver que existe una k tal que cada nodo se asigna a una zona de nivel de nivel distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensor sean menos regulares que la cuadrícula. Para algunos K, algunas zonas pueden estar vacías y otras zonas pueden tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir una K fija para el sistema general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asocie el nodo más cercano con él, para alguna definición de más cercano). Debido a que hace que nuestro sistema de enrutamiento de consultas general sea más simple, permitimos nodos en un mapa de mapa a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de la zona. Para cualquier colocación dada de nodos de red, considere un nodo A. Deje que ZA sea la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Observe que esta definición de propiedad puede dejar algunas secciones del campo del sensor no asociado con un nodo. Por ejemplo, en la Figura 2, la Zona 110 no contiene ningún nodo y no tendría un propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de Backup (Z). En nuestro ejemplo, ese propietario de zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dada una colocación de nodo, ¿existe un algoritmo distribuido que permite a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debe ser relativamente sencillo, ya que cada nodo puede determinar simplemente la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor, de modo que ningún otro nodo reside en esa zona. En la práctica, sin embargo, los vacíos y obstáculos de la comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de las zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es mayor que su radio de comunicación y el nodo no puede determinar los límites de su zona solo por comunicación local. Nuestro algoritmo de construcción de zona distribuida defiende la resolución de tales zonas hasta que se inicia una consulta o cuando se inserta un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indecisos porque no hay vecino de radio que pueda ayudar a resolver ese límite). Estos límites indecisos se resuelven más tarde por un transversal perímetro GPSR cuando los mensajes de datos realmente se enrutan. Ahora describimos el algoritmo y lo ilustramos usando ejemplos. En nuestro algoritmo, cada nodo utiliza un límite de matriz [0..3] para mantener los cuatro límites de la zona que posee (Rememfigure 1: una red, donde los círculos representan nodos de sensores y líneas discontinuas marcan el límite de red. 1111 011 00 110100 101 1110 010 Figura 2: El código de zona y los límites. 0 1 0 1 10 10 1 1 10 00 Figura 3: El árbol de zona correspondiente ber que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no elOtras zonas pueden poseer porque esas zonas están desprovistas de nodos). Cuando se inicia un nodo, cada nodo inicializa esta matriz como el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza GPSRS para aprender las ubicaciones de los vecinos dentro del rango de radio. Al enterarse de dicho vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, suponemos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona y A es un vecino recientemente descubierto de A. (el procedimiento contiene (ZA, A) se usa para decidir si se encuentra el nodo A.Dentro de los límites de la zona actual del nodo a). Usando este algoritmo, cada nodo puede decidir de forma independiente y asincrónica su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo para la red en la Figura 1. La Figura 3 describe el árbol de la zona correspondiente. Cada zona reside en un nodo de hoja y el código de una zona es la ruta desde la raíz hasta la zona si representamos la rama a la zona de construcción 66 izquierda (a) 1 mientras contiene (za, a) 2 do si longitud (código (za)) Mod 2 = 0 3 Entonces nuevo Bound ← (Bound [0] + Bound [1])/2 4 Si A.x <nuevo Bound 5 luego Bound [1] ← New Bound 6 más Bound [0] ← NUEVOBound 7 más nuevo Bound ← (Bound [2] + Bound [3])/2 8 if A.Y <nuevo Bound 9 entonces Bound [3] ← New Bound 10 más Bound [2] ← Código de código de zona de actualización de New Bound 11 (ZA ZA) Figura 4: Determinación del límite de zona, donde A.x y A.y representan la coordenada geográfica del nodo A. Insertar-Evento (E) 1 C ← Codificar (E) 2 Si contiene (ZA, C) = True y es interno () = True3 luego almacene E y Salir 4 Enviar mensajes (C, E) Enviar mensaje (C, M) 1 Si ∃ vecino y, cerrador (y, propietario (m), m) = verdadero 2 entonces addr (m) ← addr(Y) 3 de lo contrario si longitud (c)> longitud (código (m)) 4 luego actualice el código (m) y addr (m) 5 fuente (m) ← que llama 6 if es propietario (msg) = true 7 entonces propietario (propietario (m) ← Código de llamadas 8 Enviar (M) Figura 5: Insertar un evento en un DIM. El procedimiento más cercano (a, b, m) devuelve verdadero si el código (a) está más cerca del código (m) que el código (b).La fuente (m) se utiliza para establecer la dirección de origen del mensaje m.niño por 0 y la rama al niño derecho por 1. Este árbol binario forma el índice que utilizaremos en el siguiente evento y procedimientos de procesamiento de consultas. Vemos que los tamaños de zona son diferentes y dependen de las densidades locales y también lo son las longitudes de los códigos de zona para diferentes nodos. Tenga en cuenta que en la Figura 2, hay una zona vacía cuyo código debe ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar el nodo en la zona 1110, establece su límite con la zona vacía a indeciso, porque no escuchó de ningún nodo vecino desde esa dirección. Como hemos mencionado anteriormente, los límites indecisos se resuelven utilizando el modo perimetral GPSRS cuando se inserta un evento o se envía una consulta. Describimos la inserción del evento en el siguiente paso. Finalmente, esta descripción no describe cómo se ajustan los códigos de zona de nodos cuando fallan los nodos vecinos, o surgen nuevos nodos. Regresamos a esto en la Sección 3.5.3.3 Insertando un evento en esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados.3.3.1 Hashing un evento a una zona en la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensor. Ahora describimos un esquema de hashing consistente para un DIM que respalda las consultas de rango en M distintos atributos2, denotemos estos atributos A1... Soy. Por simplicidad, suponga por ahora que la profundidad de cada zona de la red es K, K es un múltiplo de M, y que este valor de K se conoce en cada nodo. Releccionaremos esta suposición en breve. Además, para facilitar la discusión, suponemos que todos los valores de atributos se han normalizado para ser entre 0 y 1. Nuestro esquema de Hashing asigna un código de zona K Bit a un evento de la siguiente manera. Para i entre 1 y m, si ai <0.5, el bit i-th bit del código de zona se asigna 0, de lo contrario 1. Para I entre m + 1 y 2m, si ai-m <0.25 o ai-m ∈ [0.5, 0.75), el bit i-° en la zona se asigna 0, de lo contrario 1, porque las divisiones de siguiente nivel están en 0.25 y0.75 que dividen los rangos a [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considere el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es el código (ZA) = 01110. Esencialmente, nuestro esquema de hash usa los valores de los atributos en forma de round-robin en el árbol de zona (como el de la Figura 3), para asignar un evento de atributo M a un código de zona. Esto recuerda a los árboles K-D [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son integridades espaciales y no incorporan los algoritmos de re-balanceado en los árboles K-D. En nuestro diseño de DIMS, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, suponga que el nodo de codificación es A y su propio código de zona es de longitud KA. Luego, dado un evento E, nodo un solo hashes e a un código de zona de longitud ka. Denotamos el código de zona asignado a un evento E por código (E). Como describimos a continuación, a medida que se enruta el evento, el código (E) se refina por nodos intermedios. Esta evaluación perezosa de los códigos de zona permite que diferentes nodos usen códigos de zona de diferentes longitud sin ninguna coordinación explícita.3.3.2 Enrutamiento de un evento a su propietario El objetivo de haber logrado un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Considere un evento E que acaba de generar en un nodo A. Después de codificar el evento E, el nodo A compara el código (E) con el código (a). Si los dos son idénticos, nodo un evento de tienda e localmente;De lo contrario, el nodo A intentará enrutar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (e) corresponde a alguna zona Z, que es como suposición actual para la zona en la que se debe almacenar el evento E. A ahora invoca GPSR para enviar un mensaje a ADDR (Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código (E) y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, también se marca como el propietario del evento E. Como veremos más adelante, la Zona Adivinada Z, la dirección de dirección (z) y el propietario de E, todos ellos contenidos en el mensaje, se refinaránpor nodos de reenvío intermedio. GPSR ahora entrega este mensaje al siguiente salto hacia Adr (Z) desde A. Este Next Hop Node (Llámalo B) no reenvía inmediatamente el mensaje. Más bien, intenta COM2 Dim no supone que todos los nodos son homogéneos en términos de los sensores que tienen. Por lo tanto, en un DIM dimensional M, un nodo que no posee todos los sensores M puede usar valores nulos para las lecturas correspondientes. Dim trata a NULL como un valor extremo para las comparaciones de rango. Como aparte, una red puede tener muchas instancias tenues ejecutándose simultáneamente.67 Puse un nuevo código de zona para que E obtenga un nuevo código de código (E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si CodeNew (E) es más largo que el código de evento en el mensaje. De esta manera, a medida que el evento se abre camino hacia su propietario, su código de zona se refina. Ahora, B compara su propio código de código (b) con el propietario del código del propietario (e) contenido en el mensaje entrante. Si el código (b) tiene una coincidencia más larga con el código (e) que el propietario actual del propietario (E), entonces B se establece para ser el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará elEvento (veremos cómo sucede esto a continuación). Si el código de zona BS no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto.3.3.3 Resolución de límites de zona indecisos durante la inserción Suponga que algún nodo, por ejemplo, C se considera el destino (o propietario eventual) de E.Recomputando localmente un código para E. En ese caso, C almacena E localmente, pero solo si se deciden los cuatro límites de la zona CS. Cuando esta condición se mantiene, C sabe con certeza que ningún otro nodo ha superado las zonas con ella. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de CS pueden estar indecisos. Si es así, C asume que otros nodos tienen una zona que se superpone con la suya y se propone resolver esta superposición. Para hacer esto, C ahora se establece para ser el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento del modo perimetral GPSRS para sondear alrededor del vacío que causa el límite indeciso. Dado que el mensaje comienza desde C y está destinado a una ubicación geográfica cerca de C, GPSR garantiza que el mensaje se entregará a C si ningún otro nodo actualizará la información en el mensaje. Si el mensaje vuelve a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con CS se marca para ser el propietario del evento, pero de lo contrario no cambia el código de zona de eventos. Este nodo también reconoce que su propia zona se superpone con CS e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta zona de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del rango de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E a 0 y se afirma que es el propietario de E. Dado que A no es un nodo interno, envía E, buscando a otros candidatos al propietario de E. Una vez que E llegue al nodo B, B verá en el propietario de los mensajescampo como código que es el mismo que el suyo. B luego encoge su zona de 0 a 01 de acuerdo con la ubicación de AS que también se registra en el mensaje y envía una solicitud de contracción a A. Al recibir esta solicitud, A también encoge su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, código de zona más largo). Etiquetemos este nodo D. D ahora intenta iniciar la entrega al centroide de la nueva zona. Esto a B 0 0 110 100 1111 1110 101 Figura 6: Los nodos A y B han reclamado la misma zona. A B <0.4,0.8,0.9> Figura 7: un mensaje de evento/consulta (flechas llenas) desencadena la zona de la zona (flechas huecas). A B 01 00 110 100 1111 1110 101 Figura 8: El diseño de la zona después de encogerse. Ahora el nodo A y B se han asignado a diferentes zonas.Podría dar lugar a una nueva caminata perimetral que regrese a D (si, por ejemplo, D es geográficamente más cercana al centroide de la zona). Sin embargo, D no sería el propietario del evento, lo que aún sería C. En el enrutamiento al centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. ahora D avisos de que C era el propietario original, por lo queEncapsula el evento y lo dirige a C. En caso de que haya otro nodo, digamos X, que posee una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente desde su cuenta. X encogerá su zona para resolver la superposición. Si la zona XS es más pequeña o igual a la zona CS, X también enviará una solicitud de contracción a C. Una vez que C reciba una solicitud de contracción, reducirá su zona de manera adecuada y arreglará su límite indeciso. De esta manera, el proceso de formación de la zona se resuelve a pedido de una manera basada en datos.68 Hay varios efectos interesantes con respecto a la caminata perímetro que surgen en nuestro algoritmo. El primero es que hay algunos casos en los que una inserción de eventos puede causar que todo el perímetro exterior de la red se atraviese3. La Figura 6 también funciona como un ejemplo en el que se atraviesa el perímetro exterior. El evento E insertado por A se almacenará eventualmente en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal BS no se cruza con el límite de la red, debe enviar E nuevamente como A, porque B en este caso no es un nodo interno. Pero si la gama de radio nominal de BS se cruza con el límite de la red, tiene dos opciones. Puede suponer que no habrá nodos fuera del límite de la red y, por lo tanto, B es un nodo interno. Este es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora suponiendo que pueda haber otros nodos de los que aún no haya oído hablar. B forzará el mensaje caminar a otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para grandes zonas donde el nodo que posee una zona está lejos del centroide de la zona de propiedad, puede existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al propietario real. Para lidiar con este problema, agregamos una operación adicional en el reenvío de eventos, llamado Discovery de vecinos eficientes. Antes de invocar GPSR, un nodo debe verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Implementamos un mensaje de baliza de GPSR para aprovechar los códigos de zona para los nodos. Entonces, al comparar el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino que es más probable que sea el propietario del evento E. C entrega e a Y, lo que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente.3.3.4 Resumen y pseudocódigo En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar muy bien con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción del evento utiliza una evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminar perimetral GPSRS para fijar los límites de zona indecisos. En la Sección 3.5, abordamos la robustez de la inserción del evento a la pérdida de paquetes o a las fallas de nodo. La Figura 5 muestra el pseudocódigo para insertar y reenviar un evento e.En este pseudo código, hemos omitido una descripción del procedimiento de reducción de la zona. En el código pseudo, el procedimiento es interno () se usa para determinar si la persona que llama es un nodo interno y el procedimiento es propietario () se utiliza para determinar si la persona que llama es más elegible para ser propietario del evento de lo que actualmente se reclama propietario comograbado en el mensaje. Procedimiento Send-Message se usa para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje se ha cambiado, la dirección de origen del paquete también debe cambiarse para evitar ser abandonada por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces.3 Esto sucede con menos frecuencia que para los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata perimetral externa.3.4 Las consultas de resolución y enrutamiento Dimes admiten consultas de puntos4 y consultas de rango. Enrutar una consulta de puntos es idéntica al enrutamiento de un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El desafío clave en las consultas de la zona de enrutamiento es presentado por el siguiente diseño de Strawman. Si toda la red se dividió uniformemente en zonas de profundidad k (para alguna constante K), entonces el consulta (el nodo emitido la consulta) podría subdividir una consulta de rango dado en las subzonas relevantes y las solicitudes individuales de ruta a cada una de las solicitudes de cada uno de loszonas. Esto puede ser ineficiente para consultas de rango grande y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se enruta inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsules más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es asignar una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil;En un árbol de zona (Figura 3), existe algún nodo que contiene toda la consulta de rango en su sub-árbol, y ninguno de sus hijos en el árbol sí. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente al nodo de árbol, y es un prefijo de los códigos de zona de todas las zonas (tenga en cuenta que estas zonas pueden no ser geográficamente contiguas) en el subárbol. El Querier calcula el código de zona de Q, denotado por el código (Q) y luego comienza a enrutar una consulta a ADDR (código (Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) lo divide en múltiples subconsules de menor tamaño si hay una superposición entre la zona de A, Zone (a) y el código de zona asociado conQ, código (Q). Nuestro enfoque para dividir una consulta Q en las subconsules es el siguiente. Si el rango del atributo QS primero contiene el valor 0.5, un divide Q en dos subteres una de cuyos primer atributo varía de 0 a 0.5, y el otro de 0.5 a 1. Luego decide la mitad que se superpone con su propia zona. Vamos a llamarlo QA. Si QA no existe, entonces un deja de dividir;De lo contrario, continúa dividiendo (usando el segundo rango de atributos) y recomputando el control de calidad hasta que el control de calidad sea lo suficientemente pequeño como para que caiga por completo en la zona (a) y, por lo tanto, A ahora puede resolverlo. Por ejemplo, suponga que el nodo A, cuyo código es 0110, es dividir una consulta de rango Q = 0.3 - 0.8, 0.6 - 0.9. Los pasos de división se muestran en la Figura 2. Después de la división, obtenemos tres consultas más pequeñas Q0 = 0.3 - 0.5, 0.6 - 0.75, Q1 = 0.3 - 0.5, 0.75 - 0.9 y Q2 = 0.5 - 0.8, 0.6 - 0.9. Este procedimiento de división se ilustra en la Figura 9 que también muestra los códigos de cada subconsulta después de la división. A luego responde a la subconsulta Q0 con datos almacenados localmente y envía subconsules Q1 y Q2 utilizando el procedimiento descrito anteriormente. En términos más generales, si el nodo A se encuentra dentro del subárbol de zona que cubre al máximo Q, enviará las subconsules que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces una Q ADDENS Q como está (en este caso Q es la consulta original o un producto de una división anterior). La Figura 10 describe el pseudocódigo para el algoritmo de división de zona. Como se muestra en el algoritmo anterior, una vez que se ha reconocido una subconsulta como perteneciente a la zona de llamadas, se invoca la resolución del procedimiento para resolver la subconsulta y enviar una respuesta a la pregunta. Cada mensaje de consulta contiene 4 por consultas de puntos, nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos de índice DIM no son necesariamente claves primarias.69 La ubicación geográfica de su iniciador, por lo que el mensaje de respuesta correspondiente se puede entregar directamente al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas pueden encogerse de manera similar a la contracción durante la inserción. Omitimos esto en el código pseudo.3.5 Robustez Hasta ahora, no hemos discutido el impacto de las fallas de nodos y las pérdidas de paquetes, o las llegadas de nodos y las salidas en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de la consulta y los eventos, y las fallas de nodos pueden dar lugar a datos perdidos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMS se pueden hacer robustos para este tipo de dinámica.3.5.1 Mantenimiento de zonas en secciones anteriores, describimos cómo el algoritmo de descubrimiento de zona podría dejar los límites de la zona indecisos. Estos límites indecisos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de la zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zona (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferirse al nuevo nodo aquellos eventos que almacenan pero que deben pertenecer al nuevo nodo. Antes de que un nodo se apague (si esto es realmente posible), sabe que su nodo de respaldo (Sección 3.1) se apoderará de su zona, y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de nodos también puede causar expansión de zona. Para mantener el mapeo entre las zonas binarias, árboles, nodos de hoja y zonas, permitimos que la expansión de la zona solo ocurra entre las zonas de hermanos (Sección 3.1). La regla es: si la zona de la zona (a) la zona de hermanos se vuelve vacía, entonces una puede expandir su propia zona para incluir su zona de hermanos. Ahora, dirigimos nuestra atención a las fallas de nodo. Las fallas de nodos son como deleciones de nodos, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del rango de radio, la ausencia de mensajes de baliza GPSR puede detectar esto. Una vez que detecta esto, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del rango de radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje contrario;No intercambian mensajes periódicamente a partir de entonces para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenidos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido propiedad del nodo fallido ahora se entregará al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y se garantiza que se visitará en un recorrido perimetral GPSR. A se estableció para ser el propietario del mensaje, y cualquier nodo que hubiera eliminado este mensaje debido a un bucle perimetral redirigirá el mensaje a A. Si la zona es el hermano de la zona BS, A puede expandir de manera segura su propia zona y notificar su zona ampliada a sus vecinos a través de mensajes de baliza GPSR.3.5.2 Prevención de la pérdida de datos por falla del nodo Los algoritmos descritos anteriormente son robustos en términos de formación de la zona, pero la falla del nodo puede borrar los datos. Para evitar esto, los DIM pueden emplear dos tipos de replicación: la replicación local para ser resistente a las fallas de nodos aleatorios y la replicación reflejada para la resiliencia a la falla concurrente de los nodos geográficamente contiguos. La replicación de espejo es conceptualmente fácil. Supongamos que un evento E tiene un código de código de zona (E). Luego, el nodo que inserta E almacenaría dos copias de E;uno en la zona denotada por el código (e) y el otro en la zona correspondiente al complemento de código (e). Esta técnica esencialmente crea un espejo tenue. Una pregunta necesitaría, en paralelo, consultar tanto el DIM original como el espejo ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, la compensación aquí es una duplicación aproximada de la inserción y los costos de consulta. Existe una técnica mucho más barata para garantizar la resiliencia a las fallas de nodos aleatorios. Nuestra técnica de replicación local se basa en la observación de que, para cada nodo A, existe un nodo único que se apoderará de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de zonas (ver Sección 3.1). La idea básica es que una replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Deje que como réplica local sea B. A menudo, B será un vecino de radio de A y se puede detectar a partir de balizas GPSR. A veces, sin embargo, este no es el caso, y B tendrá que ser descubierto explícitamente. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local está basada en datos y utiliza un mecanismo similar al de la inserción del evento. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de un tal que GPSR garantizará que el mensaje se entregará a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código (a), uno para el propietario del propietario (a) de la zona (a) que está establecida y otra para la ubicación geográfica del propietario(A). Luego, el paquete se entregará en modo perimetral GPSR. Cada nodo que reciba este mensaje comparará su código de zona y código (a) en el mensaje, y si es más elegible ser el propietario de la zona (a) que el propietario actual (a) registrado en el mensaje, se actualizaráEl propietario del campo (a) y la ubicación geográfica correspondiente. Una vez que el paquete vuelva a A, sabrá la ubicación de su réplica local y puede comenzar a enviar réplicas. En una red de sensores densos, la réplica local de un nodo generalmente está muy cerca del nodo, ya sea su vecino directo o 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, una réplica local de nodos puede fallar. Hay dos formas de lidiar con esta situación;Actualizaciones periódicas o descubrimiento repetido de réplicas locales. El primero tiene una sobrecarga más alta, pero descubre más rápidamente réplicas fallidas.3.5.3 Robustez a la pérdida de paquetes Finalmente, los mecanismos para la consulta y la inserción del evento se pueden hacer fácilmente resistente a la pérdida de paquetes. Para la inserción de eventos, un esquema ACK simple es suficiente. Por supuesto, las consultas y las respuestas también se pueden perder. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el Querier sabe qué zonas caen dentro de su consulta y deberían haber respondido (suponemos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un reconocimiento negativo). Después de un tiempo de espera conservador, el Querier puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener ninguna respuesta (positiva o negativa) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <<0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de consulta de rango dividiendo la quirera de rango de resolución (Q) 1QSUB ← Nil 2 Q0, QSUB ← Split-Query (Q) 3 Si q0 = nil 4 entonces c ← codifica (q) 5 si contiene (c, código (a)) = verdadero 6 entonces vaya al paso 12 7 más envío-Mensaje (c, q0) 8 más resuelve (q0) 9 si es interno () = true 10 entonces absorbe (q0) 11 más o más o más Q0 a QSUB 12 Si qsub = nil 13 entonces para cada subconterrado q ∈ QSUB 14 do c ← codificar(q) 15 envío de mensajes (c, q) Figura 10: Algoritmo de resolución de consulta ciertas zonas Después de tiempos de espera repetidos, al menos puede devolver los resultados de la consulta parcial a la aplicación junto con la información sobre las zonas de las que faltan datos.4. DIMS: un análisis en esta sección, presentamos una evaluación de rendimiento analítica simple de DIMS y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensional en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el costo de inserción promedio mide el número promedio de mensajes necesarios para insertar un evento en la red. El costo promedio de entrega de consultas Mide el número promedio de mensajes necesarios para enrutar un mensaje de consulta a todos los nodos relevantes en la red. No mide el número de mensajes requeridos para transmitir respuestas al consulta;Este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos DIMS. En Dims, la inserción del evento esencialmente utiliza el enrutamiento geográfico. En una densa red de nodo N donde la probabilidad de atravesar perímetros es pequeña, el costo promedio de inserción del evento proporcional a √ n [23]. Por otro lado, el costo de entrega de consultas depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subteres, hacerlo solo cuando la consulta se acerca a la zona que cubre el rango de consulta. Por lo tanto, cuando el Querier está lejos de la zona consultada, hay dos componentes para el costo de entrega de consultas. El primero, que es proporcional a √ n, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura, hay M nodos, el costo de entrega de mensajes de dividir la consulta es proporcional a M. El costo promedio de la entrega de consultas depende de la distribución de los tamaños de rango de consulta. Ahora, supongamos que los tamaños de consulta siguen la función de densidad F (x), entonces el costo promedio de resolver una consulta puede ser aproximado por ê n 1 xf (x) dx. Para dar cierta intuición para el rendimiento de DIMS, consideramos cuatro formas diferentes para F (x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta puntual;Una distribución uniforme limitada donde todos los tamaños de hasta una B con límite son igualmente probables;Una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las consultas grandes son algo probables;y una distribución exponencial donde la mayoría de las consultas son pequeñas y grandes consultas son poco probables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional a la cantidad de nodos que pueden responder esa consulta. Para la distribución uniforme P (x) ∝ c para alguna constante c.Si cada tamaño de consulta de 1... N es igualmente probable, el costo promedio de entrega de consultas de consultas distribuidas uniformemente es o (n). Por lo tanto, para las consultas distribuidas uniformemente, el rendimiento de DIMS es comparable al de las inundaciones. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red están tratando de correlacionar los eventos, la distribución uniforme es altamente poco realista. Algo más realista es una situación en la que todos los tamaños de consulta están limitados por un B. constante B. En este caso, el costo promedio para resolver dicha consulta es aproximadamente ê b 1 xf (x) dx = o (b). Recuerde ahora que todas las consultas tienen que pagar un costo aproximado de O (√ n) para entregar la consulta cerca de la zona de cobertura. Por lo tanto, si Dim limitó consultas a un tamaño proporcional a √ n, el costo promedio de consulta sería o (√ n). La distribución algebraica, donde f (x) ∝ x - K, para un k constante entre 1 y 2, tiene un costo de resolución de consulta promedio dado por ê n 1 xf (x) dx = o (n2 -k). En este caso, si K> 1.5, el costo promedio de la entrega de consultas está dominado por el costo de entregar la consulta a cerca de la zona de cobertura, dada por O (√ n). Finalmente, para la distribución exponencial, f (x) = ce - cx para una c constante, y el costo promedio es solo la media de la distribución correspondiente, es decir, o (1) para N. grande asintóticamente, entonces, el costo deLa consulta para la distribución exponencial está dominada por el costo de entregar la consulta cerca de la zona de cobertura (O (√ n)). Por lo tanto, vemos que si las consultas siguen la distribución uniforme limitada, la distribución algebraica o la distribución exponencial, el costo de consulta se escala como el costo de inserción (para la elección apropiada de constantes para el uniforme limitado y las distribuciones algebraicas). ¿Qué tan bien se compara el rendimiento de DIMS con opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan centralmente en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O (√ n) y un costo de consulta cero. Sin embargo, como señala [23], dichos sistemas pueden no ser prácticos en las redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto de acceso. Una segunda implementación alternativa almacenaría eventos en el nodo donde se generan. Las consultas se inundan 71 en toda la red, y los nodos que tienen datos coincidentes responden. Los ejemplos de sistemas que pueden usarse para esto (aunque, hasta donde sabemos, estos sistemas no implementan consultas de rango multidimensional) se dirigen difusión [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero un costo de consulta O (n). Es fácil demostrar que DIMS superan las inundaciones siempre que la relación entre el número de inserciones al número de consultas sea inferior a √ N. Una alternativa final sería usar una tabla de hash geográfica (GHT [20]). En este enfoque, se supone que los valores de los atributos son enteros (en realidad, es una suposición bastante razonable ya que los valores de atributos a menudo se cuantifican), y los eventos se cuestionan en algunos (por ejemplo, el primero) atributo. Una consulta de rango se subdivide en varias subteres, una para cada entero en el rango del primer atributo. Cada subcontrol se ha asaltado a la ubicación apropiada. Los nodos que reciben un subcrefery solo devuelven eventos que coinciden con todos los demás rangos de atributos. En este enfoque, que llamamos GHT-R (GHTS para consultas de rango) el costo de inserción es o (√ n). Suponga que el rango del primer atributo contiene valores discretos. Entonces el costo de entregar consultas es o (r √ n). Por lo tanto, asintóticamente, los GHT-R se desempeñan de manera similar a los DIM. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y las atenuadas superan a los GHT-R, como mostraremos utilizando simulaciones detalladas.5. DIMS: Resultados de simulación Nuestro análisis nos da una idea del comportamiento asintótico de varios enfoques para consultas de rango multidimensional. En esta sección, utilizamos la simulación para comparar los DIMS con las inundaciones y GHT-R;Esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos da una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques.5.1 Metodología de simulación Usamos NS-2 para nuestras simulaciones. Dado que los DIM se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de NS-2. Modificamos el módulo GPSR para llamar a nuestra implementación tenue cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de soltar un mensaje porque ese mensaje atravesó todo el perímetro. Esto permite un DIM para modificar los códigos de zona de mensajes en el vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, a esto, implementamos en NS-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión de consultas selectivas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para el trabajo futuro. Nuestra implementación DIM en NS-2 es 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en NS-2. Esta implementación fue relativamente directa, dado que habíamos portado GPSR y modificamos GPSR para detectar la finalización de los recorridos del modo perimetral. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundaciones y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un rango de radio de 40 m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodo;Están de acuerdo con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera primero 3 eventos5 en promedio (más precisamente, para una topología de tamaño N, tenemos eventos 3n, y es igualmente probable que cada nodo genere un evento). Hemos realizado experimentos para tres distribuciones de valor de eventos diferentes. Nuestra distribución de eventos uniformes genera eventos bidimensionales y, para cada dimensión, cada valor de atributo es igualmente probable. Nuestra distribución normal de eventos genera eventos bidimensionales y, para cada dimensión, el valor del atributo normalmente se distribuye con una media correspondiente al punto medio del rango de valor de atributo. La distribución normal del evento representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos traza es una colección de eventos 4 dimensionales obtenidos de una red de monitoreo de hábitat. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de tal manera que, en promedio, cada nodo genera 2 consultas. Los tamaños de consulta se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: Uniforme, Boundeduniform, Algebraico y Exponencial. Una vez que se ha determinado un tamaño de consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen uniformemente. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completen en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local desactivando las fracciones aleatorias de los nodos y midiendo la fidelidad de los resultados devueltos. Las métricas principales para nuestras simulaciones son la consulta promedio y los costos de inserción, como se define en la Sección 4. 5.2 Resultados, aunque hemos examinado casi todas las combinaciones de factores descritos anteriormente, discutimos solo los más destacados aquí, por falta de espacio. La Figura 11 traza los costos de inserción promedio para DIM y GHT-R (para las inundaciones, por supuesto, los costos de inserción son cero). DIM incurre menos por sobrecarga de eventos en la inserción de eventos (independientemente de la distribución real del evento; la Figura 11 muestra el costo de eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi todos los eventos incurre en un recorrido perimetral, y almacenar algunos eventos requiere atravesar el perímetro exterior de la red [20]. Por el contrario, en DIM, el almacenamiento de un evento incurre en un transversal perimetral solo cuando los límites de los nodos están indecisos. Además, una inserción o una consulta en un tenue puede atravesar el perímetro externo (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 traza el costo promedio de consulta para una distribución de tamaño de consulta uniforme limitada. Para este gráfico (y el siguiente) utilizamos una distribución de eventos uniformes, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1 4º del tamaño del más grande posible 5 nuestras métricas se eligen para que el número exacto de eventos y consultas no sea importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Como no tenemos relaciones realistas para estos, nos centramos en los costos microscópicos, en lugar de en los costos generales del sistema.72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AVERAGECTPERINSERTION Tamaño de la red DIM GHT-R Figura 11: Costo de inserción promedio para DIM y GHT.0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 FRACCIÓNFREPLIESCOMAREDINEWITHNON-FAILURECASE Fracción de nodos fallidos (%) Sin replicación Replicación local Figura 12: rendimiento de replicación local.consulta (por ejemplo, una consulta de la forma 0 - 0.5, 0 - 0.5. Incluso para este generoso tamaño de consulta, los dims funcionan bastante bien (casi un tercio del costo de las inundaciones). Observe, sin embargo, que los GHTR incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsules como el ancho del primer rango de atributos. La Figura 14 traza el costo promedio de consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en el 1 16º la mayor consulta posible). La escala superior de DIMS es evidente en estos gráficos. Claramente, este es el régimen en el que uno podría esperar que los DIM funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que uno esperaría usar consultas de rango multidimensionales: realizar correlaciones relativamente estrictas. Al igual que con la distribución uniforme limitada, el costo de la consulta de GHT está dominado por el costo de enviar subcenerías;Para DIMS, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, realizamos el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos de manera uniforme en toda la red, luego emitimos una consulta que cubre toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción F de los nodos al azar y volvimos a emitir la misma consulta. La figura traza la fracción de las respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallas aleatorias, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos han fallado simultáneamente 6. En ausencia de replicación local, por supuesto, cuando 6 en la práctica, el rendimiento del rendimientode la replicación local es probable que 0 100 200 200 300 400 500 600 700 50 100 150 200 250 300 AVERAGECESTERQUERYINInBoundedededUnifdistribution Tamaño de red Dim inundación Dim GHT-R Figura 13: Costo de consulta promedio con una distribución de consultas uniformes limitadas 0 50 100 150 200 250 300 350 400 400 450 450 45050 100 150 200 250 300 AveraGecostperQueryinExponentIndistribution Tamaño de la red Dim inundación GHT-R Figura 14: Costo promedio de consulta con una distribución de consultas exponencial El 30% de los nodos fallan, la tasa de respuesta es solo el 70% como se esperaría. Observamos que DIMS (según lo diseñado actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo fue para nuestro conjunto de datos de rastreo de la aplicación de monitoreo de hábitat, donde la mayoría de los valores de eventos cayeron dentro del 10% de los atributos que rango, unos pocos nodos tenues se convertirán claramente en el cuello de botella. Esto se representa en la Figura 15, que muestra que para DIMS y GHT-RS, el número máximo de transmisiones en cualquier nodo de red (los puntos calientes) es bastante alto.(Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de punto de acceso para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han tratado mediante el reequilibrio de los árboles. En nuestro caso, pueden ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de rastreo demuestra que las DIMS funcionan para eventos que tienen más de dos dimensiones. El aumento del número de dimensiones no degrada notablemente el costo de la consulta Dims (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIM son comparables en el rendimiento de las inundaciones cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de los tamaños de consulta, el rendimiento relativo es cercano a la de la distribución exponencial. Para eventos normalmente distribuidos, los costos de inserción serán mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente a menudo, un nodo casi siempre detectará una falla de réplica y replicará, lo que lleva a tasas de respuesta cercanas al 100%.73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MÁXIMUMHOTSPOTONTRACEDACIÓN Tamaño de red Tamaño de red Dim inundación Dim Ght-R Figura 15: Uso de Hotspot Manager Dim Zone Consulta Consulta Procesador de consultas Event Manager Event Router Interface GPSR (basado en eventos/hilo basado) Actualización Useuse Useuse UseusInterfaz superior GPSR (basado en eventos basado/basado en hilos) Interfaz inferior (basado en eventos/basado en hilos) Reenvío avanzado Reenvío de reenvío Beaconing Actualización de la lista de la lista de vecinos Use el socket IP de Motenic (Micaradio) (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSRson comparables a la de la distribución uniforme. Finalmente, observamos que en todas nuestras evaluaciones solo hemos utilizado consultas de listas (aquellos que solicitan todos los eventos que coincidan con el rango especificado). Esperamos que para consultas sumarias (aquellas que esperan un agregado sobre los eventos coincidentes), el costo general de los DIM podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos una comprensión de esto para el trabajo futuro. También se queda al trabajo futuro una comprensión detallada del impacto del error de ubicación en los mecanismos DIMS. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa sobre otros mecanismos de almacenamiento centrados en datos, como GHT, y descubrió que existen correcciones relativamente simples para GPSR que mejoran los efectos del error de ubicación.6. Implementación Hemos implementado DIMS en una plataforma Linux adecuada para la experimentación en PDA y máquinas de clase PC-104. Para implementar DIMS, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación tenue tiene la mayoría de los algoritmos discutidos en la Sección 3;Algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. Todo el sistema (aproximadamente 5000 líneas de código) está impulsado por eventos y múltiples. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones GPSR. El sistema GPSR se implementa como proceso de demonio a nivel de usuario. Las solicitudes se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de la consulta N.0 2 4 6 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Consulta SizetotalnumberOfMessages Sólo Forsing the Query Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre los vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes durante los paquetes.y terminación del modo perimetral. Probamos nuestra implementación en un Bed de prueba que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y usa una mota de mica (unida a través de un cable serie) para la comunicación. Estas cajas se establecen en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de la red es aproximadamente una cadena. En esta prueba de prueba, insertamos consultas y eventos de un solo nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 traza el número de eventos recibidos para consultas de diferentes tamaños. Puede parecer que recibimos menos eventos de lo esperado, pero este gráfico no cuenta los eventos que ya estaban almacenados en la Quera. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro Bed de prueba. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de DIMS como nuestras simulaciones, sin embargo, sirven como prueba de concepto para DIMS. Nuestro siguiente paso en la implementación es portuar las tenencias de las motas de mica e integrarlas en el motor de la base de datos del sensor TinyDB [17] en las motas.74 7. Conclusiones En este documento, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensional en redes de sensores. Nuestro diseño de DIMS se basa en un nuevo hash que presenta la localidad inspirada en el trabajo temprano en la indexación de bases de datos, y se basa en GPSR. Tenemos un prototipo de trabajo, tanto de GPSR como DIM, y planeamos realizar experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Uno es la adaptación a las distribuciones de datos sesgadas, ya que pueden causar puntos calientes de almacenamiento y transmisión. A diferencia de los índices de base de datos tradicionales que reequilibran los árboles en la inserción de datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho mayor después de obtener una estimación global aproximada de la distribución de datos. Otra dirección es el soporte para la heterogeneidad del nodo en el proceso de construcción de la zona;Los nodos con espacio de almacenamiento más grande afirman zonas de mayor tamaño para ellos. Un tercero es el soporte para la resolución eficiente de las consultas existenciales, ya sea que exista un evento que coincide con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del Lab Lab, así como de los comentarios proporcionados por los revisores y nuestro pastor Feng Zhao.8. Referencias [1] J. Aspnes y G. Shah. Omita gráficos. En Actas del 14º Simposio ACM-SIAM anual sobre algoritmos discretos (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binarios multidimensionales utilizados para la búsqueda asociativa. Comunicaciones de la ACM, 18 (9): 475-484, 1975. [3] P. Bonnet, J. E. Gehrke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de datos móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: un sistema distribuido de almacenamiento y recuperación de información anónima. En el diseño de tecnologías de mejora de la privacidad: taller internacional sobre temas de diseño en anonimato y no observabilidad. Springer, Nueva York, 2001. [5] D. Comer. El ubicuo árbol B. ACM Computing Surveys, 11 (2): 121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Quadreos: una estructura de datos para recuperar las claves compuestas. Acta Informatica, 4: 1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. Dimensiones: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para redes de sensores? En Actas del primer taller sobre temas calientes en redes (Hotnets-I), Princeton, NJ, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en altas dimensiones a través del hashing. En Actas de la 25ª Conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: un índice distribuido para características en redes de sensores. En Actas del 1er Taller Internacional IEEE sobre protocolos y aplicaciones de la red de sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-TRES: una estructura de índice dinámico para la búsqueda espacial. En Actas del ACM Sigmod, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes entre pares basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas de Pesos (IPTPS02), Volumen 2429 de LNCS, Página 242, Cambridge, MA, marzo de 2002. Springer-Verlag.[13] P. Indyk y R. Motwani. Vecinos aproximados más cercanos: hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio ACM anual sobre teoría de la computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. El hashing de preservación de la localidad en espacios multidimensionales. En Actas del 29º Simposio ACM anual sobre teoría de la computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press.[15] C. Intanagonwiwat, R. Govindan y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual de ACM/IEEE sobre informática móvil y redes (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: enrutamiento de estado de estado perimetral codicioso para redes inalámbricas. En Actas de la Sexta Conferencia Internacional Anual de ACM/IEEE sobre computación y redes móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consulta adquisición para redes de sensores. En Actas de ACM Sigcmod, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. Etiqueta: un pequeño servicio de agregación para redes de sensores ad-hoc. En Actas del 5º Simposio anual sobre el diseño e implementación de sistemas operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de contenido directo. En Actas de ACM Sigcomm, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: una tabla de hash geográfica para el almacenamiento centrado en los datos. En Actas del primer Taller Internacional de ACM sobre redes y aplicaciones de sensores inalámbricos, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Sistemas de base de datos modernos: el modelo de objetos, interoperabilidad y más allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento de la cara geográfica en las redes de sensores. En Sub Submisión, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en los datos en Sensornets. En Proc. Taller ACM Sigcomm sobre temas calientes en redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Acorde: un servicio de búsqueda de pares escalable para aplicaciones de Internet. En Actas de ACM Sigcomm, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la octava Conferencia Internacional ACM/IEEE sobre computación y redes móviles (Mobicom02), Atlanta, GA, septiembre de 2002. 75