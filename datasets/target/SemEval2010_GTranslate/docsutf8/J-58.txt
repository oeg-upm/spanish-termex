Hacia los mecanismos veraces para los juegos de demanda binaria: un marco general Ming-yang Kao ∗ Departamento. de informática Northwestern University Evanston, IL, EE. UU. kao@cs.northwestern.edu xiang-yang li † Departamento de informática Illinois Instituto de Tecnología Chicago, IL, EE. UU. Xli@cs.iit.edu Weizhao Wang Dept. de Computer Science de ComputerInstituto de Tecnología de Illinois Chicago, IL, EE. UU. Wangwei4@iit.edu Resumen La familia de los mecanismos de Vickrey-Clarke-Groves (VCG) es posiblemente el logro más famoso en el diseño del mecanismo veraz. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Solo se aplican a los problemas de optimización con una función objetivo utilitaria (o afina), y su salida debe optimizar la función objetivo. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos de VCG a algoritmos de tiempo polinomial que se aproximan a la solución óptima, los mecanismos resultantes ya no pueden ser sinceros. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un esquema de pago sin VCG que sea computacionalmente manejable para una regla de asignación dada O. En este documento, centramos nuestra atención en los juegos de demanda binaria en los que los agentes solo las acciones disponibles deben participar en el juego A o no. Para estos problemas, demostramos que un mecanismo veraz M = (O, P) existe con un método de pago adecuado sobre la regla de asignación o satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar dicho P. Proponemos además varias técnicas generales basadas en composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P se puede calcular a través de/y combinaciones, combinaciones basadas en la ronda y algunas combinaciones más complejas de las salidas de los subjuegos. Categorías y descriptores de sujetos F.2 [Análisis de algoritmos y complejidad del problema]: general;J.4 [Ciencias sociales y conductuales]: Economía;K.4.4 [Computer and Society]: Algoritmos de términos generales de comercio electrónico, Economía, Teoría 1. Introducción En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y confiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos en los que los agentes son egoístas en lugar de altruistas, es más razonable suponer que estos agentes son racionales, maximizan sus propias ganancias, según la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño del mecanismo algorítmico y los mecanismos de VCG aplicados a algunos problemas fundamentales en la informática, incluidas las rutas más cortas, los árboles mínimos y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño del mecanismo cuyas salidas optimizan la función objetivo utilitaria, que es simplemente la suma de las valoraciones de todos los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias;Incluso para esos problemas con una función objetivo utilitaria, a veces es imposible encontrar el resultado óptimo en el tiempo polinomial a menos que p = NP. Se necesitan algunos mecanismos distintos del mecanismo VCG para abordar estos problemas. Archer y Tardos [2] estudiaron un problema de programación en el que es difícil encontrar la salida óptima. Señalaron que una determinada propiedad de monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al.[3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos deterministas de Aprolitación (2 +) para cualquier número fijo de máquinas y varios mecanismos influyentes (1 +) para algunas restricciones difíciles de su problema de programación. Lehmann et al.[12] estudiaron la subasta combinatoria determinada y dio un mecanismo veraz de la acroximación m, donde M es el número de bienes. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el espíritu más cercano a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una determinada propiedad de monotonicidad en un entorno de subasta decidida. También mostraron cómo usar Max e If-Then-else para combinar salidas de subproblemas. Como se muestra en este documento, las combinaciones MAX e IF-Then-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en el tiempo polinomial bajo supuestos leves. En términos más generales, estudiamos cómo diseñar mecanismos veraces para los juegos de demanda binaria donde la asignación de un agente es seleccionada o no seleccionada. También suponemos que las valoraciones 213 de los agentes no están correlacionadas, es decir, la valoración de un agente solo depende de su propia asignación y tipo. Recuerde que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un esquema de pago P. Anteriormente, a menudo se supone que existe una función objetivo G y una regla de asignación O, que optimiza exactamenteo aproximadamente. A diferencia de los mecanismos de VCG, no requerimos que la asignación sea optimizar la función objetivo. De hecho, ni siquiera requerimos la existencia de una función objetivo. Dada cualquier regla de asignación o para un juego de demanda binaria, demostramos que existe un mecanismo veraz M = (O, P) para el juego si y solo si o satisface una determinada propiedad de monotonicidad. La propiedad de la monotonicidad solo garantiza la existencia de un esquema de pago P tal que (O, P) es sincero. Complementamos este teorema de existencia con un marco general para diseñar dicho esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subgamas a través de los operadores o y y;a través de combinaciones basadas en la ronda;o a través de resultados intermedios, que pueden calcularse a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos preliminares y trabajos anteriores, definimos juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que satisfacer una determinada propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). Luego se propone un marco en la Sección 4 para calcular el pago P en tiempo polinomial para varios tipos de reglas de asignación O. En la Sección 5, proporcionamos varios ejemplos para demostrar la efectividad de nuestro marco general. Concluimos nuestro documento en la Sección 6 con algunas posibles direcciones futuras.2. Preliminares 2.1 Diseño del mecanismo Como generalmente se hace en la literatura sobre el diseño de algoritmos o protocolos con aportes de agentes individuales, adoptamos la suposición en la economía neoclásica de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviaremos de losProtocolo solo si la desviación mejora su ganancia. Un modelo estándar para el diseño del mecanismo es el siguiente. Hay n agentes 1 ,..., n y cada agente I tiene cierta información privada Ti, llamada su tipo, solo conocido por sí mismo. Por ejemplo, el tipo TI puede ser el costo en el que incurre en el agente en el que estoy para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el vector tipo t = (T1, T2, ..., Tn). Cada agente I tiene un conjunto de estrategias de la que puede elegir. Para cada vector de entrada a = (a1, ..., un) donde el agente i reproduce estrategia ai ∈ Ai, el mecanismo m = (o, p) calcula una salida o = o (a) y un vector de pago p (a)= (p1 (a), ..., pn (a)). Aquí el pago PI (·) es el dinero otorgado al Agente I y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración del juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que comience el juego y no depende de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento de unidifusión [14], la configuración consta de la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este documento, a menos que se mencione explícitamente lo contrario, la configuración del juego es fija y solo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v (Ti, O) asigna una cantidad monetaria al agente I para cada posible salida o. Todo sobre un juego S, M, incluida la configuración S, la Regla de Asignación O y el Esquema de Pago P, es el conocimiento público, excepto que el agente es el tipo real Ti, que es información privada para el agente i. Deje que UI (Ti, O) denote la utilidad del Agente I en el resultado del Juego O, dadas sus preferencias TI. Aquí, después de una suposición común en la literatura, asumimos que la utilidad para el agente I es cuasi-lineal, es decir, ui (ti, o) = v (ti, o) + pi (a). Deje a | i ai = (a1, · · ·, ai - 1, ai, ai+1, · · ·, an), es decir, cada agente j = yo reproduce una acción AJ excepto que el agente que toca ai. Deje a - i = (a1, · · ·, ai - 1, ai+1, · · ·, an) denota las acciones de todos los agentes excepto i. A veces, escribimos (a - i, bi) como un | i bi. Una acción ai se llama dominante para i si (débilmente) maximiza la utilidad de I para todas las estrategias posibles b - i de otros agentes, es decir, ui (ti, o (b - i, ai)) ≥ ui (ti, o(b - i, ai)) para todos ai = ai y b - i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones disponibles para cada agente son informar su tipo privado, ya sea con sinceridad o falsamente, al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa su tipo TI con sinceridad, entonces maximizará su utilidad. Luego, en un mecanismo de revelación directa que satisface el IC, el esquema de pago debe satisfacer la propiedad que, para cada agente i, v (ti, o (t)) + pi (t) ≥ v (ti, o (t | i tii)) + pi (t | i ti). Otro requisito común en la literatura para el diseño del mecanismo es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades de IC e IR. Podría decirse que el resultado positivo más importante en el diseño del mecanismo es el mecanismo generalizado de Vickrey-Clarke (VCG) por Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetivo es utilitaria g (o, t) = p i v (ti, o) (es decir, la suma de las valoraciones de todos los agentes) y se supone que el conjunto de salidas posiblesfinito. Un mecanismo de revelación directo m = (o (t), p (t)) pertenece a la familia VCG si (1) la asignación o (t) maximizesp i v (ti, o) y (2) el pago al agente i esPi (t) = p j = i vj (tj, o (t))+ hi (t - i), donde hi () es una función arbitraria de t - i. Bajo suposiciones leves, los mecanismos de VCG son las únicas implementaciones veraces para problemas utilitarios [10]. Se requiere la regla de asignación de un mecanismo VCG para maximizar la función objetivo en el rango de la función de asignación. Esto hace que el mecanismo sea computacionalmente intratable en muchos casos. Además, reemplazar un algoritmo óptimo para calcular la salida con un algoritmo de aproximación generalmente conduce a mecanismos falsos si se usa un esquema de pago VCG. En este artículo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetivo utilitaria.2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego g = (s, m), donde m = (o, p) y el rango de o es {0, 1} n. En otras palabras, la salida es un vector n-tuple o (t) = (o1 (t), o2 (t), ..., on (t)), donde oi (t) = 1 (respectivamente, 0)significa que el agente I está (respectivamente, no está) seleccionado. Ejemplos de juegos de demanda binaria incluyen: Unicast [14, 22, 9] y multidifusión [23, 24, 8] (generalmente subcraft construcción seleccionando algunos enlaces/nodos para satisfacer algunas propiedades), ubicación de la instalación [7] y una determinada subasta[12, 2, 13]. En adelante, hacemos los siguientes supuestos adicionales.1. La valoración de los agentes no está correlacionada, es decir, V (Ti, O) es una función de V (Ti, Oi) solo se denota como V (Ti, Oi).2. La valoración v (ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Por lo tanto, a lo largo de su artículo, solo consideramos estos mecanismos de revelación directa en los que cada agente solo necesita revelar su valoración VI = V (TI, 1).214 Observe que en las solicitudes donde los agentes que brindan servicio y reciben el pago, por ejemplo, la programación de unidifusión y trabajo, la valoración VI de un agente I suele ser negativo. Para la conveniencia de la presentación, definimos el costo del agente como CI = −v (Ti, 1), es decir, cuesta al agente I CI proporcionar el servicio. A lo largo de este artículo, usaremos CI en lugar de VI en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar al establecer CI en negativo, como en una subasta. En un juego de demanda binaria, si queremos optimizar una función objetivo G (O, T), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y aquellos problemas que pueden resolverse mediante mecanismos de VCG son: 1. La función objetivo es utilitario (o problema de maximización afín) para un problema solucionable por VCG, mientras que no hay restricción en la función objetivo de un juego de demanda binaria.2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetivo, mientras que un mecanismo VCG solo usa la salida que optimiza la función objetivo. Incluso no requerimos la existencia de una función objetivo.3. Suponemos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo de VCG. En este documento, asumimos la conveniencia técnica que la función objetivo G (O, C), si existe, es continua con respecto al COS de CI, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación.2.3 Trabajo previo Lehmann et al.[12] estudiaron cómo diseñar un mecanismo veraz eficiente para una subasta combinatoria resuelta. En una subasta combinatoria individual, cada agente I (1 ≤ i ≤ n) solo quiere comprar un subset Si ⊆ s con precio privado. Un postor resuelto que declara una oferta bi = si, ai con si ⊆ s y ai ∈ R+. En [12], se supone que el conjunto de bienes asignados a un agente I es Si o ∅, que se conoce como exactitud. Lehmann et al.Dio un codicioso algoritmo de asignación basado en la ronda, basado en el rango ai | si | 1/2, que tiene una relación de aproximación √ m, donde M es el número de bienes en S. basado en el algoritmo de aproximación, dieron un pago verazesquema. Para una regla de asignación que satisface (1) exactitud: el conjunto de bienes asignados a un agente I es si o ∅;(2) Monotonicidad: proponer más dinero para menos bienes no puede causar que un postor pierda su oferta, propusieron un esquema de pago veraz de la siguiente manera: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta;(2) cobrar a un postor perdedor 0. Observe que la suposición de exactitud revela que la subasta de mentalidad individual es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de demanda binaria. En [1], Archer et al.Estudió las subastas combinatorias donde se a la venta múltiples copias de muchos artículos diferentes, y cada postor desea solo un subconjunto SI. Idearon un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para las subastas combinatorias con agentes de parámetros únicos que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente sincero en el sentido de que es sincero con alta probabilidad 1 -, donde es una probabilidad de error. Por el contrario, en este documento, estudiamos cómo diseñar un mecanismo determinista que sea veraz en función de algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios en los que cada agente, la información privada se expresa naturalmente por un solo número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi-lineal t · w, donde t es el costo privado por unidad y W es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debería tener curvas de trabajo decrecientes w y que el pago veraz debe ser pi (bi) = pi (0) + biwi (bi) - r bi 0 wi (u) du usando este modelo, arquero y yTardos diseñó mecanismos veraces para varios problemas relacionados con la programación, incluida la minimización del tramo, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de finalización. Observe cuándo la carga de los problemas es w = {0, 1}, de hecho es un juego de demanda binaria. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes W implica exactamente la propiedad de monotonicidad de la producción. Pero observe que su prueba se basa en gran medida en la suposición de que la producción es una función continua del costo, por lo que su conclusión no puede aplicarse directamente a los juegos de demanda binaria. El documento de Ahuva Mualem y Noam Nisan [13] es más cercano en espíritu a nuestro trabajo. Claramente declararon que solo discutimos una clase limitada de postores, postores de una mente soltera, que fue introducida por [12]. Probaron que todos los mecanismos veraces deberían tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una generalización simple, obtenemos nuestra conclusión para el juego general de demanda binaria. Propusieron varios métodos combinados, incluidos Max, If-Then-Else, la construcción para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la salida que satisface la propiedad bitónica. Distinción entre nuestras contribuciones y resultados anteriores: se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de mentalidad única, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una determinada propiedad de monotonicidad. El teorema 4 también depende de la propiedad de monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de mentalidad única. Además, el juego de demanda binaria estudiada aquí es diferente del IPS tradicional de embalaje: solo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisface una determinada propiedad de monotonicidad;No ponemos ninguna restricción en la función objetivo. Además, el enfoque principal de este documento es diseñar algunas técnicas generales para encontrar el esquema de pago veraz para una regla de asignación dada o satisfacer una cierta propiedad de monotonicidad.3. Enfoques generales 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos deben satisfacer para ser sincero. Teorema 1. Si un mecanismo m = (o, p) satisface el IC, entonces ∀i, si oi (t | i ti1) = oi (t | i ti2), entonces pi (t | i ti1) = pi (t | i ti2). Corolario 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binaria G con la configuración S, si solucionamos el costo C-I de todos los agentes que no sean yo, el pago al Agente I es un P1 I constante si oi (c) = 1, yEs otra constante p0 i if oi (c) = 0. Teorema 3. Se corrigió la configuración S para un juego de demanda binaria, si el mecanismo m = (o, p) satisface el IC, entonces el mecanismo M = (o, p) con el mismo método de salida O y pi (c) = pi (c) - Δi (C - I) para cualquier función Δi (C - I) también satisface IC. Las pruebas de los teoremas anteriores son sencillas y, por lo tanto, se omiten debido al límite de espacio. Este teorema implica que para los juegos de demanda binaria siempre podemos normalizar el pago a un agente I tal que el pago al agente sea 0 cuando no se selecciona. En adelante, solo consideraremos esquemas de pago normalizados.215 3.2 Existencia del aviso de mecanismos a prueba de estrategias, dada la configuración S, un problema de diseño del mecanismo se compone de dos partes: la regla de asignación O y un esquema de pago P. En este documento, dada una regla de asignación o, centramos nuestra atención en cómo diseñarUn esquema de pago veraz basado en O. Dada una regla de asignación O para un juego de demanda binaria, primero presentamos una condición suficiente y necesaria para la existencia de un esquema de pago veraz P. Definición 1 (propiedad monótona no aumentable (MP)). Se dice que un método de salida O satisface la propiedad monótona no creciente si para cada agente I y dos de sus posibles costos CI1 <CI2, OI (C | I Ci2) ≤ Oi (C | I Ci1). Esta definición no está restringida solo a los juegos de demanda binarios. Para los juegos de demanda binaria, esta definición implica que si oi (c | i ci2) = 1 entonces oi (c | i ci1) = 1. Teorema 4. Arregle la configuración S, C - I en un juego de demanda binaria G con la regla de asignación O, las siguientes tres condiciones son equivalentes: 1. Existe un valor κi (O, C - I) (que llamaremos un valor cortado, de modo que oi (c) = 1 si Ci <κi (O, c - I) y oi (c) = 0 si Ci>κi (O, C - I). Cuando CI = κi (O, C-I), Oi (c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. en adelante, no consideraremos el escenario del desempate en nuestras pruebas.2. La regla de asignación de MP3 satisfecho. Existe un esquema de pago veraz P para este juego de demanda binaria. PRUEBA. La prueba de que la condición 2 implica la condición es sencilla y se omite aquí. Luego mostramos la condición 3 implica la condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente I y dos vectores de valoración c | i ci1 y c | i ci2, donde ci1 <ci2, oi (c | i ci2) = 1 y oi (c | i ci1) = 0. De Corollary 2, sabemos que pi (c | i ci1) = p0 i y pi (c | i ci2) = p1 i. Ahora arregle C - I, la utilidad para i cuando Ci = Ci1 es ui (ci1) = p0 i. Cuando el agente I se encuentra su valoración a CI2, su utilidad es p1 i - Ci1. Dado que M = (O, P) es sincero, tenemos p0 i> p1 i - ci1. Ahora considere el escenario cuando la valoración real del agente I es CI = CI2. Su utilidad es P1 I - Ci2 cuando informa su verdadera valoración. Del mismo modo, si se encuentra su valoración a CI1, su utilidad es P0 I. Dado que M = (O, P) es sincero, tenemos p0 i <p1 i - ci2. En consecuencia, tenemos p1 i −ci2> p0 i> p1 i −ci1. Esta desigualdad implica que Ci1> Ci2, que es una contradicción. Luego mostramos la condición 1 implica la condición 3. Probamos esto construyendo un esquema de pago y demostrando que este esquema de pago es sincero. El esquema de pago es: si oi (c) = 1, entonces el agente I obtiene el pago pi (c) = κi (o, c - i);De lo contrario, obtiene el pago Pi (c) = 0. De la condición 1, si oi (c) = 1 entonces Ci> κi (O, C - I). Por lo tanto, su utilidad es κi (O, C - I) - Ci> 0, lo que implica que el esquema de pago satisface el IR. A continuación, probamos que este esquema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: CI <κ (O, C - I). En este caso, cuando declaro su verdadero costo CI, su utilidad es κi (O, C - I) - Ci> 0. Ahora considere la situación cuando declare un costo DI = CI. Si Di <κi (O, C - I), entonces obtiene el mismo pago y utilidad ya que todavía está seleccionado. Si Di> κi (O, C - I), entonces su utilidad se convierte en 0 ya que ya no se selecciona. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: IC ≥ κ (O, C - I). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando declara una valoración DI = CI. Si Di> κi (O, C - I), entonces obtiene el mismo pago y utilidad, ya que todavía no está seleccionado. Si Di ≤ κi (O, C - I), entonces su utilidad se convierte en κi (O, C - I) - Ci ≤ 0 ya que ahora se selecciona. Por lo tanto, no tiene incentivo para mentir. La equivalencia de la propiedad de monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz que usa O puede extenderse a juegos más allá de los juegos de demanda binaria. Los detalles se omiten aquí debido al límite de espacio. Ahora resumimos el proceso para diseñar un esquema de pago veraz para un juego de demanda binaria basado en un método de salida O. Marco general 1 Diseño de mecanismo veraz para un juego de demanda binaria Etapa 1: Compruebe si la regla de asignación o satisface el MP. Si no es así, entonces no hay un esquema de pago P tal que el mecanismo M = (O, P) sea sincero. De lo contrario, defina el esquema de pago P de la siguiente manera. Etapa 2: Basado en la regla de asignación O, encuentre el valor cortado κi (O, C - I) para el Agente I tal que Oi (C | I di) = 1 cuando Di <κi (O, C - I) y Oi(c | i di) = 0 cuando di> κi (o, c - i). Etapa 3: El pago del Agente I es 0 si oi (c) = 0;El pago es κi (O, C - I) si oi (c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los esquemas de pago veraces que utilizan O como salida.4. Computación de las funciones de valor de corte Para encontrar el esquema de pago veraz mediante el uso de General Framework 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor cortado en ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación, encuentre la función de valor de corte para cada una de estas nuevas reglas de asignación. Luego, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación.4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función del valor de corte mediante la combinación de múltiples reglas de asignación con conjunciones o disconjunciones. Por simplicidad, dada una regla de asignación O, usaremos κ (O, c) para denotar un vector N-tuple (κ1 (O, C-1), κ2 (O, C-2), ..., κN ((O, c - n)). Aquí, κi (O, C - I) es el valor reducido para el Agente I cuando la regla de asignación es O y los costos C - I de todos los demás agentes son fijos. Teorema 6. Con una configuración fija de un juego de demanda binaria, suponga que existen reglas de asignación M O1, O2, · · ·, que satisface la propiedad de monotonicidad, y κ (OI, C) es el vector de valor cortado para OI. Entonces la regla de asignación O (c) = Wm I = 1 Oi (c) satisface la propiedad de monotonicidad. Además, el valor cortado para O es κ (O, c) = maxm i = 1 {κ (oi, c)} aquí κ (o, c) = maxm i = 1 {κ (oi, c)} medias, ∀j ∈ [1, n], κj (o, c - j) = maxm i = 1 {κj (oi, c - j)} y o (c) = wm i = 1 oi (c) medias, ∀j ∈[1, n], oj (c) = o1 j (c) ∨ o2 j (c) ∨ · · · ∨ om j (c). PRUEBA. Suponga que Ci> Ci y Oi (c) = 1. Sin pérdida de generalidad, suponemos que OK I (C) = 1 para algunos k, 1 ≤ k ≤ m.De la suposición de que OK I (c) satisface a MP, obtenemos que 216 OK I (C | I CI) = 1. Por lo tanto, oi (c | i ci) = wm j = 1 oj (c) = 1. Esto demuestra que O (c) satisface MP. La corrección de la función de valor de corte sigue directamente desde el teorema 4. Muchos algoritmos se dividen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multidifusión. La estructura más utilizada en el enrutamiento de multidifusión se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, C), donde V es el conjunto de nodos, y el vector C es el costo real de los nodos que reenvían los datos. Suponga que el nodo fuente es S y los receptores son Q ⊂ V. Para cada receptor Qi ∈ Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP (S, Qi, D), de la fuente a Qi bajo el perfil de costo informado d.La unión de todos esos caminos más cortos forma el árbol de camino más corto. Luego usamos General Framework 1 para diseñar el esquema de pago veraz P cuando la estructura SPT se usa como salida para multidifusión, es decir, diseñamos un mecanismo M = (SPT, P). Observe que los mecanismos de VCG no se pueden aplicar aquí ya que SPT no es una maximización afina. Definimos LCP (S, Qi) ya que la asignación corresponde a la ruta LCP (S, Qi, D), es decir, LCP (S, Qi) K (D) = 1 si y solo si el nodo VK está en LCP (S, S,qi, d). Entonces la salida SPT se define como w qi∈Q lcp (s, qi). En otras palabras, SPTK (d) = 1 si y solo si QK se selecciona en algún LCP (S, Qi, D). La regla de asignación de ruta más corta es una utilitaria y satisface MP. Por lo tanto, del teorema 6, SPT también satisface MP, y el vector de función del valor cortado para SPT se puede calcular como κ (SPT, C) = Maxqi∈Q κ (LCP (S, Qi), C), donde κ (LCP (LCP (LCP (LCP (LCP (LCP (LCPS, qi), c) es el vector de función de valor cortado para la ruta más corta LCP (S, Qi, C). En consecuencia, el esquema de pago anterior es veraz y el mínimo entre todos los esquemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Se corrigió la configuración de un juego de demanda binaria, suponga que existen m métodos de salida O1, O2, · · ·, om satisfecho de MP y κ (OI, C) son las funciones de valor cortado respectivamente para OI donde i = 1, 2, · · ·, M.Entonces la regla de asignación o (c) = vm i = 1 oi (c) satisface mp. Además, la función de valor cortado para O es κ (O, C) = Minm I = 1 {κ (Oi, C)}. Mostramos que nuestra combinación simple generaliza la función if-thenelse definida en [13]. Para un agente I, suponga que hay dos reglas de asignación O1 y O2 que satisfacen MP. Sea κi (O1, C - I), κi (O2, C - I) las funciones de valor cortado para O1, O2 respectivamente. Entonces la función if-then-else Oi (c) es en realidad Oi (c) = [(CI ≤ κi (O1, C-I) + Δ1 (C-I)) ∧ O2 (C-I, CI)] ∨(CI <κI (O1, C - I) - Δ2 (C - I)) donde Δ1 (C - I) y Δ2 (C - I) son dos funciones positivas. Al aplicar los teoremas 6 y 7, sabemos que la regla de asignación O satisface el MP y, en consecuencia, κi (O, C - I) = max {min (κi (O1, C - I)+ Δ1 (C - I), κi (O2 (O2, c - i)), κi (o1, c - i) - Δ2 (c - i))}.4.2 Asignaciones basadas en la ronda Algunos algoritmos de aproximación están basados en redondos, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costo si es necesario. Por ejemplo, varios algoritmos de aproximación para la cubierta de vértice de peso mínimo [19], el conjunto independiente de peso máximo, la cubierta del conjunto de peso mínimo [4] y el árbol de peso mínimo [18] se dividen en esta categoría. Como ejemplo, discutimos el problema mínimo de cobertura de vértice ponderado (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida redonda. Dado un gráfico g = (v, e), donde los nodos v1, v2 ,..., VN son los agentes y cada agente VI tiene un CI de peso, queremos encontrar un conjunto de nodo V ⊆ V tal que para cada borde (u, v) ∈ E al menos uno de U y V esté en V. Dicha V se llama una cubierta de vértice de G. La valoración de un nodo I es −ci si se selecciona;de lo contrario, su valoración es 0. Para un subconjunto de nodos v ∈ V, definimos su peso como c (v) = p i∈V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetivo a implementar es utilitaria. Para usar el mecanismo VCG, necesitamos encontrar la cubierta del vértice con el peso mínimo, que es NP-Hard [16]. Dado que estamos interesados en mecanismos que se pueden calcular en tiempo polinomial, debemos usar reglas de asignación computables en tiempo polinómico. Se han propuesto muchos algoritmos en la literatura para aproximar la solución óptima. En este documento, utilizamos un algoritmo de 2 de acerca de 2 dados en [16]. En aras de la integridad, revisamos brevemente este algoritmo aquí. El algoritmo está basado en redondo. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo I, W (i) se inicializa a su peso CI, y cuando W (i) cae a 0, I está incluido en la cubierta del vértice. Para que la presentación sea clara, decimos que un borde (i1, j1) es lexicográficamente más pequeño que el borde (i2, j2) si (1) min (i1, j1) <min (i2, j2) o (2) min (i1, j1) = min (i2, j2) y max (i1, j1) <max (i2, j2). Algoritmo 2 Introducción de cubierta de vértice ponderada mínima aproximada: un gráfico ponderado de nodo G = (V, E, C). Salida: una cubierta de vértice v.1: establecer v = ∅. Para cada i ∈ V, establezca w (i) = ci.2: Si bien V no es una cubierta de vértice Do 3: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.4: Sea M = Min (W (I), W (J)).5: Actualización W (I) a W (I) - M y W (J) a W (J) - M.6: Si w (i) = 0, agregue i a v. Si w (j) = 0, agregue j a v. Aviso, seleccionar un borde utilizando el orden lexicográfico es crucial para garantizar la propiedad de monotonicidad. El algoritmo 2 sale una cubierta de vértice V cuyo peso está dentro de las 2 veces del óptimo. Por conveniencia, usamos VC (c) para denotar la cubierta de vértice calculada por el algoritmo 2 cuando el vector de costo de los vértices es c.A continuación generalizamos el Algoritmo 2 a un escenario más general. Por lo general, una salida redonda se puede caracterizar de la siguiente manera (Algoritmo 3). Definición 2. Se dice que una regla de actualización UR es independiente de Crossinging si, para cualquier agente no seleccioné en la ronda R, (1) Sr+1 y Cr+1 −o no depende de Cr J (2) para CR −i fijo, Cr I1≤ Cr I2 implica que Cr+1 I1 ≤ Cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz utilizando una regla de asignación basada en la ronda A. Teorema 8. Una salida redonda A, con el marco definido en el Algoritmo 3, satisface MP si los métodos de salida o satisfacen MP y todas las reglas de actualización UR son independientes del cruce. PRUEBA. Considere un agente I y C - I fijo. Probamos que cuando se selecciona un agente I con Costo CI, también se selecciona con Costo Di <Ci. Suponga que me seleccionan en la ronda R con Costo CI. Luego, bajo el costo di, si el agente I se selecciona en una ronda antes de R, nuestro reclamo es válido. De lo contrario, considere en la ronda r.Claramente, la configuración de SR y los costos de todos los demás agentes son los mismos que si el agente me hubiera costado CI, ya que no se selecciona en las rondas anteriores debido a la propiedad Independiente Cross. Como se selecciona en la ronda R con Costo CI, también se selecciona en la ronda R con di <ci por la razón que o satisface MP. Esto termina la prueba.217 Algoritmo 3 Una regla de asignación general basada en la ronda A 1: SET R = 0, C0 = C y G0 = G inicialmente.2: Repita 3: Calcule una salida o usando un algoritmo determinista o: Sr × Cr → {0, 1} n. Aquí o, CR y SR son regla de asignación, vector de costos y configuración de juego en el juego GR, respectivamente. Observación: o a menudo es un algoritmo codicioso simple, como seleccionar los agentes que minimizan alguna función utilitaria. Para el ejemplo de la cubierta del vértice, o siempre seleccionará el nodo ligero en el borde lexicográficamente menos descubierto (I, J).4: Sea r = r + 1. Actualice el juego GR - 1 para obtener un nuevo juego GR con la configuración de SR y Costo Vector CR de acuerdo con alguna regla UR: OR - 1 × (SR - 1, CR - 1) → (SR, CR). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de la cubierta de vértice, la regla de actualización disminuirá el peso de los vértices I y J por min (W (I), W (J)).5: Hasta que se encuentre una salida válida 6: devuelva la unión del conjunto de jugadores seleccionados de cada ronda como salida final. Para el ejemplo de la cobertura del vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte de cálculo para la entrada de algoritmos basados en redondos: una salida redonda A, un juego G1 = G y una función de actualización Vector U. Salida: el valor de corte x para el agente k.1: establecer r = 0 y ck = ζ. Recuerde que ζ es un valor que puede garantizar AK = 0 cuando un agente informa el costo ζ.2: Repita 3: Calcule una salida o usando un algoritmo determinista basado en configurar SR usando una regla de asignación o: SR × Cr → {0, 1} n.4: Encuentre el valor de corte para el Agente K en función de la regla de asignación o para los costos Cr −k. Sea R = κK (OR, Cr −k) el valor cortado.5: Establezca R = R + 1 y obtenga un nuevo juego GR de GR - 1 y o de acuerdo con la regla de actualización UR.6: Deje que CR sea el nuevo vector de costo para el juego Gr.7: Hasta que se encuentre una salida válida.8: Deje que GI (x) sea el costo de Ci k cuando el vector de costo original es c | k x.9: Encuentre el valor mínimo x tal que 8 >>>>> <>>>>>: G1 (x) ≥ 1;G2 (x) ≥ 2;... GT - 1 (x) ≥ t - 1;gt (x) ≥ t.Aquí, T es el número total de rondas.10: emite el valor x como el valor de corte. Si el resultado basado en la ronda satisface la propiedad de monotonicidad, el valor de corte siempre existe. Luego mostramos cómo encontrar el valor cortado para un agente K seleccionado en el algoritmo 4. La corrección del algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte R para cada ronda R se puede calcular en tiempo polinomial;(2) Podemos resolver la ecuación gr (x) = r para encontrar x en el tiempo polinomial cuando se dan el vector de costo C - I y B. Ahora consideramos el problema de la portada del vértice. Para cada ronda R, seleccionamos un vértice con el menor peso y eso es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el Agente I, actualizamos su costo a Cr I - Cr J Iff Edge (I, J) se selecciona. Es fácil verificar que esta regla de actualización sea independiente del cruce, por lo tanto, podemos aplicar el Algoritmo 4 para calcular el valor de corte para el juego de cubierta establecida como se muestra en el Algoritmo 5. Algoritmo 5 COMPUTE CUT VALOR para MVC. Entrada: un gráfico ponderado de nodo G = (V, E, C) y un nodo k seleccionado por el algoritmo 2. Salida: el valor de corte κK (V C, C - K).1: Para cada i ∈ V, establecer w (i) = ci.2: establecer w (k) = ∞, pk = 0 y v = ∅.3: Si bien V no es una cubierta de vértice Do 4: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.5: establecer m = min (w (i), w (j)).6: Actualización w (i) = w (i) - my w (j) = w (j) - m.7: Si w (i) = 0, agregue i a v;de lo contrario agregue j a v.8: si i == k o j == k luego establece pk = pk + m.9: Salida PK como valor cortado κK (V C, C - K).4.3 Combinaciones complejas en la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binaria es una combinación simple de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación, presentamos una forma más compleja de combinar reglas de asignación, y como esperábamos, la forma de encontrar el valor de corte también es más complicado. Suponga que hay n agentes 1 ≤ i ≤ n con el vector de costos C, y hay M Juegos de demanda binarios GI con funciones objetivas fi (O, C), configuración de Si y regla de asignación ψi donde i = 1, 2, · · ·, m.Hay otro juego de demanda binaria con la configuración de la regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · ·, dm). Sea F el vector de función (F1, F2, · · ·, FM), ψ el vector de regla de asignación (ψ1, ψ2, · · ·, ψm) y ∫ ser el vector de configuración (S1, S2, · · ·,,SM). Para la simplicidad de notación, definimos fi (c) = fi (ψi (c), c), para cada 1 ≤ i ≤ m, y f (c) = (F1 (c), f2 (c), · · ·,,Fm (c)). Veamos un ejemplo concreto de estas combinaciones. Considere un gráfico ponderado de enlace G = (V, E, C), y un subconjunto de N nodos Q ⊆ V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una forma de encontrar una aproximación del árbol Steiner es la siguiente: (1) Construimos una gráfica virtual completa H usando Q como vértices, y el costo de cada borde (i, j) es el costo de LCP (I, J, c) en el gráfico G;(2) construir el árbol de expansión mínimo de H, denotado como MST (H);(3) Se selecciona un borde de G si se selecciona en algunos LCP (I, J, C) y el borde (I, J) de H se selecciona para MST (H). En este juego, definimos Q (Q - 1)/2 juegos GI, J, donde i, j ∈ Q, con funciones objetivas fi, j (o, c) es el costo mínimo de 218 conectando I y J en el gráfico g, configurar Si es el gráfico original G y la regla de asignación es LCP (I, J, C). El juego G corresponde al juego MST en Graph H. El costo de las rutas Q (q-1)/2 más cortas define el vector de entrada d = (d1, d2, · · · ·, dm) para el juego MST. Se darán más detalles en la Sección 5.2. Definición 3. Dada una regla de asignación O y configuración S, un vector de función objetivo F, un vector de regla de asignación ψ y un vector de configuración ∫, definimos un juego de demanda binaria compuesta con la configuración S y la salida O ◦ F as (O ◦ F) I (C)= Wm J = 1 (OJ (F (C)) ∧ ψj I (C)). La regla de asignación de la definición anterior se puede interpretar de la siguiente manera. Se selecciona un agente I si y solo si hay una j tal que (1) i se selecciona en ψj (c), y (2) la regla de asignación o seleccionará el índice J en el perfil de costo f (c). Para simplificar, utilizaremos O ◦ F para denotar la salida de este juego de demanda binaria compuesta. Observe que existe un esquema de pago veraz que usa o ◦ f como salida si y solo si satisface la propiedad de monotonicidad. Para estudiar cuándo O ◦F satisface a MP, varias definiciones necesarias están en orden. Definición 4. Función Propiedad de monotonicidad (FMP) dada una función objetivo G y una regla de asignación O, se dice que una función h (c) = g (o (c), c) satisface la propiedad de la monotonicidad de la función, si, dado, se les da fijo c - i,Satisface: 1. Cuando Oi (c) = 0, H (c) no aumenta sobre CI.2. Cuando Oi (c) = 1, H (c) no disminuye sobre IC. Definición 5. Se dice que una propiedad de monotonicidad fuerte (SMP) una regla de asignación O satisface la fuerte propiedad de monotonicidad si o satisface MP, y para cualquier agente I con oi (c) = 1 y agente j = i, oi (c | j cj) = 1Si cj ≥ cj u oj (c | j cj) = 0. Lema 1. Para una regla de asignación dada o satisfaciendo los vectores SMP y costos C, C con Ci = Ci, si oi (c) = 1 y oi (c) = 0, entonces debe existir j = i tal que cj <cj y oj (c) = 1. De la definición de la fuerte propiedad de monotonicidad, tenemos el Lema 1 directamente. Ahora podemos dar una condición suficiente cuando O ◦ F satisface la propiedad de monotonicidad. Teorema 9. Si ∀i ∈ [1, M], Fi satisface FMP, ψi satisface MP, y la salida o satisface SMP, entonces O ◦ F satisface MP. PRUEBA. Suponiendo que para el vector de costo c tenemos (o ◦ f) i (c) = 1, debemos probar para cualquier vector de costo c = c | i ci con ci <ci, (o ◦ f) i (c) = 1. Notando que (o ◦ f) i (c) = 1, sin pérdida de generalidad, suponemos que OK (f (c)) = 1 y ψk i (c) = 1 para algún índice 1 ≤ k ≤ m.Ahora considere la salida O con el vector de costo f (c) | k fk (c). Hay dos escenarios, que se estudiarán uno por uno de la siguiente manera. Un escenario es que el índice K no es elegido por la función de salida O. De Lemma 1, debe existir j = k tal que fj (c) <fj (c) (1) oj (f (c) | k fk (c)) = 1 (2) luego demostramos que el agente seréseleccionado en la salida ψj (c), es decir, ψj i (c) = 1. Si no es así, ya que ψj (c) satisface MP, tenemos ψj i (c) = ψj i (c) = 0 de Ci <Ci. Dado que FJ satisface FMP, conocemos FJ (C) ≥ FJ (C), lo cual es una contradicción con la desigualdad (1). En consecuencia, tenemos ψj i (c) = 1. De la ecuación (2), el hecho de que el índice k no se seleccione por la regla de asignación O y la definición de SMP, tenemos OJ (f (c)) = 1, por lo tanto, el agente I es seleccionado por O ◦ F debido a OJ (OJ (F (c)) = 1 y ψj i (c) = 1. El otro escenario es que el índice K es elegido por la función de salida O. Primero, el agente I se elige en ψk (c) ya que la salida ψk (c) satisface la propiedad de monotonicidad y ci <ci y ψk i (c) = 1. En segundo lugar, dado que la función FK satisface FMP, sabemos que FK (C) ≤ Fk (C). Recuerde que la salida O satisface el SMP, por lo tanto, podemos obtener OK (F (c)) = 1 del hecho de que OK (F (C) | K Fk (C)) = 1 y Fk (C) ≤ Fk (C). En consecuencia, el agente I también será seleccionado en la salida final o ◦ F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta o ◦ F. Luego discutimos cómo encontrar el valor de corte para esta salida. A continuación, daremos un algoritmo para calcular κi (o ◦ f) cuando (1) o satisface SMP, (2) ψj satisface a MP y (3) para C - I fijo, FJ (c) es una constante, digamos HJ,Cuando ψj i (c) = 0, y fj (c) aumenta cuando ψj i (c) = 1. Observe que aquí HJ puede calcularse fácilmente configurando CI = ∞ ya que ψj satisface la propiedad de monotonicidad. Cuando se administra I y C - I fijo, definimos (fi j) −1 (y) como el X más pequeño de tal manera que FJ (C | I x) = y. Para simplificar, denotamos (fi j) −1 como f - 1 j si no se causa confusión cuando yo es un agente fijo. En este artículo, suponemos que, dado cualquier Y, podemos encontrar tales X en el tiempo polinomial. Algoritmo 6 Encuentre el valor de corte para el método de compuesto O ◦ F Entrada: Regla de asignación O, Vector de función objetivo F y Vector de función inversa F - 1 = {F - 1 1, · · · ·, F - 1 M}, Vector de regla de asignación ψ yC - I fijo. Salida: valor de corte para el agente I basado en O ◦ F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas ψj (CI).3: Calcule hj = fj (c | i ∞).4: Use H = (H1, H2, · · ·, HM) como la entrada para la función de salida O. denota τj = κJ (O, H - J) como la función de valor cortado de la salida O basada en la entrada h.5: para 1 ≤ j ≤ m do 6: set κi, j = f - 1 j (min {τj, hj}).7: El valor cortado para I es κi (O ◦ F, C - I) = maxm j = 1 κi, j. Teorema 10. El algoritmo 6 calcula el valor de corte correcto para el agente I en función de la regla de asignación O ◦ F. Prueba. Para probar la corrección de la función de valor cortado calculada por el algoritmo 6, probamos los siguientes dos casos. Para nuestra conveniencia, usaremos κi para representar κi (O ◦ F, C - I) si no se causa confusión. Primero, si di <κi entonces (o ◦ f) i (c | i di) = 1. Sin pérdida de generalidad, suponemos que κi = κi, j para algunos j. Dado que la función fj satisface fmp y ψj i (c | i di) = 1, tenemos fj (c | i di) <fj (κi). Aviso di <κi, j, a partir de la definición de κi, j = f - 1 j (min {τj, hj}) tenemos (1) ψj i (c | i di) = 1, (2) fj (c |i di) <τj debido al hecho de que FJ (x) es una función no dreible cuando se selecciona J. Por lo tanto, de la propiedad de monotonicidad de O y τj es el valor cortado para la salida o, tenemos oj (h | j fj (c | i di)) = 1. (3) Si oj (f (c | i di))= 1 entonces (o◦f) i (c | i di) = 1. De lo contrario, dado que o satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que ok (f (c | i di)) = 1 y fk (c | i di) <hk. Nota fk (c | i di) <hk implica que yo está seleccionado en ψk (c | i di) ya que hk = fk (ci | i ∞). En otras palabras, el agente I se selecciona en O◦F.219 segundo, si di ≥ κi (o ◦ f, c - i) entonces (o ◦ f) i (c | i di) = 0. Suponga en aras de la contradicción de que (o ◦ f) i (c | i di) = 1. Luego existe un índice 1 ≤ j ≤ m tal que oj (f (c | i di)) = 1 y ψj i (c | i di) = 1. Recuerde que HK ≥ fk (c | i di) para cualquier k.Por lo tanto, del hecho de que o satisface SMP, al cambiar el vector de costo de f (c | i di) a h | j fj (c | i di), todavía tenemos OJ (h | j fj (c | i di)) = 1. Esto implica que FJ (c | i di) <τj. Combinando la desigualdad anterior y el hecho de que FJ (c | i c | i di) <hj, tenemos fj (c | i di) <min {hj, τj}. Esto implica di <f - 1 j (min {hj, τj}) = κi, j <κi (o ◦ f, c - i).que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación ψj implementa la función objetivo FJ y FJ es utilitario. Por lo tanto, podemos calcular el inverso de F - 1 J de manera eficiente. Otro problema es que parece que las condiciones cuando podemos aplicar el Algoritmo 6 son restrictivos. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para una subasta combinatoria de mentalidad única, luego la combinación Max (A1, A2) devuelve la asignación con el bienestar más grande. Si el algoritmo A1 y A2 satisfacen MP y FMP, la operación max (x, y) que devuelve el elemento más grande de x e y satisface SMP. Del Teorema 9 obtenemos esa combinación Max (A1, A2) también satisface el MP. Además, el valor cortado de la combinación MAX se puede encontrar mediante el algoritmo 6. Como mostraremos en la Sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados.5. Ejemplos concretos 5.1 Cubierta establecida En el problema de la cubierta establecida, se necesita cubrir un conjunto de elementos M, y cada agente 1 ≤ I ≤ n puede cubrir un subconjunto de elementos Si con un Cos de costo. Sea S = {S1, S2, · · ·, Sn} y C = (C1, C2, · · ·, CN). Queremos encontrar un subconjunto de agentes D tal que U ⊆ S i∈D Si. Los subconjuntos seleccionados se llaman la cubierta establecida para U. La eficiencia social de la salida d se define como p i∈D Ci, que es la función objetivo que se minimiza. Claramente, este es un mecanismo utilitario y, por lo tanto, se puede aplicar un mecanismo de VCG si podemos encontrar el subconjunto de S que te cubra con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-Hard. En [4], se ha propuesto un algoritmo de relación de aproximación de HM y se ha demostrado que esta es la mejor proporción posible para el problema de la cubierta establecida. Para la integridad de la presentación, revisamos su método aquí. Algoritmo 7 Entrada de la cubierta del conjunto codicioso (GSC): el agente está cubierto de subset SI y costo CI.(1 ≤ i ≤ n). Salida: un conjunto de agentes que pueden cubrir todos los elementos.1: Inicializar r = 1, t0 = ∅ y r = ∅.2: Mientras que r = u do 3: Encuentre el conjunto SJ con la densidad mínima CJ | SJ −tr |.4: establecer tr+1 = tr s sj y r = r s j.5: R = R + 1 6: Salida R. Sea GSC (s) los conjuntos seleccionados por el algoritmo 7. Notice que el conjunto de salida es una función de S y C.Algunos trabajos suponen que el tipo de agente podría ser CI, es decir, se supone que SI es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, CI). En otras palabras, suponemos que cada agente no solo puede mentir sobre su costo CI, sino que también puede mentir sobre el conjunto SI. Este problema ahora se parece a la subasta combinatoria con postor de mentalidad única estudiada en [12], pero con las siguientes diferencias: en el problema de la cubierta del conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras en una subasta combinatoria de la combinatoriaLos conjuntos elegidos son disjuntos. Podemos mostrar que el mecanismo M = (GSC, PV CG), utilizando el Algoritmo 7 para encontrar una cubierta establecida y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la portada del conjunto es un juego de demanda binaria. Por el momento, suponemos que el agente no podré mentir sobre SI. Descargaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz aplicando nuestro marco general.1. Verifique la propiedad de monotonicidad: la salida del algoritmo 7 es una salida redonda. Por lo tanto, para un agente I, primero nos centramos en la salida de una ronda r.En la ronda R, si I es seleccionada por el algoritmo 7, entonces tiene la relación mínima CI | Si -tr |Entre todos los agentes restantes. Ahora considere el caso cuando miente su costo para Ci <ci, obviamente Ci | si - tr |sigue siendo mínimo entre todos los agentes restantes. En consecuencia, el agente I todavía se selecciona en la ronda R, lo que significa que la salida de la ronda R satisface MP. Ahora buscamos las reglas de actualización. Para cada ronda, solo actualizamos el TR+1 = TR S SJ y R = R S J, que obviamente es independiente. Por lo tanto, al aplicar el Teorema 8, sabemos que la salida por algoritmo 7 satisface MP.2. Encuentre el valor de corte: para calcular el valor de corte para el agente I con el vector de costo fijo C - I, seguimos los pasos en el algoritmo 4. Primero, establecemos CI = ∞ y aplicamos el algoritmo 7. Sea IR el agente seleccionado en la ronda R y T - I R+1 sea el conjunto correspondiente. Entonces el valor cortado de la ronda R es r = cir | señor - t - i r |· | Si - t - i r |. Recuerde que la regla de actualización solo actualiza la configuración del juego pero no el costo del agente, por lo tanto, tenemos gr (x) = x ≥ r para 1 ≤ r ≤ t.Por lo tanto, el valor de corte final para el Agente I es κi (GSC, C - I) = Max R {CIR | Sir - T - I R |· | Si - t - i r |} El pago a un agente I es κi si se selecciona;de lo contrario, su pago es 0. Ahora consideramos el escenario cuando el agente puedo mentir sobre SI. Suponga que el agente no puedo estar hacia arriba, es decir, solo puede informar un conjunto de Si ⊆ Si. Argumentamos que el agente no mentiré sobre sus elementos si. Observe que el valor de corte calculado para la ronda R es r = cir | Sir −t −i r |· | Si - t - i r |. Obviamente | Si - t - i r |≤ | si - t - i r |Para cualquier Si ⊆ Si. Por lo tanto, mentir su set como Si no aumentará el valor de corte para cada ronda. Por lo tanto, mentir sobre SI no mejorará el agente es la utilidad.5.2 Los árboles Steiner ponderados del enlace Considere cualquier enlace Network ponderada G = (V, E, C), donde E = {E1, E2, · · ·, EM} son el conjunto de enlaces y CI es el peso de la EI del enlace. El problema del árbol Steiner ponderado del enlace es encontrar un árbol enotricado en el nodo de origen que abarca un conjunto dado de nodos q = {Q1, Q2, · · ·, QK} ⊂ V. Por simplicidad, suponemos que qi = vi, para 1 ≤ i ≤ k.Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H ⊆ G se llama peso de H, denotado como Ω (H). Es difícil encontrar el árbol de multidifusión de costo mínimo cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinómico tiene la relación de aproximación 1 + Ln 3 2 [17]. Aquí, revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encuentre Entrada de SteinerTree (LST) de LinkWeeting: Network G = (V, E, C) donde C es el vector de costo para el conjunto de enlaces E. Nodos de origen y el conjunto de receptor establecido Q. Salida: un árbol LST enraizado en S y abarcó a todos los receptores.1: establecer r = 1, g1 = g, q1 = qy s1 = s.2: Repita 3: en gráfico GR, encuentre el receptor, digamos Qi, que está más cerca de la fuente S, es decir, LCP (S, Qi, C) tiene el menor costo entre las rutas más cortas de S a todos los receptores en QR.4: Seleccione todos los enlaces en LCP (S, Qi, C) como enlaces de retransmisión y establezca su costo en 0. El nuevo gráfico se denota como GR+1.5: Establezca TR como Qi y PR = LCP (S, Qi, C).6: Establezca qr + 1 = qr \ qi y r = r + 1. 7: Hasta que todos los receptores estén abarcados. En adelante, deje que LST (G) sea el árbol final construido utilizando el método anterior. Se muestra en [24] que el mecanismo M = (LST, PV CG) no es veraz, donde PV CG es el pago calculado en función del mecanismo VCG. Luego mostramos cómo diseñar un esquema de pago veraz utilizando nuestro marco general. Observe que la salida PR, para cualquier ronda R, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, del Teorema 8, la salida de base redonda LST satisface MP. En la ronda R, el valor de corte para un enlace EI se puede obtener utilizando el mecanismo VCG. Ahora establecemos Ci = ∞ y ejecutamos el algoritmo 8. Deje que W - i r (ci) sea el costo de la ruta PR (CI) seleccionado en la redonda RTH y πi r (CI) sea la ruta más corta seleccionada en la ronda R si el costo de CI se establece temporalmente en −∞. Entonces el valor cortado para la ronda R es r = wi r (c - i) - | πi r (c - i) |donde | πi r (c - i) |es el costo de la ruta πi r (c - i) excluyendo el nodo vi. Usando el Algoritmo 4, obtenemos el valor de corte final para el Agente I: κi (LST, C - I) = Maxr {R}. Por lo tanto, el pago a un enlace EI es κi (LST, C - I) si su costo informado es di <κi (LST, D - I);De lo contrario, su pago es 0. 5.3 Los árboles de expansión mínima virtual para conectar el conjunto de receptores dado al nodo fuente, además del árbol Steiner construido por los algoritmos descritos anteriormente, a menudo también se usa un árbol de expansión mínimo virtual. Suponga que Q es el conjunto de receptores, incluido el remitente. Suponga que los nodos en un gráfico ponderado por el nodo son todos agentes. El árbol de expansión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: Para todos los pares de receptores Qi, Qj ∈ Q DO 2: Calcule la ruta de menor costo LCP (Qi, QJ, D).3: Construya un gráfico ponderado de enlace completo virtual K (d) usando Q como conjunto de nodo, donde el enlace Qiqj corresponde a la ruta de menor costo LCP (Qi, Qj, D), y su peso es W (Qiqj) = | LCP(Qi, QJ, D) |.4: Construya el árbol de expansión mínimo en K (D), denotado como V MST (D).5: Para cada enlace virtual Qiqj en V MST (d) Do 6: Encuentre la ruta de menor costo correspondiente LCP (Qi, QJ, D) en la red original.7: Marque los agentes en LCP (Qi, QJ, D) seleccionado. El mecanismo M = (V MST, PV CG) no es veraz [24], donde el pago PV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos.1. Verifique la propiedad de monotonicidad: recuerde que en el gráfico completo k (d), el peso de un enlace qiqj es | lcp (qi, qj, d) |. En otras palabras, definimos implícitamente | Q | (| Q | - 1)/2 Funciones fi, j, para todos i <j y qi ∈ Q y qj ∈ Q, con fi, j (d) = | lcp (qi, QJ, D) |. Podemos mostrar que la función fi, j (d) = | lcp (qi, qj, d) |Satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde el Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad.2. Encuentre el valor de corte: aviso de VMST es la combinación de MST y función Fi, j, por lo que el valor de corte para VMST se puede calcular en función del algoritmo 6 de la siguiente manera.(a) Dado un gráfico completo ponderado de enlace k (d) en Q, deberíamos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol de expansión T y un par de terminales P y Q, claramente hay una ruta única que los conecta en T. Denotamos esta ruta como πt (P, Q), y el borde con la longitud máxima en este camino como LE (P, Q, T). Por lo tanto, el valor cortado se puede representar como κK (MST, D) = LE (Qi, QJ, MST (D | K ∞)) (b) Encontramos la función de costo de valor para LCP. Suponga vk ∈ Lcp (qi, qj, d), entonces la función de costo de valor es xk = yk-| lcpvk (qi, qj, d | k 0) |. Aquí, LCPVK (Qi, QJ, D) es la ruta de menor costo entre Qi y QJ con Node VK en esta ruta.(c) Retire VK y calcule el valor k (d | k ∞). Set h (i, j) = | lcp (qi, qj, d | ∞)) |Para cada par de nodo i = j y dejar h = {h (i, j)} el vector. Entonces es fácil mostrar que τ (i, j) = | le (qi, qj, mst (h | (i, j) ∞)) |es el valor de corte para la salida VMST. Es fácil verificar que Min {h (i, j), τ (i, j)} = | le (qi, qj, mst (h) |. Por lo tanto, sabemos κ (i, j) k (v mst, d) es | le (qi, qj, mst (h) | - | lcpvk (qi, qj, d | k 0) |. El valor de corte para el agente K es κK (V MST, D - K) = Max0≤i, J≤R κij K (V MST, D - K).3. Pagamos el agente K κK (V MST, D - K) si y solo si K se selecciona en V MST (D);De lo contrario, lo pagamos 0. 5.4 Subastas combinatorias Lehmann et al.[12] estudiaron cómo diseñar un mecanismo veraz eficiente para una subasta combinatoria resuelta. En una subasta combinatoria individual, hay un conjunto de artículos que se venden y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: Agente I quiere comprar un subconjunto con un precio máximomi. Un postor resuelto que declara una oferta bi = si, ai con si ⊆ s y ai ∈ R+. Dos ofertas SI, AI y SJ, AJ Conflicto si SI ∩ SJ = ∅. Dadas las ofertas B1, B2, · · ·, BN, dieron un codicioso algoritmo de base redondo como sigue. Primero, las ofertas se clasifican mediante algún criterio (Ai | Si | 1/2 se usa en [12]) en un orden creciente y que sea la lista de ofertas ordenadas. Se otorga la primera oferta. Luego, el algoritmo examina cada oferta de L en orden y otorga la oferta si no entra en conflicto con ninguna de las ofertas otorgadas previamente. Si es así, se niega. Probaron que este esquema de asignación codiciosa utilizando Criterion Ai | Si | 1/2 se aproxima a la asignación óptima dentro de un factor de √ m, donde M es el número de bienes en S. En la configuración de la subasta, tenemos CI = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida redonda. Recuerde que después de que el postor J sea seleccionado para la ronda R, cada postor tiene conflicto 221 con J no será seleccionado en las rondas posteriores. Esto equivale a actualizar el costo de cada postor que tenga conflicto con J a 0, lo que satisface la independencia del cruce. Además, en cualquier ronda, si el postor i es seleccionado con AI, entonces aún se seleccionará cuando declare AI> AI. Por lo tanto, para cada ronda, satisface MP y el valor cortado es | Si | 1/2 · Ajr | Sjr | 1/2 donde Jr es el postor seleccionado en la ronda R si no consideramos el agente I en absoluto. Aviso ajr | sjr | 1/2 no aumenta cuando la ronda R aumenta, por lo que el valor de corte final es | si | 1/2 · aj | sj | 1/2 donde bj es la primera oferta que se ha negado pero se habría sidoSeleccionado no fue solo por la presencia del postor i. Por lo tanto, el pago del agente I es | Si | 1/2 · AJ | SJ | 1/2 si ai ≥ | si | 1/2 · aj | sj | 1/2, y 0 de lo contrario. Este esquema de pago es exactamente el mismo que el esquema de pago en [12].6. Conclusiones En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación o satisfacer al MP es una condición necesaria y suficiente para que exista un mecanismo veraz. Luego formulamos un marco general para diseñar el pago P de manera que el mecanismo M = (O, P) sea sincero y computable en el tiempo polinomial. Además, presentamos varias técnicas generales basadas en composición para calcular P de manera eficiente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para las técnicas basadas en la composición de computación P en el tiempo polinomial. En este artículo, nos hemos concentrado en cómo calcular P en el tiempo polinomial. Nuestros algoritmos no necesariamente tienen el tiempo de ejecución óptimo para calcular P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos progresado en esta dirección de investigación en [22] al proporcionar un algoritmo para calcular los pagos de unidifusión en un gráfico ponderado de nodo en el tiempo óptimo de O (N log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación o satisfacer a MP con una buena relación de aproximación para un juego de demanda binaria determinada. Muchas obras [12, 13] en la literatura de diseño del mecanismo están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar reglas de asignación con buenas relaciones de aproximación de modo que un juego de demanda binaria determinada tenga un esquema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño del mecanismo para los juegos de demanda binaria. Sin embargo, algunos problemas no pueden formularse directamente como juegos de demanda binaria. El problema de programación de trabajo en [2] es un ejemplo. Para este problema, existe un esquema de pago veraz P para una regla de asignación o si y solo si la carga de trabajo asignada por O es monotónica de cierta manera. A la herida será de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a los juegos de demanda no binarios. Hacia esta dirección de investigación, el Teorema 4 se puede extender a una regla de asignación general O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo suposiciones leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Nos gustaría agradecer a Rakesh Vohra, Tuomas Sandholm y los revisores anónimos por sus útiles comentarios y discusiones.7. REFERENCIAS [1] A. Archer, C. Papadimitriou, K. T. y Tardos, E. Un mecanismo de veraz aproximado para subastas combinatorias con agentes de parámetros únicos. En ACM-SIAM Soda (2003), pp. 205-214.[2] Archer, A. y Tardos, E. Mecanismos veraces para agentes de un parámetro. En Actas del 42º IEEE FOCS (2001), IEEE Computer Society, p.482. [3] Auletta, V., Prisco, R. D., Penna, P. y Persiano, P. Esquemas de aproximación veraz deterministas para las máquinas relacionadas con la programación.[4] Chvatal, V. Una heurística codiciosa para el problema de cobertura del conjunto. Matemáticas de Operations Research 4, 3 (1979), 233-235.[5] Clarke, E. H. Precios multipart de bienes públicos. Public Choice (1971), 17-33.[6] R. Muller y R. V. Vohra. Sobre mecanismos de estrategia dominante. Working Paper, 2003. [7] Devanur, N. R., Mihail, M. y Vazirani, V. V. Mecanismos de intercambio de costos a prueba de estrategias para juegos de ubicación de la portada y la instalación. En ACM Electronic Commerce (EC03) (2003).[8] Feigenbaum, J., Krishnamurthy, A., Sami, R. y Shenker, S. Aproximación y colusión en costos compartidos de multidifusión (resumen). En ACM Economic Conference (2001).[9] Feigenbaum, J., Papadimitriou, C., Sami, R. y Shenker, S. Un mecanismo basado en BGP para el enrutamiento de menor costo. En Actas del Simposio ACM de 2002 sobre principios de computación distribuida.(2002), pp. 173-182.[10] Green, J. y Laffont, J. J. Caracterización de mecanismos satisfactorios para la revelación de las preferencias de los bienes públicos. Econometrica (1977), 427-438.[11] Groves, T. Incentivos en equipos. Econometrica (1973), 617-631.[12] Lehmann, D., Ocallaghan, L. I. y Shoham, Y. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Journal of ACM 49, 5 (2002), 577-602.[13] Mualem, A. y Nisan, N. Mecanismos de aproximación veraz para subastas combinatorias restringidas: abstracto extendido. En la 18ª Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana de Inteligencia Artificial, pp. 379-384.[14] Nisan, N. y Ronen, A. Diseño del mecanismo algorítmico. En Proc.31º ACM STOC anual (1999), págs. 129-140.[15] E. Halperin. Algoritmos de aproximación mejorados para el problema de la cubierta del vértice en gráficos e hipergrafios. En Actas del 11º Simposio ACM-SIAM anual sobre algoritmos discretos, páginas 329-337, 2000. [16] R. Bar-Yehuda y S. incluso. Un teorema de relación local para aproximar el problema de cubierta de vértice ponderado. Anales de Matemáticas Discretas, Volumen 25: Análisis y diseño de algoritmos para problemas combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] Robins, G. y Zelikovsky, A. Aproximación mejorada del árbol Steiner en gráficos. En Actas del 11º ACM-SIAM Soda anual (2000), pp. 770-779.[18] A. Zelikovsky. Un algoritmo de 11/6 de acujos para el problema de la red Steiner. Algorithmica, 9 (5): 463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cobertura de vértice y problemas de embalaje, matemáticas aplicadas discretas, 6: 243-254, 1983. [20] Takahashi, H. y Matsuyama, A. Una solución aproximada para el problema Steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577.[21] Vickrey, W. Contadores, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37.[22] Wang, W. y Li, X.-Y. Unicast de bajo costo en las redes inalámbricas egoístas. En la cuarta transacciones IEEE en Mobile Computing (2005), para aparecer.[23] Wang, W., Li, X.-Y., y Sun, Z. Diseñar protocolos de multidifusión para redes no cooperativas. IEEE Infocom 2005, para aparecer.[24] Wang, W., Li, X.-Y. y Wang, Y. Multicast sincero en redes inalámbricas egoístas. ACM Mobicom, 2005. 222