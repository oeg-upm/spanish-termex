Asignación de autoridad en los juegos distribuidos basados en el poder múltiples Sudhir Aggarwal Justin Christofoli Departamento de Ciencias de la Computación de la Universidad Estatal de Florida, Tallahassee, FL {Sudhir, Christof}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Bell Laboratories, Holmdel,, Holmdel,,NJ {Sarit, sampath}@bell-labs.com Resumen Presentamos una arquitectura de juego basada en el poder y una asignación de autoridad dentro de esta arquitectura que puede conducir a una mejor experiencia de juego en juegos en línea masivamente múltiples jugadores. La arquitectura de juego propuesta consiste en clientes de juegos distribuidos que se conectan a los proxies de juegos (denominados proxies de comunicación) que reenvían los mensajes relacionados con el juego de los clientes a uno o más servidores de juegos. A diferencia de las arquitecturas basadas en el proxy que se han propuesto en la literatura donde los proxies replican todo el estado del juego, los proxies de comunicación en los clientes de soporte de arquitectura propuestos que están cerca de él en la red física y mantienen información sobre las porciones seleccionadas del juegoespacio que son relevantes solo para los clientes que apoyan. Usando esta arquitectura, proponemos un mecanismo de asignación de autoridad que divide la autoridad para decidir el resultado de diferentes acciones/eventos que ocurren dentro del juego entre el cliente y los servidores por acción/evento. Mostramos que dicha división de autoridad conduce a una experiencia de juego más suave al implementar este mecanismo en un juego en línea masivamente multijugador llamado RPGQuest. Además, argumentamos que las técnicas de detección de trucos se pueden implementar fácilmente en los proxies de comunicación si se considera que la mecánica del juego. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: aplicaciones distribuidas distribuidas de sistemas Términos generales Juegos, rendimiento 1. Introducción en juegos en línea masivamente múltiples jugadores (MMOG), clientes de juegos que están posicionados a través de Internet se conectan a un servidor de juegos para interactuar con otros clientes para ser parte del juego. En las arquitecturas actuales, estas interacciones son directas en que los clientes del juego y los servidores intercambian mensajes del juego entre sí. Además, MMOGS actual delega a toda la autoridad al servidor de juegos para tomar decisiones sobre los resultados relacionados con las acciones que toman los clientes del juego y también para decidir sobre el resultado de otros eventos relacionados con el juego. Dicha autoridad centralizada se ha implementado con la afirmación de que esto mejora la seguridad y la consistencia requeridas en un entorno de juego. Varios trabajos han demostrado el efecto de la latencia de la red en los juegos distribuidos de múltiples jugadores [1, 2, 3, 4]. Se ha demostrado que la latencia de la red tiene un impacto real en la experiencia práctica en el juego [3, 5]. Algunos tipos de juegos pueden funcionar bastante bien incluso en presencia de grandes retrasos. Por ejemplo, [4] muestra que en un juego de rol moderno llamado Everquest 2, el punto de interrupción del juego al agregar latencia artificial fue de 1250 ms. Esto se explica al hecho de que el sistema de combate utilizado en Everquest 2 se basa en colas y tiene una interacción muy baja. Por ejemplo, un jugador hace cola 4 o 5 hechizos que desea lanzar, cada uno de estos hechizos tarda 1-2 segundos en realizar, dando al servidor mucho tiempo para validar estas acciones. Pero hay otros juegos, como los juegos de FPS, que se rompen en presencia de latencias de red moderadas [3, 5]. Se han propuesto técnicas de compensación de latencia para aliviar el efecto de la latencia [1, 6, 7], pero es obvio que si los MMOG aumentan en interactividad y velocidad, se deberán desarrollar más arquitecturas que aborden la capacidad de respuesta, precisión y consistencia de laGamestate. En este artículo, proponemos dos características importantes que harían que el juego se repita con el juego dentro de los MMOG más receptivos para el movimiento y escalable. Primero, proponemos que las arquitecturas centralizadas basadas en el servidor sean jerárquicas a través de la introducción de proxies de comunicación para que las actualizaciones de juegos realizadas por clientes que son sensibles al tiempo, como el movimiento, pueden distribuirse de manera más eficiente a otros jugadores dentro de su espacio de juego. En segundo lugar, proponemos que la asignación de autoridad en términos de quién toma la decisión sobre las acciones del cliente, como las recogidas y los golpes de objetos, y las colisiones entre los jugadores, se distribuyan entre los clientes y los servidores para distribuir la carga informática del servidor central del servidor central. Para avanzar hacia juegos en red en tiempo real más complejos, creemos que las definiciones de autoridad deben ser refinadas. La mayoría de los MMOG implementados actualmente tienen servidores de juegos que tienen una autoridad casi absoluta. Argumentamos que no existe una visión consistente del espacio de juegos virtual que se pueda mantener en cualquier componente dentro de una red que tenga una latencia significativa, como la que muchos jugadores de MMOG experimentarían. Creemos que en la mayoría de los casos, el cliente con la visión más precisa de una entidad es la más adecuada para tomar decisiones para esa entidad cuando la causalidad de esa acción no afectará de inmediato a ningún otro jugador. En este artículo definimos lo que significa tener autoridad dentro del contexto de eventos y objetos en un espacio de juego virtual. Luego mostramos los beneficios de delegar la autoridad para diferentes acciones y eventos de juego entre los clientes y el servidor. En nuestro modelo, el espacio de juego consta de clientes de juegos (que representan a los jugadores) y objetos que controlan. Dividamos las acciones del cliente y los eventos del juego (nos referiremos colectivamente a estos como eventos) como colisiones, éxitos, etc. en tres categorías diferentes, a) eventos para los cuales el cliente del juego tiene una autoridad absoluta, b) eventos para los cuales el servidor del juegotiene autoridad absoluta, y c) eventos para los cuales la autoridad cambia dinámicamente del cliente al servidor y al viceversa. Dependiendo de quién tenga la autoridad, esa entidad tomará decisiones sobre los eventos que ocurren dentro de un espacio de juego. Proponemos que la autoridad para todas las decisiones que pertenecen a un solo jugador u objeto en el juego que no afecte a los otros jugadores u objetos, ni se ve afectado por las acciones de otros jugadores se delegan a ese cliente del juego de jugadores. Este tipo de decisiones incluiría la detección de colisiones con objetos estáticos dentro del espacio de juego virtual y la detección de golpes con balas de ruta lineal (cuya trayectoria se fija y no cambia con el tiempo) disparadas por otros jugadores. La autoridad de las decisiones que podrían verse afectadas por dos o más jugadores deben delegarse al servidor central imparcial, en algunos casos, para garantizar que no se produzcan conflictos y en otros casos se puedan delegar a los clientes responsables de esos jugadores. Por ejemplo, la detección de colisiones de dos jugadores que chocan entre sí y golpean la detección de balas no lineales (que cambia la trayectoria con el tiempo) debe delegarse al servidor. La decisión sobre eventos como la recolección de elementos (por ejemplo, recoger elementos en un juego para acumular puntos) debe delegarse a un servidor si hay múltiples jugadores muy cerca de un elemento y cualquiera de los jugadores podría tener éxito en elegir el elemento;Para la disputa de recogida de artículos, donde el cliente se da cuenta de que ningún otro jugador, excepto su propio jugador, está dentro de un cierto rango del artículo, el cliente podría delegarse la responsabilidad de reclamar el artículo. La decisión de los clientes siempre puede ser verificada con precisión por el servidor. En resumen, argumentamos que, si bien los modelos de autoridad actual que solo delegan la responsabilidad del servidor para tomar decisiones autorizadas sobre los eventos es más seguro que permitir a los clientes tomar las decisiones, este tipo de modelos agregan demoras indeseables a los eventos que podrían decidir ser decididos.por los clientes sin que se introduzca ninguna inconsistencia en el juego. A medida que los juegos en red se vuelven más complejos, nuestra arquitectura se volverá más aplicable. Esta arquitectura es aplicable para juegos multijugador masivo donde la velocidad y la precisión del juego son una gran preocupación, mientras que la consistencia entre los estados de juego del jugador todavía se desea. Proponemos que un mecanismo de asignación de autoridad mixta, como el descrito anteriormente, se implementará en MMOG de alta interacción. Nuestro artículo tiene las siguientes contribuciones. Primero proponemos una arquitectura que utiliza proxies de comunicación para permitir que los clientes se conecten al servidor de juegos. Un proxy de comunicación en la arquitectura propuesta mantiene información solo sobre partes del espacio de juego que son relevantes para los clientes conectados a él y pueden procesar la información de movimiento de objetos y jugadores dentro de estas porciones. Además, es capaz de multidifusión de esta información solo a un subconjunto relevante de otros proxies de comunicación. Estas funcionalidades de un proxy de comunicación conducen a una disminución en la latencia de la actualización de eventos y, posteriormente, una mejor experiencia de juego. En segundo lugar, proponemos un mecanismo de asignación de autoridad mixta como se describe anteriormente que mejora la experiencia del juego. En tercer lugar, implementamos el mecanismo de asignación de autoridad mixta propuesta dentro de un MMOG llamado RPGQuest [8] para validar su viabilidad dentro de MMOGS. En la Sección 2, describimos la arquitectura del juego basada en el poder con más detalle e ilustramos sus ventajas. En la Sección 3, proporcionamos una descripción genérica del mecanismo de asignación de autoridad mixta y discutimos cómo mejora la experiencia del juego. En la Sección 4, mostramos la viabilidad de implementar el mecanismo de asignación de autoridad mixta propuesta dentro de los MMOG existentes describiendo una implementación de prueba de concepto dentro de un MMOG existente llamado RPGQuest. La Sección 5 discute el trabajo relacionado. En la Sección 6, presentamos nuestras conclusiones y discutimos el trabajo futuro.2. La arquitectura de juegos basada en el poder basada en los juegos en línea de juego múltiple (MMOG) generalmente consisten en un gran espacio de juego en el que los jugadores y los diferentes objetos de juego residen y se mueven e interactúan con uno, uno. La información estatal sobre todo el espacio del juego podría mantenerse en un solo servidor central al que nos referiríamos como una arquitectura de servidor central. Pero para aliviar la gran demanda del procesamiento para manejar la población de jugadores grandes y los objetos en el juego en tiempo real, normalmente se implementa un MMOG utilizando una arquitectura de servidor distribuido donde el espacio del juego se subdivide aún más en regiones para que cada unoLa región tiene un número relativamente menor de jugadores y objetos que pueden ser manejados por un solo servidor. En otras palabras, las diferentes regiones de juegos son alojadas por diferentes servidores de manera distribuida. Cuando un jugador sale de una región de juego a otra adyacente, el jugador debe comunicarse con un servidor diferente (de lo que se estaba comunicando actualmente) alojando la nueva región. Los servidores se comunican entre sí para entregar un jugador o un objeto de una región a otra. En este modelo, el reproductor de la máquina cliente tiene que establecer múltiples sesiones de juego con diferentes servidores para que pueda deambular en todo el espacio del juego. Proponemos una arquitectura basada en el proxy de comunicación donde un reproductor se conecta a un proxy (geográficamente) cercano en lugar de conectarse a un servidor central en el caso de una arquitectura de centralserver o a uno de los servidores en caso de DIS2 el quinto taller en la red y el soporte del sistemaPara los Juegos 2006 - NetGames 2006 Arquitectura del servidor Tributed. En la arquitectura propuesta, los jugadores que están cerca se unen geográficamente un proxy particular. El proxy luego se conecta a uno o más servidores de juegos, según lo sea necesario por el conjunto de jugadores que se conectan a él y mantienen sesiones de transporte persistentes con este servidor. Esto alivia el problema de que cada jugador tenga que conectarse directamente a múltiples servidores de juegos, lo que puede agregar un retraso de configuración de conexión adicional. La introducción de los proxies de comunicación también mitiga la sobrecarga de una gran cantidad de sesiones de transporte que deben administrarse y reduce el ancho de banda de red requerido [9] y el procesamiento en los servidores de juegos con arquitecturas de servidor central y servidor distribuido. Con las arquitecturas del servidor central, los proxies de comunicación reducen la sobrecarga en el servidor al no requerir que el servidor termine las sesiones de transporte persistentes de cada uno de los clientes. Con las arquitecturas de servidor distribuido, además, los representantes de comunicación eliminan la necesidad de que los clientes mantengan sesiones de transporte persistentes a cada uno de los servidores. La Figura 1 muestra la arquitectura propuesta. Figura 1: Arquitectura del entorno de juego. Tenga en cuenta que los proxies de comunicación no necesitan ser conscientes del juego. Organizan a varios jugadores e informan a los servidores qué jugadores son alojados por el proxy en cuestión. También tenga en cuenta que los jugadores organizados por un proxy pueden no estar en el mismo espacio de juego. Es decir, un proxy alberga jugadores que están geográficamente cerca de él, pero los propios jugadores pueden residir en diferentes partes del espacio del juego. El proxy se comunica con los servidores responsables de mantener los espacios de juego suscritos por los diferentes jugadores. Los proxies se comunican entre sí en un punto de igual a la moda. La capacidad de respuesta del juego se puede mejorar para las actualizaciones que no necesitan esperar el procesamiento en una autoridad central. De esta manera, la información sobre los jugadores se puede difundir más rápido antes de que el servidor del juego lo sepa. Esto definitivamente mejora la capacidad de respuesta del juego. Sin embargo, ignora la consistencia que es crítica en MMORPG. La noción de que una arquitectura como esta aún puede mantener la consistencia temporal se discutirá en detalle en la Sección 3. La Figura 2 muestra y ejemplo del principio de funcionamiento de la arquitectura propuesta. Suponga que el espacio del juego se divide en 9 regiones y hay tres servidores responsables de administrar las regiones. Server S1 posee las regiones 1 y 2, S2 administra 4, 5, 7 y 8, y S3 es responsable de 3, 6 y 9. Figura 2: Un ejemplo. Hay cuatro proxies de comunicación colocados en ubicaciones geográficamente distantes. Los jugadores A, B, C se unen a Proxy P1, proxy P2 Hosts Players D, E, F, Players G, H son con Proxy P3, mientras que los jugadores I, J, K, L están con Proxy P4. Debajo de cada jugador, la figura muestra qué región de juego se encuentra el jugador actualmente. Por ejemplo, los jugadores A, B, C están en las regiones 1, 2, 6, respectivamente. Por lo tanto, el proxy P1 debe comunicarse con los servidores S1 y S3. El lector puede verificar el resto de los enlaces entre los proxies y los servidores. Los jugadores pueden moverse dentro de la región y entre regiones. El movimiento del jugador dentro de una región será rastreado por el proxy que aloja al jugador y esta información de movimiento (por ejemplo, las nuevas coordenadas de los jugadores) serán multidifusión a un subconjunto de otros proxies de comunicación relevantes directamente. Al mismo tiempo, esta información se enviará al servidor responsable de esa región con la indicación de que este movimiento ya se ha comunicado a todos los demás proxies de comunicación relevantes (para que el servidor no tenga que transmitir esta información a todos los proxies). Por ejemplo, si el jugador A se mueve dentro de la Región 1, esta información será comunicada por Proxy P1 al servidor S1 y multidifusión a proxies P3 y P4. Tenga en cuenta que los representantes que no mantienen información estatal sobre esta región en este momento (porque no tienen ningún cliente dentro de esa región) como P2 no tienen que recibir esta información de movimiento. Si un jugador está en el límite de una región y se muda a una nueva región, hay dos posibilidades. La primera posibilidad es que el proxy que aloja al jugador puede identificar la región en la que se mueve el jugador (según la información de la trayectoria) porque también mantiene información de estado sobre la nueva región en ese momento. En este caso, el proxy puede actualizar la información del movimiento directamente a los otros representantes de comunicación relevantes y también enviar información al servidor apropiado informando sobre el movimiento (esto puede requerir la transferencia entre los servidores como describiremos). Considere el escenario en el que el Jugador A está en el límite de la Región 1 y Proxy P1 puede identificar que el jugador se está mudando a la Región 2. Debido a que Proxy P1 actualmente mantiene la información estatal sobre la Región 2, puede informar todo el quinto taller sobre el soporte de redes y sistemas para los juegos 2006 - NetGames 2006 3 Los otros proxies de comunicación relevantes (en este ejemplo, ningún otro proxy mantiene información sobre la Región 2 enEste punto y, por lo tanto, no se debe enviar ninguna actualización a ninguno de los otros proxies) sobre este movimiento y luego informar al servidor de forma independiente. En este caso particular, el servidor S1 también es responsable de la Región 2, por lo que no se necesitaría transferir entre servidores. Ahora considere otro escenario en el que el jugador J se mueve de la región 9 a la región 8 y ese proxy P4 puede identificar este movimiento. Nuevamente, debido a que Proxy P4 mantiene información estatal sobre la Región 8, puede informar a cualquier otro proxies de comunicación relevante (nuevamente, ninguno en este ejemplo) sobre este movimiento. Pero ahora, las regiones 9 y 8 son manejadas por diferentes servidores (servidores S3 y S2 respectivamente) y, por lo tanto, se necesita una transferencia entre estos servidores. Proponemos que en este escenario particular, la transferencia sea administrada por el proxy P4 en sí. Cuando el proxy envía la actualización de movimiento al servidor S3 (informando al servidor que el reproductor se está mudando de su región), también enviaría un mensaje al servidor S2 informando al servidor sobre la presencia y la ubicación del reproductor en una de su región. En los escenarios intra-región e interregión descritos anteriormente, el proxy puede administrar la información relacionada con el movimiento, actualizar solo los proxies de comunicación relevantes sobre el movimiento, actualizar los servidores con el movimiento y habilitar la transferencia de un jugador entre los servidores si es necesario.. De esta manera, el proxy realiza actualizaciones de movimiento sin involucrar a los servidores de ninguna manera en esta función crítica de tiempo, acelerando así el juego y mejorando la experiencia de juego para los jugadores. Consideramos que este es el camino rápido para la actualización del movimiento. Imaginamos que los proxies son justos proxies de comunicación, ya que no saben sobre el funcionamiento de juegos específicos. Simplemente procesan información de movimiento de jugadores y objetos y comunican esta información a los otros proxies y los servidores. Si los proxies se hacen más inteligentes, ya que entienden más de la lógica del juego, es posible que verifiquen rápidamente las reclamaciones hechas por los clientes y mitigan las trampas. Los servidores podrían realizar la misma funcionalidad pero con más retraso. Incluso sin ser conscientes de la lógica del juego, los proxies pueden proporcionar funcionalidades adicionales, como mensajes de marca de tiempo para hacer que la experiencia de juego del juego sea más precisa [10] y justa [11]. La segunda posibilidad que debe considerarse es cuando los jugadores se mueven entre regiones. Es posible que un jugador se mueva de una región a otra, pero el proxy que está alojando al jugador no puede determinar la región en la que el jugador se mueve, a) el proxy no mantiene información de estado sobre todas las regiones en las que las regiones en las queEl jugador podría moverse, o b) el proxy no puede determinar en qué región puede moverse el jugador (incluso si mantiene información de estado sobre todas estas regiones). En este caso, proponemos que el proxy no sea responsable de tomar la decisión del movimiento, sino comunicar la indicación del movimiento al servidor responsable de la región dentro de la cual se encuentra actualmente el jugador. Luego, el servidor tomará la decisión de movimiento y luego a) informa a todos los proxies, incluido el proxy que aloja al reproductor, y b) iniciará la transferencia con otro servidor si el reproductor se mueve a una región administrada por otro servidor. Consideramos que esta es la actualización de ruta lenta para el movimiento en que los servidores deben participar en la determinación de la nueva posición del jugador. En el ejemplo, suponga que el jugador A se mueve de la Región 1 a la Región 4. Proxy P1 no mantiene información estatal sobre la Región 4 y, por lo tanto, pasaría la información del movimiento al servidor S1. El servidor identificará que el jugador se ha mudado a la Región 4 e informará a Proxy P1 y Proxy P2 (que es el único otro proxy que mantiene información sobre la Región 4 en este momento). Server S1 también iniciará una transferencia del Jugador A con el servidor S2. Proxy P1 ahora comenzará a mantener la información estatal sobre la Región 4 porque uno de sus jugadores alojados, el Jugador A se ha mudado a esta región. Lo hará solicitando y recibiendo la información del estado actual sobre la Región 4 del servidor S2 que es responsable de esta región. Por lo tanto, una arquitectura proxy nos permite hacer uso de actualizaciones de movimiento más rápidas a través de la ruta rápida a través de un proxy si es posible, en lugar de las arquitecturas convencionales basadas en servidores que siempre tienen que usar la ruta lenta a través del servidor para las actualizaciones de movimiento. Al mantener selectivamente la información relevante del estado del juego regional en los proxies, podemos lograr esta capacidad en nuestra arquitectura sin la necesidad de mantener el estado completo del juego en cada proxy.3. Se juega la asignación de autoridad como MMOG, los jugadores y los objetos del juego que forman parte del juego, cambian continuamente su estado. Por ejemplo, considere a un jugador que posee un tanque en un juego de campo de batalla. Según la acción del jugador, el tanque cambia su posición en el espacio del juego, la cantidad de municiones que el tanque contiene cambios a medida que dispara a otros tanques, el tanque recolecta un poder de disparo de bonificación basada en éxitos exitosos, etc. De manera similar, los objetos en el campo de batalla, como banderas, edificios, etc., cambian su estado cuando un jugador recoge una bandera (es decir, un tanque) o un edificio se destruye disparando. Es decir, se debe tomar alguna decisión en el estado de cada jugador y objeto a medida que avanza el juego. Tenga en cuenta que el estado de un jugador y/u objeto puede contener varios parámetros (por ejemplo, posición, cantidad de municiones, almacenamiento de combustible, puntos recolectados, etc.), y si alguno de los parámetros cambia, el estado del jugador/objeto cambia. En un juego basado en el cliente-servidor, el servidor controla a todos los jugadores y los objetos. Cuando un reproductor en una máquina cliente hace un movimiento, el movimiento se transmite al servidor a través de la red. Luego, el servidor analiza el movimiento, y si el movimiento es válido, cambia el estado del reproductor en el servidor e informa al cliente del cambio. Posteriormente, el cliente actualiza el estado del jugador y representa al jugador en la nueva ubicación. En este caso, la autoridad para cambiar el estado del reproductor reside con el servidor por completo y el cliente simplemente sigue lo que el servidor le indica que haga. La mayoría de los juegos actuales de First Person Shooter (FPS) y los juegos de rol (RPG) caen en esta categoría. En los juegos actuales de FPS, al igual que en los juegos RPG, no se confía en el cliente. Todos los movimientos y acciones que realiza están validados. Si un cliente detecta que ha golpeado a otro jugador con una bala, procede asumiendo que es un éxito. Mientras tanto, se envía una actualización al servidor y el servidor enviará un mensaje afirmando o negando que el reproductor fuera golpeado. Si el jugador remoto no fue golpeado, entonces el cliente sabrá que es el quinto taller en la red y el soporte del sistema para los juegos 2006 - NetGames 2006 en realidad no realizó la toma. Si hizo el golpe, también se enviará una actualización del servidor a los otros clientes informándoles que el otro jugador fue golpeado. Una diferencia que ocurre en algunos juegos de rol es que usan programas de clientes muy tontos. Algunos juegos de rol no mantienen información de estado en el cliente y, por lo tanto, no pueden predecir nada como los golpes en el cliente. La información del estado no se mantiene porque no se confía en el cliente. En los juegos de rol, un jugador de trampa con un cliente de juego pirateado puede usar información estatal almacenada en el cliente para obtener una ventaja y encontrar cosas como tesoros ocultos o monstruos que acechan a la vuelta de la esquina. Esta es una razón por la cual la mayoría de los MMORPG no envían mucha información estatal al cliente y hace que el juego sea menos receptivo y tenga un juego de juego de interacción más bajo que los juegos de FPS. En un juego de pares, cada par de pares controla el jugador y el objeto que posee. Cuando un jugador hace un movimiento, la máquina de pares analiza el movimiento y, si es válido, cambia el estado del jugador y coloca al jugador en una nueva posición. Posteriormente, el pares del propietario informa a todos los demás pares sobre el nuevo estado del jugador y el resto de los pares actualizan el estado del jugador. En este escenario, la autoridad para cambiar el estado del jugador se le da al compañero de propiedad y todos los demás pares simplemente siguen al propietario. Por ejemplo, Battle Zone Flag (BZFlag) [12] es un juego de servidor de cliente multijugador donde el cliente tiene toda la autoridad para tomar decisiones. Fue construido principalmente con Lan Play en mente y engañando como una ocurrencia tardía. Los clientes en BZFLAG son completamente autorizados y cuando detectan que fueron golpeados por una bala, envían una actualización al servidor que simplemente reenvía el mensaje a todos los demás jugadores. El servidor no hace un tipo de validación. Cada uno de los dos enfoques tradicionales anteriores tiene su propio conjunto de ventajas y desventajas. El primer enfoque, al que nos referiremos como autoridad del servidor en adelante, utiliza un método centralizado para asignar autoridad. Si bien un enfoque centralizado puede mantener el estado del juego (es decir, el estado de todos los jugadores y objetos) consistente en cualquier cantidad de máquinas clientes, sufre una respuesta retrasada en el juego como cualquier movimiento que un jugador en la máquina del cliente realizaDebe pasar por un retraso de ida y vuelta al servidor antes de que pueda entrar en vigencia en la pantalla del cliente. Además del retraso de ida y vuelta, también existe un retraso en cola en el procesamiento de la solicitud de cambio de estado en el servidor. Esto puede dar lugar a un retraso de procesamiento adicional, y también puede traer problemas de escalabilidad severos si hay una gran cantidad de clientes que juegan el juego. Una ventaja definitiva del enfoque autorizado del servidor es que puede detectar fácilmente si un cliente está haciendo trampa y puede tomar las medidas apropiadas para evitar hacer trampa. El enfoque de igual a igual, en adelante denominado autorizado por el cliente, puede hacer que los juegos sean muy receptivos. Sin embargo, puede hacer que el estado del juego sea inconsistente para algunos jugadores y se debe realizar un descanso (o retroceder) para llevar el juego de regreso a un estado consistente. Ni Tie Break ni Roll Back es una característica deseable de los juegos en línea. Por ejemplo, suponga que para un juego, el objetivo de cada jugador es recolectar tantas banderas como sea posible del espacio del juego (p. Ej. Bzflag). Cuando dos jugadores en proximidad intentan recolectar la misma bandera al mismo tiempo, dependiendo del algoritmo utilizado en el lado del cliente, ambos clientes pueden determinar que es el ganador, aunque en realidad solo un jugador puede recoger la bandera. Ambos jugadores verán en su pantalla que es el ganador. Esto hace que el estado del juego sea inconsistente. Las formas de recuperarse de esta inconsistencia son dar la bandera a un solo jugador (usando una regla de break de back) o retroceder el juego para que los jugadores puedan intentarlo nuevamente. Ninguno de estos dos enfoques es una experiencia agradable para los juegos en línea. Otro problema con el enfoque autorizado del cliente es el engaño de los clientes, ya que no hay verificación cruzada de la validación de los cambios estatales autorizados por el cliente propietario. Proponemos utilizar un enfoque híbrido para asignar la autoridad dinámicamente entre el cliente y el servidor. Es decir, asignamos la autoridad al cliente para que el juego responda, y usamos la autoridad de los servidores solo cuando las decisiones autorizadas individuales de los clientes pueden hacer que el juego sea inconsistente. Al trasladar las actualizaciones críticas de la autoridad del tiempo al cliente, evitamos el retraso adicional causado al requerir que el servidor valida estas actualizaciones. Por ejemplo, en el juego de recolección de banderas, a los clientes tendrán la autoridad de recoger banderas solo cuando otros jugadores no están dentro de un rango de que podrían recoger inminentemente una bandera. Solo cuando dos o más jugadores están cerca para que más de un jugador pueda afirmar haber recogido una bandera, la autoridad para el movimiento y la recolección de bandera irían al servidor central para que el estado del juego no se vuelva inconsistente. Creemos que en un gran espacio de juego donde un jugador a menudo se encuentra en un área muy abierta y escasamente poblada como las que a menudo se ven en el juego Second Life [13], esta arquitectura híbrida sería muy beneficiosa debido a los largos períodos queEl cliente tendría autoridad para enviar actualizaciones de movimiento por sí mismo. Esto tiene dos ventajas sobre el enfoque de la centralidad central, distribuye la carga de procesamiento a los clientes para la mayoría de los eventos y permite un juego más receptivo que no necesita esperar en un servidor para su validación. Creemos que nuestra noción de autoridad puede usarse para desarrollar un modelo estatal globalmente consistente de la evolución de un juego. Fundamentalmente, el estado consistente del sistema es el que define el servidor. Sin embargo, si la autoridad local se delega al cliente, en este caso, el estado del cliente se superpone en el estado de los servidores para determinar el estado global correcto. Por ejemplo, si el cliente es autorizado con respecto al movimiento de un jugador, entonces la trayectoria del jugador es la verdadera trayectoria y debe reemplazar la vista de los servidores de la trayectoria de los jugadores. Tenga en cuenta que esto podría ser problemático y conducir a una inconsistencia temporal solo si, por ejemplo, dos o más entidades se mueven en la misma región y pueden interactuar entre sí. En esta situación, la autoridad del cliente debe volver al servidor y el grave tomaría decisiones. Por lo tanto, el cliente solo es autorizado en situaciones en las que no hay potencial para interactuar inminentemente con otros jugadores. Creemos que en los MMOG complejos, al permitir un movimiento más rápido, seguirá siendo el caso de que la autoridad local sea posible para tramos significativos de tiempo de juego. Tenga en cuenta que también podría ser posible minimizar las ocurrencias del problema de disparo del hombre muerto descrito en [14]. Esto podría hacerse permitiendo que el cliente sea autorizado para más acciones, como sus jugadores, la muerte de sus jugadores y rechazar a otros jugadores de tomar decisiones preventivas basadas en un jugador remoto. El quinto taller sobre el soporte de redes y sistemas para los juegos 2006 - NetGames 2006 5 Una razón por la cual la arquitectura basada en el cliente -servidor ha ganado popularidad se debe a la creencia de que la ruta más rápida hacia los otros clientes es a través del servidor. Si bien esto puede ser cierto, nuestro objetivo es crear una nueva arquitectura donde las decisiones no siempre tengan que tomarse en el servidor de juegos y la ruta más rápida hacia un cliente es realmente a través de un proxy de comunicación ubicado cerca del cliente. Es decir, la distancia más corta en nuestra arquitectura no es a través del servidor de juegos sino a través del proxy de comunicación. Después de que un cliente realiza una acción como el movimiento, lo distribuirá simultáneamente directamente a los clientes y al servidor de juegos a través del proxy de comunicaciones. Sin embargo, notamos que nuestra arquitectura no es práctica para un juego en el que los jugadores de juego configuran sus propios servidores de manera ad-hoc y no tienen acceso a proxies en los diversos ISP. Esta arquitectura de proxy y autoridad distribuida se puede utilizar a su máximo potencial solo cuando los proxies se pueden colocar en lugares estratégicos dentro de los ISP principales y distribuirse de manera uniforme geográficamente. Nuestra arquitectura del juego no supone que el cliente no sea confiado. Estamos diseñando nuestra arquitectura sobre el hecho de que habrá suficientes mecanismos de disuasión y detección de trucos presentes para que sea indeseable y muy difícil de hacer trampa [15]. En nuestro enfoque propuesto, podemos hacer que los juegos trate de resistencia utilizando la arquitectura basada en el proxy cuando tienen lugar las decisiones autoritarias del cliente. Para lograr esto, los proxies deben ser conscientes del juego para que las decisiones tomadas por un cliente puedan verificarse cruzadas por un proxy al que el cliente se conecta. Por ejemplo, suponga que en un juego un avión controlado por un cliente se mueve en el espacio del juego. No es posible que el avión pase por un edificio ileso. En un modo autoritario del cliente, es posible que el cliente haga trampa maniobre el avión a través de un edificio y reclamando que el avión no se d azaña. Sin embargo, cuando el cliente publica tal movimiento, el proxy, al tanto del espacio de juego en el que se encuentra el avión, puede verificar rápidamente que el cliente haya utilizado mal la autoridad y luego puede bloquear dicho movimiento. Esto nos permite distribuir autoridad para tomar decisiones sobre los clientes. En la siguiente sección, utilizamos un juego multijugador llamado RPGQuest para implementar diferentes esquemas autorizados y discutir nuestra experiencia con la implementación. Nuestra implementación muestra la viabilidad de nuestra solución propuesta.4. Experiencia de implementación Hemos experimentado con el mecanismo de asignación de autoridad descrito en la última sección mediante la implementación de los mecanismos en un juego llamado RPGQuest. Una captura de pantalla de este juego se muestra en la Figura 3. El propósito de la implementación es probar su viabilidad en un juego real. RPGQuest es un juego básico en primera persona donde el jugador puede moverse alrededor de un entorno tridimensional. Los objetos se colocan dentro del mundo del juego y los jugadores obtienen puntos para cada objeto que se recopila. Los clientes del juego se conectan a un servidor de juegos que permite que muchos jugadores coexistan en el mismo mundo del juego. La funcionalidad básica de este juego es representativa de los juegos actuales en primera persona en primera persona y los juegos de rol. El juego utiliza la API de gráficos DirectX 8 y la API de redes de DirectPlay. En esta sección discutiremos las tres versiones diferentes del juego con las que experimentamos. Figura 3: El juego RPGQuest. La primera versión del juego, que es la implementación original de RPGQuest, se creó con un servidor completamente autorizado y un cliente no autoritario. La autoridad dada al servidor incluye decisiones de cuándo un jugador choca con objetos estáticos y otros jugadores y cuándo un jugador recoge un objeto. Esta versión del juego funciona bien hasta 100 ms de latencia de ida y vuelta entre el cliente y el servidor. Hay poco retraso entre el tiempo que el jugador llega a una pared y el tiempo que el servidor corrige la posición de los jugadores. Sin embargo, a medida que se induce más latencia entre el cliente y el servidor, el juego se vuelve cada vez más difícil de jugar. Con el aumento de la latencia, los mensajes provenientes del servidor corrigen el reproductor cuando se ejecuta en una pared no se reciben lo suficientemente rápido. Esto hace que el jugador pase por la pared durante el período que está esperando que el servidor resuelva la colisión. Al estudiar el código fuente de la versión original del juego RPGQuest, hay un retraso sustancial que es inevitable cada vez que el servidor debe validar una acción. Cada vez que se envía una actualización de movimiento al servidor, el cliente debe esperar cualquiera que sea el retraso de ida y vuelta, más algún tiempo de procesamiento en el servidor para recibir su posición validada o corregida. Obviamente, esto es inaceptable en cualquier juego donde el movimiento o cualquier otra información de estado que cambie rápidamente debe validarse y difundir a los otros clientes rápidamente. Para evitar este problema, desarrollamos una segunda versión del juego, que le da toda la autoridad al cliente. El cliente fue delegado la autoridad para validar su propio movimiento y la autoridad para recoger objetos sin validación del servidor. En esta versión del juego, cuando un jugador se mueve por el espacio del juego, el cliente valida que la nueva posición de los jugadores no se cruza con ninguna pared o objetos estáticos. Luego se envía una actualización de posición al servidor que luego reenvía inmediatamente la actualización a los otros clientes dentro de la región. La actualización no tiene que pasar por ningún procesamiento o validación adicional. Este modelo de juego de autoridad completa que se le da al cliente es beneficioso con respecto al movimiento. Cuando las latencias de 6 el quinto taller en la red y el soporte del sistema para los juegos 2006 - NetGames 2006 100ms y Up se inducen al enlace entre el cliente y el servidor, el juego todavía se puede jugar ya que los aspectos críticos del tiempo del juego no tienen queEspere una respuesta desde el servidor. Cuando un jugador golpea un muro, la colisión se procesa localmente y no tiene que esperar en el servidor para resolver la colisión. Aunque la experiencia del juego con respecto a la capacidad de respuesta se mejora cuando la autoridad para el movimiento se da al cliente, todavía hay aspectos de los juegos que no se benefician de este enfoque. El más importante de estos es la consistencia. Aunque las acciones como el movimiento son críticas en el tiempo, otras acciones no son tan críticas del tiempo, sino que requieren consistencia entre los estados del jugador. Un ejemplo de un aspecto del juego que requiere consistencia es recoger objetos que solo deben poseer por un solo jugador. En nuestro cliente, la versión autorizada de los clientes RPGQuest envía sus propias actualizaciones a todos los demás jugadores cada vez que eligen un objeto. A partir de nuestras pruebas, nos hemos dado cuenta de que este es un problema porque cuando hay una cantidad realista de latencia entre el cliente y el servidor, es posible que dos jugadores recojan el mismo objeto al mismo tiempo. Cuando dos jugadores intentan recoger un objeto en los momentos físicos que están cerca el uno del otro, la actualización enviada por el jugador que recogió el objeto primero no llegará al segundo jugador a tiempo para ver que el objeto ya se ha reclamado.. Los dos jugadores ahora pensarán que son dueños del objeto. Es por eso que un servidor todavía es necesario para ser autorizado en esta situación y mantener la consistencia en los jugadores. Estas dos versiones del juego RPGQuest nos han mostrado por qué es necesario mezclar los dos modelos absolutos de autoridad. Es mejor colocar autoridad en el cliente para cambiar rápidamente acciones como el movimiento. No es deseable tener que esperar la validación del servidor en un movimiento que podría cambiar antes de que se reciba la respuesta. A veces también es necesario poner consistencia sobre la eficiencia en los aspectos del juego que no pueden tolerar ninguna inconsistencia como la propiedad de objetos. Creemos que a medida que aumenta la interactividad de los juegos, será necesaria nuestra arquitectura de autoridad mixta que no depende de la validación del servidor. Para probar los beneficios y mostrar la viabilidad de nuestra arquitectura de autoridad mixta, desarrollamos una tercera versión del juego RPGQuest que distribuyó autoridad para diferentes acciones entre el cliente y el servidor. En esta versión, en aras de la consistencia, el servidor siguió siendo autorizado por decidir quién recogió un objeto. El cliente recibió plena autoridad para enviar actualizaciones posicionales a otros clientes y verificar su propia posición sin la necesidad de verificar sus actualizaciones con el servidor. Cuando el jugador intenta mover su avatar, el cliente verifica que el movimiento no hará que se mueva a través de una pared. Luego se envía una actualización posicional al servidor que simplemente la reenvía a los otros clientes dentro de la región. Esto elimina cualquier retraso de procesamiento adicional que ocurra en el servidor y también es un medio de verificación más preciso, ya que el cliente tiene una visión más precisa de su propio estado que el servidor. Esta versión del juego RPGQuest donde se distribuye la autoridad entre el cliente y el servidor es una mejora de la versión autorizada del servidor. El cliente no tiene demora en esperar una actualización para su propio puesto y otros clientes no tienen que esperar en el servidor para verificar la actualización. Las inconsistencias en las que dos clientes pueden recoger el mismo objeto en la arquitectura autorizada del cliente no están presentes en esta versión del cliente. Sin embargo, los beneficios de la autoridad mixta no se verán realmente hasta que una implementación de nuestro proxy de comunicación se integre en el juego. Con la adición del proxy de comunicación, después de que el cliente verifica sus propias actualizaciones posicionales, podrá enviar la actualización a todos los clientes dentro de su región a través de un enlace de baja latencia en lugar de tener que pasar primero por el servidor de juegos que posiblemente podría estar enuna ubicación muy remota. La codificación de las diferentes versiones del juego fue muy simple. La complejidad del cliente aumentó muy ligeramente en los modelos autoritarios e híbridos del cliente. Los clientes tontos originales de RPGQuest conocen la posición de otros jugadores;No solo se envía una instantánea de pantalla desde el servidor. El servidor actualiza a cada cliente con la posición de todos los clientes cercanos. Los clientes tontos usan la predicción del lado del cliente para llenar los vacíos entre las actualizaciones que reciben. El único procesamiento adicional que el cliente tiene que hacer en la arquitectura híbrida es comparar su posición actual con las posiciones de todos los objetos (paredes, cajas, etc.) en su área. Obviamente, esto significa que cada cliente ya tendrá que haber descargado las ubicaciones de todos los objetos estáticos dentro de su región actual.5. Trabajo relacionado Se ha observado que, además de la latencia, los requisitos de ancho de banda también dictan el tipo de arquitectura de juego que se utilizará. En [16], se estudian diferentes tipos de arquitecturas con respecto a la eficiencia y la latencia del ancho de banda. Se señala que las arquitecturas del servidor central no son escalables debido a los requisitos de ancho de banda en el servidor, pero la sobrecarga para las verificaciones de consistencia es limitada a medida que se realizan en el servidor. Una arquitectura de igual a igual, por otro lado, es escalable, pero hay una sobrecarga significativa para las verificaciones de consistencia, ya que esto se requiere en cada jugador. El documento propone una arquitectura híbrida que es un tope de pares en términos de intercambio de mensajes (y por lo tanto es escalable) donde se utiliza un servidor central para verificaciones de consistencia fuera de línea (por lo tanto, mitigan la sobrecarga de verificación de consistencia). El documento proporciona un ejemplo de implementación de BZFLAG, que es un juego de igual a igual que se modifica para transferir toda la autoridad a un servidor central. En esencia, este documento aboga por una arquitectura de autoridad que se basa en el servidor incluso para los juegos de peert-peer, pero no considera la división de autoridad entre un cliente y un servidor para minimizar la latencia que podría afectar la experiencia de juego de los juegos incluso con el tipo de latencia que se encuentra enJuegos basados en servidor (donde toda la autoridad está con el servidor). También hay trabajos previos que han sugerido que se utilizarán arquitecturas basadas en proxy para aliviar el problema de latencia y, además, utilizar proxies para proporcionar control de congestión y mecanismos a prueba de trucos en juegos distribuidos de múltiples jugadores [17]. En [18], se presenta una arquitectura de red de servidor proxy que tiene como objetivo mejorar la escalabilidad de los juegos multijugador y reducir la latencia en la transmisión de datos del servidor-cliente. El objetivo principal de este trabajo es mejorar la escalabilidad de los juegos de disparos en primera persona (FPS) y los juegos de RPG. El objetivo adicional es mejorar la capacidad de respuesta MMOGS proporcionando comunicaciones de baja latencia entre el cliente y el quinto taller sobre el soporte de redes y sistemas para los juegos 2006 - NetGames 2006 7 Server. La arquitectura utiliza servidores proxy interconectados que tienen una visión completa del estado del juego global. Los servidores proxy se encuentran en varios ISP diferentes. Se menciona en este trabajo que dividir el espacio del juego entre los servidores de múltiples juegos, como el modelo federado presentado en [19], es ineficiente para un flujo de juego relativamente rápido y que la arquitectura propuesta alivia este problema porque los usuarios no tienen que conectarse a unServidor diferente cada vez que cruzan el límite del servidor. Esta arquitectura aún requiere que todos los proxies tengan en cuenta el estado general del juego en todo el espacio del juego a diferencia de nuestro trabajo donde requerimos que los proxies mantengan solo información de estado parcial sobre el espacio del juego. Se han propuesto arquitecturas de agentes basadas en fidelidad en [20, 21]. Estos trabajos proponen una arquitectura distribuida de cliente-servidor para simulaciones interactivas distribuidas donde diferentes servidores son responsables de diferentes partes del espacio del juego. Cuando un objeto se mueve de una porción a otra, hay una transferencia de un servidor a otro. Aunque estos trabajos proponen una arquitectura donde diferentes partes del espacio de simulación son administradas por diferentes servidores, no abordan el problema de disminuir el ancho de banda requerido mediante el uso de representantes de comunicación. Nuestro trabajo difiere de los trabajos anteriores discutidos anteriormente al proponer a) una arquitectura distribuida basada en el poder para disminuir los requisitos de ancho de banda en los clientes y los servidores sin requerir que los representantes mantengan información estatal sobre todo el espacio del juego, b) una técnica de asignación de autoridad dinámicapara reducir la latencia (realizando controles de consistencia localmente en el cliente siempre que sea posible) dividiendo la autoridad entre los clientes y los servidores por objeto, y c) proponer que la detección de trucos se pueda integrar en los proxies si se les proporciona más información sobreEl juego específico en lugar de usarlos puramente como proxies de comunicación (aunque esta idea aún no se ha implementado y es parte de nuestro trabajo futuro).6. Conclusiones y trabajo futuro En este documento, primero propusimos una arquitectura basada en el poder para los MMOG que permite que los MMOG se escalen a un gran número de usuarios mediante la mitigación de la necesidad de que se mantenga una gran cantidad de sesiones de transporte y disminuyan tanto la sobrecarga de la banda como la latenciade actualización de eventos. En segundo lugar, propusimos un mecanismo de asignación de autoridad mixta que divide la autoridad para tomar decisiones sobre acciones y eventos dentro del juego entre los clientes y el servidor y argumentamos cómo tal tarea de autoridad conduce a una mejor experiencia en el juego sin sacrificar la consistencia del juego. Tercero, para validar la viabilidad del mecanismo de asignación de autoridad mixta, lo implementamos dentro de un MMOG llamado RPGQuest y describimos nuestra experiencia de implementación. En el trabajo futuro, proponemos implementar la arquitectura proxy de comunicaciones descrita en este documento e integrar el mecanismo de autoridad mixta dentro de esta arquitectura. Proponemos evaluar los beneficios de la arquitectura basada en el poder en términos de escalabilidad, precisión y capacidad de respuesta. También planeamos implementar una versión del juego RPGQuest con una asignación dinámica de autoridad para permitir a los jugadores la autoridad para recoger objetos cuando ningún otro jugador está cerca. Como se discutió anteriormente, esto permitirá un juego más eficiente y receptivo en ciertas situaciones y aliviará parte de la carga de procesamiento del servidor. Además, dado que se pone tanta confianza en los clientes de nuestra arquitectura, será necesario integrarse en la arquitectura, muchos de los esquemas de detección de trucos que se han propuesto en la literatura. El software como Punkbuster [22] y un sistema de reputación como los propuestos por [23] y [15] serían integrales para el funcionamiento de una arquitectura como la nuestra que tiene mucha confianza en el cliente. Además, proponemos hacer que los proxies en nuestra arquitectura sean más conscientes de juegos para que los mecanismos de detección de trucos puedan incorporarse en los proxies mismos.7. Referencias [1] Y. W. Bernier. Métodos de compensación de latencia en el diseño y optimización del protocolo del cliente/servidor. En Proc.de Game Developers Conference01, 2001. [2] Lothar Pantel y Lars C. Wolf. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Nossdav 02: Actas del 12º Taller Internacional sobre Soporte de Red y Sistemas Operativos para Audio y Video digital, Páginas 23-29, Nueva York, NY, EE. UU., 2002. ACM Press.[3] G. Armitage. Sensibilidad de los jugadores de Quake3 a la latencia de red. En Proc.de IMW2001, Sesión del Taller Poster, noviembre de 2001. http://www.geocities.com/ GJ Armitage/Q3/Quake-Results.html.[4] Tobias Fritsch, Hartmut Ritter y Jochen Schiller. El efecto de la latencia y las limitaciones de la red en los MMORPG: un estudio de campo de Everquest2. En NetGames 05: Actas del 4º Taller de ACM Sigcomm en la red y el soporte del sistema para juegos, páginas 1-9, Nueva York, NY, EE. UU., 2005. ACM Press.[5] Tom Beigbeder, Rory Coughlan, Corey Lusher, John Plunkett, Emmanuel Agu y Mark Claypool. Los efectos de la pérdida y la latencia en el rendimiento del usuario en Unreal Tournament 2003. En NetGames 04: Actas del tercer taller de ACM Sigcomm en la red y el soporte del sistema para juegos, páginas 144-151, Nueva York, NY, EE. UU., 2004. ACM Press.[6] Y. Lin, K. Guo y S. Paul. Sync-MS: servicio de mensajería sincronizada para juegos distribuidos de jugadores múltiples en tiempo real. En Proc.de la décima Conferencia Internacional IEEE sobre protocolos de red (ICNP), noviembre de 2002. [7] Katherine Guo, Sarit Mukherjee, Sampath Rangarajan y Sanjoy Paul. Un marco de intercambio de mensajes justo para juegos distribuidos de múltiples jugadores. En NetGames 03: Actas del segundo taller en la red y el soporte del sistema para juegos, páginas 29-41, Nueva York, NY, EE. UU., 2003. ACM Press.[8] T. Barron. Programación del juego multijugador, Capítulo 16-17, páginas 672-731. Serie de desarrollo de juegos Prima Techs. Prima Publishing, 2001. 8 El quinto taller sobre el soporte de redes y sistemas para los juegos 2006 - NetGames 2006 [9] Carsten Griwodz y P˚al Halvorsen. La diversión de usar TCP para un MMORPG. En Nossdav 06: Actas del Taller Internacional sobre Soporte de Redes y Sistemas Operativos para Audio y Video Digital, Nueva York, NY, EE. UU., 2006. ACM Press.[10] Sudhir Aggarwal, Hemant Banavar, Amit Khandelwal, Sarit Mukherjee y Sampath Rangarajan. Precisión en juegos de juego múltiples basados en la reducción muerta. En NetGames 04: Actas del tercer taller de ACM Sigcomm en la red y el soporte del sistema para juegos, páginas 161-165, Nueva York, NY, EE. UU., 2004. ACM Press.[11] Sudhir Aggarwal, Hemant Banavar, Sarit Mukherjee y Sampath Rangarajan. Justicia en juegos de juego múltiples basados en reciones muertas. En NetGames 05: Actas del taller de 4º ACM SIGCOMM en Network and System Support para Juegos, Páginas 1-10, Nueva York, NY, EE. UU., 2005. ACM Press.[12] Riker, T. et al. Bzflag.http://www.bzflag.org, 2000-2006.[13] Linden Lab. Segunda vida.http://secondlife.com, 2003. [14] Martin Mauve. Cómo evitar que un hombre muerto dispare. En IDMS 00: Actas del 7º Taller Internacional sobre Sistemas Multimedia Distribuidos Interactivos y Servicios de Telecomunicaciones, páginas 199-204, Londres, Reino Unido, 2000. Springer-Verlag.[15] Max Skibinsky. Desarrollo de juego multijugador masivo 2, Capítulo La búsqueda de Holy Scalepart 2: P2P Continuum, páginas 355-373. Charles River Media, 2005. [16] Joseph D. Pellegrino y Constantinos Dovrolis. Requisito de ancho de banda y consistencia de estado en tres arquitecturas de juegos multijugador. En NetGames 03: Actas del segundo taller en la red y el soporte del sistema para juegos, páginas 52-59, Nueva York, NY, EE. UU., 2003. ACM Press.[17] M. Mauve J. Widmer y S. Fischer. Un sistema proxy genérico para juegos de computadora en red. En Proc.del taller en los juegos de red, NetGames 2002, abril de 2002. [18] S. Gorlatch J. Muller, S. Fischer y M.Mauve. Una arquitectura de red de servidor proxy para juegos de computadora en tiempo real. En Euor-PAR 2004 Procesamiento paralelo: 10ª Conferencia Internacional de Euro-PAR, agosto-septiembre de 2004. [19] H. Hazeyama T. Limura e Y. Kadobayashi. Federación Zoned de Servidores de Juego: un enfoque de igual a igual para juegos en línea multijugador escalables. En Proc.de ACM Workshop en los juegos de red, NetGames 2004, agosto-septiembre de 2004. [20] B. Kelly y S. Aggarwal. Un marco para una arquitectura de agente basada en fidelidad para la simulación interactiva distribuida. En Proc.14º taller sobre estándares para la simulación interactiva distribuida, páginas 541-546, marzo de 1996. [21] S. Aggarwal y B. Kelly. Estructura jerárquica para la simulación interactiva distribuida. En Proc.13º taller sobre estándares para la simulación interactiva distribuida, páginas 125-132, septiembre de 1995. [22] Incluso Balance, Inc. Punkbuster.http://www.evenbalance.com/, 2001-2006.[23] Y. Wang y J. Vassileva. Modelo de confianza y reputación en redes entre pares. En la Tercera Conferencia Internacional sobre Computación de Peer-To-Peer, 2003. El quinto taller sobre el soporte de redes y sistemas para los juegos 2006 - NetGames 2006 9