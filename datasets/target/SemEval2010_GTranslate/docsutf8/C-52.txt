Equidad en los juegos de múltiples jugadores distribuidos basados en la recubrimiento muerto Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación de la Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {Sudhir, banavarht.fsu.edu sarit Mukherjee Sampath Rangarajan Center para la investigación Bell Laboratories,,Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com Resumen En un juego de jugadores múltiples distribuido que utiliza vectores de recuperación muerta para intercambiar información de movimiento entre los jugadores, existe una inexactitud para representar los objetos en el receptor debido a la redretraso entre el remitente y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de recuperación muerta, pero para ese momento, la posición real podría haber cambiado considerablemente en el remitente. Esta inexactitud sería tolerable si es consistente entre todos los jugadores;Es decir, al mismo tiempo físico, todos los jugadores ven inexactos (con respecto a la posición real del objeto) pero la misma posición y trayectoria para un objeto. Pero debido a los diferentes retrasos en la red entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto lleva a la injusticia en el juego. En este artículo, primero introducimos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de madera muerta a un remitente que se esfuerza por hacer que este error sea igual a los diferentes receptores con el tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en el presupuesto que proporciona una mayor justicia sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en el presupuesto como parte de BZFLAG, un popular juego de jugadores distribuidos. Mostramos a través de los experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de los retrasos de red ampliamente variables. Una propiedad adicional de los algoritmos propuestos es que requieren que se intercambien menos número de DR (en comparación con la implementación actual de BZFLAG) para lograr el mismo nivel de precisión en el juego. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: Aplicaciones distribuidas distribuidas de sistemas Algoritmos de términos generales, diseño, experimentación, rendimiento 1. Introducción En un juego multijugador distribuido, los jugadores normalmente se distribuyen en Internet y tienen retrasos diferentes entre sí o con un servidor de juegos central. Por lo general, en tales juegos, los jugadores son parte del juego y, además, pueden controlar entidades que componen el juego. Durante el curso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla a los otros jugadores que usan un vector de rescate muerto (DR). Un vector DR contiene información sobre la posición actual del reproductor/entidad en términos de coordenadas x, y y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos del componente de velocidad en cada uno de loslas dimensiones. Cada uno de los jugadores participantes recibe tales vectores DR el uno del otro y hace que los otros jugadores/entidades en las consolas locales se reciban un nuevo Dr. Vector para ese jugador/entidad. En un juego de pares, los jugadores se envían vectores DR directamente entre sí;En un juego de cliente cliente, estos vectores DR pueden reenviarse a través de un servidor de juegos. La idea de DR se usa porque es casi imposible para los jugadores/entidades intercambiar sus posiciones actuales en cada unidad de tiempo. Los vectores DR son cuantificación de la trayectoria real (que nos referimos como ruta real) en un jugador. Normalmente, se calcula y se envía un nuevo Vector DR cada vez que la ruta real se desvía de la ruta extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano X, Y, Z) en cierta cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador de envío, hay una desviación entre la ruta real y la ruta exportada. El error debido a esta desviación se puede eliminar si cada movimiento de jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo;Ese es un vector DR se genera en cada unidad de tiempo, lo que hace que las rutas reales y exportadas sean iguales. Dado que no es factible satisfacer esto debido a las limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, en el mejor de los casos, seguir la ruta exportada. Debido al retraso de la red entre los jugadores de envío y recepción, cuando se recibe y se presenta un Vector DR en un jugador, la trayectoria original del jugador/entidad ya puede haber cambiado. Por lo tanto, en tiempo físico, hay una desviación en el jugador receptor entre la ruta exportada y la trayectoria renderizada (a la que nos referimos como ruta colocada). Nos referimos a este error como el error de exportación. Tenga en cuenta que el error de exportación, a su vez, da como resultado una desviación entre las rutas reales y colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR se reciba en el receptor (denominado error de exportación anterior, y (ii) despuésEl vector DR se recibe en el receptor (denominado error de exportación posterior). En un artículo anterior [1], demostramos que al sincronizar los relojes en todos los jugadores y al usar una técnica basada en mensajes de estampado de tiempo que transportan los vectores DR, podemos garantizar que el error de exportación posterior se haga cero. Es decir, las rutas colocadas y exportadas coinciden después de que se recibe el vector DR. También demostramos que el error de exportación anterior nunca se puede eliminar, ya que siempre hay un retraso de red no cero, pero puede reducirse significativamente utilizando nuestra técnica [1]. En adelante, suponemos que los jugadores usan una técnica de este tipo que resulta en un error de exportación inevitable pero pequeño general. En este documento consideramos el problema de los retrasos en la red diferentes y variables entre cada par del remitente-receptor de un vector DR y, en consecuencia, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferente tiempo físico en diferentes receptores. Esto trae injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionó instantáneamente después de que se prestara la entidad. Nuestro objetivo en este documento es mejorar la equidad de estos juegos a pesar de los diferentes retrasos en la red al igualar el error de exportación a los jugadores. Exploramos si el promedio de tiempo de los errores de exportación (que es el error de exportación acumulativo durante un período de tiempo promediado durante el período de tiempo) en todos los jugadores se puede hacer lo mismo programando el envío de los vectores DR adecuadamente en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o soltar) el envío de vectores DR a algunos jugadores de forma continua para tratar de hacer que el error de exportación sea el mismo en todos los jugadores. En un nivel abstracto, el algoritmo retrasa que envían vectores DR a jugadores cuyo error acumulado hasta ahora en el juego es más pequeño que otros;Esto significaría que el error de exportación debido a este vector DR en estos jugadores será más grande que el de los otros jugadores, lo que los hace lo mismo. El objetivo es cometer este error al menos aproximadamente igual en cada vector DR con la desviación en el error que se hace más pequeño a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y la refinación del envío de vectores DR al programarlos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de una implementación de este algoritmo utilizando el juego de código abierto BZFlag, mostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). El inconveniente de este algoritmo es que tiende a impulsar el error de todos los jugadores hacia el del jugador con el peor error (que es el error en el jugador más lejano, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que presupueste cómo se envían los DR a diferentes jugadores. En un alto nivel, el algoritmo se basa en la idea de enviar más DRS a los jugadores que están más lejos del remitente en comparación con los que están más cerca. Los resultados experimentales de BZFLAG ilustran que el algoritmo basado en el presupuesto sigue un enfoque más equilibrado. Mejora la justicia del juego, pero al mismo tiempo lo hace sin presionar el error medio de los jugadores, manteniendo así la precisión del juego. Además, se muestra que el algoritmo basado en el presupuesto alcanza el mismo nivel de precisión del juego que la implementación actual de BZFLAG utilizando mucho menos número de vectores DR.2. Trabajo anterior El trabajo anterior en los juegos de red para tratar la latencia de la red se ha centrado principalmente en técnicas de compensación para el retraso y pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los grandes retrasos y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden introducirse variando retrasos del servidor a diferentes jugadores o de los jugadores entre sí. Por ejemplo, el concepto de retraso local se ha utilizado en [3] donde cada jugador retrasa cada operación local durante una cierta cantidad de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación al mismo tiempo,reduciendo así las inconsistencias estatales. El juego de múltiples jugadores en línea Mimaze [2, 5, 6], por ejemplo, toma un enfoque de sincronización de cubo estático para compensar los retrasos en la red variables. En Mimaze, cada jugador retrasa todos los eventos en 100 ms, independientemente de si se generan a nivel local o remotamente. Los jugadores con un retraso de la red mayor de 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubos dependen de imponer el peor retraso de todos los jugadores. Ha habido algunos documentos que han estudiado el problema de la equidad en un juego distribuido por mecanismos de entrega de mensajes más sofisticados. Pero estas obras [7, 8] asumen la existencia de una visión global del juego donde un servidor de juegos mantiene una vista (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de tiradores en primera persona, disparando el objeto). Estas adiciones y deleciones se comunican al servidor de juegos utilizando mensajes de acción. Según estos mensajes de acción, el estado del juego se cambia en el servidor del juego y estos cambios se comunican a los jugadores utilizando mensajes de actualización. La justicia se logra ordenando la entrega de la acción y actualizar los mensajes en el servidor de juegos y los jugadores, respectivamente, en función de la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo esta información se comunica a los jugadores parece estar más allá del alcance de estos trabajos. En este sentido, estos trabajos tienen un alcance muy limitado y pueden ser aplicables solo a los juegos de tiradores de la primera persona y eso también solo para juegos donde los jugadores no son parte del juego. Los vectores DR se pueden intercambiar directamente entre los jugadores (modelo de pares de pares) o utilizando un servidor central como relé (modelo de cliente cliente). Se ha demostrado en [9] que los juegos de múltiples jugadores que usan vectores DR junto con la sincronización de cubos no son a prueba de trucos a menos que se establezcan mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en el presupuesto descrito en nuestros vectores DR de uso en papel y, por lo tanto, no son a prueba de trucos. Por ejemplo, un receptor podría sesgar la estimación de retraso en el remitente para que el remitente crea que la demora entre el remitente y el receptor es alta, obteniendo así una ventaja indebida. Hacemos hincapié en que el enfoque de este documento está en la justicia sin abordar el tema de las trampas. En la siguiente sección, describimos el modelo de juego que usamos e ilustramos cómo los remitentes y receptores intercambian vectores DR y cómo se representan las entidades en los receptores en función del intercambio de vectores DR de la tabla de tiempo como se describe en [1]. En la Sección 4, describimos el algoritmo de programación DR Vector que tiene como objetivo hacer que el error de exportación sea igual a los jugadores con retrasos variables del remitente de un vector DR, seguido de resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFLAG. La Sección 5 describe el algoritmo basado en el presupuesto que logra una mayor justicia pero sin reducir la precisión del nivel del juego. Las conclusiones se presentan en la Sección 6. 2 3. Modelo de juego La arquitectura del juego se basa en jugadores distribuidos en Internet e intercambiando vectores DR entre ellos. Los vectores DR podrían enviarse directamente de un jugador a otro (modelo peerto-peer) o podrían enviarse a través de un servidor de juegos que recibe el vector DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos los relojes sincronizados entre los jugadores participantes. Cada DR Vector enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Asumimos un vector DR lineal en que la información contenida en el Vector DR es solo suficiente en el jugador receptor para calcular la trayectoria y representar la entidad en una ruta de línea recta. Tal vector DR contiene información sobre la posición inicial y la velocidad del reproductor/entidad donde la velocidad es constante1. Por lo tanto, los vectores DR enviados por un jugador especifican la hora actual en el jugador cuando se calcula el vector DR (no el momento en que este vector DR se envía a los otros jugadores como explicaremos más adelante), la posición actual del jugador/Entidad en términos de las coordenadas X, Y, Z y el vector de velocidad en la dirección de las coordenadas X, Y y Z. Específicamente, el I -ésimo DR Vector enviado por el jugador J sobre la entidad KTH es denotada por DRJ IK y está representado por la siguiente tuple (TJ Ik, Xj Ik, Yj Ik, Zj Ik, Vxj Ik, Vyj Ik, VZJ IK). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y solo para una entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRI para denotar el ésimo vector DR representado como la tupla (ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basada en Xi, Yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo TI en el que se calculó. Tenga en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor usa los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo Vector DR que cambia la posición y/o la velocidad de la entidad.TIMET1 REAL exportado colocado dt1 a b c d dr1 = (t1, x1, y1, vx1, vy1) calculado en el tiempo t1 y enviado al receptor dr0 = (t0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptorT0 dt0 colocado e Figura 1: trayectorias y desviaciones. Según este modelo, la Figura 1 ilustra el envío y el otro tipo de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y los vectores DR de la spline cúbica que consideran la posición inicial y la velocidad y la posición final y la velocidad de la entidad.ing vectores DR y los diferentes errores que se encuentran. La figura muestra la recepción de los vectores DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que se sincroniza entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el momento T0 T0 Vector DR0 es calculado por el remitente e inmediatamente enviado al receptor. Suponga que DR0 se recibe en el receptor después de un retraso de las unidades de tiempo DT0. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (se muestra como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor en función de los componentes de velocidad VX0 y VY0 (ruta colocada). En el momento T1 se calcula un DR Vector DR1 para la misma entidad e inmediatamente se envía al receptor2. Suponga que DR1 se recibe en el receptor después de un retraso de las unidades de tiempo DT1. Cuando se recibe este vector DR, suponga que la entidad está en el punto D. Una nueva posición para la entidad se calcula como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto c). Los componentes de velocidad VX1 y VY1 se utilizan para proyectar y hacer que esta entidad sea aún más. Consideremos ahora el error debido al retraso de la red. Aunque el DR1 se calculó en el momento T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + DT1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el momento T1 es la trayectoria AC, hasta el tiempo T1 + DT1, en el receptor, esta entidad se estaba presentando en Trayectory BD basada en DR0. Solo en el tiempo T1 + DT1 se movió la entidad al punto C desde el cual se exportó y las rutas colocadas son las mismas. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo cuando no están sincronizados. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algún DR DRI durante un intervalo de tiempo [T1, T2] como ERR (DRI, T1, T2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD durante el intervalo de tiempo [T1, T1 + DT1]. Tenga en cuenta que también podría haber otras formas de representar este error, pero en este documento, utilizamos la integral de la distancia entre las dos trayectorias como una medida del error de exportación. Tenga en cuenta que habría habido un error de exportación creado debido a la recepción de DR0, momento en el que la ruta colocada se habría basado en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordarle al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, existe una desviación entre las rutas reales y exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anteriores ilustran solo un receptor. Pero en realidad, el remitente envía DR Vectores DR0 y DR1 a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando diferentes valores de error de exportación en diferentes jugadores. El objetivo del algoritmo de programación DR Vector que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual a cada jugador de forma independiente para cada una de las entidades que componen el juego.4. Algoritmo de programación que atraviesa los vectores DR En la Sección 3. Mostramos cómo el retraso del remitente de un nuevo DR 2 Normalmente, los vectores DR no se calculan de manera periódica, sino a base de demanda en la que la decisión de calcular un nuevo vector DR se basa enSe excedió algún umbral de la desviación entre la ruta real y la ruta exportada por el vector DR anterior.3 Vector al receptor del vector DR podría conducir a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se recibe este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación del vector DR es hacer que el error de exportación sea igual a todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad haga un seguimiento de todos los errores en los receptores e intente hacerlos igual. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que obtenga alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe comentarios de los receptores. En esta sección proporcionamos motivaciones para el algoritmo y describimos los pasos por los que pasa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo.TIMET1 Ruta exportada Ruta colocada en el receptor 2 DT1 A B C D E F T0 G2 G1 DT2 DR1 Enviado al receptor 1 DR1 Enviado al receptor 2 T1 1 T1 2 Da1 Da2 G H I J K L N M DR1 estimado por el receptor 2 DR1 estimado por el receptor 1 DR1 realmente recibidopor el receptor 1 DR1 realmente recibido por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por la ruta colocada del remitente en el receptor 1 Figura 2: Flujo del vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, X0, Y0, VX0, VY0), enviado en el momento T0 a ambos receptores. Dr1 = (t1, t1 1, x1, y1, vx1, vy1) enviado en el tiempo t1 1 = t1+Δ1 al receptor 1 y dr1 = (t1, t2 1, x1, y1, vx1, vy1) enviado en el tiempo t2 1= T1 + Δ2 al receptor 2. Considere el ejemplo en la Figura 2. La figura muestra un solo remitente que envía vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, en cuyo momento mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la ruta de la entidad se muestra solo desde el punto donde la ruta colocada coincide con la ruta exportada para DR0. Ahora considere DR1. En el momento T1, DR1 es calculado por el remitente, pero suponga que no se envía inmediatamente a los receptores y solo se envía después del tiempo Δ1 al receptor 1 (en el tiempo T1 1 = T1 + Δ1) y después del tiempo Δ2 al receptor 2 (AT ATTiempo T2 1 = T1 + Δ2). Tenga en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Suponga que el remitente estima (estará claro en breve por qué el remitente debe estimar el retraso) que después de un retraso de DT1, el receptor 1 lo recibirá, usará los parámetros de coordenadas y de velocidad para calcular la ubicación actual de las entidades y lo moverá allí(Punto C) y a partir de este momento, las rutas exportadas y colocadas se convertirán en las mismas. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de DA1 (que es menor que las estimaciones de los remitentes de DT1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de DT2, el receptor 2 recibiráDR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de Da2> dt2 y mueve la entidad para que puntos N. los otros puntos que se muestran en el colocado yLas rutas exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error.4.1 Cálculo del error de exportación relativa que se refiere a la discusión desde la Sección 3, desde la perspectiva del remitente, el error de exportación en el receptor 1 debido a DR1 viene dado por ERR (DR1, T1, T1 + Δ1 + DT1) (la integral de la distancia de la distanciaentre las trayectorias AC y DB durante el intervalo de tiempo [T1, T1 + Δ1 + DT1]) de la Figura 2. Esto se debe al hecho de que el remitente usa el retraso estimado DT1 para calcular este error. Del mismo modo, el error de exportación desde la perspectiva de los remitentes en Recibe 2 debido a DR1 está dado por ERR (DR1, T1, T1 + Δ2 + DT2) (la integral de la distancia entre las trayectorias AE y DF durante el intervalo de tiempo [T1, T1, T1,+ Δ2 + dt2]). Tenga en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será menor o mayor que el valor estimado, en función de si la estimación de retraso fue mayor o menor que el retraso real que experimentó DR1. Esta diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que podría ser positivo o negativo) que ocurre para cada vector DR que se envía y se acumula en el remitente. El concepto de error de exportación relativo se ilustra en la Figura 2. Dado que el retraso real al receptor 1 es DA1, el error de exportación inducido por DR1 en el receptor 1 es ERR (DR1, T1, T1 + Δ1 + DA1). Esto significa que hay un error en el error de exportación estimado y el remitente puede calcular este error solo después de que reciba una retroalimentación del receptor sobre el retraso real para la entrega de DR1, es decir, el valor de DA1. Proponemos que una vez que el receptor 1 reciba DR1, envía el valor de DA1 al remitente. El receptor puede calcular esta información, ya que sabe el momento en que se envió DR1 (T1 1 = T1 + Δ1, que se adjunta al vector DR como se muestra en la Figura 2) y el tiempo de recepción local (que se sincroniza con el reloj de los remitentes). Por lo tanto, el remitente calcula el error de exportación relativa para el receptor 1, representado usando R1 como R1 = err (DR1, T1, T1 + Δ1 + DT1) - ERR (DR1, T1, T1 + Δ1 + Da1) = ERR (DR1, T1, T1, T1,+ Δ1 + dt1, t1 + Δ1 + da1) De manera similar, el error de exportación relativo para el receptor 2 se calcula como r2 = err (dr1, t1, t1 + Δ2 + dt2) - err (dr1, t1, t1 + Δ2 + da2) = = =ERR (DR1, T1 + Δ2 + DT2, T1 + Δ2 + DA2) Tenga en cuenta que R1> 0 como Da1 <DT1 y R2 <0 como Da2> DT2. El remitente calcula los errores de exportación relativos cuando recibe los comentarios de los receptores. Este ejemplo muestra los 4 valores de error de exportación relativos después de que se envía DR1 y se reciben los comentarios correspondientes.4.2 Equalización de error entre los receptores ahora explicamos lo que queremos decir con hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se indica antes, el remitente mantiene las estimaciones de los retrasos a los receptores, DT1 y DT2 en el ejemplo de la Figura 2. Esto dice que en el momento T1, cuando se calcula DR1, el remitente ya sabe cuánto tiempo puede tomar mensajes que llevan este vector DR para llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son ERR (DR1, T1, T1 + Δ1 + DT1) y ERR (DR1, T1, T1 + Δ2 + DT2) para los receptores 1 y 2, respectivamente. Tenga en cuenta que las áreas de estos componentes de error son una función de Δ1 y Δ2, así como de la red retrasa DT1 y DT2. Si queremos hacer los errores de exportaciones debido a DR1 lo mismo en ambos receptores, el remitente debe elegir Δ1 y Δ2 tal que Err (DR1, T1, T1 + Δ1 + DT1) = err (DR1, T1, T1 + Δ2 +dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores de exportación relativos debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRI para el receptor J as ri j. Para acomodar estos errores relativos acumulados, el remitente ahora debe elegir Δ1 y Δ2 tal que R0 1 + err (DR1, T1, T1 + Δ1 + DT1) = R0 2 + err (DR1, T1, T1 + Δ2 + DT2) el ΔIDetermina el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de ΔS garantiza que el error de exportación acumulado (es decir, error real total) para cada receptor iguale a la transmisión de cada vector DR. Para establecer esto, suponga que la retroalimentación para DR Vector DI de un receptor llega al remitente antes de calcular el horario para DI+1. Deje que Si M y Ai M denoten el error estimado para el receptor M utilizado para el programa de computación para DI y error acumulado para el receptor M calculado después de recibir comentarios para DI, respectivamente. Entonces ri m = ai m −si m.Para calcular las instancias de programación (es decir, ΔS) para DI, para cualquier par de receptores M y N, hacemos Ri - 1 m + Si M = Ri - 1 N + Si N.El siguiente teorema establece el hecho de que el error de exportación acumulado se iguala en cada instante de programación. Teorema 4.1. Cuando se calculan las instancias de programación para el envío de DI para cualquier par de receptores M y N, se cumple la siguiente condición: I - 1 K = 1 Ak M + Si M = I - 1 K = 1 Ak N + Si N.Prueba: por inducción. Suponga que la premisa se mantiene para algunos i. Mostramos que es necesario para i+1. El caso base para i = 1 se mantiene ya que inicialmente R0 m = R0 n = 0, y el S1 M = S1 N se usa para calcular las instancias de programación. Para calcular el cronograma para Di+1, primero calculamos los errores relativos como ri m = ai m - si m, y ri n = ai n - si n.Luego, para calcular ΔS, ejecutamos Ri M + Si + 1 M = Ri N + Si + 1 N Ai M - Si M + Si + 1 M = Ai N - Si N + Si + 1 n. Agregando la condición de la premisa en ambos lados que obtenemos, I K = 1 Ak M + Si + 1 M = I K = 1 Ak N + Si + 1 N.4.3 Cálculo del error de exportación Consideremos ahora cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar Δ1 y Δ2 necesitamos encontrar ERR (DR1, T1, T1 +Δ1 +DT1) y ERR (DR1, T1, T1 +Δ2 +DT2). Tenga en cuenta que los valores de R0 1 y R0 2 ya se conocen en el remitente. Considere el cálculo de ERR (DR1, T1, T1 +Δ1 +DT1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. De DR0 y DR1, punto A es (x1, y1) = (x1, y1) y el punto B es (x0, y0) = (x0 + (t1 - t0) × vx0, y0 + (t1 - t0) × vy0). La trayectoria AC se puede representar como una función del tiempo como (x1 (t), y1 (t) = (x1 + vx1 × t, y1 + vy1 × t) y la trayectoria de BD se puede representar como (x0 (t), Y0 (t) = (x0 + vx0 × t, y0 + vy0 × t). La distancia entre las dos trayectorias en función del tiempo se convierte en Dist (t) = (x1 (t) - x0 (t)) 2 + (y1 (t) - y0 (t)) 2 = ((x1 - x0) + (vx1 - vx0) t) 2 + ((y1 - y0) + (vy1 - vy0) t) 2 = ((vx1 - vx0) 2 + (vy1 - vy0) 2) t2 +2 ((x1 - x0) (vx1 - vx0) + (y1 - y0) (vy1 - vy0)) t + (x1 - x0) 2 + (y1 - y0) 2 dejen a = (vx1 - vx0) 2 + (vy1 - vy0) 2 b) 2 b) 2 b)= 2 ((x1 - x0) (vx1 - vx0) + (y1 - y0) (vy1 - vy0)) c = (x1 - x0) 2 + (y1 - y0) 2 entonces el dist (t) se puede escribir como dist(t) = A × T2 + B × T + C.Entonces ERR (DR1, T1, T2) para algún intervalo de tiempo [T1, T2] se convierte en T2 T1 Dist (T) DT = T2 T1 A × T2 + B × T + C DT. Una solución de forma cerrada para la integral indefinida A × T2 + B × T + C DT = (2AT + B) √ AT2 + BT + C 4A + 1 2 LN 1 2B + AT √ A + AT2 + BT + C C 1 √ A- 1 8 ln 1 2b + en √ a + at2 + bt + c b2 a− 3 2 err (dr1, t1, t1 + Δ1 + dt1) y err (dr1, t1, t1 + Δ2 + dt2) luego se puede calcularaplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los receptores ΔS para N.5 4.4 Cálculo de los instantes de programación nuevamente observamos el cálculo de ΔS referiéndose a la Figura 2. El remitente elige Δ1 y Δ2 tal que R0 1 +Err (DR1, T1, T1 +Δ1 +DT1) = R0 2 +Err (DR1, T1, T1 +Δ2 +DT2). Si R0 1 y R0 2 son cero, entonces Δ1 y Δ2 deben elegirse de tal manera que ERR (DR1, T1, T1 +Δ1 +DT1) = err (DR1, T1, T1 +Δ2 +DT2). Esta igualdad se mantendrá si Δ1 + DT1 = Δ2 + DT2. Por lo tanto, si no hay un error de exportación relativo acumulado, todo lo que el remitente debe hacer es elegir los Δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, de modo que reciban el vector DR al mismo tiempotiempo. Como se discutió anteriormente, debido a que el remitente no puede aprender a priori el retraso, siempre habrá un error de exportación relativo acumulado de un vector DR anterior que debe tenerse en cuenta. Para profundizar en esto, considere el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular el ΔS requerimos que R0 1 + Err (DR1, T1, T1 + Δ1 + DT1) = R0 2 + err (DR1, T1, T1 + Δ2 + DT2). Es decir, R0 1+T1+Δ1+DT1 T1 Dist (T) DT = R0 2+T1+Δ2+DT2 T1 Dist (T) DT. Es decir r0 1+t1+dt1 t1 dist (t) dt+t1+dt1+Δ1 t1+dt1 dist (t) dt = r0 2+t1+dt2 t1 dist (t) dt+t1+dt2+Δ2 t1+dt2dist (t) dt. Los componentes R0 1, R0 2, ya se conocen (o estimados por) el remitente. Además, los componentes de error T1+DT1 T1 Dist (T) DT y T1+DT2 T1 Dist (T) DT pueden calcularse a priori por el remitente utilizando valores estimados de DT1 y DT2. Usemos E1 para denotar R0 1 + T1 + DT1 T1 Dist (T) DT y E2 para denotar R0 2 + T1 + DT2 T1 Dist (T) DT. Luego, requerimos que E1+T1+DT1+Δ1 T1+DT1 Dist (T) DT = E2+T1+DT2+Δ2 T1+DT2 Dist (T) DT. Suponga que e1> e2. Luego, para que la ecuación anterior se mantenga, requerimos que t1+dt1+Δ1 t1+dt1 dist (t) dt <t1+dt2+Δ2 t1+dt2 dist (t) dt. Para hacer que el juego lo sea lo más rápido posible dentro de este marco, los valores δ deben hacerse lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible sujeto al requisito de equidad. Dado esto, elegiríamos Δ1 para ser cero y calcular Δ2 de la ecuación E1 = E2+T1+DT2+Δ2 T1+DT2 Dist (T) DT. En general, si hay n receptores 1 ,..., N, cuando un remitente genera un vector DR y decide programarlos para que se envíen, primero calcula los valores de EI para todos ellos a partir de los errores de exportación relativos acumulados y las estimaciones de los retrasos. Luego, encuentra el más pequeño de estos valores. Deje que Ek sea el valor más pequeño. El remitente hace que ΔK sea cero y calcula el resto de los ΔS de la igualdad ei+t1+dti+Δi t1+dti dist (t) dt = ek, ∀i 1 ≤ i ≤ n, i = k.(1) El ΔS así obtenido proporciona los instantes de programación del vector DR para los receptores.4.5 Pasos del algoritmo de programación a los efectos de la discusión a continuación, como antes denotamos el error de exportación relativa acumulado en un remitente para el receptor k up hasta que DRI se ri k.Denotemos el retraso programado en el remitente antes de que DRI se envíe al receptor K como Δi k.Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRI en (digamos) tiempo Ti y luego calcula ΔI K, y Ri - 1 k, ∀K, 1 ≤ k ≤ n basado en la estimación de retrasos DTK, ∀K, 1 ≤ k ≤ n según la ecuación ((1). Programas, DRI se enviará al receptor K en el momento ti + Δi k.2. Los vectores DR se envían a los receptores en los tiempos programados que se reciben después de un retraso de DAK, ∀K, 1 ≤ K ≤ N donde DAK ≤ o> DTK. Los receptores envían el valor de DAK nuevamente al remitente (el receptor puede calcular este valor en función de las marcas de tiempo en el vector DR como se describió anteriormente).3. El remitente calcula Ri K como se describió anteriormente e ilustrado en la Figura 2. El remitente también recomputa (utilizando un método de promedio exponencial similar a la estimación de tiempo de ida y vuelta por TCP [10]) La estimación de DTART DTK del nuevo valor de DAK para el receptor k.4. Regrese al paso 1 para calcular DRI+1 cuando sea necesario y siga los pasos del algoritmo para programar y enviar este vector DR a los receptores.4.6 Manejo de casos en la práctica Hasta ahora que implicidad asumimos que DRI se envía a todos los receptores antes de que se tome una decisión para calcular el próximo DR Vector DRI+1, y los receptores envían el valor de DAK correspondiente a DRI y esta información llega al remitenteAntes de calcular DRI+1 para que pueda calcular Ri+1 K y luego usarlo en el cálculo de ΔI+1 K. Dos problemas necesitan consideración con respecto al algoritmo anterior cuando se usa en la práctica.• Puede suceder que se calcule un nuevo DR Vector incluso antes de que el Vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación?• ¿Qué sucede si la retroalimentación no llega antes de que DRI+1 se calcule y se programe? Consideremos el primer escenario. Suponemos que se ha programado DRI para ser enviado y los instantes de programación son tales que Δi 1 <ΔI 2 <· · · <Δi n. Suponga que DRI+1 debe calcularse (porque la ruta real se ha desviado excediendo un umbral de la ruta exportada por DRI) en el tiempo Ti+1 donde Ti+Δi K <ti+1 <ti+ΔI K+1. Esto significa que DRI ha sido enviado solo a receptores hasta K en el orden programado. En nuestro algoritmo, en este caso, la cola de pedido de retraso programada está enjuagada, lo que significa que DRI no se envía a los receptores que todavía están en cola para recibirlo, pero se calcula una nueva orden de programación para que todos los receptores envíen DRI+1. Para aquellos receptores que han recibido DRI, suponga por ahora que DAJ, 1 ≤ J ≤ K ha sido recibido de todos los receptores (el escenario en el que DAJ no se ha recibido se considerará como parte del segundo escenario más adelante). Para estos receptores, se puede calcular 1 ≤ j ≤ k. Para aquellos receptores J, K + 1 ≤ J ≤ n a quien no se envió DRI ei J no se aplica. Considere un receptor j, k + 1 ≤ j ≤ n a quien no se envió DRI. Consulte la Figura 3. Para dicho receptor J, cuando Dri+1 debe programarse y 6 TIMETI exportó ruta dtj a b c d ti-1 gi j dri+1 calculado por remitente y DRI para el receptor K+1 a N se elimina de la cola DRI+1 programada paraReceptor K+1 Ti+1 G H E F DRI Programado para el receptor J DRI calculado por el remitente Ruta colocada en el receptor K+1 GI+1 J Figura 3: Cálculo de programación Cuando DRI no se envía al receptor J, K+1 ≤ J ≤ N.Se debe calcular ΔI+1 J, el error de exportación total es el error de exportación relativo acumulado en el tiempo TI cuando se calculó el cronograma para DRI, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 durante el intervalo de tiempo [Ti, ti + 1 + Δi + 1 j + dtj]. Tenga en cuenta que esta integral está dada por ERR (DRI, TI, TI+1)+ERR (DRI+1, TI+1, TI+1+ΔI+1 J+DTJ). Por lo tanto, en lugar de Ei J de la ecuación (1), usamos el valor ri - 1 j+err (dri, ti, ti+1)+err (dri+1, ti+1, ti+1+Δi+1 j+ dtj) donde RI - 1 J es un error de exportación relativo utilizado cuando se calculó el cronograma para DRI. Ahora considere el segundo escenario. Aquí los comentarios Dak correspondientes a DRI no han llegado antes de que DRI+1 se calcule y programe. En este caso, Ri K no se puede calcular. Por lo tanto, en el cálculo de ΔK para DRI+1, esto se supondrá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar DAK al remitente. Cuando esta información llega en un momento posterior, Ri K se calculará y acumulará en futuros errores de exportación relativa (por ejemplo, RI+1 k si DAK se recibe antes de que DRI+2 se calcule) y se use en el cálculo de ΔK cuando un futuro DRSe debe programar vector (por ejemplo DRI+2).4.7 Resultados experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos mediante el uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFLAG (Battle Zone Flag) [11]. Es un juego de tiradores en primera persona donde los jugadores de los equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar banderas pertenecientes al otro equipo y traerlas de regreso a su propia área. Los jugadores se disparan tanques con balas de tiro. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores que usan vectores DR. Hemos modificado la implementación de BZFLAG para incorporar relojes sincronizados entre los jugadores y el servidor e intercambiar puestos de tiempo con el Vector DR. Configuramos un testbed con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como remitente y el resto como receptores. El enfoque de programación y el caso base en el que cada vector DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores DR de acuerdo con el tipo de enfoque utilizado para enviar el vector DR. NISTNET [12] se usó para introducir demoras en todo el remitente y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el remitente y el primer, segundo y el tercer receptor, respectivamente. Introducimos una varianza de 100 ms (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 traza la media y la desviación estándar del error de exportación acumulado de todos los receptores en el caso de programación contra el caso base. Tenga en cuenta que el eje X de estos gráficos (y los otros gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca uno del otro. Esto muestra que el enfoque de programación logra la equidad entre los receptores, incluso si están a diferentes distancias (es decir, latencias) del remitente. Observe que la media del error acumulado aumentó múltiples con la programación en comparación con el caso base. Una mayor exploración por el motivo del aumento en la media condujo a la conclusión de que cada vez que los vectores DR están programados para igualar el error total, empuja a cada error total de los receptores más alto. Además, como el error acumulado tiene un componente estimado, el cronograma no es preciso para igualar los errores para los receptores, lo que lleva a que el vector DR llegue más temprano o posterior al horario real. En cualquier caso, el error no se iguala y si el vector DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el siguiente disparo, este receptor será el que tenga el error más alto y cualquier otro error de receptores se impulsará a este valor de error. Este efecto de flip-flop conduce al aumento en el error acumulado para todos los receptores. La programación de la justicia conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero tiene costo de un error medio más alto, lo que puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Usando la misma cantidad de vectores DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores DR a todos los receptores a la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de enviar los vectores DR al receptor conMayor error acumulado y disminuir la frecuencia de enviar vectores DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error más acumulado en el caso base (por supuesto, este receptor se enviaría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto.5. Algoritmo basado en presupuesto En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Bajo el umbral, se generan más vectores DR durante un período de tiempo determinado. Dado que los vectores DR se envían a todos los receptores y no se puede evitar el retraso de la red entre los pares de remitente-receptor, el error de exportación antes de la exportación 3 con el jugador más distante siempre notará que después de la exportación se elimina el error de exportación utilizando el reloj sincronizado entre el reloj entre eljugadores.7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MEDIACUMULELETER TIEME EN SECUESAlgoritmo de programación #1 Figura 4: media y desviación estándar del error con la programación y sin (es decir, caso base).ser más alto que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores DR selectivamente a diferentes jugadores en función de los errores acumulados de estos jugadores. El algoritmo basado en el presupuesto se basa en esta idea y hay dos variaciones de la misma. Uno es un esquema probabilístico basado en presupuesto y el otro, un esquema de base de presupuesto determinista.5.1 Esquema probabilístico basado en el presupuesto El esquema basado en el presupuesto probabilístico tiene tres pasos principales: a) Baje el umbral de calibración muerta, pero al mismo tiempo mantenga el número total de DR enviados al mismo tiempo que el caso base, b) en cada desencadenante, elija probabilísticamente a AJugador para enviar el Dr. Vector a, y c) enviar el Vector DR al reproductor elegido. Estos pasos se describen a continuación. La disminución del umbral de DR se implementa de la siguiente manera. Bajar el umbral es equivalente a aumentar el número de puntos de activación donde se generan vectores DR. Supongamos que el umbral es tal que el número de desencadenantes causados por él en el caso base es T y en cada desencadenante N DR vectores enviados por el remitente, lo que resulta en un total de vectores NT DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijados en NT, pero reducir el número de vectores DR enviados en cada disparador (es decir, no envíe el vector DR a todos los receptores). Sea N y T el número de vectores DR enviados en cada activador y número de desencadenantes respectivamente en el caso modificado. Queremos asegurarnos de n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t> t, esto significaría que n <n.Es decir, no todos los receptores recibirán el Vector DR en cada disparador. En el esquema basado en el presupuesto probabilístico, en cada desencadenante, se calcula una probabilidad para que cada receptor se envíe un vector DR y solo se envía un receptor el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los receptores acumulados por errores. Es decir, un receptor con un error acumulado más alto tendrá una mayor probabilidad de recibir el vector DR. Considere que el error acumulado para tres jugadores son A1, A2 y A3 respectivamente. Entonces, la probabilidad de que el Jugador 1 reciba el Vector DR sería A1 A1+A2+A3. Del mismo modo para los otros jugadores. Una vez que el jugador es elegido, el Dr. Vector se envía a ese jugador. Para comparar el algoritmo probabilístico basado en el presupuesto con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Como el umbral de cálculo muerto en el caso base ya estaba muy bien, se decidió que en lugar de reducir el umbral, el enfoque probabilístico basado en el presupuesto se compararía con un caso base modificado que usaría el umbral normal como algoritmo basado en el presupuesto, pero el algoritmo pero el algoritmo pero elEl caso base se modificó de manera que cada tercer desencadenante se usara para enviar un vector DR a los tres receptores utilizados en nuestros experimentos. Esto se llamó como el caso base 1/3, ya que resultó en que se envió 1/3 número de vectores DR en comparación con el caso base. El presupuesto por activación para el enfoque basado en la probabilidad se calculó como un vector DR en cada desencadenante en comparación con tres vectores DR en cada tercio de activación en el caso base 1/3;Por lo tanto, los dos casos conducen a la misma cantidad de vectores de DR que se envían con el tiempo. Para evaluar la efectividad del algoritmo probabilístico basado en el presupuesto, instrumimos el juego BZFLAG para usar este enfoque. Utilizamos el mismo Testbed que consta de un remitente y tres receptores con retrasos de 800 ms, 500 ms y 200 ms del remitente y con baja varianza de retraso (100 ms) y varianza de retraso moderada (180 ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje X de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las cifras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base 1/3 y la media es un poco más alta que el caso base 1/3. Esto implica que el juego es más justo en comparación con el caso base 1/3 a costa de aumentar el error medio en una pequeña cantidad en comparación con el caso base 1/3. El aumento del error medio en el caso probabilístico en comparación con el caso base 1/3 se puede atribuir al hecho de que a pesar de que el enfoque probabilístico en promedio envía el mismo número de vectores DR que el caso base 1/3, a veces envíaLos vectores de DR a un receptor con menos frecuencia y, a veces, con mayor frecuencia que el caso base 1/3 debido a su naturaleza probabilística. Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria de los receptores está cada vez más apagado de la trayectoria del remitente y, por lo tanto, la tasa de acumulación del error en el receptor es más alta. En momentos en que un receptor recibe vectores DR con más frecuencia, se acumula un error a una velocidad más baja, pero no hay forma de revertir el error que se construyó cuando no recibió un vector DR durante mucho tiempo. Esto lleva a los receptores a acumular más error en el caso probabilístico en comparación con el caso base 1/3 donde los receptores reciben un vector DR casi periódicamente.8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MEDIACUMULELETROR TIEMPO en segundos 1/3 Caso base Algoritmo Determinista Algoritmo probabilístico 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16150 16200 16250 16300 16300Segundos 1/3 Caso base Algoritmo determinista Algoritmo probabilístico Figura 5: media y desviación estándar de error para diferentes algoritmos (incluidos los algoritmos basados en presupuesto) para una baja varianza de retraso.0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180EstandaryDeviationFacumulatedError Tiempo en segundos 1/3 Caso base Algoritmo Determinista Algoritmo probabilístico Figura 6: media y desviación estándar de error para diferentes algoritmos (incluidos los algoritmos basados en presupuesto) para una varianza de retraso moderada.5.2 Esquema determinista basado en el presupuesto para limitar el aumento del error medio, decidimos modificar el algoritmo basado en el presupuesto para ser determinista. Los primeros dos pasos del algoritmo son los mismos que en el algoritmo probabilístico;Los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor receptor de un vector DR. Una vez que se completan estos pasos, un cronograma determinista para el receptor se calcula de la siguiente manera: 1. Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al receptor respectivo. Si al menos un receptor se envió un vector DR, el remitente calcula las probabilidades de cada receptor que recibe un vector DR como se explica anteriormente y sigue los pasos 2 a 6, de lo contrario, no hace nada.2. Para cada receptor, el valor de probabilidad se multiplica con el presupuesto disponible en cada disparador (que se establece en 1 como se explica a continuación) para dar la frecuencia de enviar el vector DR a cada receptor.3. Si alguna de las frecuencia de los receptores después de multiplicar con el presupuesto pasa por 1, la frecuencia de los receptores se establece como 1 y la cantidad excedente se distribuye por igual a todos los receptores al agregar la cantidad a sus frecuencias existentes. Este proceso se repite hasta que todos los receptores tengan una frecuencia de menos o igual a 1. Esto se debe al hecho de que en un desencadenante no podemos enviar más de un vector DR al receptor respectivo. Ese será el desperdicio de vectores DR enviando información redundante.4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo. El crédito obtenido anteriormente (explicado en el paso 5) si alguno se resta del cronograma. Observe que el valor resultante del cronograma podría no ser un entero;Por lo tanto, el valor se redondea tomando el techo del horario. Por ejemplo, si la frecuencia es 1/3.5, esto implica que nos gustaría que un vector DR envíe cada 3.5 desencadenantes. Sin embargo, estamos obligados a enviarlo en el 4to disparador que nos da un crédito de 0.5. Cuando enviemos el Dr. Vector la próxima vez, podríamos enviarlo 9 en el tercer desencadenante debido al crédito 0.5.5. La diferencia entre el cronograma y el techo del cronograma es el crédito que el receptor ha obtenido, lo que se recuerda para el futuro y se usa en la próxima vez como se explica en el Paso 4. 6. Para cada uno de esos receptores que se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el siguiente vector DR en el desencadenante que ocurre exactamente el cronograma (el techo del horario) número de veces del activador actual. Observe que ningún horario de otro receptores se modifica en este punto, ya que todos están ejecutando un programa calculado en algún momento anterior. Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el próximo Vector DR. En el primer activador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 a 6 para calcular el siguiente horario para cada receptor de la misma manera que se menciona para otrosdesencadenantes. Este algoritmo asegura que cada receptor tenga un cronograma garantizado de recepción de vectores DR y, por lo tanto, no existe irregularidad en el envío del vector DR a cualquier receptor como se observó en el algoritmo probabilístico basado en el presupuesto. Utilizamos el Testbed descrito anteriormente (tres receptores con retrasos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por disparador para usar el mismo número de vectores DR que en el caso base 1/3. Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6. Se puede observar que la desviación estándar del error en el algoritmo basado en el presupuesto determinista es menor que el caso base 1/3 y también tiene el mismo error medio que el caso base 1/3. Esto indica que el algoritmo determinista es más justo que el caso base 1/3 y, al mismo tiempo, no aumenta el error medio, lo que lleva a una mejor calidad del juego en comparación con el algoritmo probabilístico. En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado medio siempre fue menor en el enfoque determinista. Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fijos o bajos, el enfoque determinista fue generalmente más bajo, pero en casos de varianza más alto, era más difícil sacar conclusiones ya que el enfoque probabilístico a veces era mejor que el deterministaacercarse.6. Conclusiones y el trabajo futuro en los juegos multiplicadores distribuidos jugados en Internet, la trayectoria de los objetos y el jugador dentro del espacio del juego se intercambian en términos de vectores DR. Debido al retraso variable entre los jugadores, estos vectores DR alcanzan diferentes jugadores en diferentes momentos. Hay una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden hacer que la posición de los remitentes con mayor precisión en tiempo real. En este artículo, primero desarrollamos un modelo para estimar el error al representar las trayectorias de los jugadores en los receptores. Luego presentamos un algoritmo basado en la programación de los vectores DR para que se enviaran a diferentes jugadores en diferentes momentos, igualando así el error en diferentes jugadores. Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error medio de los jugadores. Para contrarrestar este efecto, presentamos algoritmos basados en presupuesto donde los vectores DR aún están programados para enviarse a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de ser justos con el requisito de que el error de los peores jugadores (que están más lejos deEl remitente) no aumentan en comparación con el caso base (donde todos los vectores DR se envían a todos los jugadores cada vez que se genera un vector DR). Presentamos dos variaciones de los algoritmos basados en el presupuesto y mediante la experimentación mostró que los algoritmos reducen la desviación estándar del error, lo que hace que el juego sea más justo y al mismo tiempo tiene un error medio comparable para el caso base.7. Referencias [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos de múltiples jugadores distribuidos basados en la reducción muerta, Actas de ACM Sigcomm 2004 Workshop en la red y el soporte del sistema para juegos para juegos(NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y evaluación de Mimaze, un juego multijugador en Internet, en Proc.de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Proc.de la Conferencia ACM sobre el trabajo cooperativo compatible con la computadora (CSCW00), 2000, pp. 181-190.[4] S.K. Singhal y D.R. Cheriton, Explotación del historial de posición para una representación remota eficiente en la realidad virtual en red, presencia: teleoperators y entornos virtuales, vol.4, no.2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en IEEE Network Magazine, 1999, vol.13, págs. 6-15.[6] L. Pantel y L.C. Wolf, sobre el impacto del retraso en los juegos multijugador en tiempo real, en Proc.de ACM Nossdav02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizado para juegos distribuidos de jugadores múltiples en tiempo real, en Proc.de la décima Conferencia Internacional IEEE sobre protocolos de red (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, un marco de intercambio de mensajes justo para juegos múltiples distribuidos, en Proc.de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Juega a prueba de trucos para juegos en línea centralizados y distribuidos, en Proc.de IEEE Infocom01, abril de 2001. [10] M. Allman y V. Paxson, al estimar las propiedades de la ruta de red de extremo a extremo, en Proc.de ACM SIGCOMM99, septiembre de 1999. [11] Foro BZFlag, juego BZFlag, URL: http://www.bzflag.org.[12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/.10