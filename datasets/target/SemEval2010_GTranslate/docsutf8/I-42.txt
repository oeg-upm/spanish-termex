Un método completo de optimización de restricciones distribuidas para arreglos de pseudotreos no tradicionales ∗ James Atlas Computer and Information Sciences de Delaware Newark, de 19716 atlas@cis.udel.edu Keith Decker Computadora e ciencias de la información Universidad de Delaware Newark, DE 19716 Decker@cis.La optimización de restricciones distribuidas abstractas de UDEL.EDU (DCOP) es un marco general que puede modelar problemas complejos en sistemas de múltiples agentes. Varios algoritmos actuales que resuelven instancias generales de DCOP, incluidas las adoptas y DPOP, organizan agentes en una estructura de pseudotree tradicional. Introducimos una extensión al algoritmo DPOP que maneja un conjunto extendido de arreglos de pseudotree. Nuestro algoritmo resuelve correctamente las instancias DCOP para seudotrees que incluyen bordes entre nodos en ramas separadas. El algoritmo también resuelve instancias con arreglos de pseudotree tradicionales utilizando el mismo procedimiento que DPOP. Comparamos nuestro algoritmo con DPOP utilizando varias métricas, incluido el ancho inducido de los seudotrees, la dimensionalidad máxima de los mensajes y el cálculo, y el costo máximo de ruta secuencial a través del algoritmo. Probamos que para algunas instancias problemáticas no es posible generar una pseudotree tradicional utilizando heurísticas transversales de borde que supere a una pseudotree de bordes cruzados. Utilizamos múltiples heurísticas para generar seudotrees y elegir el mejor seudotree en la complejidad lineal del espacio-tiempo. Para algunas instancias problemáticas, observamos mejoras significativas en los tamaños de mensajes y cálculos en comparación con DPOP. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: Sistemas de inteligencia artificial distribuidos Algoritmos de términos generales 1. Introducción Muchos problemas históricos en la comunidad de IA pueden transformarse en problemas de satisfacción de restricciones (CSP). Con el advenimiento de la IA distribuida, los sistemas de múltiples agentes se convirtieron en una forma popular de modelar las complejas interacciones y la coordinación requeridas para resolver problemas distribuidos. Los CSP se extendieron originalmente a los entornos de agentes distribuidos en [9]. Los primeros dominios para problemas de satisfacción de restricciones distribuidas (DISCSP) incluyeron la programación de la tienda de trabajo [1] y la asignación de recursos [2]. Muchos dominios para los sistemas de agentes, especialmente la coordinación del trabajo en equipo, la programación distribuida y las redes de sensores, implican problemas demasiado restringidos que son difíciles o imposibles de satisfacer para cada restricción. Los enfoques recientes para resolver problemas en estos dominios se basan en técnicas de optimización que mapean las limitaciones en funciones de utilidad de valores múltiples. En lugar de encontrar una tarea que satisfaga todas las limitaciones, estos enfoques encuentran una tarea que produce un alto nivel de utilidad global. Esta extensión al enfoque DISCSP original se ha vuelto popular en los sistemas de múltiples agentes, y se ha etiquetado como el problema de optimización de restricciones distribuidas (DCOP) [1]. Los algoritmos actuales que resuelven DCOP completos utilizan dos enfoques principales: búsqueda y programación dinámica. Los algoritmos basados en la búsqueda que se originaron en DISCSP generalmente usan alguna forma de retracking [10] o propagación de límites, como en Adopt [3]. Los algoritmos basados en programación dinámica incluyen DPOP y sus extensiones [5, 6, 7]. Hasta la fecha, ambas categorías de algoritmos organizan agentes en una pseudotree tradicional para resolver el problema. Se ha demostrado en [6] que cualquier gráfico de restricción se puede asignar en una pseudotree tradicional. Sin embargo, también se demostró que encontrar el pseudotree óptimo era NP-Hard. Comenzamos a investigar el rendimiento de los pseudotrees tradicionales generados por la heurística actual transversal de los bordes. Descubrimos que estas heurísticas a menudo producían poco paralelismo, ya que los seudotrees tendían a tener factores de alta profundidad y baja ramificación. Sospechamos que podría haber otras formas de organizar los pseudotrees que proporcionarían un mayor paralelismo y tamaños de mensajes más pequeños. Después de explorar estos otros arreglos, encontramos que los pseudotrees de bordes cruzados proporcionan profundidades más cortas y factores de ramificación más altos que los pseudotrees tradicionales. Nuestra hipótesis era que estos pseudotrees cruzados superarían a los pseudotrees tradicionales para algunos tipos de problemas. En este artículo presentamos una extensión del algoritmo DPOP que maneja un conjunto extendido de arreglos de pseudotree que incluyen seudotrees de bordes cruzados. Comenzamos con una definición de 741 978-81-904262-7-5 (RPS) c 2007 Ifaamas DCOP, pseudotrees tradicionales y pseudotrees de bordes cruzados. Luego proporcionamos un resumen del algoritmo DPOP original e presentamos nuestro algoritmo DCPOP. Discutimos la complejidad de nuestro algoritmo, así como el impacto de la heurística de la generación de seudotree. Luego mostramos que nuestro procedimiento distribuido de optimización de pseudotree de bordes cruzados (DCPOP) funciona significativamente mejor en la práctica que el algoritmo DPOP original para algunas instancias problemáticas. Concluimos con una selección de ideas para el trabajo futuro y las extensiones para DCPOP.2. Definición de problemas DCOP se ha formalizado de manera ligeramente diferente en la literatura reciente, por lo que adoptaremos la definición como se presenta en [6]. Un problema de optimización de restricción distribuido con nodos n y restricciones M consiste en la tuple <x, d, u> donde: • x = {x1, .., xn} es un conjunto de variables, cada una asignada a un agente único • D= {d1, .., dn} es un conjunto de dominios finitos para cada variable • u = {u1, .., um} es un conjunto de funciones de utilidad, de modo que cada función implica un subconjunto de variables en x y define una utilidadPara cada combinación de valores entre estas variables, una solución óptima a una instancia de DCOP consiste en una asignación de valores en D a X de modo que la suma de utilidades en U es máxima. Los dominios de problemas que requieren un costo mínimo en lugar de la utilidad máxima pueden asignar los costos en servicios públicos negativos. Las funciones de utilidad representan restricciones suaves, pero también pueden representar restricciones duras mediante el uso de valores negativos arbitrariamente grandes. Para este artículo solo consideramos funciones de utilidad binaria que involucran dos variables. Las funciones de utilidad de orden superior pueden modelarse con cambios menores en el algoritmo, pero también aumentan sustancialmente la complejidad.2.1 Los pseudotrees tradicionales seudotrees son una estructura común utilizada en los procedimientos de búsqueda para permitir el procesamiento paralelo de ramas independientes. Como se define en [6], una pseudotree es una disposición de un gráfico G en un árbol enraizado t de tal manera que los vértices en G que comparten un borde están en la misma rama en T. Un borde posterior es un borde entre un nodo X yCualquier nodo que se encuentre en la ruta de X a la raíz (excluyendo XS Parent). La Figura 1 muestra una pseudotree con cuatro nodos, tres bordes (A-B, B-C, BD) y un de vanguardia (A-C). También se definen en [6] se existen cuatro tipos de relaciones entre los nodos en un pseudotree: • p (x) - el padre de un nodo x: el nodo único más alto en la seudotree que está conectado a x directamente a través de un borde de árbol • c(X) - Los hijos de un nodo X: el conjunto de nodos más bajos en el pseudotree que están conectados a x directamente a través de los bordes de los árboles • PP (x) - los pseudo -parentes de un nodo X: el conjunto de nodos más altos en elPseudotree que están conectados a x directamente a través de back-back-backs (en la Figura 1, a = pp (c)) • PC (x)-los pseudo-niños de un nodo X: el conjunto de nodos más bajos en el pseudotree que están conectados aX directamente a través de bordes de fondo (en la Figura 1, c = PC (a)) Figura 1: una pseudotree tradicional. Los bordes de línea continua representan relaciones entre padres e hijos y la línea discontinua representa una relación pseudo-parent-pseudo-e-e-e-e-e-e-e-e-child. Figura 2: un pseudotree de bordes cruzados. Los bordes de la línea continua representan relaciones entre padres e hijos, la línea discontinua representa una relación pseudoparent-pseudo-e-e-e-e-e-e-e-e-fild, y la línea punteada representa una relación de rama-sobrenadina. El nodo en negrita, B, es el punto de fusión para el nodo E. 2.2 Pseudotrees de bordes cruzados. Definimos un borde cruzado como un borde del nodo X a un nodo Y que está por encima de X pero no en la ruta de X a la raíz. Un pseudotree de bordes cruzados es una pseudotree tradicional con la adición de carcajadas cruzadas. La Figura 2 muestra una pseudotree cruzada con un borde cruzado (D-E). En una pseudotree de bordes cruzados designamos ciertos bordes como primarios. El conjunto de bordes primarios define un árbol de expansión de los nodos. Las relaciones padre, niño, pseudo-parente y pseudo-child de la pseudotree tradicional ahora se definen en el contexto de este árbol principal de abordaje de borde. Esta definición también produce dos tipos adicionales de relaciones que pueden existir entre los nodos: • BP (X): los padres de rama de un nodo X: el conjunto de nodos más altos en el pseudotree que están conectados a X pero no están en la ruta primariade x a la raíz (en la figura 2, d = bp (e)) • bc (x) - los niños ramificados de un nodo x: el conjunto de nodos más bajos en el pseudotree que están conectados a x pero no están en ningúnruta primaria de x a cualquier nodo de hoja (en la Figura 2, E = BC (d)) 2.3 Generación de seudotree 742 El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07), los algoritmos de corriente generalmente tienen una fase de preexecución para generar una pseudotree tradicional a partir de una instancia general de DCOP. Nuestro algoritmo DCPOP genera un pseudotree de bordes cruzados de la misma manera. Primero, la instancia DCOP <x, d, u> se traduce directamente en un gráfico con x como el conjunto de vértices y un borde para cada par de variables representadas en U. A continuación, se utilizan varias heurísticas para organizar este gráfico en una pseudotree. Una heurística común es realizar una búsqueda guiada de profundidad primero (DFS) ya que el recorrido resultante es una pseudotree, y un DFS se puede realizar fácilmente de manera distribuida. Definimos un método basado en el borde como cualquier método que produzca un pseudotree en el que todos los pares de padres/niños compartan un borde en el gráfico original. Esto incluye DFS, búsqueda de amplitud-primera y la mejor primera búsqueda basadas en la búsqueda. Nuestras heurísticas que generan pseudotrees de bordes cruzados utilizan un recorrido de búsqueda distribuido de la mejor primera búsqueda.3. Algoritmo DPOP El algoritmo DPOP original funciona en tres fases principales. La primera fase genera una pseudotree tradicional a partir de la instancia de DCOP utilizando un algoritmo distribuido. La segunda fase se une a los hipercubos de servicios públicos de los niños y el nodo local y los propaga hacia la raíz. La tercera fase elige una tarea para cada dominio de una manera de arriba hacia abajo, comenzando con el agente en el nodo raíz. La complejidad de DPOP depende del tamaño del mensaje de cálculo y utilidad más grande durante la fase dos. Se ha demostrado que este tamaño corresponde directamente al ancho inducido de la pseudotree generada en la fase uno [6]. DPOP utiliza heurísticas de tiempo polinomial para generar la seudotree desde que encontrar el ancho mínimo de ancho inducido pseudotree es NP-Hard. Se han desarrollado varias heurísticas distribuidas EdgetRaversal para encontrar pseudotrees de bajo ancho [8]. Al final de la primera fase, cada agente conoce a sus padres, hijos, pseudo-padres y pseudo-niños.3.1 Los agentes de propagación de servicios públicos ubicados en nodos de hoja en el pseudotree comienzan el proceso calculando un hipercubo local de utilidad. Este hipercubo en el nodo X contiene utilidades sumadas para cada combinación de valores en los dominios para p (x) y pp (x). Este hipercube tiene un tamaño dimensional igual al número de pseudo-parentes más uno. Un mensaje que contiene este hipercube se envía a P (x). Los agentes ubicados en los nodos no hojas esperan a que lleguen todos los mensajes de los niños. Una vez que el agente en el nodo Y tiene todos los mensajes de utilidad, calcula su hipercubo de utilidad local que incluye dominios para P (Y), PP (Y) e Y. El hipercube de utilidad local se une con todos los hipercubos de los mensajes infantiles. En este punto, se conocen todas las utilidades que involucran el nodo Y, y el dominio para Y puede eliminarse de manera segura del hipercubo unido. Este proceso de eliminación elige la mejor utilidad sobre el dominio de Y para cada combinación de los dominios restantes. Un mensaje que contiene este hipercube ahora se envía a P (y). El tamaño dimensional de este hipercubo depende del número de dominios superpuestos en los mensajes recibidos y la utilidad local Hypercube. Esta fase de propagación basada en programación dinámica continúa hasta que el agente en el nodo raíz del pseudotree haya recibido todos los mensajes de sus hijos.3.2 Propagación del valor La propagación del valor comienza cuando el agente en el nodo raíz Z ha recibido todos los mensajes de sus hijos. Como Z no tiene padres ni pseudo-padres, simplemente combina los hipercubos de servicios públicos recibidos de sus hijos. El hipercubo combinado contiene solo valores para el dominio para Z. En este punto, el agente en el nodo Z simplemente elige la asignación para su dominio que tiene la mejor utilidad. Se envía un mensaje de propagación de valor con esta asignación a cada nodo en C (z). El nodo del otro recibe un mensaje de propagación de valor de su padre y elige la asignación de su dominio que tiene la mejor utilidad dadas las tareas recibidas en el mensaje. El nodo agrega su asignación de dominio a las asignaciones que recibió y pasa el conjunto de tareas a sus hijos. El algoritmo está completo cuando todos los nodos han elegido una tarea para su dominio.4. Algoritmo DCPOP Nuestra extensión al algoritmo DPOP original, que se muestra en el Algoritmo 1, comparte las mismas tres fases. La primera fase genera el pseudotree de bordes cruzados para la instancia de DCOP. La segunda fase fusiona ramas y propaga los hipercubos de utilidad. La tercera fase elige asignaciones para dominios en los puntos de fusión de rama y de una manera de arriba hacia abajo, comenzando con el agente en el nodo raíz. Para la primera fase generamos una pseudotree utilizando varias heurísticas distribuidas y seleccionamos la que con la más baja complejidad general. La complejidad del tamaño del mensaje de cálculo y utilidad en DCPOP no corresponde directamente al ancho inducido del pseudotree de filo cruzado. En cambio, utilizamos un método de tiempo polinomial para calcular el tamaño máximo de cálculo y mensaje de utilidad para una pseudotree de filo cruzado dado. Una descripción de este método y el proceso de selección de pseudotree aparece en la Sección 5. Al final de la primera fase, cada agente conoce a sus padres, hijos, pseudoparentes, pseudo-niños, sucursales y hijos de ramas.4.1 Las ramas de fusión y la propagación de utilidad en el algoritmo DPOP original Un nodo X solo tenía funciones de utilidad que involucraban a su padre y sus pseudo-padres. En DCPOP, se permite que un nodo X tenga una función de utilidad que involucre a un parente de rama. El concepto de una rama se puede ver en la Figura 2 con el nodo E que representa nuestro nodo X. Las dos rutas distintas desde el nodo E al nodo B se denominan ramas de E. El nodo único donde todas las ramas de E se encuentran es el nodo B, que se llama el punto de fusión de E. Agentes con nodos que tienen a los padres de ramas que comienzan enviando unMensaje de propagación de utilidad a cada sán y padre. Este mensaje incluye un hipercubo de utilidad bidimensional con dominios para el nodo X y la BP-PARENT BP (X). También incluye una estructura de información de rama que contiene el nodo de origen de la rama, x, el número total de ramas que se originan en x y el número de ramas que se originan en x que se fusionan en una sola representación por esta estructura de información de la rama (este númerocomienza en 1). Intuitivamente cuando el número de ramas fusionadas es igual al número total de ramas de origen, el algoritmo ha alcanzado el punto de fusión para X. En la Figura 2, el nodo E envía un mensaje de propagación de utilidad a su billete de rama, nodo D. Este mensaje tiene dimensiones para los dominios de E y D, e incluye información de rama con un origen de E, 2 ramas totales y 1 rama fusionada. Como en la fase original de propagación de utilidad DPOP, un agente en el nodo Leaf X envía un mensaje de propagación de utilidad a su padre. En DCPOP, este mensaje contiene dimensiones para los dominios de P (x) y PP (x). Si el nodo X también tiene a la sucursal, entonces el mensaje de propagación de la utilidad también contiene una dimensión para el dominio de X, e incluirá una estructura de información de rama. En la Figura 2, el nodo E envía un mensaje de propagación de utilidad a su padre, el nodo C. Este mensaje tiene dimensiones para los dominios de E y C, e incluye información de rama con un origen de E, 2 ramas totales y 1 rama fusionada. Cuando un nodo Y recibe mensajes de propagación de utilidad de todo el sexto INTL. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 743 Sus hijos y children, fusiona cualquier ramas con el mismo nodo de origen X. La estructura de información de la rama fusionada acumula el número de ramas fusionadas para X. Si el número total acumulativo de ramas fusionadas es igual al número total de ramas, entonces Y es el punto de fusión para X. Esto significa que los hipercubos de utilidad presentes en Y contienen toda la información sobre las valoraciones para las funciones de servicios públicos que involucran el nodo X. Además de la eliminación típica del dominio de Y de los hipercubos de utilidad, ahora podemos eliminar de manera segura el dominio de X de los hipercubos de utilidad. Para ilustrar este proceso, examinaremos lo que sucede en la segunda fase para el nodo B en la Figura 2. En la segunda fase, el nodo B recibe dos mensajes de propagación de utilidad. El primero proviene del nodo C e incluye dimensiones para dominios E, B y A. También tiene una estructura de información de rama con origen de E, 2 ramas totales y 1 rama fusionada. El segundo proviene del nodo D e incluye dimensiones para los dominios E y B. También tiene una estructura de información de rama con origen de E, 2 ramas totales y 1 rama fusionada. El nodo B luego fusiona las estructuras de información de la rama de ambos mensajes porque tienen el mismo origen, el nodo E. Dado que el número de ramas fusionadas que se originan en E ahora es 2 y las ramas totales que se originan en E es 2, el nodo B ahora elimina las dimensiones paraDominio E. El nodo B también elimina la dimensión para su propio dominio, dejando solo información sobre el dominio A. El nodo B luego envía un mensaje de propagación de utilidad al nodo A, que contiene solo una dimensión para el dominio de A. Aunque no es posible en DPOP, este método de propagación de utilidad y eliminación de dimensiones puede producir hipercubos en el nodo Y que no comparten ningún dominio. En DCPOP no unimos hipercubos independientes del dominio, sino que podemos enviar múltiples hipercubos en el mensaje de propagación de utilidad enviado a los padres de Y. Este enfoque perezoso para unirse ayuda a reducir los tamaños de mensajes.4.2 Propagación del valor Como en DPOP, la propagación del valor comienza cuando el agente en el nodo raíz Z ha recibido todos los mensajes de sus hijos. En este punto, el agente en el nodo Z elige la asignación para su dominio que tiene la mejor utilidad. Si Z es el punto de fusión para las ramas de algún nodo X, Z también elegirá la asignación para el dominio de X. Por lo tanto, cualquier nodo que sea un punto de fusión elegirá tareas para un dominio que no sea el suyo. Estas tareas se transmiten por la jerarquía de borde primario. Si el nodo X en la jerarquía tiene algas de ramas, entonces el mensaje de asignación de valor de P (x) contendrá una asignación para el dominio de X. Cada nodo en la jerarquía agrega cualquier tarea que haya elegido a las que recibió y pasa el conjunto de tareas a sus hijos. El algoritmo está completo cuando todos los nodos han elegido o recibido una tarea para su dominio.4.3 Prueba de corrección probaremos la corrección de DCPOP al señalar primero que DCPOP extiende completamente DPOP y luego examinando los dos casos para la asignación de valor en DCPOP. Dada una pseudotree tradicional como entrada, la ejecución del algoritmo DCPOP es idéntica a DPOP. Usando una disposición de pseudotree tradicional, no los nodos tienen serales de ramas o children, ya que todos los bordes son bordes o bordes de árboles. Por lo tanto, el algoritmo DCPOP que utiliza una pseudotree tradicional envía solo mensajes de propagación de utilidad que contienen dominios pertenecientes a los padres o pseudo-parentes de un nodo. Dado que ningún nodo tiene ningún tipo de sucursal, no existen ramas y, por lo tanto, ningún nodo sirve como punto de fusión para ningún otro nodo. Por lo tanto, todas las asignaciones de propagación de valor se eligen en el nodo del dominio de asignación. Para la ejecución de DCPOP con pseudotrees de bordes cruzados, algunos nodos sirven como puntos de fusión. Observamos que cualquier nodo X que no sea un punto de fusión asigna su valor exactamente como en DPOP. El hipercube de utilidad local en X contiene dominios para X, P (X), PP (X) y BC (X). Como en DPOP, el mensaje de asignación de valor recibido en x incluye los valores asignados a P (x) y pp (x). Además, dado que X no es un punto de fusión, todas las tareas a BC (x) deben haberse calculado en puntos de fusión más altos en el árbol y están en el mensaje de asignación de valor de P (x). Por lo tanto, después de eliminar los dominios para los cuales se conocen las tareas, solo queda el dominio de x. El agente en el nodo X ahora puede elegir correctamente la asignación con la utilidad máxima para su propio dominio. Si el nodo X es un punto de fusión para alguna rama, Hijo Y, sabemos que X debe ser un nodo a lo largo de la ruta desde y hasta la raíz, y de P (y) y toda BP (y) a la raíz. Del algoritmo, sabemos que Y necesariamente tiene toda la información de C (y), PC (y) y BC (y) ya que espera sus mensajes. El nodo X tiene información sobre todos los nodos debajo del árbol, que incluiría Y, P (Y), BP (y) y los PP (y) que están por debajo de x en el árbol. Para cualquier pp (y) arriba x en el árbol, X recibe la asignación para el dominio de PP (y) en el mensaje de asignación de valor de P (x). Por lo tanto, X tiene información de utilidad sobre todas las funciones de utilidad de las cuales Y es parte. Al eliminar los dominios incluidos en el mensaje de asignación de valor, el nodo X se deja con un hipercubo de utilidad local con dominios para X e Y. El agente en el nodo X ahora puede elegir correctamente las tareas con la utilidad máxima para los dominios de X e Y. 4.4 Análisis de complejidad La primera fase de DCPOP envía un mensaje a cada P (x), PP (x) y BP (x). La segunda fase envía un mensaje de asignación de valor a cada C (x). Por lo tanto, DCPOP produce un número lineal de mensajes con respecto al número de bordes (funciones de utilidad) en el pseudotree cruzado y la instancia DCOP original. La complejidad real de DCPOP depende de dos medidas adicionales: tamaño de mensaje y tamaño de cálculo. El tamaño del mensaje y el tamaño de cálculo en DCPOP dependen del número de ramas superpuestas, así como del número de bordes superpuestos. Se demostró en [6] que el número de bordes posteriores superpuestos es igual al ancho inducido de la seudotree. En un pseudotree de bordes cruzados mal construidos, el número de ramas superpuestas en el nodo X puede ser tan grande como el número total de descendientes de X. Por lo tanto, el tamaño total del mensaje en DCPOP en una instancia mal construida puede ser exponencial en el número total de nodos en el gráfico. Sin embargo, en la práctica, una pseudotree bien construida puede lograr resultados mucho mejores. Más tarde abordamos el tema de elegir pseudotrees cruzados bien construidos de un conjunto. Introducimos una medición adicional del costo de ruta secuencial máximo a través del algoritmo. Esta medición se relaciona directamente con la cantidad máxima de paralelismo que se puede lograr por el algoritmo. Para tomar esta medición, primero almacenamos el tamaño total de cálculo para cada nodo durante la fase dos y tres. Este tamaño de cálculo representa el número de accesos individuales a un valor en un hipercubo en cada nodo. Por ejemplo, una unión entre dos dominios de tamaño 4 cuesta 4 ∗ 4 = 16. Luego se pueden dibujar dos gráficos acíclicos dirigidos (DAG);Uno con los mensajes de propagación de utilidad como bordes y la fase dos costos en los nodos, y el otro con mensajes de asignación de valor y la fase tres costos en los nodos. El costo máximo de ruta secuencial es igual a la suma de la ruta más larga en cada DAG desde la raíz hasta cualquier nodo de hoja.5. Heurística En nuestra evaluación de la complejidad en DCPOP, nos centramos en el peor de los casos que posiblemente produce el algoritmo. Reconocemos 744 el sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) Algoritmo 1 Algoritmo DCPOP 1: DCPOP (x; d; u) Cada agente XI ejecuta: Fase 1: Creación de pseudotree 2: Líder electo de todos XJ ∈ X 3: Iniciadores de líder electoPseudotree Creation 4: después, Xi sabe P (xi), pp (xi), bp (xi), c (xi), bc (xi) y pc (xi) fase 2: propagación de mensajes utilizado 5: if | bp (xi (xi) |> 0 luego 6: Branchxi ← | BP (xi) |+ 1 7: Para todos los xk ∈Bp (xi) do 8: utilxi (xk) ← Compute utils (xi, xk) 9: enviar mensaje (xk, utilxi (xk), branchxi) 10: if | c (xi) |= 0 (es decir. Xi es un nodo de hoja) luego 11: utilxi (p (xi)) ← Computed Utils (p (xi), pp (xi)) para todos los pp (xi) 12: enviar mensaje (p (xi), utilxi (p (p (p (p (p (p (p (p (p (Xi)), Branchxi) 13: Enviar mensaje (pp (xi), utilizar vacío, rama vacía) a todos los pp (xi) 14: activar el controlador de mensajes utilizado () Fase 3: Valor Propagación de mensajes 15: Activar Valor Message Handler ()Handler de mensajes del algoritmo final (xk, utilxk (xi), branchxk) 16: almacenar utilxk (xi), branchxk (xi) 17: si los mensajes de todos los niños y los niños de la rama llegaron entonces 18: para todos bj ∈Branch (xi)do 19: si bj se fusiona, entonces 20: une a todos los hipercubos donde bj ∈Util (xi) 21: elimine bj del hipercubo unido 22: si p (xi) == nulo (eso significa xi es la raíz) entonces 23: v∗ i ← Elija óptimo (nulo) 24: envío de valor (xi, v ∗ i) a todos c (xi) 25: else 26: utilxi (p (xi)) ← Compute Utils (P (xi), pp (xi)) 27: Enviar mensaje (p (xi), utilxi (p (xi)), branchxi (p (xi))) Valor Mensaje Handler (valuexi, p (xi)) 28: Agregue todo xk ← v ∗ k ∈Valuexi,P (xi) a la vista del agente 29: xi ← v ∗ i = Elija óptimo (vista de agente) 30: Enviar valorxl, xi a todos xl ∈C (xi) que en los problemas del mundo real la generación de la pseudotree tiene un impacto significativo enel rendimiento real. El problema de encontrar el mejor pseudotree para una instancia de DCOP dada es NP-Hard. Por lo tanto, se usa una heurística para la generación, y el rendimiento del algoritmo depende de la seudotree encontrada por la heurística. Algunas investigaciones anteriores se centraron en encontrar heurísticas para generar buenos pseudotrees [8]. Si bien hemos desarrollado algunas heurísticas que generan buenos pseudotrees de bordes cruzados para su uso con DCPOP, nuestro enfoque ha sido usar múltiples heurísticas y luego seleccionar la mejor pseudotree de los seudotrees generados. Consideramos solo la heurística que se ejecutan en tiempo polinomial con respecto al número de nodos en la instancia original de DCOP. El algoritmo DCPOP real tiene la peor complejidad exponencial de los casos, pero podemos calcular el tamaño máximo del mensaje, el tamaño de la cálculo y el costo de ruta secuencial para una pseudotree de bordes cruzados dados en la complejidad lineal de espacio-tiempo. Para hacer esto, simplemente ejecutamos el algoritmo sin intentar calcular cualquiera de los hipercubos de utilidad local u asignaciones de valor óptimas. En su lugar, los mensajes incluyen información dimensional y de rama, pero no hay hipercubos de utilidad. Después de que cada heurística complete su generación de una pseudotree, ejecutamos el procedimiento de medición y propagamos la información de medición hasta la raíz elegida en esa seudotree. La raíz luego transmite la complejidad total de esa heurística para todos los nodos. Después de que todas las heurísticas han tenido la oportunidad de completar, cada nodo sabe qué heurística produjo la mejor seudotree. Cada nodo luego procede a comenzar el algoritmo DCPOP utilizando su conocimiento del pseudotree generado por la mejor heurística. La heurística utilizada para generar seudotrees tradicionales realiza un transversal DFS distribuido. El algoritmo distribuido general utiliza un mecanismo de aprobación de tokens y un número lineal de mensajes. La heurística basada en DFS mejorada Utilice un procedimiento especial para elegir el nodo raíz y también proporcionar una función de pedido sobre los vecinos de un nodo para determinar el orden de la recursión de ruta. Las heurísticas basadas en DFS utilizadas en nuestros experimentos provienen del trabajo realizado en [4, 8].5.1 El mejor primer pseudotree heurística de bordes cruzados La heurística utilizada para generar pseudotrees cruzados realizan una mejor transversal. En el Algoritmo 2 se presenta un algoritmo general distribuido para la expansión del nodo para la expansión del nodo. Una función de evaluación en cada nodo proporciona los valores que se utilizan para determinar el siguiente mejor nodo para expandirse. Tenga en cuenta que en este algoritmo cada nodo solo intercambia su mejor valor con sus vecinos. En nuestros experimentos utilizamos varias funciones de evaluación que tomaron como argumentos una lista ordenada de antepasados y un nodo, que contiene una lista de vecinos (con la profundidad de colocación de cada vecino en el árbol si se colocó). A partir de estos, podemos calcular los ramas, las ramas y las relaciones desconocidas para una posible colocación de nodos. La mejor función general calculó el valor como antepasados (Branchparents+Branchildren) con el número de relaciones desconocidas como un desempate. Después de completar, cada nodo tiene conocimiento de sus padres y antepasados, por lo que puede determinar fácilmente qué nodos conectados son pseudo-padres, ramas, pseudo-niñes y chíbles de sucursales. La complejidad de la mejor transversal depende de la complejidad de la función de evaluación. Suponiendo una complejidad de O (V) para la función de evaluación, que es el caso de nuestra mejor función general, la mejor transversal es O (V · E) que es en el peor de O (N3). Para cada v ∈ V realizamos una operación de lugar y encontramos el siguiente nodo para colocar utilizando la operación GetBestneighbor. La operación del lugar es como máximo o (v) debido a los mensajes enviados. Encontrar el siguiente nodo usa recursión y recorridos solo se colocó el sexto INTL. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 745 Algoritmo 2 Distribuido el mejor algoritmo de búsqueda de la primera raíz ← ElegedLeader Next (root, ∅) lugar (nodo, parent) nodoEnviar mensaje de colocación (nodo, nodo.ancestors) a todos los vecinos de nodo siguiente (actual, anterior) Si la corriente no se coloca, entonces coloque (actual, anterior) Siguiente (actual, ∅) más mejor ← GetBestneighbor (actual, anterior) Si es mejor)= ∅ Entonces, si anteriormente = ∅ entonces termina, todos los nodos se colocan a continuación (anterior, ∅) más siguiente (mejor, actual) getBestneighbor (actual, anterior) mejor ← ∅;puntaje ← 0 para todos n ∈ Current. Neighbors do si n!= Anterior entonces si n se coloca, entonces nscore ← getBestneighbor (n, actual) más nscore ← Evalúe (actual, n) Si nscore> anota y luego obtiene ← nscore mejor ← n devuelve mejor, puntaje nodos, por lo que tiene o (v) recursiones. Cada recursión realiza una operación recursiva de GetBestneighbor que atraviesa todos los nodos colocados y sus vecinos. Esta operación es O (V · E), pero los resultados se pueden almacenar en caché utilizando solo el espacio O (V) en cada nodo. Así tenemos O (V · (V +V +V · E)) = O (V 2 · E). Si somos inteligentes sobre la evaluación de los cambios locales cuando cada nodo recibe mensajes de colocación de sus vecinos y almacena en caché los resultados La operación de GetBestneighbor es solo o (e). Esto aumenta la complejidad de la operación del lugar, pero para todas las ubicaciones la complejidad total es solo o (V · E). Por lo tanto, tenemos una complejidad general de O (V · E +V · (V +E)) = O (V · E).6. Comparación de la complejidad en DPOP y DCPOP Ya hemos demostrado que, dada la misma entrada, DCPOP realiza lo mismo que DPOP. También hemos demostrado que podemos predecir con precisión el rendimiento de un pseudotree dado en complejidad lineal en tiempo espacial. Si usamos un número constante de heurísticas para generar el conjunto de seudotrees, podemos elegir el mejor seudotree en la complejidad lineal del espacio-tiempo. Ahora demostraremos que existe una instancia de DCOP para la cual un pseudotree de bordes cruzados supera a todos los pseudotrees tradicionales posibles (basados en heurísticas traversales de borde). En la Figura 3 (a) tenemos una instancia de DCOP con seis nodos. Este es un gráfico bipartito con cada partición totalmente conectada a la otra (a) (b) (c) Figura 3: (a) la instancia de DCOP (b) Una disposición de pseudotree tradicional para la instancia DCOP (c) un pseudotree de filo cruzadodisposición para la partición de instancia DCOP. En la Figura 3 (b) vemos una disposición tradicional de seudotree para esta instancia de DCOP. Es fácil ver que cualquier heurística basada en EdgetRaversal no puede expandir dos nodos de la misma partición en sucesión. También vemos que ningún nodo puede tener más de un hijo porque cualquier acuerdo de este tipo sería una seudotree inválida. Por lo tanto, cualquier disposición de pseudotree tradicional para esta instancia de DCOP debe tomar la forma de la Figura 3 (b). Podemos ver que el nodo de superposición F-B y F-A del nodo C. C. El nodo C también tiene un padre E, y un borde posterior con D. usando el algoritmo DPOP original (o DCPOP ya que son idénticos en este caso), encontramosQue el cálculo en el nodo C implica cinco dominios: A, B, C, D y E., en contraste, la disposición de pseudotree de filo cruzado en la Figura 3 (c) requiere solo un máximo de cuatro dominios en cualquier cálculo durante DCPOP. Dado que el nodo A es el punto de fusión para ramas de B y C, podemos ver que cada uno de los nodos D, E y F tienen dos ramas superpuestas. Además, cada uno de estos nodos tiene el nodo A como padre. Usando el algoritmo DCPOP, encontramos que el cálculo en el nodo D (o E o F) implica cuatro dominios: A, B, C y D (o E o F). Dado que no se puede crear una mejor disposición de pseudotree tradicional utilizando una heurística transversal de borde, hemos demostrado que DCPOP puede superar a DPOP incluso si usamos la pseudotree óptima que se encuentra a través del traversal de borde. Reconocemos que los arreglos de pseudotree que permiten las relaciones entre padres e hijos sin una restricción real pueden resolver el problema en la Figura 3 (a) con el tamaño máximo de cálculo de cuatro dominios. Sin embargo, las heurísticas actuales utilizadas con DPOP no producen tales pseudotrees, y tal heurística sería difícil de distribuir ya que cada nodo requeriría información sobre los nodos con los que no tiene restricción. Además, si bien no lo probamos aquí, los pseudotrees de bordes cruzados pueden producir tamaños de mensajes más pequeños que tales seudotatas, incluso si el tamaño de cálculo es similar. En la práctica, dado que encontrar la mejor disposición de pseudotree es NP-Hard, encontramos que las heurísticas que producen pseudotrees de filo cruzado a menudo producen tamaños de cálculo y mensajes significativamente más pequeños.7. Resultados experimentales 746 El sexto intl. Conf.En agentes autónomos y sistemas de agentes múltiples (AAMAS 07), las métricas de rendimiento existentes para los algoritmos DCOP incluyen el número total de mensajes, ciclos de reloj sincrónicos y tamaño de mensaje. Ya hemos demostrado que el número total de mensajes es lineal con respecto al número de restricciones en la instancia de DCOP. También introdujimos el costo máximo de ruta secuencial (PC) como una medición de la cantidad máxima de paralelismo lograble por el algoritmo. El costo máximo de la ruta secuencial es igual a la suma de los cálculos realizados en la ruta más larga desde la raíz hasta cualquier nodo de hoja. También incluimos como métricas el tamaño máximo de cálculo en número de dimensiones (CD) y tamaño máximo del mensaje en número de dimensiones (MD). Para analizar la complejidad relativa de una instancia DCOP dada, encontramos el ancho mínimo inducido (IW) de cualquier pseudotree tradicional producida por una heurística para el DPOP original.7.1 Instancias genéricas de DCOP Para nuestras pruebas iniciales generamos al azar dos conjuntos de problemas con 3000 casos en cada uno. Cada problema se generó asignando un número aleatorio (elegido desde un rango) de restricciones a cada variable. Luego, el generador creó restricciones binarias hasta que cada variable alcanzó su número máximo de restricciones. El primer conjunto usa 20 variables, y el mejor DPOP IW varía de 1 a 16 con un promedio de 8.5. El segundo conjunto usa 100 variables, y el mejor DPOP IW varió de 2 a 68 con un promedio de 39.3. Dado que la mayoría de los problemas en el segundo conjunto eran demasiado complejos para calcular la solución, tomamos medidas de las métricas utilizando las técnicas descritas anteriormente en la Sección 5 sin resolver el problema. Los resultados se muestran para el primer conjunto en la Tabla 1 y para el segundo conjunto en la Tabla 2. Para los dos conjuntos de problemas, dividimos los casos en categorías de baja densidad y alta densidad. Los casos de baja densidad consisten en aquellos problemas que tienen un mejor DEPOP es menor o igual a la mitad del número total de nodos (p. IW ≤ 10 para los 20 problemas de nodo e IW ≤ 50 para los 100 problemas de nodo). Los problemas de alta densidad consisten en el resto de los conjuntos de problemas. Tanto en la Tabla 1 como en la Tabla 2, hemos enumerado las métricas de rendimiento para el algoritmo DPOP original, el algoritmo DCPOP que usa solo seudotreos de bordado cruzado (DCPOP-CE) y el algoritmo DCPOP utilizando seudotreos tradicionales y de bordes cruzados (DCPOP-ALL). Los pseudotrees utilizados para DPOP se generaron utilizando 5 heurísticas: DFS, DFS MCN, DFS Clique MCN, DFS MCN DSTB y DFS MCN BEC. Estas son todas las versiones del traversal DFS guiado discutido en la Sección 5. Los pseudotrees de bordes cruzados utilizados para DCPOP-CE se generaron usando 5 heurísticas: MCN, LCN, MCN A-B, LCN A-B y LCSG A-B. Estas son todas las versiones del mejor recorrido discutido en la Sección 5. Tanto para DPOP como para DCPOP-CE elegimos la mejor pseudotree producida por sus respectivas 5 heurísticas para cada problema en el set. Para DCPOP-All, elegimos la mejor pseudotree producida por las 10 heurísticas para cada problema en el set. Para las métricas de CD y MD, el valor que se muestra es el número promedio de dimensiones. Para la métrica de PC, el valor que se muestra es el logaritmo natural del costo máximo de la ruta secuencial (ya que el valor real crece exponencialmente con la complejidad del problema). La fila final en ambas tablas es una medición de la mejora de DCPOP-ALL sobre DPOP. Para las métricas de CD y MD, el valor que se muestra es una reducción en el número de dimensiones. Para la métrica de PC, el valor mostrado es una reducción porcentual en el costo máximo de ruta secuencial (% = DP OP −DCP OP DCP OP ∗ 100). Observe que DCPOPall supera a DPOP en todas las métricas. Esto lógicamente se deduce de nuestra afirmación anterior de que dada la misma entrada, DCPOP funciona exactamente igual que DPOP. Por lo tanto, dada la elección entre los pseudotrees producidos por las 10 heurísticas, DCPOP-ALL siempre eliminará el algoritmo de alta densidad de densidad CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-ALL 7.62 6.49.3.66 12.72 11.36 5.05 Mejora 0.18 0.32 13% 0.62 0.98 36% Tabla 1: 20 Problemas de nodos Algoritmo de alta densidad CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-ECE 33.49 29.17 15.22 57.11 529.57 14.10 56.33 51.17 18.84 Mejora 1.00 2.78 104% 2.18 6.33 256% Tabla 2: 100 Problemas de nodos Figura 4: Tamaño de dimensión de cálculo Figura 5: Tamaño de dimensión del mensaje El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 747 Figura 6: Costo de ruta DCPOP Mejora Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 24 2476 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Tabla 3: Problemas de programación de reuniones realizan DPOP. Otra tendencia que notamos es que la mejora es mayor para problemas de alta densidad que los problemas de baja densidad. Mostramos esta tendencia con mayor detalle en las Figuras 4, 5 y 6. Observe cómo aumenta la mejora a medida que aumenta la complejidad del problema.7.2 Problema de programación de reuniones Además de nuestras pruebas DCOP genéricas iniciales, realizamos una serie de pruebas en el problema de programación de reuniones (MSP) como se describe en [6]. La configuración del problema incluye a varias personas que se agrupan en los departamentos. Cada persona debe asistir a un número específico de reuniones. Las reuniones se pueden celebrar dentro de los departamentos o entre los departamentos, y pueden asignarse a uno de los ocho espacios de tiempo. El MSP se asigna a una instancia de DCOP donde cada variable representa la ranura de tiempo a la que una persona específica asistirá a una reunión específica. Todas las variables que pertenecen a la misma persona tienen restricciones de exclusión mutua colocadas para que la persona no pueda asistir a más de una reunión durante el mismo intervalo de tiempo. Todas las variables que pertenecen a la misma reunión tienen restricciones de igualdad para que todos los participantes elijan la misma ranura de tiempo. Se colocan restricciones unarias en cada variable para tener en cuenta la valoración de una persona de cada reunión y intervalo de tiempo. Para nuestras pruebas generamos 100 problemas de muestra para cada combinación de agentes y reuniones. Los resultados se muestran en la Tabla 3. Los valores en las primeras cinco columnas representan (en orden de izquierda a derecha), el número total de agentes, el número total de reuniones, el número total de variables, el número total promedio de limitaciones y el IW mínimo promedio producido por unseudotree. Las últimas tres columnas muestran las mismas métricas que utilizamos para las instancias genéricas de DCOP, excepto que esta vez solo mostramos las mejoras de DCPOP-ALL sobre DPOP. El rendimiento es mejor en promedio para todas las instancias de MSP, pero nuevamente vemos mejoras más grandes para instancias problemáticas más complejas.8. Conclusiones y trabajos futuros presentamos un algoritmo completo y distribuido que resuelve instancias generales de DCOP utilizando arreglos de pseudotree cruzados. Nuestro algoritmo extiende el algoritmo DPOP agregando mensajes de propagación de utilidad adicionales e introduciendo el concepto de fusión de ramas durante la fase de propagación de servicios públicos. Nuestro algoritmo también permite que las asignaciones de valor ocurran en puntos de fusión de nivel superior para nodos de nivel inferior. Hemos demostrado que DCPOP extiende completamente DPOP realizando las mismas operaciones dada la misma entrada. También hemos demostrado a través de algunos ejemplos y datos experimentales que DCPOP puede lograr un mayor rendimiento para algunas instancias problemáticas al extender el conjunto de entrada permitido para incluir pseudotrees de bordes cruzados. Pusimos especial énfasis en el papel que juegan las heurísticas que trazan el borde en la generación de seudotrees. Hemos demostrado que la penalización de rendimiento es mínima para generar múltiples heurísticas, y que podemos elegir el pseudotree mejor generado en la complejidad lineal del espacio-tiempo. Dada la importancia de un buen seudotree para el rendimiento, el trabajo futuro incluirá nuevas heurísticas para encontrar mejores seudotrees. El trabajo futuro también incluirá la adaptación de las extensiones DPOP existentes [5, 7] que admiten diferentes dominios de problemas para su uso con DCPOP.9. Referencias [1] J. Liu y K. P. Sycara. Explotación de la estructura del problema para la optimización de restricciones distribuidas. En V. Lesser, Editor, Actas de la primera conferencia internacional sobre sistemas de múltiples agentes, páginas 246-254, San Francisco, CA, 1995. MIT Press.[2] P. J. Modi, H. Jung, M. Tambe, W.-M.Shen y S. Kulkarni. Un enfoque dinámico de satisfacción de restricción distribuida para la asignación de recursos. Notas de conferencia en informática, 2239: 685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe y M. Yokoo. Un método completo asincrónico para la optimización de restricciones distribuidas. En Aamas 03, 2003. [4] A. Petcu. Frodo: un marco para la optimización de restricciones abiertas/distribuidas. Informe técnico No. 2006/001 2006/001, Instituto Swiss Federal de Tecnología (EPFL), Lausana (Suiza), 2006. http://liawww.epfl.ch/frodo/.[5] A. Petcu y B. Faltings. A-DPOP: aproximaciones en la optimización distribuida. En el póster en CP 2005, páginas 802-806, Sitges, España, octubre de 2005. [6] A. Petcu y B. Faltings. DPOP: un método escalable para la optimización de restricciones multiagente. En IJCAI 05, páginas 266-271, Edimburgo, Escocia, agosto de 2005. [7] A. Petcu, B. Faltings y D. Parkes. M-DPOP: Implementación distribuida fiel de problemas eficientes de elección social. En Aamas 06, páginas 1397-1404, Hakodate, Japón, mayo de 2006. [8] G. Ushakov. Resolver problemas de programación de reuniones utilizando el procedimiento distribuido de pseudotree-optimización. Tesis de maestría, ´ECOLE POLYTECHNIQUE F´ED´ERALE DE LAUSANNE, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida y K. Kuwabara. Satisfacción de restricción distribuida para formalizar la resolución de problemas distribuidos. En la Conferencia Internacional sobre Sistemas de Computación Distribuida, páginas 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida y K. Kuwabara. El problema de satisfacción de la restricción distribuida: formalización y algoritmos. Conocimiento e ingeniería de datos, 10 (5): 673-685, 1998. 748 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07)