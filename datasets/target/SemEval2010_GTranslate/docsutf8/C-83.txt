Concepto y arquitectura de un sistema de edición y gestión de documentos generalizados Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Universidad de Suiza de Zúrich, Universidad de Suiza de Zúrich, Departamento de Informática de Suiza de Departamento de Informática de Informática, LEONE@IFI.UNIZH.CH.CHhodel@ifi.unizh.ch Gall@ifi.unizh.ch El procesamiento de documentos colaborativos abstractos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en el versículo de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y administración de documentos generalizados. Explota técnicas de base de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los meta datos de documentos. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y lo discutimos con un ejemplo. Categorías y descriptores de sujetos c.2.4 Sistemas distribuidos [redes de comunicación informática]: organización del sistema informático, sistemas distribuidos, aplicaciones distribuidas de gestión de términos generales, medición, documentación, economía, factores humanos 1. Introducción Los documentos de texto son un recurso valioso para prácticamente cualquier empresa y organización. Documentos como documentos, informes y documentos comerciales generales contienen una gran parte del conocimiento de hoy. Los documentos se almacenan principalmente en una estructura de carpeta jerárquica en los servidores de archivos y es difícil organizarlos con respecto a la clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de documentossiempre que quieran y, de manera fácil de usar.1.1 La descripción del problema con la mayoría de los documentos de aplicaciones de procesamiento de palabras comúnmente utilizados pueden ser manipulados por un solo usuario a la vez: las herramientas para la edición y la gestión de documentos colaborativos generalizados rara vez se implementan en el mundo de hoy. A pesar del hecho de que las personas se esfuerzan por la independencia de ubicación y tiempo, la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión de documentos colaborativos está totalmente descuidada. Por lo tanto, los documentos podrían verse como una fuente vulnerable en el mundo de hoy, que exige una solución apropiada: la necesidad de almacenar, recuperar y editar estos documentos en colaboración en cualquier momento, en todas partes y con casi todos los dispositivos adecuados y con mecanismos garantizados de seguridad, consistencia, disponibilidady el control de acceso, es obvio. Además, los sistemas de procesamiento de textos ignoran el hecho de que el historial de un documento de texto contiene información crucial para su gestión. Dichos meta datos incluyen fecha de creación, creador, autores, versión, información basada en la ubicación, como el tiempo y el lugar cuando/donde un usuario lee/edita un documento, etc. Dichos meta datos se pueden recopilar durante el proceso de creación de documentos y se pueden usar versatiliamente. Especialmente en el campo de la gestión generalizada de documentos, los meta datos son de importancia crucial, ya que ofrece formas totalmente nuevas de organizar y clasificar documentos: por un lado, la situación real de los usuarios influye en los objetivos de los usuarios. Los meta datos podrían usarse para dar al usuario la mejor vista posible de los documentos, dependiendo de su información real. Por otro lado, tan pronto como el usuario comienza a funcionar, es decir, lee o edita un documento, se pueden recopilar nuevos meta datos para que el sistema sea más adaptable y, en cierto sentido, para la situación de los usuarios y, para ofrecer a los usuarios futuros unMejor vista sobre los documentos. Hasta donde sabemos, no existe ningún sistema que satisfaga los requisitos antes mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se describe en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos generalizados, que permite la edición y administración de documentos generalizadas (y colaborativas): los usuarios deben poder leer y editar documentos cuando, donde sea, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de textos en tiempo real basado en la base de datos colaborativa, que proporciona una funcionalidad de edición y gestión de documentos generalizados. Permite al usuario trabajar en documentos en colaboración y ofrece una sofisticada instalación de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y administrar documentos sobre la base de meta datos. Además, los datos del documento se tratan como ciudadano de primera clase de la base de datos como se exige en [1].1.2 Conceptos subyacentes El concepto de nuestro sistema de edición y gestión de documentos generalizados requiere una base arquitectónica apropiada. Nuestro concepto e implementación se basan en el sistema de edición y gestión de documentos basado en la base de datos Tendax [3] basado en la base de datos, que permite la edición y administración de documentos generalizados. Tendax es una extensión de base de datos nativa de texto. Permite el almacenamiento de texto en bases de datos en forma nativa para que la edición del texto finalmente se represente como transacciones en tiempo real. En el término edición de texto, entendemos lo siguiente: escribir y eliminar texto (caracteres), copiar y pegar texto, definir el diseño y estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, etc., es decir, todosLas acciones realizadas regularmente por usuarios de procesamiento de textos. Con la transacción en tiempo real, queremos decir que la edición del texto (por ejemplo, escribir un carácter/palabra) invoca una o varias transacciones de base de datos para que todo, que se escribe, aparece dentro del editor tan pronto como estos objetos se almacenan de manera persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los meta datos que pertenecen a los documentos se almacenan de manera especial en la base de datos, que permite transacciones en tiempo real muy rápidas para todas las tareas de edición [2]. El esquema de la base de datos y las transacciones mencionadas anteriormente se crean de tal manera que todo se puede hacer dentro de un entorno multiusuario, como lo hace la tecnología de la base de datos. Como consecuencia, muchos de los logros (con respecto a la organización de datos y la consulta, la aplicación de la recuperación, la integridad y la seguridad, la operación múltiple, la gestión de distribución, el acceso a las herramientas uniformes, etc.) ahora, por medio de este enfoque, también están disponiblespara el procesamiento de textos.2. Enfoque nuestro sistema de edición y gestión generalizada se basa en el enfoque Tendax basado en la base de datos mencionado anteriormente, donde los datos de documentos se almacenan de forma nativa en la base de datos y admite la edición de texto colaborativa generalizada y la gestión de documentos. Definimos el sistema de edición y gestión de documentos generalizados, como un sistema, donde se puede acceder fácilmente a los documentos y manipularse en todas partes (dentro de la red), en cualquier momento (independientemente del número de usuarios que trabajan en el mismo documento) y con cualquier dispositivo (escritorio,cuaderno, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 dB 1 dB 2 AS 2 AS 4 dB 4 A B C D E F G Figura 1. Arquitectura de la aplicación Tendax En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario con la versión actualizada de un documento y los cambios realizados en el documento se almacenan persistentemente en la base de datos e inmediatamentepropagado a todos los clientes que trabajan en el mismo documento. Además, los meta datos recopilados durante todo el proceso de creación de documentos permiten una gestión sofisticada de documentos. Con la API de texto SQL como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema se basa en los siguientes componentes (ver Figura 1): un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de palabras bien conocida como OpenOffice. La capa lógica de negocios representa la interfaz entre la base de datos y la aplicación de procesamiento de palabras. Consiste en los siguientes tres componentes: el servidor de aplicaciones (marcado como 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, la seguridad, la gestión de documentos, etc., todo dentro de una colaboración en tiempo real y en tiempo realy entorno múltiple. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de la información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los meta datos relacionados dentro de las bases de datos de la base de datos se pueden distribuir en una red de igual a igual (DB 1-4 en la Figura 1). A continuación, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite la gestión sofisticada de documentos sobre la base de meta datos.2.1 Arquitectura de aplicaciones Un editor colaborativo en tiempo real basado en la base de datos permite abrir y editar el mismo documento simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras que se están abriendo múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de manera persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento.2.1.1 Esquema de la base de datos como se mencionó anteriormente que el texto se almacena de manera nativa. Cada personaje de un documento de texto se almacena como un solo objeto en la base de datos [3]. Al almacenar texto en una forma tan nativa, el rendimiento del sistema de base de datos empleado es de crucial importancia. Los problemas de concepto y rendimiento de dicha base de datos de texto se describen en [3], diseña colaborativa en [2], procesos comerciales de colaboración dinámica dentro de los documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relacióna bases de datos XML en [7]. La Figura 2 muestra el esquema de la base de datos central. Al conectar un cliente a la base de datos, se crea una instancia de sesión. Un atributo importante de la sesión es el documento. Este atributo se refiere a las instancias de documentos, que administra todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. El Documentsession es importante para el componente del servidor en tiempo real, que, en el caso de un 42, es antes que después de que Char (ID) tiene TextElement (ID) con el que se utiliza el archivo interno (ID).IR CaracterValue (Unicode) tiene List (ID) inicio de inicio con los extremos con los fines con filesse ha usador (id) Última lectura por último escrito por creado por creado por style dtd (id) usa usos usos es utilizado por los autores en su descripción de contraseña imagenUserColors UserListSeCurity ha tiene ha hecho que tiene referencias de FileNode (ID)/ISREFERENEDY es dinámica dinámica Dynstructure NodeDetails ha es es NodeType es padre de HA de que el matriz tiene un rol (id) creado por el nombre por nombre ha descripción descripción de usuarId) ha es accessmatrix opción de lectura de lectura de la opción de escritura contiene los tiempos de acceso que se abren ... tiempos con ... por contenido/ispartof ir ir es ... e incluye el linaje (id) referencias después de que las referencias de CopyPaste (ID) se encuentran en la copia dees una copia de HasCopyPaste (ID) IS ActiveLength ha str (stream) ha insertado / insertado regularchar startchar el archivo endchar externalfile es desde el tipo de url (extensión) es de título que el título tiene documentos (ID) se abre ha abierto la sesión ha abierto (ID (ID) ISCONNECTADO con el lanzado por VersionNumber usa ha lectura opción de lectura La opción Gran Opción de escritura termina con IN IN IN IS es un único dtd (stream) ha name la columna (id) se ha establecido encendido/apagadoMarcado de perfil de nombre (ID) tiene un padre interno es copia de HasRank IS Onposition comienza con los extremos con el estilo lógico que está detallado es que la cursiva es enumerada es subrayado es parte del tamaño de alineación de la alineación que ha font ha que hascolor is bold ha usado elementname stylesheetname se usa por el proceso (ID) está en ejecución por el sistema operativo que los roles de la sesión de la sesión web tienen los roles de la marca de tiempo de tiempo (fecha, hora) creada en la marca de tiempo de tiempo (fecha, hora) TimeStamp (fecha, hora) marca de tiempo de tiempo (fecha, hora) Timestamp (fecha, hora) creado en el tipo tiene puertoIP tiene MessagePropagator (ID) Imagen (transmisión) Imagen de nombre (ID) Contiene LayoutBlock WorkflowBlockLogicalBlock Contiene BlockDatatype tiene Propiedad BlockData es de Workflowinstance (ID) ISIN TaskInstance (ID) tiene marca de tiempo principal (fecha, hora) (fecha, hora, hora))TimeStamp (fecha, hora) TimeStamp (fecha, hora) Modificada por última vez en ComeTe At AT creado AT está en el nombre creado por ha adjunto el tipo de comentario adjunto de marca de tiempo de tiempo (fecha, hora) marca de tiempo de tiempo (fecha, hora) marca de tiempo (fecha, hora)creado en el inicio en << Último modificado en la categoría Los editores de la categoría tienen estado tienen marca de tiempo (fecha, hora) << Estado de la última marca de tiempo modificada (fecha, hora) se debe en duetype que tiene una zona horaria tiene notas de horno de homicisas de nivel de seguridad (fecha, hora) <<se completa en la tarea de isfollowedby (Código) Descripción tiene referencias de sangría que hasbeenopenedat ... por timestamp redohistory es antes después de las referencias que ha caseón de inhase ha compensado actionId (código) marca de tiempo (fecha, hora) invocada en invocado por la versión (id) isbuild from deha creado byarchived ha comment timeStamp (fecha, hora) << creatingat undohistory (id) inicia los extremos ha creado por el nombre que ha anterior es después de << referencias Charcounter que ha creado en Timestamp is Active creado por el desplazamiento ha creado que ha creado el desplazamiento ha creado.En el índice de marca de tiempo de tiempo (ID) LastModifiedby Léxico (ID) ISOF La frecuencia se produce la frecuencia de detener el término de la palabra está en los fines con los comienzos con << comienzos originales con WordNumber SentenceNumber Párraphnumber Citatons ha en IS IS IS en IStemporán<< Describe SpiderBuild (ID) se actualiza se elimina la marca de tiempo de tiempo (fecha, hora) << LastUpdatedat ha validado estructura << necesaria Tiempo de Index (MS) IndexUpdate NextUpdatein ha indicado isRunningbyos LastUpdate habilitado TimeStamp Time (S) Documentos StopCharChrooración parar es párrafo name de parada es es opciones de opciones. Mostrar información Mostrar excepciones de advertencia de advertencia Do Lineage Grabación Do Grabación de linaje interno Solicitar Fuente desconocida Show Intra Intra Información La información de linaje se establece para X X X VirtualBorder (ID) ISONHAS {1, 2}} {1, 2}IR IR usermode (código) usermode (código) Figura 2. El esquema de la base de datos de Tendax (diagrama de modelado de roles de objeto) cambia en un documento realizado por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El documento en la clase Documentsession apunta a una instancia de FileNode y corresponde a la ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a el de un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un personaje se almacena en el Valor de caracteres del atributo. La secuencia se define por los atributos después y antes de la clase Char. Instancias particulares de Char Marcan el principio y el final de un documento. Los métodos InsertChars y Removechars se utilizan para agregar y eliminar caracteres.2.1.2 Editor Como se ve anteriormente, cada documento se almacena de forma nativa en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativa en el sentido de réplicas de la base de datos. En cambio, tiene una llamada imagen como su réplica. Incluso si varios autores editan el mismo texto al mismo tiempo, funcionan en un documento único en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, sacar la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y en cuarto lugar, informando a todos los demás clientes sobre los cambios.2.1.3 Componente del servidor en tiempo real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que trabajan o han abierto el mismo documento. Cuando un editor se conecta al servidor de aplicaciones, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si ya no hay una conexión). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión del editor (sesión), que el componente del servidor en tiempo real administra en su SessionManager. Luego, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos del cliente en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena persistentemente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez, envía los cambios a todos los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. Protocolo de actualización El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, que envía los mensajes a los editores afectados. El protocolo de actualización consta de diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se pasa a los editores y contiene la información de actualización, como se muestra en la Figura 3. ||RTSC ||Parámetro |… |Parámetro ||||Datos del editor ||Protocolo entre el sistema de bases de datos y el protocolo de componentes del servidor en tiempo real entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de actualización A continuación, se presentan dos tipos de mensajes: || u | sessionID, ..., sessionID |||| Datos del editor ||U: Actualizar mensaje, SessionID: ID de la sesión del cliente con este mensaje Tipo de componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de SessionID.|| UD | FileID |||| Datos del editor ||UD: Actualizar mensaje del documento, fileid: ID del archivo con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que han abierto el documento con el ID de archivo indicado. Modelo de clase La Figura 4 muestra el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente en el editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente del servidor en tiempo real puede conectarse. ConnectionListener: esta clase es responsable de la conexión con los clientes, es decir, a la base de datos y a los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de editorworker o una instancia de trabajo de datos de datos respectivamente. Editorworker: esta clase administra las conexiones de tipo editor. La conexión (un socket y su secuencia de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, p.Los sockets del editor, qué editor ha abierto qué documento, etc. se almacenan dentro de esta estructura de datos. DataBAsEmessageWorker: esta clase es responsable de las conexiones de la base de datos de tipo. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, enviado a los clientes correspondientes. ServiceClass: esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes.tdb.mp.editor tdb.mp.database tdb.mp.mgmt editorworker databaseMessageWorker sessionsManager MessageHandler ConnectionListener ServiceClass Messagequeue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1 * 1 * editores datenbanksystem 1sthstem 1sstem 1sstem 1sstem 1sstem 1sstem 1 SEMSEM 1 SECTUSTEME 1 STAMEME 1 SECTUSTEME 1 SECCIÓN 1 *2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clase de componentes del servidor en tiempo real 2.1.4 Carpetas dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Como toda la información se almacena en la base de datos, un carácter puede tener una multitud de información, que luego puede usarse para la recuperación de documentos. Los meta datos se recopilan a nivel de caracteres, a partir de la estructura de documentos (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), en el nivel de una sección de documentos y en el nivel de todo el documento [6]. Todos los meta datos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de palabras. Este meta datos se puede utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios al bien conocido sistema de archivos jerárquicos. Esta es también la razón principal por la que no ignoramos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos se organizan según los meta datos, se denominarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas construyen subarres, que están guiados por los meta datos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe construirse. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de meta datos. El siguiente ejemplo ilustra los pasos que deben tomarse para definir una carpeta dinámica y los meta datos que deben usarse. Como primer paso, se deben elegir los meta datos que se utilizarán para la carpeta dinámica (ver Tabla 1): la secuencia de los meta datos influye en la estructura de la carpeta. Además, para cada meta datos utilizados, el usuario debe definir restricciones y granularidad;Si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en el número de subcarpetas que se creará para la división de los documentos.44 A medida que el usuario ingresa a la estructura del árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar a los documentos que está buscando. Los nombres de directorio indican qué meta datos determina el contenido del subcarpelo en cuestión. En cada nivel, se pueden inspeccionar los documentos, que hasta ahora coinciden con los meta datos. Tabla 1. Definición de las carpetas dinámicas (ejemplo) Restricciones de meta datos de nivel Granularidad 1 El creador solo muestra documentos que han sido creados por los usuarios Leona o Hodel o una carpeta una carpeta por Creador 2 Ubicación actual Solo muestra documentos que se leen en mi ubicación actual una carpeta por estado de tarea Estado de la tarea3 autores solo muestran documentos en los que al menos al 40% fue escrito por el usuario Leone cada 20% de una carpeta Los cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para un uso frecuente, p.Una carpeta basada en la ubicación, así como para crear y modificar carpetas dinámicas sobre una base ad-hoc. Además, el contenido de tales carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento.3. Validación La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones principalmente utilizadas en un sistema de edición (colaborativo). La inserción del carácter se basa en el algoritmo de inserción de Tendax que se describe formalmente a continuación. El algoritmo se simplifica para este propósito.3.1 Insertar Algoritmo de caracteres El símbolo C representa el carácter del objeto, P representa el carácter anterior, n representa el siguiente carácter de un objeto de caracteres C y el símbolo L representa una lista de objetos de caracteres.c = carácter p = carácter anterior n = siguiente carácter l = lista de caracteres El símbolo C1 representa el primer carácter de la lista L, CI significa un carácter en la lista L en la posición I, mientras que I es un valor entre 1y la longitud de la lista L y CN representa el último carácter de la lista l.c1 = primer carácter en la lista l Ci = carácter en la posición I en la lista l Cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el comienzo de un documento y ε representa el carácter especial que marca el final deun documento.β = comienzo del documento ε = final del documento La función Startta inicia una transacción.startTA = transacción de inicio El comités de funciones comete una transacción que se inició.ComitA = Conjunto de la transacción La función verificaciones de checkwriteAccess si se otorga el acceso de escritura para una sesión de documentos.CheckwriteAccess (s) = Verifique si se otorga acceso a la sesión de documentos para la sesión de documentos, el bloqueo de la función adquiere un bloqueo exclusivo para un carácter C y devuelve 1 para un éxito y 0 para no tener éxito.bloqueo (c) = adquirir el bloqueo para el carácter c éxito: return 1, sin éxito: return 0 La función releSeSelocks libera todos los bloqueos que una transacción ha adquirido hasta ahora.ReleasElocks = Release Todos los bloqueos La función getPrevious devuelve el personaje anterior y getNext Devuelve el siguiente carácter de un carácter c.getPrevious (c) = return CARÁCTER anterior del carácter c getNext (c) = return siguiente carácter de carácter c la función enlace antes de un carácter p anterior con un carácter siguiente X y la función linkafter enlaza un carácter n con un carácter anterior y.linkbefore (p, x) = link carácter p a carácter x linkafter (n, y) = link carácter n a carácter y la función actualización de la función un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el últimoCarácter CN de una lista de caracteres L UpdateTring (L, P, N) = LinkBefore (P Cl) ∧ Linkafter (N, CN) La función InsertChar inserta un carácter C de caracteres en la tabla Char con los campos después de establecer un carácter P y antesestablecido en un personaje n.insertchar (c, p, n) = linkafter (c, p) ∧ linkbefore (c, n) ∧ linkbefore (p, c) ∧ linkafter (n, c) La función de verificación de la función determina el valor de caracteres anterior de los caracteres de un carácter c e ifEl estado de los caracteres anteriores está activo.CheckPreceding (c) = Estado de retorno y Valor de caracteres del carácter anterior La función de verificación de la función determina el siguiente Value de caracteres de un carácter C y si el siguiente estado de caracteres está activo.45 CheckSuceding (C) = Estado de retorno y Value de caracteres del siguiente carácter La función checkarvalue determina el intervalor de un carácter c.CheckCharValue (c) = return CaracterValue del carácter C La función sendupdate envía un mensaje de actualización (actualización) desde la base de datos al componente del servidor en tiempo real.sendupdate (UpdateMessage) La función leída se usa en el componente del servidor en tiempo real para leer el UpdateMessage. Leer (UpdateInformationMessage) La función asigna verificaciones de los aturdidos en la base del UpdateMessage y el SessionManager, que los editores deben estar informados. AllockEditors (UpdateInformationMessage, SessionManager) = Devuelve los editores afectados La función sendMessage (editORDATA) envía la parte del editor del actualatorepresentado en la Figura 2. Los parámetros relevantes para las definiciones debajo, se introducen en la siguiente lista: - Next Characteride: OID del personaje situado junto a la cadena que se insertará - Caracterioides anteriores: OID de la característica situada anteriormente a la cadena para ser insertadas - Carpoortoides (Lista): Lista de carácter que deben insertarse así, la inserción de los caracteres se puede definir paso a paso de la siguiente manera: iniciar una transacción.Startta Seleccione el personaje que se encuentra antes del personaje que sigue la cadena a insertar.getPrevious (NextCharacteriCeroid) = prátelo (prolioides) ⇐ π después de ϑoid = nextCharacteriD (char)) adquiere el bloqueo para el carácter que se encuentra en el documento antes del carácter que sigue la cadena que se insertará.LOCK (PRIMCHARID) En este momento, los caracterales de la lista contienen los caracteres C1 a CN que se insertarán.COMPARAMOIDS = {C1, ..., CN} Cada carácter de la cadena se inserta en la posición apropiada vinculando el carácter anterior y siguiente. Para cada caracteres CI de caracterales: Insertchar (ci, p, n) mientras que ci ∈ {c1, ..., cn} verifique si los caracteres anteriores y seguidos están activos o si es el comienzo o el final del documento.checkPreceding (prprecaroide) = ISOK (IsActive, CaracterValue) ⇐ π Isactive, CaracterValue (ϑ oid = nextCharacterOd (char)) CheckSuceding (NextCharacteriD) = ISOK (IsActive, CaracterValue) ⇐ π Isactive, carácter, Value (ϑ ϑ ϑ ϑ ϑ - nextaracteracteriCeroid (char)))Actualice los caracteres antes y después de la cadena que se insertará.UpdateString (carmoides, carcoides, NextCharacterian) libera todas las bloqueos y transacciones de confirmación.El Comité del Comité de ReleaseLocks Envía información de actualización al componente del servidor en tiempo real Sendupdate (UpdateTenMessage) Leer el mensaje de actualización e informar a los editores afectados de la lectura de cambio (UpdateMessage) Asignar editores (UpdateMessage, SessionManager) SendMessage (EditionAdata) 3.2 Insertar caracteres Figura 1 Da una instantánea.El sistema, es decir, de su arquitectura: cuatro bases de datos se distribuyen a través de una red de igual a igual. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente del servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes del servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un personaje en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez, la pasa a la base de datos 1, donde se invoca una operación de inserción;Los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (de acuerdo con el protocolo de actualización discutido antes) al Componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran inmediatamente. Los conflictos de colaboración que ocurren se resuelven y describen en [3].4. Resumen Con el enfoque presentado en este documento y el prototipo implementado, ofrecemos edición y gestión de documentos colaborativos en tiempo real almacenados de manera especial en una base de datos. Con este enfoque, proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos edición y gestión de documentos generalizados. La edición y la gestión de documentos generalizados se habilitan debido a la arquitectura propuesta con el componente integrado del servidor de tiempo Real46 integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y administración de documentos está habilitado en consecuencia en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema de desorden anterior se implementa en un prototipo en ejecución. El sistema se probará pronto en línea con un taller de estudiantes el próximo otoño. Referencias [1] Abiteboul, S., Agrawal, R., et al.: La autoevaluación de la investigación de la base de datos Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Soporte de diseño colaborativo en el procesamiento de textos. IEEE International Conference on Cooperative Information Systems (Coopis), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno de procesos comerciales colaborativos para el procesamiento de documentos. Ingeniería de datos y conocimiento 52, Número especial: Tecnologías de procesos comerciales colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de sistemas de gestión de bases de datos para edición de texto colaborativo. Conferencia Europea de ACM de trabajo cooperativo compuprado (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H. y Dittrich, K. R.: Procesos comerciales colaborativos dinámicos dentro de los documentos. ACM Special Interest Group on Design of Communication (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de meta datos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería de Sistemas de Información Avanzada (Caise05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor de jabón integrado en el nivel del sistema operativo para AD-HOC REAL AD-HOC-Tiempo de comunicación bidireccional. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] Okelly, P.: Revolución en comunicación y colaboración en tiempo real: de verdad esta vez. Estrategias de aplicación: informe de investigación en profundidad. Burton Group, 2005. 47