Bullet: difusión de datos de ancho de banda alto utilizando una malla superpuesta Dejan Kosti´c, Adolfo Rodríguez, Jeannie Albrecht y Amin Vahdat ∗ Departamento de Informática Duke University {Dkostic, Razor, Albrecht, Vahdat}@cs.duke.edu Resumen en los últimos años en los últimos años en los últimos años., las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para un punto eficiente a la comunicación multipunta en Internet. Por lo general, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, uno que cumpla con los objetivos de rendimiento sin colocar una carga indebida en la red subyacente. En este documento, nos dirigimos a la distribución de datos de alto ancho de banda de una sola fuente a una gran cantidad de receptores. Las aplicaciones incluyen transferencias de gran archivo y transmisión multimedia en tiempo real. Para estas aplicaciones, argumentamos que una malla superpuesta, en lugar de un árbol, puede ofrecer un ancho de banda y confiabilidad fundamentalmente más altos en relación con las estructuras de árboles típicas. Este artículo presenta bala, un algoritmo escalable y distribuido que permite que los nodos se extiendan a través de Internet para autoorganizarse en una malla de alto ancho de banda. Construimos una bala alrededor de la idea de que los datos deben distribuirse de manera disjunta a puntos estratégicos en la red. Los receptores de bala individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las contribuciones clave de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de tal manera que cualquier objeto de datos es igualmente probable en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite que los nodos ubiquen y recuperen datos faltantesLos elementos, y iii) una implementación y evaluación completa de la bala que se ejecuta en Internet y en un entorno de emulación a gran escala revela hasta un factor de dos mejoras de ancho de banda en una variedad de circunstancias. Además, encontramos que, en relación con las soluciones basadas en árboles, la bala reduce la necesidad de realizar un costoso sondeo de ancho de banda. En un árbol, es fundamental que un padre nodos entregue una alta tasa de datos de aplicación a cada niño. Sin embargo, en Bullet, los nodos reciben datos simultáneamente de múltiples fuentes en paralelo, lo que hace que sea menos importante localizar cualquier fuente única capaz de mantener una alta tasa de transmisión. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: sistemas distribuidos;H.4.3 [Aplicaciones de sistemas de información]: Aplicaciones de comunicaciones Términos generales Experimentación, gestión, rendimiento 1. Introducción En este documento, consideramos el siguiente problema general. Dado un remitente y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye distribución de software o video y transmisión multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluidas la escala, la confiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Incluso si se abordaran todos estos problemas, la multidifusión IP no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora a la multidifusión para el punto de red de red a la entrega de datos multipunto. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento de multidifusión. Sin embargo, en la multidifusión de la capa de red, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento y extensibilidad limitadas. Las superposiciones, por otro lado, usan hosts finales programables (y por lo tanto extensibles) como nodos interiores en el árbol de superposición, con estos hosts actuando como repetidores para varios niños en el árbol. Las superposiciones han mostrado una gran promesa para aplicaciones de estilo multidifusión. Sin embargo, argumentamos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alto ancho de banda como para la alta confiabilidad. Una dificultad con los árboles es que se garantiza que el ancho de banda está disminuyendo monotónicamente moviendo por el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo del árbol. Se han propuesto varias técnicas para recuperarse de las pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol de superposición [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier anfitrión está limitado por el ancho de banda disponible de ese padre soltero en el árbol. Por lo tanto, nuestro trabajo opera con la premisa de que el modelo para la difusión de datos de multidifusión de ancho de banda debe reexaminar. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de la pérdida, proponemos que los participantes en una superposición de multidifusión cooperen estratégicamente a 282 conjuntos de datos de transmisión a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen en objetos individuales que a su vez se transmiten a diferentes puntos de la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar a los compañeros que contienen objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo hacer que la disponibilidad de elementos de datos se extienda de manera uniforme a todos los participantes superpuestos. De esta manera, evitamos el problema de localizar el último objeto, que solo puede estar disponible en unos pocos nodos. Una hipótesis de este trabajo es que, en relación con un árbol, este modelo dará como resultado una mayor apalancamiento de ancho de banda, el ancho de banda de las descargas paralelas simultáneas de múltiples fuentes en lugar de una sola de los datos de recuperación de la confiabilidad de los padres y mayores de múltiples compañeros reduce el daño potencial de daño potencial.de una sola falla de nodo. Para ilustrar el comportamiento de las balas, considere una simple superposición de tres nodos con una raíz R y dos niños A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto de datos disjunto a 1 Mbps a cada uno de A y B. A y B, cada uno descubriría de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzaría a transmitir datos entre sí, logrando efectivamente una tasa de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está restringido a la entrega como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debería consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su velocidad de transmisión. En segundo lugar, debe imponer un bajo control por encima. Existen muchas fuentes posibles de tales gastos generales, incluido el sondeo de ancho de banda disponible entre nodos, ubicando nodos apropiados para igual para la recuperación de datos y recibir redundantemente los mismos objetos de datos de múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. No se debe requerir ningún nodo para aprender o mantener el conocimiento global, por ejemplo, la membresía del grupo global o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto para las fallas individuales. Por ejemplo, la falla de un solo nodo debería dar como resultado una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes;Ninguna falla única debe dar lugar a la pérdida completa de datos para cualquier fracción significativa de nodos, como podría ser el caso de una falla de nodo única en un árbol de superposición de multidifusión. En este contexto, este documento presenta el diseño y la evaluación de la bala, un algoritmo para construir una malla superpuesta que intente mantener las propiedades anteriores. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo bala, comenzando con la raíz del árbol subyacente, transmite un conjunto de datos disjunto a cada uno de sus hijos, con el objetivo de mantener la representatividad uniforme de cada elemento de datos en todos los participantes. El nivel de desargitud está determinado por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir que los nodos ubiquen rápidamente múltiples pares capaces de transmitir elementos de datos faltantes al nodo. Por lo tanto, las capas de bala son una malla de alto ancho de banda sobre un árbol de superposición arbitraria. Dependiendo del tipo de datos que se transmiten, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, por ejemplo, los códigos de borrado [7, 26, 25] o la codificación de descripción múltiple (MDC) [17], para difundir los datos de manera eficiente, adaptarse al ancho de banda variable, y recuperarse de pérdidas. Finalmente, usamos TFRC [15] para transferir datos tanto por el árbol de superposición como entre los compañeros. Esto garantiza que toda la superposición se comporte de una manera amigable con la congestión, ajustando su velocidad de transmisión sobre una base por conexión basada en condiciones de red prevalecientes. Un beneficio importante de nuestro enfoque es que el ancho de banda entregado por la malla de bala es algo independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles superpuestos de alto ancho de banda es la sobrecarga asociada con el protocolo de construcción de árboles. En estos árboles, es fundamental que cada participante localice a un padre mediante sondeo con un alto nivel de ancho de banda disponible porque recibe datos de una sola fuente (su padre). Por lo tanto, incluso una vez que se construye el árbol, los nodos deben continuar su sondeo para adaptarse a las condiciones de red que cambian dinámicamente. Si bien el sondeo de ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para ganar confianza en los resultados. Nuestro enfoque con bala permite a los receptores obtener un alto ancho de banda en conjunto utilizando transferencias individuales de pares repartidos por el sistema. Por lo tanto, en la bala, el ancho de banda disponible de cualquier compañero individual es mucho menos importante que en cualquier árbol de elevación de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando para el ancho de banda se puede reasignar para transmitir datos a través de la malla de bala. Hemos completado un prototipo de bala que se ejecuta encima de una serie de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red de nodos emuladas de 20,000 muestra que Bullet puede entregar hasta el doble del ancho de banda de un árbol optimizado del ancho de banda (utilizando un algoritmo de la red global y la información de la topología de la red global).TCP amigable. También implementamos nuestro prototipo en el plano de la prueba de área de PlanetLab [31]. Para estas ejecuciones de Internet en vivo, encontramos que Bullet puede ofrecer mejoras de rendimiento de ancho de banda comparables. En ambos casos, la sobrecarga de mantener la malla de la bala y la ubicación de los datos disjuntos apropiados se limita a 30 kbps por nodo, aceptable para nuestros escenarios objetivo de alto nivel de ancho de banda a gran escala. El resto de este documento está organizado de la siguiente manera. La Sección 2 presenta componentes del sistema de balas que incluyen RANSUB, entrega de contenido informado y TFRC. La Sección 3 luego detalla Bullet, un sistema de distribución de datos eficiente para aplicaciones intensivas de ancho de banda. La Sección 4 evalúa el rendimiento de las balas para una variedad de topologías de red y la compara con las técnicas de multidifusión existentes. La Sección 5 coloca nuestro trabajo en el contexto de los esfuerzos relacionados y la Sección 6 presenta nuestras conclusiones.2. Componentes del sistema Nuestro enfoque para los centros de difusión de datos de alto ancho de banda alrededor de las técnicas representadas en la Figura 1. Primero, dividimos el flujo de datos de destino en bloques que se subdividen en objetos individuales (típicamente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden estar codificados [17, 26] para hacer que la recuperación de datos sea más eficiente. A continuación, difundimos a propósito objetos disjuntos 283 S A C Stream de datos originales: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC Para determinar BW D E 1 2 5 1 3 4 Figura 1: Alto nivelVista de la operación de balas.a diferentes clientes a un ritmo determinado por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en la ecuación para comunicarse entre todos los nodos en la superposición de una manera de congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se extienden a través del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Sin embargo, nuestro objetivo general es entregar más ancho de banda de lo que de otro modo estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene suficiente ancho de banda para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. La ubicación de pares remotos apropiados no puede requerir una comunicación global o global. Por lo tanto, proponemos la diseminación periódica de los subconjuntos de estado globales cambiantes, uniformemente aleatorios a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene boletos resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos de nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones con los objetivos de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado. En el resto de esta sección, proporcionamos breves antecedentes sobre cada una de las técnicas que empleamos como bloques de construcción fundamentales para nuestro trabajo. La Sección 3 presenta los detalles de toda la arquitectura de bala.2.1 Codificación de datos Dependiendo del tipo de datos que se distribuyen a través del sistema, varios esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si los datos multimedia se distribuyen a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de datos aún mantengan una secuencia multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no concentrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo umbral de paquetes, los receptores pueden decodificar el flujo de datos original. Por supuesto, Bullet es susceptible de una variedad de otros esquemas de codificación o incluso el esquema de codificación nula, donde el flujo de datos original se transmite mejor a través del sistema. En este documento, nos centramos en los beneficios de una clase especial de códigos de corrección de borrado utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundante [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren cualquier paquete (1+) K recibido correctamente para reconstruir los paquetes de datos K originales, con la sobrecarga de recepción típicamente baja () de 0.03 - 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como hayan llegado muchos paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados), y su tiempo de codificación es proporcional a n.Los códigos LT [25] eliminan estas dos limitaciones, al tiempo que mantienen una sobrecarga de recepción baja de 0.05.2.2 RANSUB Para abordar el desafío de localizar el contenido de disjunto dentro del sistema, utilizamos RANSUB [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes de estado global a todos los nodos de un árbol de superposición. Ransub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Varias de tales técnicas se describen en [1, 18, 21, 24, 34]. Ransub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopile mensajes comience en las hojas y propague el árbol, dejando el estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes Comience en la raíz y viaje por el árbol, utilizando la información que queda en los nodos durante la ronda de recopilación anterior para distribuir subconjuntos uniformemente aleatorios a todos los participantes. Usando los mensajes de recopilación y distribución, Ransub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior a la longitud de una época se determina por el momento en que se necesita para propagar datos y luego retroceder por el árbol, o aproximadamente el doble de la altura del árbol. Para los árboles construidos adecuadamente, la longitud mínima de la época crecerá con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, a sus hijos. El contenido del conjunto de distribución se construye utilizando el conjunto de recolección recopilado durante la fase de recolección anterior. Durante esta fase, cada participante envía un conjunto de recolección que consiste en un subconjunto aleatorio de sus nodos descendientes por el árbol a la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos de recolección y la fase de recolección se completa, la fase de distribución comienza nuevamente en una nueva época. Una de las características clave de Ransub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto de recolección propagado por un nodo a su padre sea al azar y uniformemente representativo de todos los miembros del sub-árbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. El 284 a csc = {cs}, csd = {ds} csf = {fs}, csg = {gs} csb = {bs, cs, ds}, cse = {es, fs, gs} b c e d gf b c a e d gf dse ={AS, BS, CS, DS} DSB = {as, ES, FS, GS} DSG = {AS, BS, CS, DS, ES, FS} DSD = {AS, BS, CS, ES, FS, GS}Dsf = {as, BS, CS, DS, ES, GS} DSC = {AS, BS, DS, ES, FS, GS} Figura 2: Este ejemplo muestra las dos fases del protocolo RANSUB que ocurren en una época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección viajan por la superposición a la raíz. La fase de distribución a la derecha muestra los conjuntos de distribución que viajan por la superposición a los nodos de la hoja.Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. Ransub ofrece varias formas de construir conjuntos de distribución. Para nuestro sistema, elegimos la opción Ransub-Nondescendents. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos que excluyen a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo antepasado en la mayoría de los casos. Un padre crea conjuntos de distribución de distribución de Ransub-Nondescendientes para cada niño compactando conjuntos de recolección de los hermanos de los niños y su propio conjunto de distribución. El resultado es un conjunto de distribución que contiene un subconjunto aleatorio que representa todos los nodos en el árbol, excepto los enraizados en ese niño en particular. Representamos un ejemplo de proceso de distribución de recolección RANSUBS en la Figura 2. En la figura, como significa nodo como estado.2.3 Técnicas de entrega de contenido informado Suponiendo que podemos permitir que un nodo localice un par con contenido disjunto con RANSUB, necesitamos un método para conciliar las diferencias en los datos. Además, requerimos un método de eficiencia de ancho de banda con baja sobrecarga computacional. Elegimos implementar las técnicas aproximadas de reconciliación propuestas en [6] para estas tareas en bala. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante algún período de tiempo. Necesitamos la capacidad de discernir rápidamente la semejanza entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación de grano fino es beneficiosa. Los boletos resumidos, o bocetos mínimos [5], cumplen este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una pequeña matriz de tamaño fijo. Cada entrada en esta matriz se mantiene mediante una función de permutación específica. El objetivo es tener cada entrada poblada por el elemento con el valor más pequeño permitido. Para insertar un nuevo elemento en el ticket de resumen, aplicamos las funciones de permutación en orden y actualizamos los valores de la matriz según corresponda. La función de permutación puede considerarse como una función hash especializada. La elección de las funciones de permutación es importante ya que la calidad del boleto de resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan una sobrecarga computacional baja, utilizamos funciones de permutación simples, como PJ (x) = (ax+b) mod | u |, donde u es el tamaño del universo (depende del esquema de codificación de datos). Para calcular la semejanza entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumidos que tienen el mismo valor y lo dividimos por el número total de entradas en los boletos de resumen. La Figura 3 muestra la forma en que se utilizan las funciones de permutación para poblar el boleto de resumen.12 10 2 27 7 2 18 19 40 1 Trabajo 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 22 28 45 61 14 51 PN ...construido desde el conjunto de trabajo. Para realizar una reconciliación aproximada de grano fino, un compañero A envía su resumen al compañero B y espera recibir paquetes no descritos en el resumen. Para este propósito, usamos un filtro de floración [4], una variedad de tamaño M con K con funciones hash asociadas independientes. Un elemento S del conjunto de claves recibidas s = {SO, S2 ,..., Sn - 1} se inserta en el filtro calculando los valores hash H0, H1 ,..., HK - 1 de S y configurando los bits en la matriz que corresponden a los valores hash 285. Para verificar si un elemento X está en el filtro Bloom, lo hash usando las funciones hash y verificamos si todas las posiciones en la matriz de bits están configuradas. Si al menos uno no está configurado, sabemos que el filtro Bloom no contiene x. Al usar filtros Bloom, la inserción de diferentes elementos puede causar todas las posiciones en la matriz de bits correspondientes a un elemento que no está en el conjunto como distinto de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que Peer B no envíe un paquete para mirar a, aunque A se le falta. Por otro lado, un nodo nunca enviará un paquete que se describe en el filtro Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un PF falso positivo en la consulta de membresía puede expresarse en función de la relación m n y el número de funciones hash k: pf = (1 - e - kn/m) k. Por lo tanto, podemos elegir el tamaño del filtro Bloom y el número de funciones hash que producirán una relación falsa positiva deseada.2.4 Control de tasa amigable para TCP Aunque la mayoría del tráfico en Internet hoy es mejor servido por TCP, aplicaciones que requieren una tasa de envío sin problemas y que tienen una mayor tolerancia a la pérdida a menudo encuentran la reacción de TCP a un solo paquete caído para ser innecesariamente severo. El control de tasa amigable para TCP, o TFRC, se dirige a aplicaciones multimedia de transmisión de unidifusión con la necesidad de respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP se reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquete. Alternativamente, TFRC es un protocolo de control de congestión basado en la ecuación que se basa en eventos de pérdida, que consisten en múltiples paquetes que se caen en un tiempo de viaje de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y usar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente estable y al mismo tiempo responder a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío de estado estacionario de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la velocidad de envío es: T = S R õ2P 3 +TRT O (3 õ3p 8) P (1 +32p2) Esta es la expresión para la tasa de envío t enBytes/Segundo, en función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida P, tamaño de paquete S en bytes y valor retransmisión de TCP trt O en segundos. Los remitentes y receptores de TFRC deben cooperar para lograr una velocidad de transmisión suave. El remitente es responsable de calcular la estimación de tiempo de ida y vuelta ponderada R entre el remitente y el receptor, así como para determinar un valor de tiempo de espera de retransmisión razonable TRT O. En la mayoría de los casos, el uso de la fórmula simple TRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida P informado por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que se recibe un paquete de retroalimentación del receptor. Hasta que se informa la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe comentarios al igual que TCP durante el inicio lento. El papel principal del receptor es enviar comentarios al remitente una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene una matriz de intervalo de pérdida que contiene valores para los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado en función de la suma de los valores de intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida informada, p.Al implementar Bullet, utilizamos una versión poco confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaron más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente un ancho de banda recién disponible como TCP, un rasgo deseable en un árbol de superposición donde podría haber múltiples flujos en competencia que comparten los mismos enlaces. Por ejemplo, si un nodo de hoja en el árbol intentaba buscar agresivamente un nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al usar TFRC pudimos evitar estos escenarios.3. Bullet Bullet es un sistema de distribución de datos eficiente para aplicaciones intensivas de ancho de banda. Mientras que muchos algoritmos de distribución de red de superposición actual usan un árbol de distribución para entregar datos de la raíz de los árboles a todos los demás nodos, las balas están una malla sobre un árbol de superposición original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe una corriente principal de su padre en el árbol y una cantidad de corrientes perpendiculares de pares elegidos en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede ofrecer un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RANSUB entregue subconjuntos aleatorios de los participantes que estén a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos que no están disponibles de ninguno de los nodos de pares y padres actuales. Si bien también usamos el árbol subyacente para la transmisión de línea de base, esto no es crítico para la capacidad de las balas para entregar eficientemente datos a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar además de cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado bala sobre árboles aleatorios y optimizados de ancho de banda creados o ﬄ ine (con conocimiento topológico global). Bullet se registra con el árbol de superposición subyacente para que esté informado cuando la superposición cambia a medida que los nodos van y vienen o hacen transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión, Bullet puede usar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC, ya que principalmente nos dirigimos a la transmisión de contenido de ancho de elevación y no requerimos una entrega confiable o en orden. Para simplificar, suponemos que los paquetes se originan en la raíz del árbol y están etiquetados con el aumento de los números de secuencia. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del niño y su posición relativa en el árbol.3.1 Encontrar los compañeros superpuestos Ransub periódicamente entrega subconjuntos de nodos seleccionados uniformemente aleatorios a cada participante en la superposición. Los receptores de bala usan estas listas para ubicar a sus pares remotos capaces de transmitir elementos de datos faltantes con buen ancho de banda. Los mensajes RANSUB contienen un conjunto de boletos de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. Ransub ofrece subconjuntos de estos boletos de resumen a los nodos cada época configurable (5 segundos de forma predeterminada). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta ahora, indexado por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de floración que mantiene un resumen de los paquetes recibidos hasta ahora. Dado que el filtro Bloom no excede un tamaño específico (M) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro Bloom al eliminar los números de secuencia más bajos de él. Esto nos permite evitar que la población de filtro de floración n crezca a un ritmo ilimitado. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito, dependiendo de la tasa de llegada del paquete. Del mismo modo, Bullet elimina los elementos más antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y boleto de resumen. Utilizamos las fases de recolección y distribución de Ransub para transportar boletos de resumen de bala arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño establecido de 10 boletos de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjuntos más grandes, esperamos que este parámetro sea sintonizable con las necesidades de aplicaciones específicas. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época, un nodo recibe una visión parcial resumida del estado de sistemas en ese momento. Al recibir un subconjunto aleatorio cada época, un nodo bala puede optar por mirar con el nodo que tiene la relación de similitud más baja en comparación con su propio boleto de resumen. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con rendimiento mediocre se eliminan de la lista actual del remitente como se describe en la Sección 3.4). Una vez que un nodo ha elegido el mejor nodo, lo envía una solicitud de emparejamiento que contiene el filtro de floración de nodos solicitantes. Tal solicitud es aceptada por el posible remitente si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío se rechaza (el espacio se crea periódicamente en las listas del receptor como se describe más adelante en la Sección 3.4).3.2 Recuperación de datos de pares Suponiendo que tiene espacio para el nuevo par, un destinatario de la solicitud de pares instala el filtro de floración recibido y transmitirá periódicamente claves que no están presentes en el filtro Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de floración instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro fresco, un nodo receptor también asignará una parte del espacio de secuencia a cada uno de sus remitentes. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando los recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus remitentes de manera uniforme. Como se ilustra en la Figura 4, un receptor de bala ve el espacio de datos como una matriz de secuencias de paquetes que contienen filas S, donde S es su número actual de pares de envío. Un receptor periódicamente (cada 5 segundos por defecto) actualiza cada remitente con su filtro de floración actual y el rango de secuencias cubiertas en su filtro Bloom. Esto identifica la gama de paquetes que el receptor está actualmente interesado en recuperarse. Con el tiempo, este rango cambia como se muestra en la Figura 4-B). Además, el nodo receptor asigna a cada remitente una fila desde la matriz, etiquetada con mod. Un remitente reenviará los paquetes a b) mod = 3 000000000000000000000000000000000000001111111111111111111111111111111111111 7 1 2 8 a) remitentes = 7mod = 2 Tiempo alto 000000000000000000000000000000000000001111111111111111111111111111: una figura de bullet de bullets al número de remitentes de paresActualmente tiene. Solicita datos dentro del rango (bajo, alto) de los números de secuencia en función de lo que ha recibido.a) El receptor solicita una fila específica en la matriz de secuencia de cada remitente.b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita diferentes filas de los remitentes.El receptor que tiene un número de secuencia X de tal manera que X Modulo S es igual al número de mod. De esta manera, los receptores se registran para recibir datos disjuntos de sus compañeros de envío. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que daría como resultado un ancho de banda desperdiciado. Sin embargo, se puede recibir un paquete duplicado cuando un padre recupera un paquete de uno de sus pares y transmite el paquete a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de servicio y puede haberlo recuperado de uno de sus compañeros. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable;Menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos.3.3 Hacer que los datos sean disjuntos ahora proporcionamos detalles de los mecanismos de balas para aumentar la facilidad por la cual los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos con la premisa de que el principal desafío para recuperar paquetes de datos perdidos transmitidos a través de un árbol de distribución de superposición radica en encontrar el nodo par de los datos para recuperar. Muchos sistemas adoptan un enfoque jerárquico de este problema, propagando solicitudes de reparación en el árbol de distribución hasta que se pueda cumplir la solicitud. En última instancia, esto conduce a problemas de escalabilidad en niveles más altos en la jerarquía, particularmente cuando los enlaces de superposición están en forma de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo antepasados, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden mediante el transporte de transmisión y/o la red. Los nodos intentan transmitir datos lo más rápido posible para cada niño y esencialmente no tienen control sobre qué partes del flujo de datos son eliminadas por el transporte o la red. Como resultado, el subsistema de transmisión no tiene control sobre cuántos nodos en el sistema finalmente recibirá una parte particular de los datos. Si pocos nodos reciben una gama particular de paquetes, la recuperación de estos datos se vuelve más difícil, requiriendo mayores costos de comunicación y conduciendo a problemas de escalabilidad. En contraste, los nodos de bala son conscientes del ancho de banda que se puede lograr para cada uno de sus hijos utilizando el transporte subyacente. Si 287, un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte de la corriente de datos se reenvía al niño restringido. Además, debido a que los nodos recuperan los datos de los participantes elegidos uniformemente al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable de aproximadamente el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegido al azar, es con la misma probabilidad de que cada nodo tenga un paquete de datos particular. Si bien no se ha probado explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de qué paquete se pierda. Con este fin, la bala distribuye paquetes entrantes entre uno o más niños con la esperanza de que el número esperado de nodos que reciban cada paquete sean aproximadamente el mismo. Un nodo P mantiene para cada niño, I, un factor limitante y de envío, LFI y SFI. Estos factores determinan la proporción de PS recibieron la tasa de datos que reenviará a cada niño. El factor de envío SFI es la parte de la corriente principal (tasa) que cada niño debe poseer en función del número de descendientes que tiene el niño. Cuantos más descendientes tenga un niño, mayor será la parte de los datos recibidos que debe poseer. El factor limitante LFI representa la proporción de la tasa principal más allá del factor de envío que cada niño puede manejar. Por ejemplo, un niño con un descendiente, pero el alto ancho de banda tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña porción de los datos recibidos, en realidad puede recibir una gran parte. Debido a que Ransub recopila descendientes conteos DI para cada niño I, Bullet simplemente hace una llamada a Ransub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño que sale de K en total, establecemos el factor de envío para que sea: SFI = Dièk J = 1 DJ. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los enchufes de transporte de datos de bala no son bloqueos;Las transmisiones exitosas son intentos de envío que son aceptados por el transporte sin bloqueo. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa de los recursos de red), el envío falla y se cuenta como un intento de envío sin éxito. Cuando un padre recibe un paquete de datos, calcula la proporción del flujo de datos total que se ha enviado a cada niño, hasta ahora, en esta época. Luego asigna la propiedad del paquete actual al niño que envíe una proporción más lejos de su SFI como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al niño. Si el envío no tiene éxito, el nodo debe encontrar un niño alternativo para ser dueño del paquete. Esto ocurre cuando un ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (SFI). Para compensar, el nodo intenta encontrar determinista un niño que pueda ser dueño del paquete (como lo demuestra su transporte que acepta el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda inadecuado. En el caso de que ningún niño pueda aceptar un paquete, debe eliminarse, correspondiente al caso en el que la suma de todos los anchos de banda de los niños es inadecuado para servir al niño recibido en niños {if ((infantil-> enviado / total_sent) <niño-> sending_factor) target_child = child;} if (! sendData (target_child-> addr, msg, size, key)) {// envíe a Target_child-> envíe ++;Target_child-> child_filter.insert (got_key);SENT_PACKET = 1;} niño foreach en niños {deber_send = 0;if (! Sent_packet) // transferir la propiedad debería_send = 1;else // prueba el ancho de banda disponible if (clave % (1.0/child-> limiting_factor) == 0) debería_send = 1;if (debería_send) {if (! sendData (child-> addr, msg, size, key)) {if (! Sent_packet) // Recibí la propiedad Child-> SED ++;el más aumento (child-> limiting_factor);Child-> Child_filter.insert (got_key);SENT_PACKET = 1;} else // enviar fallido if (sent_packet) // fue para bw adicional disminución (child-> limiting_factor);}} Figura 5: Código de pseudo para las balas Disjunto de datos Enviar la transmisión de rutina. Si bien hacen que los datos sean más difíciles de recuperar, Bullet aún permite la recuperación de dichos datos a sus hijos. El nodo de envío almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos recuperar potencialmente el paquete de uno de sus propios pares, a quien puede estar disponible un ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los demás niños dependiendo de los factores limitantes LFI. Para cada niño I, un nodo intenta reenviar el paquete de forma determinista si el módulo de secuencia de paquetes 1/LFI es cero. Esencialmente, esto identifica qué fracción LFI de los paquetes del flujo de datos recibido debe enviarse a cada niño para utilizar el ancho de banda disponible para cada uno. Si la transmisión de paquetes es exitosa, LFI aumenta de tal manera que se enviará un paquete más por época. Si la transmisión falla, LFI disminuye en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, esencialmente estamos utilizando comentarios de los niños (al observar el comportamiento de transporte) para determinar los mejores datos para dejar de enviar durante los momentos en que un niño no puede manejar toda la corriente principal. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir toda la transmisión matriz, cada niño recibirá un flujo de datos completamente disjunto de paquetes que posee. En el otro extremo, si cada 288 niños tiene un amplio ancho de banda, recibirá toda la transmisión matriz ya que cada LFI se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean desarticulados entre los niños con la premisa guía de que, tanto como sea posible, el número esperado de nodos que reciben un paquete es el mismo en todos los paquetes.3.4 Mejorar la bala de malla de bala permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de remitentes (cada uno de los valores predeterminados a 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de presas actuales sean subóptimas en un momento dado: i) La naturaleza probabilística de Ransub significa que un nodo puede no haber estado expuesto a un compañero suficientemente apropiado, ii) los receptores eligen con avidez y iii)Las condiciones de la red cambian constantemente. Por ejemplo, un nodo del remitente puede terminar no poder proporcionar un nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo periódicamente (cada pocas épocas Ransub) evalúa el rendimiento de ancho de banda que recibe de sus compañeros de envío. Un nodo dejará caer un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral se establece en 50% por defecto. Si no se encuentra dicho remitente derrochador, un nodo soltará el remitente que le entrega la menor cantidad de datos útiles. Reemplazará a este remitente con algún otro candidato de pares que envíe, esencialmente reservando una ranura de prueba en su lista de remitentes. De esta manera, estamos seguros de mantener a los mejores remitentes vistos hasta ahora y eliminaremos los remitentes cuyo rendimiento se deteriora con las condiciones de red cambiantes. Del mismo modo, un remitente de bala evaluará periódicamente a sus receptores. Cada receptor actualiza los remitentes del total de banda recibido. El remitente, sabiendo la cantidad de datos que ha enviado a cada receptor, puede determinar qué receptor se beneficia menos al mirar con este remitente. Esto corresponde a que el receptor que adquiere la menor parte de su ancho de banda a través de este remitente. El remitente deja caer este receptor, creando una ranura vacía para algún otro receptor de prueba. Esto es similar al concepto de destete presentado en [24].4. Evaluación Hemos evaluado el rendimiento de las balas en entornos de Internet reales, así como en el marco de emulación IP Modelnet [37]. Si bien la mayor parte de nuestros experimentos usan ModelNet, también informamos sobre nuestra experiencia con Bullet on the PlanetLab Internet Testbed [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales la bala puede ejecutar. Debido a que Bullet se desempeña bien sobre un árbol de superposición creado al azar, presentamos resultados con una bala que se extiende sobre un árbol de este tipo en comparación con un algoritmo de árbol de ancho de banda de cuello de botella de cuello de botella que utilizan información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura de desarrollo común llamada Macedonia [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite la reutilización de la mayoría de la funcionalidad común en estos sistemas distribuidos, incluidas las infraestructuras de sondeo, la gestión de hilos, el paso de mensajes y el entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran cualitativamente diferencias algorítmicas en lugar de complejidades de implementación. Nuestra implementación de la lógica de bala central está bajo 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 pentium4 de 2 GHz con Linux 2.4.20 e interconectados con 100 Mbps y 1 GBPS Ethernet Switches. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones de superposición en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de los emuladores responsables de emular con precisión el retraso de lúpulo por salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium III de 1.4GHz que ejecuta FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos stub de un grado en la topología. Seleccionamos aleatoriamente a uno de estos participantes para actuar como la fuente del flujo de datos. Los retrasos de propagación en la topología de la red se calculan en función de la colocación relativa de los nodos de red en el plano por INET. Basado en la clasificación en [8], clasificamos los enlaces de red como stub de clientes, stub-stub, transitStub y tranit-transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico estableciendo el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado desde el cual el ancho de banda se elige de manera uniforme al azar. Al cambiar estos rangos, variamos las limitaciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 kbps como se especifica en la Tabla 1. Si bien los resultados de ModelNet presentados están restringidos a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación en particular para nuestros experimentos. Más bien, suponemos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo.4.1 Árbol de ancho de banda de cuello de botella fuera de línea Uno de nuestros objetivos es determinar el rendimiento de las balas en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando bala en relación con el mejor árbol posible. Si bien aún no hemos demostrado esto, creemos que este problema es NP-Hard. Por lo tanto, en esta sección presentamos un algoritmo simple codicioso de ine para determinar la conectividad de un árbol que probablemente entrega un alto nivel de ancho de banda. En la práctica, no conocemos ningún algoritmo en línea escalable que pueda entregar el ancho de banda de un algoritmo de ine. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, haciéndolos menos resistentes a las fallas e inapropiados para las aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de bala tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a la falla, como se discutió en la Sección 4.6.289 Clasificación de topología CLIENTE-STUB-STUB-STUB-STUB Transit-Transit Low Bandwhidth 300-600 500-1000 1000-2000 2000-4000 ancho de banda medio 800-2800 1000-4000 1000-4000 5000-10000 Alto ancho de banda 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresadas en KBP. Específicamente, consideramos el siguiente problema: dado el conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que entregará el mayor ancho de banda a un conjunto de nodos superpuestos predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace del cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace máximo de cuello de botella. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo (OMBT) superpuesto. En un caso simplificado, suponiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando el sistema puede elegir la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-Hard [12], incluso en ausencia de pérdidas de enlace. A los fines de este documento, nuestro objetivo es determinar un buen árbol de transmisión de superposición que proporcione a cada participante superpuesto un ancho de banda sustancial, al tiempo que evita los vínculos superpuestos con altas tasas de pérdida de extremo a extremo. Hacemos los siguientes supuestos: 1. La ruta de enrutamiento entre dos participantes superpuestos es fija. Esto modela de cerca el modelo de red superpuesta existente con IP para el enrutamiento de unidifusión.2. El árbol de superposición utilizará conexiones de unidifusión amigables para TCP para transferir datos punto a punto.3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable para TCP utilizando una fórmula de estado estable [27].4. Cuando varios (n) flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar el rendimiento de la mayoría de C N, donde C es la capacidad física del enlace. Dadas estos supuestos, nos concentramos en estimar el rendimiento disponible entre dos participantes en la superposición. Comenzamos calculando el rendimiento utilizando la fórmula de estado estacionario. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a la vez. En cada enlace físico, calculamos la acción justa para cada uno de los flujos competitivos. El rendimiento de un enlace de superposición se aproxima al mínimo de las claras justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma participación del enlace del cuello de botella que otros flujos competitivos (es decir, su rendimiento podría estar limitado por las pérdidas en otras partes de la red), entonces los otros flujos podrían terminar con una mayor participación que la que calculamos. No contabilizamos esto, ya que el objetivo principal de esta estimación es simplemente evitar vínculos físicos con pérdida y muy congestionados. Más formalmente, definimos el problema de la siguiente manera: superposición del árbol máximo de cuello de botella (OMBT). Dada una red física representada como un gráfico G = (V, E), conjunto de participantes superpuestos P ⊂ V, Nodo de origen (S ∈ P), ancho de banda B: E → R+, tasa de pérdida L: E → [0, 1], retraso de propagación D: E → R+ de cada enlace, conjunto de posibles enlaces de superposición o = {(v, w) |v, w ∈ P, v = w}, tabla de enrutamiento rt: o × e → {0, 1}, encuentre el árbol de superposición t = {o |o ∈ O} (| t | = | p | - 1, ∀v ∈ P existe una ruta ov = s ❀ v) que maximiza min o | o∈T (min (f (o), min e | e∈o b (e) | {p | p ∈ T, e ∈ P} |)) donde f (o) es la tasa de envío de estado estacionario TCP, calculado a partir del tiempo de viaje redondo d (O) = èe∈O d (e)+ Èe∈O d (e) (dado el enlace de superposición o = (v, w), o = (w, v)) y la tasa de pérdida l (o) = 1 - ée∈O (1 - l (e)). Escribimos e ∈ O para expresar que el enlace E se incluye en la ruta de enrutamiento del sistema operativo (RT (O, E) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funciona bien [12]. Nuestro algoritmo es similar a la heurística de ruta más amplia (WPH) [12], y más generalmente al algoritmo MST Prims [32]. Durante su ejecución, mantenemos el conjunto de nodos que ya están en el árbol y el conjunto de nodos restantes. Para cultivar el árbol, consideramos todos los enlaces de superposición que conducen desde los nodos en el árbol hasta los nodos restantes. Elegimos con avidez el nodo con el enlace de superposición de rendimiento más alto. El uso de este enlace de superposición puede hacernos enrutar el tráfico a través de enlaces físicos atravesados por otros flujos de árboles. Dado que no reexaminamos el rendimiento de los nodos que ya están en el árbol, podrían terminar conectados al árbol con enlaces de superposición más lentos de lo que se estima inicialmente. Sin embargo, al conectar el nodo con el mayor ancho de banda residual en cada paso, esperamos disminuir los efectos del intercambio de enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte severamente la calidad del árbol.4.2 Bullet vs. transmisión Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a través de esta transmisión a medida que avanza el tiempo en el eje X. En este ejemplo, usamos TFRC para transmitir 600 kbps sobre nuestro árbol de ancho de banda de cuello de botella o un árbol aleatorio (otros árboles aleatorios exhiben un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos en cada carrera. Mientras que el árbol aleatorio ofrece un ancho de banda alcanzado de menos de 100 kbps, nuestra superposición de algoritmo O ﬄ ine ofrece aproximadamente 400 kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol superpuesto de ancho de banda en línea restringido en el grado exhibiría un comportamiento similar (o más bajo) a nuestro ancho de banda290 0 200 400 600 800 1000 0 50 100 100 150 200 250 300 350 400 anchura de banda (KBPS) Tiempo (S) de cubierta de botellaÁrbol Figura 6: El ancho de banda logrado con el tiempo para la transmisión de TFRC sobre el árbol de ancho de banda de cuello de botella y un árbol aleatorio.superposición optimizada. Por lo tanto, el objetivo de las balas es superar este límite de ancho de banda al permitir la recepción perpendicular de los datos y utilizando flujos de datos disjuntos en un intento de igualar o exceder el rendimiento de nuestro algoritmo O ﬄ ine. Para evaluar la capacidad de las balas para exceder el ancho de banda que se puede alcanzar a través de superposiciones de distribución de árboles, comparamos la bala que se ejecuta sobre un árbol de superposición aleatorio con el comportamiento de transmisión que se muestra en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado en total útil) con desviación estándar. El gráfico también traza la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y entorno de ancho de banda, Bullet pudo lograr un ancho de banda promedio de 500 kbps, los cinco tiempos logrados por el árbol aleatorio y más del 25% más alto que el algoritmo de ancho de banda de cuello de botella. Además, el ancho de banda total (incluidos los datos redundantes) recibidos por cada nodo es solo ligeramente más alto que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pequeños recursos de red. El uso de balas de TFRC en este ejemplo asegura que la superposición sea amigable para TCP en todo momento. La sobrecarga promedio de control por nodo es de aproximadamente 30 kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete trazado. Para este experimento, Bullet tiene una tensión de enlace promedio de aproximadamente 1.5 con un estrés de enlace máximo absoluto de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces de stub y stub-stub. Creemos que esto es consistente con el comportamiento real de Internet, donde los clientes tienen una conectividad de red ampliamente variable. Una porción de tiempo se muestra en la Figura 8 que traza el CDF de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben un ancho de banda inadecuado a pesar de que están limitados. La distribución aumenta bruscamente a partir de aproximadamente 500 kbps. La gran mayoría de los nodos reciben una corriente de 500-600 kbps. Hemos evaluado la bala bajo una serie de restricciones de ancho de banda para determinar cómo la bala se desempeña en relación con el 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 TIEMPO DE ENCURCIÓN DE BANDA (KBPS)7: logró el ancho de banda con el tiempo para la bala sobre un árbol aleatorio.0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Porcentaje de ancho de banda (KBPS) Figura 8: CDF del ancho de banda alcanzado instantáneo en el tiempo 430 segundos.Ancho de banda disponible de la topología subyacente. La Tabla 1 describe la configuración de ancho de banda representativa para nuestra tasa de transmisión de 600 kbps. La intención de estas configuraciones es mostrar un escenario en el que hay un ancho de banda más que suficiente para lograr una tasa objetivo incluso con la transmisión tradicional de árboles, un ejemplo de dónde no es un poco suficiente y uno en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda alcanzados para la bala y el árbol de ancho de banda de cuello de botella con el tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella por un factor de hasta 100%, dependiendo de cuánto ancho de banda esté limitado en la topología subyacente. En un extremo, tener más que amplio ancho de banda, bala y el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 kbps en nuestro ejemplo). En la otra topologías extremas y muy limitadas permiten que Bullet alcance el doble del ancho de banda que se puede lograr a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de balas están en algún punto intermedio. En nuestro ejemplo, la bala que se ejecuta sobre nuestra topología de ancho de banda mediana de las limitaciones es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, enfatizamos que creemos que sería 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Anwidth de banda (kbps) Bullet (s) Bullet - Alto de cuello de botella de ancho de banda - Bullet de ancho de banda medio - Árbol de cuello de cubierta de banda media - MedianaBullet de ancho de banda - Árbol de cuello de botella bajo ancho de banda - Ancho de banda bajo Figura 9: ancho de banda alcanzado para bala y árbol de cuello de botella con el tiempo para topologías de ancho de banda altas, medianas y bajas.Sea extremadamente difícil para cualquier algoritmo basado en árboles en línea para exceder el ancho de banda que se puede lograr con nuestro algoritmo de cuello de botella que utiliza información topológica global. Por ejemplo, construimos un simple ancho de banda que optimiza la construcción de árboles de superposición basada en nublado [21]. Los árboles de construcción dinámica resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo o ﬄ ine.4.3 Crear balas de datos disjuntos Capacidad para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño es limitado, la bala intenta enviar las porciones correctas de datos para que se facilite la recuperación de los datos perdidos. Un padre de bala envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos repartidos por su subárbol. Lo hace asignando la propiedad de los objetos de datos a los niños de una manera que hace que el número esperado de nodos que contengan un objeto de datos particular igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no discográfica en la que un nodo (y, lo que es más importante, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en enlaces infantiles individuales). Debido a que los niños transportan acelerando la tasa de envío en cada padre, algunos datos se envían inherentemente desarticulados (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a la bala del 25% de su capacidad de ancho de banda, en comparación con el caso en que nuestra estrategia de disjunto está habilitada en la Figura 7. 4.4 Enfoques epidémicos en esta sección, exploramos cómo Bullet se comparaA los enfoques de difusión de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismes, donde un nodo reenvía paquetes no duplicados a un número de nodos elegidos al azar en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a LPBCast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No difundimos los paquetes cada t Seconds;En cambio, los reenviamos tan pronto como llegan.0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (KBPS) Tiempo total en bruto Total útil del principal Figura 10: El ancho de banda alcanzado con el tiempo utilizando la transmisión de datos NondisJoint. También implementamos un enfoque de PBCast [2] para recuperar los datos que faltan de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayoría de sus datos de sus padres. Luego, los nodos intentan recuperar cualquier elemento de datos faltante a través del chismoso con compañeros aleatorios. En lugar de usar chismes con un número fijo de rondas para cada paquete, usamos anti-entropía con un filtro FIFO Bloom para intentar localizar a sus pares que mantienen cualquier elemento de datos que faltan localmente. Para que nuestra evaluación sea conservadora, suponemos que los nodos que emplean la recuperación de chismes y anti-entropía pueden mantener la membresía completa del grupo. Si bien esto podría ser difícil en la práctica, suponemos que Ransub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación contra la entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de floración, transporte TFRC, etc. Para reducir el número de paquetes duplicados, usamos menos pares en cada ronda (5) que la bala (10). Para nuestra configuración, encontramos experimentalmente que 5 pares da como resultado el mejor rendimiento con la sobrecarga más baja. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio alcanzado en todo el sistema. Para permitir el tiempo de TFRC suficiente para aumentar la tasa de envío apropiada para TCP, establecemos la longitud de la época para la recuperación contra la entropía en 20 segundos. Para estos experimentos, utilizamos una topología INET de nodo 5000 sin pérdidas explícitas de enlaces físicos. Establecimos ancho de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos al azar 100 participantes superpuestos. La raíz elegida al azar se transmite a 900 kbps (sobre un árbol aleatorio para bala y árbol de cuello de botella codicioso para la recuperación anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para chismes. La Figura 11 muestra el ancho de banda resultante con el tiempo logrado por la bala y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el cotilogening y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el útil ancho de banda proporcionado a cada nodo. Más importante aún, ambos enfoques asignan la misma importancia a otros pares, independientemente de la banda disponible292 0 500 1000 1500 2000 0 50 100 100 150 200 250 300 ancho de banda (kbps) Tiempo (s) Push Gossiping Streaming Raw Bullet Bullet Bullet Push Útil.Gossiping Streaming útil con AE Figura 11: El ancho de banda alcanzado con el tiempo para los enfoques de bala y epidemia.Ancho y la relación de similitud. Bullet, por otro lado, establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido de disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de cada nodos pares.4.5 Bullet En una red con pérdida para evaluar el rendimiento de las balas en condiciones de red más con pérdida, hemos modificado nuestras topologías de 20,000 nodos utilizadas en nuestros experimentos anteriores para incluir pérdidas de paquetes aleatorios. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de colas cuando la red está bajo carga debido al tráfico de red de fondo. Para efectuar este comportamiento, primero modificamos todos los enlaces no transits en cada topología para tener una tasa de pérdida de paquetes elegida uniformemente aleatoria de [0, 0.003] que resulta en una tasa de pérdida máxima de 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa de pérdida máxima de 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargadas y estableciendo sus tasas de pérdida uniformemente aleatorias de [0.05, 0.1], lo que resulta en una tasa de pérdida de paquete máxima del 10%. La Figura 12 muestra los anchos de banda alcanzados para transmitir sobre bala y usar nuestro codicioso árbol de ancho de banda de cuello de botella. Debido a que las pérdidas afectan negativamente el ancho de banda que se puede alcanzar sobre el transporte amigable con TCP y, dado que los anchos de banda están disminuyendo estrictamente monotónicamente sobre un árbol de transmisión, los algoritmos a base de árbol funcionan considerablemente peor que la bala cuando se usan en una red perdida. En todos los casos, Bullet ofrece al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de bajo ancho de banda esencialmente evitan que el árbol de ancho de banda de cuello de botella entregue cualquier dato, un artefacto que evita la bala.4.6 Rendimiento bajo falla En esta sección, discutimos el comportamiento de las balas frente a la falla del nodo. A diferencia de los árboles de distribución de la transmisión que deben detectar y hacer que las transformaciones de los árboles rápidamente superen la falla, la resiliencia de falla de las balas se basa en su capacidad para mantener un mayor nivel de ancho de banda logrado en virtud de la transmisión perpendicular (par). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán un 0 200 400 600 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (kbps) Tiempo (s) bala - bala de ancho de banda alto - ancho de banda mediano árbol de cuello de botella - altoÁrbol de cuello de botella de ancho de banda - bala de ancho de banda mediano - Árbol de cuello de botella de bajo ancho de banda - Ancho de banda bajo Figura 12: anchos de banda alcanzados para bala y árbol de ancho de banda de cuello de botella sobre una topología de red con pérdida.Disrupción En el servicio, los nodos de bala pueden compensar esto al recibir datos de pares durante todo el interrupción. Debido a que la bala y, lo que es más importante, Ransub utiliza una superposición de árbol subyacente, parte de las propiedades de recuperación de falla de balas dependerán del comportamiento de recuperación de fallas del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el peor de los casos en el que un árbol subyacente no tiene recuperación de falla. En nuestros experimentos de falla, fallamos en uno de los niños de raíces (con 110 del total de 1000 nodos como descendientes) 250 segundos después de que se inicia la transmisión de datos. Al reprobar a uno de los niños de Roots, podemos mostrar las balas en el peor rendimiento de los casos bajo una sola falla de nodo. En nuestro primer escenario, deshabilitamos la detección de fallas en RANSUB para que después de que ocurra una falla, los nodos de bala solicitan datos solo de sus pares actuales. Es decir, en este punto, Ransub deja de funcionar y no se crean nuevas relaciones entre pares para el resto de la carrera. La Figura 13 muestra balas logradas ancho de banda con el tiempo para este caso. Mientras que la tasa promedio alcanzada cae de 500 kbps a 350 kbps, la mayoría de los nodos (incluidos los descendientes del niño raíz fallido) pueden recuperar una gran parte de la velocidad de datos. A continuación, habilitamos la detección de falla RANSUB que reconoce una falla de nodos cuando una época Ransub ha durado más tiempo que el máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la próxima fase de distribución en el tiempo de espera de RANSUB. El resultado neto es que los nodos que no son descendientes del nodo fallido continuarán recibiendo subconjuntos aleatorios actualizados que les permiten igualar con nodos apropiados que reflejan las nuevas condiciones de red. Como se muestra en la Figura 14, la falla provoca una interrupción insignificante en el rendimiento. Con la detección de fallas RANSUB habilitada, los nodos se enteran rápidamente de otros nodos para recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido usan sus relaciones entre pares ya establecidas para compensar el fracaso de sus antepasados. Por lo tanto, debido a que Bullet es una malla superpuesta, sus características de confiabilidad exceden con creces las de los árboles de distribución de superposición típicos.4.7 PlanetLab Esta sección contiene resultados del despliegue de bala a través de la prueba de red de planeetLab [31] de área de amplio área. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (KBPS) Tiempo (s) de ancho de banda recibido Total útil de la Figura 13 Parente: El ancho de banda con el tiempo con una falla del nodo en el peor de los casos y sin recuperación de Ransub.0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (KBPS) Tiempo (s) Ancho de banda recibido Total útil de la Figura 14 principal: Ancho de banda con el tiempo con una falla del nodo peor y recuperación de Ransub habilitado.Nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que se implementen dos máquinas en el mismo sitio. Dado que actualmente hay un amplio ancho de banda disponible en toda la superposición de PlanetLab (una característica no necesariamente representativa de Internet en general), diseñamos este experimento para demostrar que la bala puede lograr un mayor ancho de banda que un árbol de superposición cuando la fuente está limitada, por ejemplo en los casos.de congestión en su enlace de acceso saliente, o de sobrecarga por un flash-crowd. Hicimos esto eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos fue en Italia (cs.unibo.it) y tuvimos otros 10 nodos superpuestos en Europa. Sin el conocimiento global de la topología en PlanetLab (e Internet), no podemos producir nuestro codicioso árbol de ancho de banda de cuello de botella para comparar. Ejecutamos bala sobre un árbol de superposición al azar durante 300 segundos mientras intentamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unan con éxito al árbol. Comparamos el rendimiento de la bala con la transmisión de datos sobre múltiples árboles artesanales. La Figura 15 muestra nuestros resultados para dos de estos árboles. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos la carga de ruta [20] para medir el 0 200 400 600 800 1000 1200 0 50 100 150 200 250 ancho de banda (kbps) tiempo (s) bala buena árbol peor árbol Figura 15: ancho de banda logrado con el tiempo para bala y tfrc transmitiendo sobre diferentes árbolesen Planetlab con una raíz en Europa.Ancho de banda disponible entre la raíz y todos los demás nodos. Los nodos con mediciones de alto ancho de banda se colocaron cerca de la raíz. En este caso, podemos lograr un ancho de banda de aproximadamente 300 kbps. El peor árbol se creó al establecer a los niños de los Roots para que fueran los tres nodos con las peores características de ancho de banda de la raíz medidas por la carga de ruta. Todos los niveles posteriores en el árbol se establecieron de esta manera. A modo de comparación, reemplazamos todos los nodos en Europa desde nuestra topología con nodos en los EE. UU., Crear una topología que solo incluía nodos de EE. UU. Con características de alto ancho de banda. Como se esperaba, Bullet pudo lograr la tasa completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de gran ancho de banda produjo ligeramente inferior a 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda restringidos.5. Trabajo relacionado Snoeren et al.[36] use una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos de la misión. En este sistema, cada nodo elige n padres para recibir corrientes de paquetes duplicados. Dado que su énfasis principal es la confiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes superpuestos enviando datos disjuntos a cada nivel. Además, durante la recuperación de la falla de los padres, limita una elección de enrutadores superpuestos de los padres a los nodos con un número de nivel que es menor que su propio número de nivel. El poder de las descargas perpendiculares es quizás mejor ilustrado por Kazaa [22], la popular red de intercambio de archivos de igual a igual. Los nodos de kazaa se organizan en una estructura jerárquica escalable. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios que descargan el mismo archivo consumirían más ancho de banda que los nodos organizados en la estructura de superposición de balas. Kazaa no usa la codificación de borrado;Por lo tanto, puede tomar un tiempo considerable localizar los últimos bytes.294 BitTorrent [3] es otro ejemplo de un sistema de distribución de archivos actualmente implementado en Internet. Utiliza rastreadores que dirigen descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución de todo el sistema del archivo. Bajar la tasa de comunicación del rastreador podría dañar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos a diferentes regiones de la red, lo que potencialmente hace que sea más difícil recuperar datos dependiendo de los patrones de acceso al cliente. Similar a Bullet, BitTorrent incorpora la noción de asfixia en cada nodo con el objetivo de identificar a los receptores que se benefician más al descargar de esa fuente en particular. FASTREPLICA [11] aborda el problema de la distribución de archivos confiable y eficiente en las redes de distribución de contenido (CDN). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (N), con información completa de membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo y les indica que descarguen las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo una parte fija del archivo se transmite a lo largo de cada uno de los enlaces de superposición, el impacto de la congestión es menor que en el caso de la distribución del árbol. Sin embargo, dado que trata todas las rutas por igual, Fastreplica no aprovecha al máximo los enlaces de superposición de ancho alto en el sistema. Dado que requiere la lógica de almacenamiento y delante de los archivos en cada nivel de la jerarquía necesaria para escalar el sistema, es posible que no sea aplicable a la transmisión de alto ancho de banda. Existen numerosos protocolos que tienen como objetivo agregar confiabilidad a la multidifusión IP. En multidifusión confiable escalable (SRM) [16], las solicitudes de retransmisión de multidifusión nodos para paquetes perdidos. Dos técnicas intentan mejorar la escalabilidad de este enfoque: elección probabilística de tiempos de retransmisión y la organización de receptores en grupos de recuperación locales jerárquicos. Sin embargo, es difícil encontrar los valores de temporizador apropiados y la configuración de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que SRM puede tener una sobrecarga significativa debido a las solicitudes de retransmisión. La bala está estrechamente relacionada con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de las pérdidas en el árbol de múltiples IP no dependiente. En PBCast [2], un nodo tiene membresía en el grupo global y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de sus paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes de una manera de última entrada. LBPCast [14] aborda los problemas de escalabilidad PBCasts (asociados con el conocimiento global) mediante la construcción, de manera descentralizada, una vista de membresía de grupo parcial en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que LBPCast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo Push-Gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos confiables de multidifusión, Bullet se comporta favorablemente en términos de sobrecarga de la red porque los nodos no solicitan reembolsos a ciegas de sus compañeros. En su lugar, Bullet utiliza las vistas de resumen que obtiene a través de RANSUB para guiar sus acciones hacia los nodos con contenido disjunto. Además, un nodo de bala divide la carga de retransmisión entre todos sus pares. Observamos que los nodos PBCast contienen un mecanismo para calificar paquetes retransmitidos por límite y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos sean desarticulados deliberadamente en todo el árbol. Narada [19] construye una malla optimizada de retraso interconectando todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de superposición. Luego ejecuta un protocolo de enrutamiento estándar en la parte superior de la malla superpuesta para construir árboles de reenvío utilizando cada nodo como una posible fuente. Los nodos de Narada mantienen el conocimiento global sobre todos los participantes del grupo, lo que limita la escalabilidad del sistema a varias decenas de nodos. Además, el ancho de banda disponible a través de un árbol Narada todavía está limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda a través de la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árboles superpuestos de ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodo que cualquier árbol, incluido el nublado. En lugar de un nodo que espera obtener los datos que se perdió de un nuevo padre, un nodo puede comenzar a obtener datos de sus pares perpendiculares. Esta transición es perfecta, ya que el nodo que está desconectado de su padre comenzará a exigir más paquetes faltantes de sus pares durante la ronda estándar de actualizar sus filtros. El tiempo de convergencia nublado está limitado por las sondas a hermanos y antepasados inmediatos. Bullet puede proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergente. Paralelamente a nuestro propio trabajo, Splitstream [9] también tiene el objetivo de lograr una alta difusión de datos de ancho de banda. Funciona dividiendo la corriente de multidifusión en rayas K, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido con escriba [34]. El objetivo clave de diseño del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en el máximo de un árbol (mientras observa las restricciones de ancho de banda de nodo entrantes y salientes), reduciendo así el impacto de un solo nodo de salida en el resto del resto del resto del resto desistema. El procedimiento de unión puede sacrificar potencialmente la disco-nodo interior alcanzada por el escriba. Quizás lo más importante, Splitstream supone que hay suficiente ancho de banda disponible para llevar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de rayas individuales elegidos independientemente por el escriba. Hasta cierto punto, Bullet y Splitstream son complementarios. Por ejemplo, Bullet podría ejecutarse en cada una de las rayas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. Coopnet [29] considera la transmisión de contenido en vivo en un entorno de pares de pares, sujeto a una gran rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodo aleatorio o determinista-disjo (similar a la vida dividida), e incluye un marco de adaptación MDC [17] basado en la retroalimentación del receptor escalable que intenta maximizar la relación señal / ruido percibida por los receptores. En el caso de la transmisión a pedido, Coopnet [30] aborda 295 el problema de Flash-Crowd en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que han recuperado previamente porciones del mismo contenido. En comparación con Coopnet, Bullet proporciona nodos con un subconjunto uniformemente aleatorio de la distribución de todo el sistema del archivo.6. Conclusiones típicamente, la transmisión de datos de superposición de ancho de banda de alto nivel tiene lugar sobre un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta puede entregar un ancho de banda fundamentalmente más alto. Por supuesto, se deben superar varios desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus compañeros. Este artículo presenta el diseño y la implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas de ancho de banda en relación con las estructuras de árboles tradicionales. Específicamente, este documento hace las siguientes contribuciones: • Presentamos el diseño y el análisis de la bala, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes superpuestos lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga requerida para investigar el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos.• Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RANSUB difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto cambiante y uniformemente aleatorio de participantes globales.• Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de una manera uniforme que haga la probabilidad de encontrar un compañero que contenga datos faltantes igual para todos los nodos.• Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de nodos emulado de 20,000, así como la experimentación en la parte superior de la prueba de prueba de Internet de PlanetLab, muestra que la bala que se ejecuta sobre un árbol aleatorio puede lograr el doble de la transmisión sobre un ancho de banda tradicionalárbol. Agradecimientos Nos gustaría agradecer a David Becker por su invaluable ayuda con nuestros experimentos de ModelNet y Ken Yocum por su ayuda con las optimizaciones de emulación ModelNet. Además, agradecemos a nuestra pastor Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios.7. Referencias [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multicast de capa de aplicación escalable. En Actas de ACM Sigcomm, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multicast bimodal. Transacción ACM en sistemas informáticos, 17 (2), mayo de 1999. [3] BitTorrent.http://bitconjurer.org/bittorrent.[4] Burton Bloom. Las compensaciones de espacio/tiempo en la codificación hash con errores permitidos. Comunicación de ACM, 13 (7): 422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de compresión y complejidad de secuencias (secuencias97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informado en redes de superposición adaptativa. En Actas de ACM Sigcomm, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En Sigcomm, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de topología de Internet. IEEE Communications Magazine, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alto ancho de banda en entornos cooperativos. En Actas del 19º Simposio ACM sobre principios del sistema operativo, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet representativas de nivel AS. En Actas de ACM Sigmetrics, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FASTREPLICA: distribución eficiente de archivos grandes dentro de las redes de entrega de contenido. En el 4to Simposio de Usenix sobre tecnologías y sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en unicast para transmitir multidifusión. En Infocom, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Aparecer en transacciones ACM en sistemas informáticos.[14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en la ecuación para aplicaciones de unidifusión. En Sigcomm 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de multidifusión confiable para sesiones de peso ligero y marco de nivel de aplicación. Transacciones IEEE/ACM en redes, 5 (6): 784-803, 1997. [17] Vivek K Goyal. Múltiple codificación de descripción: la compresión cumple con la red. IEEE Signal Processing Mag., Páginas 74-93, mayo de 2001. [18] Yang Hua Chu, Sanjay Rao y Hui Zhang. Un caso para la multidifusión del sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre medición y modelado de sistemas informáticos, junio de 2000. [19] Yang Hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión de superposición. En Actas de ACM Sigcomm, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de Sigcomm 2002, Nueva York, 19 al 23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jam. James W. Otoole. Nublado: multidifusión confiable con una red superpuesta. En Actas del diseño e implementación de sistemas operativos (OSDI), octubre de 2000. [22] Kazaa Media Desktop.http://www.kazaa.com.[23] Min Sik Kim, Simon S. Lam y Dong-Young Lee.296 Árbol de distribución óptimo para medios de transmisión de Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodríguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Uso de subconjuntos aleatorios para crear servicios de red escalables. En Actas del Simposio de Usenix sobre tecnologías y sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio IEEE anual sobre Fundamentos de la Informática, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos prácticos resistentes a la pérdida. En Actas del 29º Simposio ACM anual sobre la teoría de la computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para Maquinaria de Computación.[27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado de rendimiento TCP: un modelo simple y su validación empírica. En la Conferencia ACM Sigcomm 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en servidor de la pérdida de enlaces de Internet. En Actas del IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión resistente entre pares. En Actas del 11 ° ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios de transmisión utilizando redes cooperativas. En ACM/IEEE Nossdav, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM Hotnets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En Bell Systems Technical Journal, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. Macedón: Metodología para crear, evaluar y diseñar automáticamente redes superpuestos. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. Escribo: el diseño de una infraestructura de notificación de eventos a gran escala. En Third International Workshop en Networked Group Communication, noviembre de 2001. [35] Stefan Savage. Sting: una herramienta de medición de red basada en TCP. En Actas del segundo Simposio de Usenix sobre tecnologías y sistemas de Internet (USIT-99), páginas 71-80, Berkeley, CA, 11 al 14 de octubre de 1999. Asociación Usenix.[36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla usando XML. En Actas del 18º Simposio ACM sobre los principios de sistemas operativos (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre diseño e implementación de sistemas operativos (OSDI), diciembre de 2002. 297