Subastas de unidades múltiples a prueba de estrategia y manejo de estrategias Anshul Kothari ∗ David C. Parkes † Subhash Suri ∗ Abstract presentamos un mecanismo de subasta de aproximadamente eficiente y aproximadamente estreno para un problema de asignación múltiple de unidades múltiples. El lenguaje de licitación en nuestras subastas permite que las curvas constantes por partes de la toma de ley marginal. Primero, desarrollamos un esquema de aproximación en tiempo polinómico para el problema de asignación de unidades múltiples, que calcula una aproximación (1 +) en el peor tiempo de casos t = o (n3 /), dada n ofertas cada una con un número constante de piezas. En segundo lugar, incrusimos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a los agentes de N para un costo asintótico de O (T log n). La ganancia máxima posible de la manipulación a un postor en el esquema combinado está limitado por /(1+) V, donde V es el excedente total en el resultado eficiente. Categorías y descriptores de sujetos F.2 [Teoría de la computación]: Análisis de algoritmos y complejidad del problema;J.4 [Aplicaciones informáticas]: ciencias sociales y conductuales-economía. Algoritmos de Términos Generales, Economía.1. Introducción En este documento presentamos un esquema de aproximación en tiempo polinómico para el problema de subasta de unidades múltiples para una sola buena. Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias. La configuración de subasta considerada en nuestro artículo está motivada por tendencias recientes en el comercio electrónico;Por ejemplo, las corporaciones están utilizando cada vez más subastas para su abastecimiento estratégico. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de licitación compacto y expresivo que permita curvas constantes por partes de recurso marginal. En la subasta inversa, consideramos un solo comprador con una demanda de unidades M de un bien y a los proveedores de N, cada uno con una función de costo por partes por partes de la toma de partes marginal. Además, cada proveedor también puede expresar un límite superior o una restricción de capacidad en la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, proveedores de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta hacia adelante, consideramos un solo vendedor con unidades M de un bien y compradores N, cada uno con una función de valoración de pie-dependiente de las partes marginales. Un comprador también puede expresar un tamaño de lote límite o mínimo, en la cantidad de unidades que exige. Los modelos de variación hacia adelante, por ejemplo, una subasta para vender un exceso de inventario en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta múltiple. El mecanismo Vickrey-Clarke-Groves (VCG) tiene una serie de propiedades económicas interesantes en este entorno, incluida la a prueba de estrategias, de modo que la oferta veraz es una estrategia dominante para los compradores en la subasta a plazo y los vendedores en la subasta inversa y la eficiencia de asignación, talque el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG es limitada en la dirección inversa a los casos en que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe funcionar con una pérdida en estos casos, o no se puede esperar que el comprador elija voluntariamente participar. Este es un ejemplo del problema de déficit presupuestario que a menudo ocurre en un diseño de mecanismo eficiente [17]. El problema computacional es interesante, porque incluso con las curvas de oferta marginales, el problema de asignación subyacente resulta intratable (débilmente). Por ejemplo, la mochila clásica 0/1 es un caso especial de este problema.1 Modelamos el 1 Sin embargo, el problema puede resolverse fácilmente mediante un esquema codicioso si eliminamos todas las limitaciones de capacidad del vendedor y todos los 166 problemas de asignación como unGeneralización novedosa e interesante del problema clásico de la mochila, y desarrolle un esquema de aproximación totalmente polinómico, calculando una (1 +)-abroximación en el peor de los casos T = O (N3 /ε), donde cada oferta tiene un número fijo de constante por partes constantepiezas. Dado este esquema, un cálculo directo de los pagos de VCG a todos los agentes N requiere tiempo O (NT). Calculamos los pagos de VCG aproximados en el peor de los casos O (αT log (αN/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, suponga que C (i) es el costo mínimo para adquirir unidades M con todos los vendedores I, y C (i \ i) es el costo mínimo sin el vendedor i. Luego, la constante α se define como un límite superior para la relación c (i \ i)/c (i), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo de VCG aproximado es (ε 1 + ε) -Strategy-Probar para una aproximación dentro (1 +) de la asignación óptima. Esto significa que un postor puede ganar como máximo (ε 1+ε) V de una oferta no triphal, donde V es el excedente total de la asignación eficiente. Como tal, este es un ejemplo de un resultado de dominancia ε computacionalmente tractable.2 En la práctica, podemos tener buena confianza en que los postores sin buena información sobre las estrategias de licitación de otros participantes tendrán poco que ganar de los intentos de manipulación. La Sección 2 define formalmente las subastas hacia adelante e inversa, y define los mecanismos de VCG. También probamos nuestras afirmaciones sobre la prueba de estrategia ε. La Sección 3 proporciona la formulación de mochila generalizada para los problemas de asignación de unidades múltiples e introduce el esquema de aproximación de tiempo totalmente polinómico. La Sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye.1.1 Trabajo relacionado Ha habido un interés considerable en los últimos años en la caracterización de casos especiales de tiempo polinomial o aproximada del problema de asignación combinatoria general, en los que hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es compatible con NP e inapropiado (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje expresivo exclusivo de o licitación rompe rápidamente estos casos especiales. Identificamos un problema de asignación no trivial pero aproximado con un lenguaje de licitación de exclusivo expresivo: el tomador de ofertas en nuestro entorno puede aceptar como máximo un momento en la curva de oferta. La idea de usar aproximaciones dentro de los mecanismos, al tiempo que conserva la resistencia a la estrategia completa o la dominancia ε ha recibido alguna atención previa. Por ejemplo, Lehmann et al.[15] propone una aproximación codiciosa y a prueba de estrategias a un problema de subasta combinatorial resuelta. Nisan y Ronen [18] discutieron los mecanismos aproximados basados en VCG, pero apelaron a aproximaciones particulares de máximo en rango para retener la prueba completa de la estrategia, o a agentes limitados por recursos con información o limitaciones computacionales sobre la capacidad de calcular estrategias. Feigenminimum-lot restricciones de tamaño de los compradores.2 Sin embargo, este puede no ser un ejemplo de lo que Feigenbaum y Shenker se refieren como un mecanismo tolerablemente manipulable [8] porque no hemos tratado de vincular el efecto de tal manipulación en la eficiencia del resultado. Sin embargo, el mecanismo de VCG tiene una propiedad de autocorrección natural, porque una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación en función de los informes de otros agentes y el valor de los agentes.Baum y Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles y han propuesto el estudio de aproximaciones como una dirección importante para el diseño del mecanismo algorítmico. Schummer [21] y Parkes et al [19] han considerado previamente la dominancia ε, en el contexto de los resultados de imposibilidad económica, por ejemplo, en los intercambios combinatorios. Eso et al.[7] han estudiado un problema de adquisición similar, pero para un modelo de descuento de volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y ofrece algunos resultados empíricos sobre los datos simulados. Kalagnanam et al.[12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este documento también es diferente: investiga los precios de equilibrio utilizando las curvas de demanda y oferta, mientras que nuestro enfoque está en el diseño eficiente del mecanismo. Ausubel [1] ha propuesto una subasta de unidades múltiples de precio ascendente para compradores con valores de decreciente marginal [1], con una interpretación como un algoritmo primal-dual [2].2. Aproximadamente las subastas de VCG a prueba de estrategias En esta sección, primero describimos el lenguaje de licitación por partes de la toma marginal que se usa en nuestras subastas hacia adelante e inversa. Continuando, presentamos el mecanismo VCG para el problema y los resultados de dominancia ε para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos de VCG en estos entornos de unidades múltiples de subasta hacia adelante e inversa.2.1 Ofertas por partes de decisión marginal Proporcionamos un lenguaje de licitación por partes constantes y marginales. Este lenguaje de licitación es expresivo para una clase natural de valoración y funciones de costos: precios unitarios fijos durante intervalos de cantidades. Ver Figura 1 para un ejemplo. Además, relajamos ligeramente el requisito de decisión marginal para permitir: un postor en la subasta directa para establecer una cantidad mínima de compra, de modo que tiene un valor cero para cantidades menores que esa cantidad;Un vendedor en la subasta inversa para establecer una restricción de capacidad, de modo que tiene un costo efectivamente infinito para suministrar cantidades superiores a una cantidad particular. Oferta de subasta inversa 7 5 10 20 25 10 8 Precio de la cantidad 7 5 10 20 25 10 8 PRECIO DE CANTIDAD SUBASTA ATTRANJA BID Figura 1: Ofertas constantes de decisión marginal, por partes. En la oferta de subasta hacia adelante, el postor ofrece $ 10 por unidad por cantidad en el rango [5, 10), $ 8 por unidad en el rango [10, 20) y $ 7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la oferta de subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta directa, una oferta del comprador puedo ser escrita como una lista de tuplas (de rango de cantidad, precio de unidades), ((U1 I, P1 I), (U2 I, P2 I), .. .. ..., (umi - 1 i, pmi - 1 i)), con un umi i umi i superior en la cantidad. La interpretación es que la valoración de los licitantes en el rango de cantidad 167 (semi-abre) [UJ I, UJ+1 I) es PJ I para cada unidad. Además, se supone que la valoración es 0 para cantidades inferiores a U1 I, así como para cantidades más que um i. Esto se implementa agregando dos tuplas de oferta ficticia, con cero precios en el rango [0, U1 I) y (Umi I, ∞). Interpretamos la lista de ofertas como definir una función de precio, pbid, i (q) = qpj i, si uj i ≤ q <uj+1 i, donde j = 1, 2 ,..., mi −1. Para resolver la condición de límite, suponemos que el precio de oferta para la cantidad límite superior umi i es pbid, i (umi i) = umi i pmi - 1 i. Una oferta de vendedores se define de manera similar en la subasta inversa. La interpretación es que los postores cuestan en el rango de cantidad (semi-abierta) [UJ I, UJ+1 I) es PJ I para cada unidad. Además, se supone que el costo es ∞ para cantidades inferiores a U1 I, así como para cantidades más que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i) y (um i, ∞) son infinitos. Interpretamos la lista de ofertas como definir una función de precio, Pask, I (Q) = Qpj I, si UJ I ≤ Q <UJ+1 i.2.2 Subastas de unidades múltiples basadas en VCG Construimos las subastas múltiples manejables y aproximadamente estrategias en torno a un mecanismo VCG. Suponemos que todos los agentes tienen funciones cuasilíneas de utilidad;es decir, ui (q, p) = vi (q) - p, para un comprador i con valoración vi (q) para unidades Q al precio p, y ui (q, p) = p - ci (q) para unVendedor I con Costo CI (Q) al precio p.Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales por riesgo [13]. Usaremos el término recompensa indistintamente para la utilidad. En la subasta hacia adelante, hay un vendedor con unidades M para vender. Suponemos que este vendedor no tiene valor intrínseco para los artículos. Dado un conjunto de ofertas de los agentes I, vaya V (i) denotar los ingresos máximos al vendedor, dado que, como máximo, se puede seleccionar un punto de la curva de ofertas de cada agente y no se pueden vender más de las unidades M del artículo. Sea x ∗ = (x ∗ 1, ..., x ∗ n) denota la solución a este problema de determinación de ganador, donde x ∗ i es el número de unidades vendidas al agente i. Del mismo modo, deje que V (i \ i) denote los ingresos máximos al vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Reciba curvas de oferta y limitaciones de capacidad de todos los compradores.2. Implemente el resultado x ∗ que resuelva el problema de determinación del ganador con todos los compradores.3. Recolecte el pago pvcg, i = pbid, i (x ∗ i) - [v (i) - v (i \ i)] de cada comprador y pase los pagos al vendedor. En esta subasta hacia adelante, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que la licitación veraz es una estrategia dominante, es decir, la utilidad maximizando las ofertas de otros compradores. Además, el mecanismo VCG es asignalmente eficiente, y los pagos de cada comprador siempre son positivos.3 Además, cada comprador paga menos de su valor y recibe el pago V (i) −v (i \ i) en equilibrio;Este es precisamente el valor marginal que el comprador I contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con unidades M para comprar, y N proveedores. Suponemos que el Comprador tiene valor V> 0 para comprar todas las unidades M, pero de lo contrario el valor cero. Para simplificar el problema de diseño del mecanismo, suponemos que el comprador anunciará con sinceramente este valor al mecanismo.4 El ganador3 De hecho, el mecanismo de VCG maximiza el pago esperado al vendedor en todos los mecanismos eficientes, incluso permitiendo implementaciones bayesianas [14 14]4 Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite [17] ya implicaría que no deberíamos esperar un mecanismo comercial eficiente en este entorno.El problema de determinación en la subasta inversa es determinar la asignación, x ∗, que minimiza el costo para el comprador o pierde el comercio si el costo mínimo es mayor que el valor, v. Deje que C (i) denote el costo mínimo dado las ofertas de todos los vendedores, y Ca (i \ i) denote el costo mínimo sin ofertas del vendedor i. Podemos suponer, sin pérdida de generalidad, que hay un comercio eficiente y v ≥ c (i). De lo contrario, entonces el resultado eficiente no es comercio, y el resultado del mecanismo VCG no es comercio ni pagos. El mecanismo VCG implementa el resultado x ∗ que minimiza el costo según las ofertas de todos los vendedores, y luego proporciona pagos de PVCG, i = Pask, I (x ∗ i)+[v −c (i) −max (0, V −C(I \ i))] a cada vendedor. El pago total se recauda del comprador. Una vez más, en equilibrio cada pago de los vendedores es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema;En el caso simple de que v ≥ c (i \ i) para todos los vendedores I, esto es precisamente c (i \ i) - c (i). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad se limita a los casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elegirá participar voluntariamente en el mecanismo, en función de su propio valor y sus creencias sobre los costos de los vendedores. Esto lleva a una pérdida de eficiencia cuando el comprador elige no participar, porque se pierden operaciones eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo elemento, o incluso en subastas inversas de múltiples unidades con un comprador que tiene una valuación marginal constante para cada artículo adicional que adquiere.5 intuitivamente, elEl problema ocurre en la configuración inversa de unidades múltiples porque el comprador exige un número fijo de artículos y tiene un valor cero sin ellos. Esto lleva a la posibilidad de que el comercio sea dependiendo de la presencia de vendedores fundamentales particulares. Defina un vendedor I como fundamental, si c (i) ≤ v pero c (i \ i)> v. En palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor fundamental, los pagos de VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para mantener el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando la recompensa total a los vendedores, en equilibrio, excede el pago total de la asignación eficiente: V - C (i) ≥ I [V - C (I) - Máx (0, V - c (i \ i))] Como se indicó anteriormente, primero nota que requerimos v> c (i \ i) para todos los vendedores i. En otras palabras, no debe haber vendedores fundamentales. Dado esto, es necesario y suficiente que: v - c (i) ≥ I (c (i \ i) - c (i)) (1) 5 Para hacer que la subasta inversa simétrica con la dirección hacia adelante, necesitaríamosUn comprador con un valor marginal constante para comprar las primeras unidades M y un valor cero para unidades adicionales. Los pagos a los vendedores nunca excederían el valor de los compradores en este caso. Por el contrario, para hacer que la subasta de avance sea simétrica con la subasta inversa, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos que las primeras unidades M, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser menores que el costo de los vendedores por el resultado en este caso.168 En palabras, el excedente de la asignación eficiente debe ser mayor que el total marginal de marginal proporcionado por cada vendedor.6 Considere un ejemplo con 3 agentes {1, 2, 3} y V = 150 y C (123) = 50. La condición (1) se mantiene cuando C (12) = C (23) = 70 y C (13) = 100, pero no cuando C (12) = C (23) = 80 y C (13) = 100. En el primer caso, los pagos del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, es (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sí sabemos, porque el mecanismo VCG maximizará la recompensa al comprador en todos los mecanismos eficientes [14], es que cada vez que la ecuación.1 no está satisfecho, no puede haber un mecanismo de subasta eficiente.7 2.3 ε-resistencia-resistencia ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Derivamos un resultado de resistencia a la estrategia ε, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple de revelación de la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, deje que V (i) denote el valor de la solución óptima al problema de asignación con ofertas veraz de todos los agentes, y v (i \ i) denota el valor de la solución óptima calculada sin ofertas del agente i. Deje ˆv (i) y ˆv (i \ i) denotan el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación satisface: (1 +) ˆv (i) ≥ V (i) para algunos> 0. Proporcionamos dicho esquema de aproximación para nuestra configuración más adelante en el documento. Sea ˆx denota la asignación implementada por el esquema de aproximación. La recompensa al Agente I, para anunciar la valoración ˆVi, es: VI (ˆXi) + J = I ˆVJ (ˆXJ) - ˆV (i \ i) El término final es independiente del valor anunciado de los agentes y puede ignorarse en un incentivo-análisis. Sin embargo, el agente I puede tratar de mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente I quiere que el mecanismo seleccione ˆx para maximizar la suma de su valor verdadero, vi (ˆxi), y el valor informado de los otros agentes, èj = i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente debe hacer es establecer sinceramente su valor y el mecanismo hará el resto. Sin embargo, frente a un algoritmo de asignación aproximada, el agente puede tratar de mejorar su recompensa al anunciar un valor que corrige la aproximación, y hace que el algoritmo de aproximación implementa la asignación que maximiza exactamente el valor total informado de los otros agentes junto con suValor real propio [18].6 Esta condición es implícita por los agentes son requisitos de sustitutos [3], que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos de VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen los agentes son sustitutos, en términos de las valoraciones subyacentes de los agentes han demostrado ser bastante difíciles de alcanzar.7 Además, aunque existe una pequeña literatura sobre mecanismos de máxima eficiente sujeto a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo que no introduce ni elimina dinero), los resultados analíticos solo se conocen por problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación a un agente en nuestro entorno. Primero asumimos que los otros agentes son sinceros y luego relajan esto. En ambos casos, el beneficio máximo para el agente I ocurre cuando la aproximación inicial es el peor de los casos. Con informes veraces de otros agentes, esto ocurre cuando el valor de elección ˆx es V (i)/(1 + ε). Entonces, un agente podría esperar recibir una recompensa mejorada de: V (i) - V (i) 1 + ε = ε 1 + ε V (i) Esto es posible si el agente puede seleccionar un tipo informado para corregir elAlgoritmo de aproximación y hacer que el algoritmo implementa la asignación con el valor V (i). Por lo tanto, si otros agentes son sinceros, y con un esquema (1 + ε) -alprolación al problema de asignación, entonces ningún agente puede mejorar su recompensa en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son veraz. En este caso, un agente individual puede mejorar su recompensa por no más de un factor /(1 +) del valor de la solución óptima dados los valores reportados por los otros agentes. Deje que V en el siguiente teorema define el valor total de la asignación eficiente, dados los valores informados de los agentes J = I, y el verdadero valor del agente i.Teorema 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V) a prueba de estrategias para el agente I, y el agente que puedo obtener a lo sumo esta recompensa a través de alguna estrategia no húmeda. Observe que no necesitamos limitar el error de los problemas de asignación sin cada agente, porque el resultado de la resistencia a la extracción se deriva de la precisión del primer período en el pago de VCG y es independiente de la precisión del segundo período. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG.3. El problema de la mochila generalizada En esta sección, diseñamos un esquema de aproximación totalmente polinomial para la mochila generalizada, que modela el problema de Determinación ganadora para las subastas múltiples basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta a la oración. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad de anclaje) de una solución óptima de mochila. Utilizamos esta propiedad para desarrollar una O (N2) Tiempo 2-Apromentación para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación de tiempo polinómico (FPTA). Una de las principales apelaciones de nuestro lenguaje de licitación por partes es su representación compacta de las funciones de valoración de los licitantes. Nos esforzamos por preservar esto, y presentar un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en la configuración realista de la adquisición. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x ∗, en el peor tiempo de casos t = o (n3 /ε), donde n es el número de licitadores, y donde asumimos que la oferta por partes para cada postortiene o (1) piezas. La dependencia del número de piezas también es polinomio: si cada oferta tiene un máximo de 169 de piezas C, entonces el tiempo de ejecución se puede derivar sustituyendo NC por cada aparición de n.3.1 Preliminares Antes de comenzar, recordemos el problema clásico de mochila 0/1: se nos da un conjunto de N elementos, donde el elemento I tiene valor VI y tamaño SI, y una mochila de capacidad M;Todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con el tamaño total en la mayoría de M. Dado que queremos centrarnos en una subasta inversa, el problema de mochila equivalente será elegir un conjunto de elementos con un valor mínimo (es decir, costo) cuyo tamañoexcede M. El problema de interés generalizado de la mochila para nosotros se puede definir de la siguiente manera: mochila generalizada: instancia: un objetivo m y un conjunto de n listas, donde la lista de i -ésimo tiene la forma bi = (u1 i, p1 i),..., (umi - 1 i, pmi - 1 i), (umi i (i), ∞), donde uj i están aumentando con j y pj i están disminuyendo con j, y uj i, pj i, m son enteros positivos. Problema: Determine un conjunto de enteros xj i tal que 1. (uno por lista) como máximo uno XJ I no es cero para cualquiera i, 2. (membresía) xj i = 0 implica xj i ∈ [UJ I, UJ+1 i), 3. (objetivo) èi èj xj i ≥ m, y 4. (objetivo) èi èj pj i xj i está minimizado. Esta formulación de mochila generalizada es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un solo punto (Si, VI) .8 La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, que representa múltiples intervalos de cantidad mutuamente excluyentes, y uno puede elegir cualquier cantidad en un intervalo, pero a lo sumo se puede seleccionar un intervalo. Elegir el intervalo [UJ I, UJ+1 I) ha costado PJ I por unidad. El objetivo es adquirir al menos las unidades M del bien a un costo mínimo posible. El problema tiene algún sabor del problema continuo de la mochila. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, y así elegir el intervalo [UJ I, UJ+1 I) requiere que al menos UJ I y en la mayoría de las unidades UJ+1 Idebe ser tomada;(2) A diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen diferentes costos unitarios.3.2 Un esquema de 2-accesorios comenzamos con una definición. Dada una instancia de la mochila generalizada, llamamos a cada tuple tj i = (uj i, pj i) un ancla. Recuerde que estas tuplas representan los puntos de interrupción en las ofertas de curva constante por partes. Decimos que el tamaño de un ancla TJ I es UJ I, 8 de hecho, debido a la única restricción por lista, el problema generalizado es más cercano en espíritu al problema de mochila de opción múltiple [9], donde el conjunto subyacente de elementos estádividido en subconjuntos disjuntos u1, u2 ,..., Reino Unido, y uno puede elegir como máximo un elemento de cada subconjunto. Los PTA existen para este problema [10], y de hecho, uno puede convertir nuestro problema en una gran instancia del problema de mochila múltiple, creando un grupo para cada lista;Ponga una tupla de punto (de precio, precio) (x, p) para cada posible cantidad para un postor en su grupo (subconjunto). Sin embargo, esta conversión explota el tamaño del problema, por lo que no es posible para todas las instancias, excepto las más triviales.El número mínimo de unidades disponibles a este precio de anclaje PJ i. El costo del ancla tj I se define como el precio total mínimo asociado con esta tupla, a saber, costo (tj i) = pj i uj i si j <mi y costo (tmi i) = pmi - 1 i umi i i i. En una solución factible {x1, x2 ,..., xn} de la mochila generalizada, decimos que un elemento xi = 0 es un ancla si xi = uJ I, para algún ancla uj i. De lo contrario, decimos que Xi es de rango medio. Observamos que siempre se puede construir una solución óptima de mochila para que, como máximo, un elemento de solución sea de rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y disminución x, hasta que uno de ellos se convierta en un ancla. Ver Figura 2 para un ejemplo. Lema 1. [Propiedad de anclaje] Existe una solución óptima del problema de la mochila generalizada con como máximo un elemento de rango medio. Todos los demás elementos son anclajes.1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Cantidad de precio 5 20 15 10 15 5 25 30201510 35 3 2 1 Cantidad de precio (i) Solución óptima con 2 ofertas de rango medio (ii) Soltución óptima con la Figura 2: ((((i) una solución óptima con más de una oferta no anclada (2,3);(ii) Una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad de anclaje para obtener primero un esquema de enfoques de 2 veces en tiempo polinomial. Hacemos esto resolviendo varias instancias de un problema restringido de la cola generalizada, que llamamos Iknapsack, donde un elemento se ve obligado a ser de rango medio para un intervalo particular. Específicamente, suponga que el elemento X para el agente L se ve obligado a mentir en su rango JTH, [UJ, UJ+1), mientras que todos los demás elementos, x1 ,..., xl - 1, xl+1, xn, deben ser anclajes o cero. Esto corresponde al problema restringido iknapsack (, j), en el que el objetivo es obtener al menos unidades M - UJ con un costo mínimo. Se supone que el elemento x ya ha contribuido con unidades UJ. El valor de una solución a iKnapsack (, j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos N - 1 grupos de anclajes potenciales, donde el grupo I -Ith contiene todos los anclajes de la lista I en la mochila generalizada. El grupo para el Agente L contiene un elemento único que representa el intervalo [0, UJ+1 −UJ) y el PJ de precio de la unidad asociado. Este intervalo representa el número excesivo de unidades que se pueden tomar del Agente L en Iknapsack (, J), además de UJ, que ya se ha cometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudo-código describe nuestro algoritmo para esta restricción del problema de mochila generalizada. U es la unión de todas las tuplas en n grupos, incluida una tuple t para el agente l.El tamaño de esta tupla especial se define como UJ+1 - UJ, y el costo se define como PJ L (UJ+1 −UJ). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la solución tentativa 170 actual. Lo mejor es la mejor solución que se encuentra hasta ahora. Skip variable solo se usa en la prueba de corrección. Algoritmo codicioso (, j) 1. Ordena todas las tuplas de u en el orden ascendente del precio unitario;En caso de lazos, ordene en orden ascendente de cantidades unitarias.2. Establecer Mark (i) = 0, para todas las listas i = 1, 2 ,..., n.Inicializar r = m - UJ, s = best = skip = ∅.3. Escanee las tuplas en U en el orden ordenado. Supongamos que la siguiente tupla es TK I, es decir, el ancla de KTH del agente i. Si Mark (i) = 1, ignora esta tupla;de lo contrario, haga los siguientes pasos: • Si tamaño (tk i)> r e i = return min {cost (s) + rpj, costo (mejor)};• Si el tamaño (tk i)> r y costo (tk i) ≤ costos (s) retorno min {costo (s) + costo (tk i), costo (mejor)};• Si el tamaño (tk i)> r y el costo (tk i)> costos (s) agregue tk i para omitir;Establecer mejor a S ∪ {tk i} si el costo mejora;• Si el tamaño (tk i) ≤ r, entonces agregue tk i a s;marca (i) = 1;Tamaño de resta (TK I) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila. Como deseamos minimizar el costo total, consideramos las tuplas en orden de aumento por costo unitario. Si el tamaño de Tuple Tk I es más pequeño que R, entonces lo agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que TK I. Si el tamaño (TK I) es mayor que R, entonces S junto con TK I forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de TK I es mucho mayor que R. Si el costo total de S y TK I es más pequeño que la mejor solución actual, actualizamos mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla se puede tomar fraccionalmente, actualizamos mejor si la suma del costo de SS y el costo fraccional de T es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cada vez que encontramos un TK I tal que el tamaño (TK I) es mayor que R, pero el costo (TK I) es menor que el costo (s), o cuando llegamos al Tuple Representing Agent L y da un Faciblesolución. Lema 2. Suponga que A ∗ es una solución óptima de la mochila generalizada, y suponga que el elemento (L, J) es de rango medio en la solución óptima. Luego, el costo V (L, J), devuelto por Greedy (, J), satisface: V (, J) + Costo (TJ) ≤ 2cost (A ∗) prueba. Sea V (, j) el valor devuelto por Greedy (, j) y vamos v ∗ (, j) una solución óptima para iKnapsack (, j). Considere el set omitir al final de la codicia (, j). Hay dos casos a considerar: o Skip tuple t ∈ también está en V ∗ (, j), o ninguna tupla en Skip está en V ∗ (, J). En el primer caso, ST sea la solución tentativa en el momento en que se agrega T para omitir. Porque t ∈ Skip entonces tamaño (t)> r, y st junto con t forma una solución factible, y tenemos: v (, j) ≤ costo (mejor) ≤ costo (st) + costo (t). Nuevamente, porque t ∈ Skip luego costo (t)> costo (st), y tenemos v (, j) <2cost (t). Por otro lado, dado que T se incluye en V ∗ (, j), tenemos V ∗ (, j) ≥ costo (t). Estas dos desigualdades implican el límite deseado: V ∗ (, J) ≤ V (, J) <2V ∗ (, J). En el segundo caso, imagine una instancia modificada de iKnapsack (, j), que excluye todas las tuplas del set Skip. Dado que ninguna de estas tuplas se incluyó en V ∗ (, j), la solución óptima para el problema modificado debe ser la misma que para el original. Supongamos que nuestro algoritmo de aproximación devuelve el valor V (, j) para esta instancia modificada. Sea T la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea la solución tentativa correspondiente establecida en ese paso. Dado que consideramos las tuplas en orden de aumento por precio unitario, y ninguna de las tuplas se colocará en el set Skip, debemos haber costado (ST) <v ∗ (, j) porque ST es la forma óptima de obtener tamaño(Calle ). También tenemos costo (t) ≤ costo (st), y las siguientes desigualdades: v (, j) ≤ v (, j) ≤ costo (st) + costo (t) <2v ∗ (, j) la desigualdad v (, j) ≤ V (, j) se deduce del hecho de que una tupla en la lista de omisión solo puede afectar las mejores pero no las soluciones tentativas. Por lo tanto, dejar caer las tuplas en el set Skip solo puede empeorar la solución. El argumento anterior ha demostrado que el valor devuelto por Greedy (, j) está dentro de un factor 2 de la solución óptima para iKnapsack (, j). Ahora mostramos que el valor v (, j) más costo (TJ) es una acroximación de 2 del problema original de la mochila generalizada. Deje que A ∗ sea una solución óptima de la mochila generalizada, y suponga que el elemento XJ es de rango medio. Deje que X- se establezca de los elementos restantes, cero o anclajes, en esta solución. Además, defina x = xj - uj. Por lo tanto, costo (a ∗) = costo (xl) + costo (tj l) + costo (x - l) Es fácil ver que (x−, x) es una solución óptima para iknapsack (, j). Dado que V (, j) es una aplicación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V (, J) + Costo (TJ) ≤ Costo (TJ) + 2 (costo (x) + costo (x−)) ≤ 2 (costo (x) + costo (tj) + costo (x−)) ≤ 2cost (a ∗) Esto completa la prueba de lema 2. Es fácil ver que, después de una clasificación inicial de las tuplas en u, el algoritmo codicioso (, j) toma o (n) tiempo. Tenemos nuestro primer algoritmo de aproximación polinomial. Teorema 2. Se puede encontrar una característica de 2 de la mochila generalizada en el tiempo O (N2), donde n es el número de listas de elementos (cada una de longitud constante). PRUEBA. Dirigimos el algoritmo codicioso (, j) una vez para cada tupla (L, j) como candidato para el rango medio. Hay O (N) tuplas, y es suficiente ordenarlas una vez, el costo total del algoritmo es O (N2). Por Lemma 1, existe una solución óptima con como máximo un elemento de rango medio, por lo que nuestro algoritmo encontrará una acerca de 2, como se afirma. La dependencia del número de piezas también es polinomio: si cada oferta tiene un máximo de piezas C, entonces el tiempo de ejecución es O ((NC) 2).171 3.3 Un esquema de aproximación ahora usamos el algoritmo de 2 de acujos presentado en la sección anterior para desarrollar una aproximación totalmente polinomial (FPTA) para el problema de la colcha generalizada. La idea de alto nivel es bastante estándar, pero los detalles requieren atención técnica. Utilizamos un algoritmo de programación dinámica para resolver iKnapsack (, j) para cada elemento de rango medio posible, con el algoritmo de 2 de acoplamiento que proporciona un límite superior en el valor de la solución y permite el uso de la escala en la dimensión de costo de la programación dinámica (Dp) tabla. Considere, por ejemplo, el caso de que el elemento de rango medio es x, que cae en el rango [UJ, UJ+1). En nuestros FPTA, en lugar de usar un algoritmo de aproximación codicioso para resolver iKnapsack (, j), construimos una tabla de programación dinámica para calcular el costo mínimo al que se pueden obtener al menos m - Uj+1 unidades utilizando las listas de N - 1 restantesEn la mochila generalizada. Supongamos que G [i, R] denota el número máximo de unidades que se pueden obtener a costo como máximo R usando solo las primeras listas I en la mochila generalizada. Luego, la siguiente relación de recurrencia describe cómo construir la tabla de programación dinámica: g [0, r] = 0 g [i, r] = max ´ g [i - 1, r] max j∈β (i, r) {G [i - 1, r - costo (tj i)] + uj i} µ donde β (i, r) = {j: 1 ≤ j ≤ mi, costo (tj i) ≤ r}, es el conjunto de anclajespara el agente i. Como convención, agente, indexaré la fila, y el costo r indexará la columna. Este algoritmo de programación dinámica es solo pseudopolinomio, ya que el número de columna en la tabla de programación dinámica depende del costo total. Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión de costos. Deje que den la denota la 2-ACOMAXIMACIÓN al problema generalizado de la mochila, con costo total, costo (a). Deje que ε denote el factor de aproximación deseado. Calculamos el costo escalado de una tupla tj I, denotó scost (tj i), como scost (tj i) = n costo (tj i) εcost (a) (2) Esta escala mejora el tiempo de ejecución del algoritmo porque el númerode columnas en la tabla modificada es como máximo n ε e independiente del costo total. Sin embargo, la solución calculada podría no ser una solución óptima para el problema original. Mostramos que el error introducido está dentro de un factor de ε de la solución óptima. Como preludio de nuestra garantía de aproximación, primero mostramos que si dos soluciones diferentes al problema de Iknapsack tienen el mismo costo escalado, entonces sus costos originales (sin calificar) no pueden diferir en más de εcost (a). Lema 3. Sea X e Y dos soluciones factibles distintas de Iknapsack (, J), excluyendo sus elementos de rango medio. Si X e Y tienen costos escalados iguales, entonces sus costos no calificados no pueden diferir en más de εcost (a). PRUEBA. Deje que IX e iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores de anclaje x e y-hay 1 en la posición IX [i, k] si el xk i> 0. Dado que x e y tienen un costo a escala igual, i = k scost (tk i) ix [i, k] = i = k scost (tk i) iy [i, k] (3) Sin embargo, por (2), el escaladoLos costos satisfacen las siguientes desigualdades: (Scost (Tk I)-1) εcost (a) n ≤ costo (tk i) ≤ scost (tk i) εcost (a) n (4) que sustituye el costo escalado superior (4) Para el costo (x), el límite inferior en el costo escalado de (4) para el costo (y), y usando la igualdad (3) para simplificar, tenemos: costo (x)-costo (y) ≤ εcost (a) n i = k iy [i, k] ≤ εcost (a), la última desigualdad usa el hecho de que, a la mayoría de los componentes de un vector indicador, no son cero;Es decir, cualquier solución factible contiene como máximo n tuplas. Finalmente, dada la tabla de programación dinámica para iKnapsack (, j), consideramos todas las entradas en la última fila de esta tabla, G [n - 1, r]. Estas entradas corresponden a soluciones óptimas con todos los agentes, excepto L, para diferentes niveles de costo. En particular, consideramos las entradas que proporcionan al menos m - Uj+1 unidades. Junto con una contribución del Agente L, elegimos la entrada en este conjunto que minimiza el costo total, definido de la siguiente manera: Costo (G [N - 1, R]) + Max {UJ, M - G [N - 1, R]} Pj, donde costo () es el costo original y sin calificar asociado con la entrada G [N - 1, R]. Vale la pena señalar que, a diferencia del esquema de 2 de acumulación para iKnapsack (, j), el valor calculado con este FPTAS incluye el costo de adquirir unidades UJ L de l.El siguiente lema muestra que logramos una acroximación (1+ε). Lema 4. Supongamos que A ∗ es una solución óptima del problema generalizado de la mochila, y suponga que ese elemento (L, j) es de rango medio en la solución óptima. Luego, la solución A (L, J) de ejecutar el algoritmo de programación dinámica escalada en iKnapsack (, J) satisface el costo (A (L, J)) ≤ (1 + 2ε) Costo (A ∗) Prueba. Deje que X- denote el vector de los elementos en solución a ∗ sin elemento l.Entonces, por definición, costo (a ∗) = costo (x−) + pj xj. Sea r = scost (x−) el costo escalado asociado con el vector x-. Ahora considere la tabla de programación dinámica construida para iKnapsack (, j), y considere su entrada g [n - 1, r]. Deje que A denote la agrupación de 2 al problema generalizado de la mochila, y A (L, j) denota la solución del algoritmo de programación dinámica. Supongamos que Y- es la solución asociada con esta entrada en nuestro programa dinámico;Los componentes del vector Y- son las cantidades de diferentes listas. Dado que tanto X- e Y tienen los costos escalados iguales, por Lemma 3, sus costos no calificados están dentro de εcost (a) entre sí;es decir, costo (y−) - costo (x−) ≤ εcost (a). Ahora, defina yj = max {UJ, m - èi = èj yj i};Esta es la contribución necesaria de hacer (y-, yj) una solución factible. Entre todas las soluciones de igual costo, nuestras tablas de programación dinámica eligen la que con unidades máximas. Por lo tanto, i = j yj i ≥ i = j xj i 172 Por lo tanto, debe ser el caso que yj ≤ xj. Porque (YJ, Y-) también es una solución factible, si nuestro algoritmo devuelve una solución con costo de costo (A (L, J)), entonces debemos tener un costo (A (L, J)) ≤ Costo (Y-)+ pj yj ≤ costo (x−) + εcost (a) + pj xj ≤ (1 + 2ε) costo (a ∗), donde usamos el hecho de que el costo (a) ≤ 2cost (a ∗). Al armar esto, nuestro esquema de aproximación para el problema de la mochila generalizada iterará el esquema descrito anteriormente para cada opción del elemento de rango medio (L, J), y elegirá la mejor solución entre estas soluciones O (N). Para un rango medio dado, el paso más costoso en el algoritmo es la construcción de la tabla de programación dinámica, que se puede hacer en el tiempo O (N2 /ε) suponiendo intervalos constantes por lista. Por lo tanto, tenemos el siguiente resultado. Teorema 3. Podemos calcular una aproximación (1 + ε) a la solución de un problema de mochila generalizada en el peor de los casos O (N3 /ε). La dependencia del número de piezas también es polinomio: si cada oferta tiene un máximo de piezas C, entonces el tiempo de ejecución se puede derivar sustituyendo CN por cada aparición de n.4. Computación de pagos de VCG Ahora consideramos el problema relacionado de calcular los pagos de VCG para todos los agentes. Un enfoque ingenuo requiere resolver el problema de asignación n veces, eliminando a cada agente a su vez. En esta sección, mostramos que nuestro esquema de aproximación para la mochila generalizada puede extenderse para determinar todos los pagos de N en el tiempo total O (αT log (αN/ε)), donde 1 ≤ c (i \ i)/c (i)≤ α, para un límite superior constante, α, y t es la complejidad de resolver el problema de asignación una vez. Este límite de α puede justificarse como una condición de no monopolio, porque limita el valor marginal que un solo comprador aporta a la subasta. Del mismo modo, en la variación inversa podemos calcular los pagos de VCG a cada vendedor en el tiempo O (αT log (αN/ε)), donde α limita la relación c (i \ i)/c (i) para todo i. Nuestra estrategia general será construir dos tablas de programación dinámica, hacia adelante y hacia atrás, para cada elemento de rango medio (L, j) una vez. La tabla delantera se construye considerando a los agentes en el orden de sus índices, donde se construye la tabla hacia atrás considerándolos en el orden inverso. La solución óptima correspondiente a C (i \ i) se puede dividir en dos partes: una correspondiente a los agentes primero (i - 1) y el otro correspondiente a los últimos agentes (N - I). Como la (i - 1) en la fila de la tabla delantera corresponde a los vendedores con los primeros índices (I - 1), se contenerá una aproximación a la primera parte en (i - 1) en la fila de la tabla delantera. Del mismo modo, (n− i) la fila de la tabla hacia atrás contendrá una aproximación para la segunda parte. Primero presentamos una forma simple pero ineficiente de calcular el valor aproximado de C (i \ i), que ilustra la idea principal de nuestro algoritmo. Luego presentamos un esquema mejorado, que utiliza el hecho de que los elementos en las filas están ordenados, para calcular el valor aproximado de manera más eficiente. A continuación, nos concentramos en calcular una asignación con XJ de rango medio, y algún agente I = L eliminado. Este será un componente para calcular una aproximación a C (i \ i), el valor de la solución a la mochila generalizada sin ofertas del agente i. Comenzamos con el esquema simple.4.1 Un esquema de aproximación simple implementamos el algoritmo de programación dinámica a escala para iknapsack (, j) con dos pedidos alternativos sobre los otros vendedores, k = l, uno con vendedores ordenados 1, 2 ,..., n, y uno con vendedores ordenados n, n - 1 ,..., 1. Llamamos a la primera tabla la tabla delantera y la denotamos F, y la segunda tabla de la tabla hacia atrás, y la denotamos Bl. El subíndice nos recuerda que el agente es de rango medio.9 En la construcción de estas tablas, usamos el mismo factor de escala que antes;a saber, el costo de una tupla TJ I se escala de la siguiente manera: Scost (TJ I) = NCOST (TJ I) εcost (a) donde el costo (a) es el límite superior en C (i), dado por nuestro esquema de 2 apropiaciones. En este caso, debido a que C (i \ i) puede ser α veces C (i), el valor escalado de C (i \ i) puede ser como máximo Nα/ε. Por lo tanto, la dimensión de costo de nuestra tabla de programas dinámicos será Nα/ε. Fltable F (I - 1) L 2 3 1 2 I - 1 1 M - 1 M N - 1 G 2 31 M - 1 M B (N - I) N - 1 N - 2 N - I 1 LH Tabla BL Figura 3: Computación de pagos VCG.M = Nα ε Ahora, supongamos que queremos calcular una acroximación (1 +) al problema generalizado de la mochila restringida al elemento (L, j) medio, y restringidos aún más a eliminar las ofertas de algunos vendedores i = l.Llame a este problema iknapsack - i (, j). Recuerde que la fila ésica de nuestra tabla DP almacena la mejor solución posible utilizando solo los primeros agentes I excluyendo el Agente L, todos despejados en cero o en anclajes. Estos primeros agentes I son un subconjunto diferente de agentes en las tablas delantera y hacia atrás. Al combinar cuidadosamente una fila de FL con una fila de BL podemos calcular una aproximación a IKNAPSACK - I (, J). Consideramos la fila de FL que corresponde a soluciones construidas a partir de agentes {1, 2 ,..., i - 1}, saltando agente l.Consideramos la fila de BL que corresponde a soluciones construidas a partir de agentes {i+1, i+2 ,..., n}, nuevamente omitiendo agente l.Las filas están etiquetadas FL (I - 1) y BL (N - I) respectivamente.10 Los costos escalados para adquirir estas unidades son los índices de columna para estas entradas. Para resolver iknapsack - i (, j) elegimos una entrada de la fila F (i - 1) y otra de la fila B (n - i) de modo que su cantidad total excede m - Uj+1 y su costo combinado es mínimo en todotales combinaciones. Formalmente, deje g ∈ Fl (i - 1), y h ∈ Bl (n - 1) denotan entradas en cada fila, con tamaño (g), tamaño (h), denotando el número de unidades y el costo (g) y el costo(h) Denotar el costo no calificado asociado con la entrada. Calculamos lo siguiente, sujeto 9 podríamos etiquetar las tablas con ambos y j, para indicar que la tupla Jth se ve obligada a ser de rango medio, pero omitir J para evitar el desorden.10 Para ser precisos, el índice de las filas es (i - 2) y (n - i) para fl y bl cuando l <i, y (i - 1) y (n - i - 1), respectivamente, cuando l> i.173 a la condición de que G y H satisfagan el tamaño (g) + tamaño (h)> m - Uj + 1: min g∈F (i - 1), h∈B (n - i) òcost (g) + costo (H) + PJ · Max {UJ, M - Tamaño (G) - Tamaño (H)} Ó (5) Lemma 5. Supongamos que A - I es una solución óptima del problema de mochila generalizada sin ofertas del Agente I, y suponga que el elemento (L, J) es el elemento de rango medio en la solución óptima. Entonces, la expresión en la ecuación.5, para el problema restringido iknapsack-i (, j), calcula una acroximación de una (1 + ε) a A-I. PRUEBA. Desde anteriormente, definimos el costo (a - i) = c (i \ i). Podemos dividir la solución óptima, A - I, en tres partes disjuntas: XL corresponde al vendedor de rango medio, Xi corresponde a los primeros vendedores I - 1 (salteando el agente L if l <i) y X - I corresponde al último n − -I Sellers (omitiendo agente l if l> i). Tenemos: costo (a - i) = costo (xi) + costo (x - i) + pj xj dejar ri = scost (xi) y r - i = scost (x - i). Deje que Yi e Y - i sean los vectores de solución correspondientes al costo escalado RI y R - I en F (i - 1) y B (N - I), respectivamente. De Lemma 3 concluimos que, costo (yi) + costo (y-i)-costo (xi)-costo (x-i) ≤ εcost (a) donde el costo (a) es el límite superior en c (i)calculado con la acroximación de 2. Entre todas las soluciones de costos de igual escalada, nuestro programa dinámico elige el que tiene unidades máximas. Por lo tanto, también tenemos, (tamaño (yi) ≥ tamaño (xi)) y (tamaño (y - i) ≥ tamaño (x - i)) donde usamos el tamaño de la taquigrafía (x) para denotar el número total de unidades en todas las tuplas enX. Ahora, defina yj l = max (uj l, m −size (yi) −size (y - i)). De las desigualdades anteriores, tenemos yj l ≤ xj l. Dado que (yj l, yi, y - i) también es una solución factible para el problema generalizado de la mochila sin el agente I, el valor devuelto por la ecuación.5 es como máximo costo (yi) + costo (y - i) + pj l yj l ≤ c (i \ i) + εcost (a) ≤ c (i \ i) + 2cost (a ∗) ε ≤ c (i\ i) + 2c (i \ i) ε Esto completa la prueba. Una implementación ingenua de este esquema será ineficiente porque podría verificar (Nα/ε) 2 pares de elementos, para cualquier opción particular de (L, J) y la elección del agente caído i. En la siguiente sección, presentamos una forma eficiente de calcular la ecuación.5, y eventualmente para calcular los pagos de VCG.4.2 Esquema de aproximación mejorado Nuestro esquema de aproximación mejorada para el problema de determinación del ganador sin el agente i utiliza el hecho de que los elementos en F (i-1) y B (n-i) están ordenados;Específicamente, tanto el costo y la cantidad sin escala (es decir, el tamaño) aumenta de izquierda a derecha. Como antes, deje que G y H denoten entradas genéricas en F (I - 1) y B (N - I) respectivamente. Para calcular la ecuación.5, consideramos todos los pares de tupla, y primero dividimos las tuplas que satisfacen el tamaño de la condición (g) + tamaño (h)> m - uj + 1 L en dos conjuntos de disjunto. Para cada conjunto, calculamos la mejor solución y luego tomamos lo mejor entre los dos conjuntos.[Caso I: tamaño (g) + tamaño (h) ≥ m - uj l] El problema se reduce a min g∈F (i - 1), h∈B (n - i) òcost (g) + costo (h)+ Pj L UJ Ó (6) Definimos un par (G, H) para que sea factible si el tamaño (G) + tamaño (H) ≥ M - Uj l. Ahora para calcular la ecuación.6, hacemos una caminata hacia adelante y hacia atrás en F (I - 1) y B (N - I) respectivamente. Comenzamos desde el índice más pequeño de F (i - 1) y nos movemos a la derecha, y desde el índice más alto de B (N - I) y movemos a la izquierda. Sea (G, H) el par actual. Si (G, H) es factible, disminuimos el puntero de BS (es decir, avanzar hacia atrás) De lo contrario, incrementamos el puntero FS. Los pares factibles que se encuentran durante la caminata se utilizan para calcular la ecuación.6. La complejidad de este paso es de tamaño lineal de F (I - 1), que es O (Nα/ε).[Caso II: M - UJ + 1 L ≤ Tamaño (G) + Tamaño (H) ≤ M - Uj L] El problema se reduce a Min G∈F (I - 1), H∈B (N - I) òcost (g) + costo (h) + pj l (m - tamaño (g) - tamaño (h)) ó Para calcular la ecuación anterior, transformamos el problema anterior en otro problema usando el costo modificado, que se define como: mcost (g) = costo (g) - pj l · tamaño (g) mcost (h) = costo (h) - pj l · tamaño (h) El nuevo problema es calcular min g∈F (i - 1), h∈B(n - i) òmcost (g) + mcost (h) + pj l m ó (7) El costo modificado simplifica el problema, pero desafortunadamente los elementos en f (i - 1) y b (n - i) ya no sonordenado con respecto a Mcost. Sin embargo, los elementos aún se clasifican en cantidad y usamos esta propiedad para calcular la ecuación.7. Llame a un par (G, H) factible si M - UJ + 1 L ≤ Tamaño (G) + Tamaño (H) ≤ M - Uj l. Defina el conjunto factible de G como los elementos h ∈ B (n - i) que son factibles dados g.Como los elementos se clasifican por cantidad, el conjunto factible de G es un subconjunto contiguo de B (N - I) y cambia a la izquierda a medida que aumenta G.2 3 4 5 10 20 30 30 40 50 60 Comienzo B (N - I) 15 20 25 30 35 40 65421 3 1 6 F (I - 1) L L Figura 4: El conjunto factible de G = 3, definido en B (n - i), es {2, 3, 4} cuando m - UJ+1 L = 50 y M - UJ L = 60. El comienzo y el final representan los punteros de inicio y finalización del conjunto factible. Por lo tanto, podemos calcular la ecuación.7 haciendo una caminata hacia adelante y hacia atrás en F (I - 1) y B (N - I) respectivamente. Caminamos sobre B (N - I), comenzando desde el índice más alto, usando dos punteros, comenzamos y terminan, para indicar el inicio y el final del conjunto factible actual. Mantenemos el conjunto factible como un montón mínimo, donde la clave es el costo modificado. Para actualizar el conjunto factible, cuando incrementamos el puntero FS (avanzamos), caminamos a la izquierda en B, primero usando el extremo para eliminar elementos del conjunto factible que ya no son factibles y luego usando comenzar a agregar nuevos elementos factibles. Para una G dada, el único elemento que debemos considerar en el conjunto factible de GS es el que tiene un costo mínimo modificado que se puede calcular en un tiempo constante con el montón min. Entonces, la principal complejidad del cálculo se encuentra en las actualizaciones de montón. Dado que cualquier elemento se agrega o elimina como máximo una vez, hay actualizaciones de montón O (Nα ε) y la complejidad del tiempo de este paso es O (Nα ε log Nα ε).4.3 Recogiendo las piezas El algoritmo funciona de la siguiente manera. Primero, utilizando el algoritmo de aproximación 2, calculamos un límite superior en C (I). Utilizamos esto ligado a escalar los costos de la tupla. Usando los costos escalados, construimos las tablas hacia adelante y hacia atrás correspondientes a cada tupla (L, J). Las tablas delanteras se utilizan para calcular C (i). Para calcular C (i \ i), itreamos sobre todas las tuplas de rango medio posibles y usamos las tablas de avance y hacia atrás correspondientes para calcular la solución localmente óptima utilizando el esquema anterior. Entre todas las soluciones localmente óptimas, elegimos una con el costo total mínimo. El paso más caro en el algoritmo es el cálculo de C (i \ i). La complejidad del tiempo de este paso es O (N2 α ε log Nα ε) como tenemos que iterar sobre todas las opciones O (n) de TJ L, para todos L = I, y cada vez que use el esquema anterior para calcular la ecuación.5. En el peor de los casos, es posible que necesitemos calcular C (i \ i) para todos los n vendedores, en cuyo caso la complejidad final del algoritmo será O (N3 α ε log nα ε). Teorema 4. Podemos calcular una aproximación a prueba de estrategia /(1+) al mecanismo VCG en las subastas de unidades múltiples de avance e inversa en el peor tiempo O (N3 α ε log Nα ε). Es interesante recordar que T = O (N3 ε) es la complejidad del tiempo de los FPTA al problema generalizado de la mochila con todos los agentes. Nuestro esquema combinado calcula una aproximación al mecanismo VCG completo, incluidos los pagos a los agentes O (N), en la complejidad del tiempo O (T log (N/ε)), tomando el parámetro no monopolio, α, como constante. Por lo tanto, nuestro algoritmo funciona mucho mejor que el esquema ingenuo, que calcula el pago de VCG para cada agente resolviendo una nueva instancia de problema generalizado de mochila. La velocidad proviene de la forma en que resolvemos iknapsack - i (, j). La complejidad del tiempo de la calculación IKNAPSACK - I (, J) Al crear una nueva tabla de programación dinámica será O (N2 ε) pero al usar las tablas hacia adelante y hacia atrás, la complejidad se reduce a O (N ε log n ε). Podemos mejorar aún más la complejidad del tiempo de nuestro algoritmo calculando la ecuación.5 más eficientemente. Actualmente, el algoritmo usa Heap, que tiene tiempo de actualización logarítmica. En el peor de los casos, podemos tener dos operaciones de actualización de Heap para cada elemento, lo que hace que la complejidad del tiempo sea súper lineal. Si podemos calcular la ecuación.5 En tiempo lineal, entonces la complejidad de calcular el pago de VCG será la misma que la complejidad de resolver un solo problema de mochila generalizada.5. Conclusiones Presentamos un esquema de aproximación en tiempo polinómico para el problema de subasta de una sola unidad de bienvenida, utilizando un lenguaje de licitación constante de partes por partes decrecientes marginales. Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias dentro de cualquier factor especificado ε> 0. Como tal, es un ejemplo de resultado de dominancia ε computacionalmente manejable, así como un ejemplo de un problema de asignación no trivial pero aproximable. Es particularmente interesante que podamos calcular los pagos a los agentes de N en un mecanismo basado en VCG en el peor tiempo de casos o (T log n), donde T es la complejidad del tiempo para calcular la solución a un solo problema de asignación.6. Referencias [1] L M Ausubel y P R Milgrom. Subastas ascendentes con ofertas de paquetes. Fronteras de la economía teórica, 1: 1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer y R V Vohra. Programación lineal y subastas de Vickrey. Informe técnico, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani y J M Ostroy. El modelo de asignación de paquetes. Journal of Economic Theory, 2002. Próximo.[4] K Chatterjee y W Samuelson. Negociación bajo información incompleta. Operations Research, 31: 835-851, 1983. [5] E H Clarke. Precio multiparte de bienes públicos. Public Choice, 11: 17-33, 1971. [6] S de Vries y R v Vohra. Subastas combinatorias: una encuesta. Informa Journal on Computing, 2002. Próximo.[7] M Eso, S Ghosh, J R Kalagnanam y L Ladanyi. Evaluación de ofertas en subastas de adquisiciones con curvas de suministro lineal por pieza. Informe técnico, IBM TJ Watson Research Center, 2001. En preparación.[8] J Feigenbaum y S Shenker. Diseño de mecanismo algorítmico distribuido: resultados recientes y direcciones futuras. En Actas del 6to Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, Páginas 1-13, 2002. [9] M R Garey y D S Johnson. Computadoras e intratabilidad: una guía de la teoría de la completitud de NP. W.H.Freeman and Company, Nueva York, 1979. [10] G V Gens y E V Levner. Complejidad computacional de algoritmos de aproximación para problemas combinatorios. En Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves. Incentivos en equipos. Econometrica, 41: 617-631, 1973. [12] J R Kalagnanam, A J Davenport, y H S Lee. Aspectos computacionales de la compensación de subastas dobles de llamadas continuas con restricciones de asignación y demanda indivisible. Electronic Commerce Journal, 1 (3): 221-238, 2001. [13] V Krishna. Teoría de la subasta. Academic Press, 2002. [14] v Krishna y M Perry. Diseño de mecanismo eficiente. Informe técnico, Universidad Estatal de Pensilvania, 1998. Disponible en: http://econ.la.psu.edu/˜vkrishna/vcg18.ps.[15] D Lehmann, L I Ocallaghan e Y Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. JACM, 49 (5): 577-602, septiembre de 2002. [16] R B Myerson. Diseño de subasta óptimo. Matemáticas de Operation Research, 6: 58-73, 1981. [17] R B Myerson y M A Satterthwaite. Mecanismos eficientes para el comercio bilateral. Journal of Economic Theory, 28: 265-281, 1983. [18] N Nisan y A Ronen. Mecanismos VCG computacionalmente factibles. En ACM-EC, páginas 242-252, 2000. [19] D C Parkes, J R Kalagnanam y M Eso. Lograr el equilibrio presupuestario con los esquemas de pago con sede en Vickrey en los intercambios. En Ijcai, 2001. [20] M H Rothkopf, A Pekeˇc y R M Harstad. Subastas combinatorias computacionalmente manejables. Management Science, 44 (8): 1131-1147, 1998. [21] J Schummer. Implementación de la estrategia casi dominante. Informe técnico, Departamento de Meds, Kellogg Graduate School of Management, 2001. [22] W Vickrey. Contrapeculación, subastas y licitaciones selladas competitivas. Journal of Finance, 16: 8-37, 1961. 175