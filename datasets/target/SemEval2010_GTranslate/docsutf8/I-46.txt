Sistemas interpretados modulares Wojciech Jamroga Departamento de Informática de la Universidad de Claustral, Alemania wjamroga@in.tu-Clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Bergen University College, Noruega Tag@hib.No Resumen, proponemos una nueva clase de representaciones que pueden ser que pueden serUtilizado para modelar (y verificación de modelos) propiedades temporales, estratégicas y epistémicas de los agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin et al.;Sin embargo, también son modulares y compactos de la forma en que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la comprobación de modelos de lógica temporal en tiempo alterno para esta clase natural de modelos. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: sistemas artificiales de inteligencia artificiales distribuidos;I.2.4 [Inteligencia artificial]: Formalismos de representación del conocimiento y métodos lógica modal Términos generales Teoría 1. Introducción Los fundamentos lógicos de los sistemas de múltiples agentes han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar, por ejemplo, conocimiento [7], tiempo [6], cooperación y capacidad estratégica [3]. Últimamente, una cantidad cada vez mayor de investigación se ha centrado en los lenguajes de representación de nivel superior para modelos de tales lógicas, motivados principalmente por la necesidad de representaciones compactas y para representaciones que se corresponden más estrechamente a los sistemas reales que se modelan. Los sistemas de múltiples agentes son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas de múltiples agentes que sean modulares, en el sentido de que un componente, como un agente, puede ser reemplazado, eliminado o agregado, sin cambios importantes en la representación de todo el modelo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son modulares, compactos y computacionalmente basados por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas abiertos de múltiples agentes, que son modulares, compactos y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos los antecedentes de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo de ramificación, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica del árbol de cálculo CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de lógica temporal de tiempo alterno (ATL): una para el perfecto y otro para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 generalmente se definen sobre modelos explícitos (estructuras de Kripke) que enumeran todos los estados posibles (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno quiere evitar, porque hay demasiados de ellos incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para usar una clase de modelos más especializada es que las estructuras generales de Kripke no siempre brindan suficiente ayuda en términos de metodología, tanto en la etapa del diseño, ni en la implementación. Esto requiere una semántica que se basa más en el sentido de que la correspondencia entre los elementos del modelo y las entidades modeladas es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar modelos sistemas en los que son importantes el tiempo, la acción (y posiblemente el conocimiento);Mencionamos representaciones especialmente utilizadas para el análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no juegan su papel de manera satisfactoria cuando se consideran estrategias de agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (MIS) y mostramos dónde encaja en la imagen. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación del modelo de información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfectas (y los otros eran indiferentes).2. La lógica del tiempo, el conocimiento y la capacidad estratégica primero, presentamos las lógicas CTL, CTLK, ATL y ATLIR que son el punto de partida de nuestro estudio.2.1 Tiempo de ramificación: CTL Computation Tree Logic CTL [6] incluye operadores para propiedades temporales de los sistemas: es decir, cuantificador de ruta e (hay una ruta), junto con operadores temporales: F (en el siguiente estado), 2 (siempre a partir de ahoraOn) y U (hasta) .1 Cada aparición de un operador temporal está inmediatamente precedido por exactamente un cuantificador de ruta (esta variante del lenguaje a veces se llama CTL de vainilla). Sea π un conjunto de proposiciones atómicas con un elemento típico p.Las fórmulas CTL ϕ se definen de la siguiente manera: ϕ :: = P |¬ϕ |ϕ ∧ ϕ |E fϕ |E2ϕ |Eϕ u ϕ. La semántica de CTL se basa en los modelos Kripke M = ST, R, π, que incluyen un conjunto no vacío de estados ST, una relación de transición de estado R ⊆ ST × ST y una valoración de las proposiciones π: π → P (ST). Una ruta λ en M se refiere a un posible comportamiento (o cálculo) del sistema M, y puede representarse como una secuencia infinita de estados Q0Q1Q2 ... tales que qirqi+1 por cada i = 0, 1, 2, .... Denotamos el estado ésano en λ por λ [i]. Un Q-Path es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: m, q | = p iff q ∈ π (p);M, q | = ¬ϕ iff m, q | = ϕ;M, q | = ϕ ∧ ψ iff m, q | = ϕ y m, q | = ψ;M, q | = e fϕ iff hay una ruta q λ tal que m, λ [1] | = ϕ;M, q | = e2ϕ iff hay una ruta q λ tal que m, λ [i] | = ϕ por cada i ≥ 0;M, q | = eϕ u ψ iff hay un Q-Path λ e I ≥ 0 tal que m, λ [i] | = ψ y m, λ [j] | = ϕ para cada 0 ≤ j <i.2.2 Agregar conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea agt = {1, ..., k} un conjunto de agentes con un elemento típico a.La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como agente A sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones epistémicas de indistingencia ∼A⊆ ST × ST (uno por agente). Suponemos que todas las ∼A son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: m, q | = kaϕ iff m, q | = ϕ para cada q tal que q ∼A q. Tenga en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una sola unidad, pero será importante cuando los agentes particulares y sus estrategias se destacen.2.3 Agentes y sus estrategias: la lógica temporal de tiempo alterno ATL ATL [3] es una lógica para razonar sobre las propiedades temporales y estratégicas de los sistemas computacionales abiertos (sistemas de múltiples agentes en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ :: = P |¬ϕ |ϕ ∧ ϕ |A fϕ |A 2ϕ |A ϕ u ϕ.donde a ⊆ agt. Informalmente, un ϕ dice que los agentes A tienen una estrategia colectiva para hacer cumplir ϕ. Cabe señalar que los cuantificadores de la ruta CTL A, E se pueden expresar con ∅, AGT respectivamente. La semántica de ATL se define en las llamadas estructuras de juego concurrentes (CGSS). Un CGS es una tupla M = Agt, ST, Act, D, O, π, π, 1 operadores adicionales A (para cada ruta) y 3 (en algún momento en el futuro) se definen de la manera habitual.que consiste en: un conjunto agt = {1 ,..., k} de agentes;establecer el st de los estados;valoración de proposiciones π: π → p (st);Establecer acto de acciones atómicas. Función D: AGT × ST → P (ACT) indica las acciones disponibles para el agente A ∈ AGT en el estado q ∈ St. Finalmente, O es una función de transición determinista que mapea un estado q ∈ ST y un perfil de acción α1 ,..., αk ∈ Actk, αi ∈ D (i, Q), a otro estado q = O (Q, α1, ..., αk). Definición 1. Una estrategia (sin memoria) del agente A es una función SA: ST → ACT de tal manera que SA (Q) ∈ D (A, Q) .2 Una estrategia colectiva SA para un equipo A ⊆ AGT especifica una estrategia individual para cada agente a ∈A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todos los cálculos que pueden resultar de ejecutar SA de Q on: out (q, sa) = {λ = q0q1q2 ... |Q0 = Q y por cada i = 1, 2, ... existe αi - 1 1, ..., αi - 1 k tal que αi - 1 a = sa (a) (qi - 1) para cada una a ∈A, αi - 1 a ∈ D (A, Qi - 1) para cada A /∈ A y O (Qi - 1, αi - 1 1, ..., αi - 1 K) = Qi}. La semántica de las modalidades de cooperación es la siguiente: m, q | = a fϕ iff hay una estrategia colectiva sa tal que, por cada λ ∈ (q, sa), tenemos m, λ [1] | = ϕ;M, q | = a 2ϕ iff existe sa tal que, por cada λ ∈ Out (q, sa), tenemos m, λ [i] por cada i ≥ 0;M, q | = a ϕ u ψ si existe sa tal que por cada λ ∈ Out (q, sa) hay un i ≥ 0, para el cual m, λ [i] | = ψ y m, λ [j]| = ϕ por cada 0 ≤ j <i.2.4 Agentes con información imperfecta: ATLIR AS ATL no incluye información incompleta en su alcance, puede verse como una lógica para razonamiento sobre los agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. Atlir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: un IR indica que abordan a los agentes con información imperfecta y un retiro imperfecto. Formalmente, la definición recursiva de las fórmulas Atlir es: ϕ :: = P |¬ϕ |ϕ ∧ ϕ |A IR fϕ |Un ir2ϕ |Los modelos Irϕ u ϕ de Atlir, estructuras de juegos epistémicos concurrentes (CEG), pueden definirse como tuplas m = agt, st, acto, d, o, ∼1, ..., ∼k, π, π, donde agt,ST, Act, D, O, π, π es un CGS, y ∼1, ..., ∼K son relaciones epistémicas (equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: Q ∼A Q implica D (A, Q) = D (A, Q). Atlir restringe las estrategias que los agentes pueden usar para estrategias uniformes, es decir, funciones sa: st → actuar, de modo que: (1) sa (q) ∈ D (a, q) y (2) si q ∼A q entonces sa(q) = sa (q). Una estrategia colectiva es uniforme si contiene solo estrategias individuales uniformes. Nuevamente, la función (Q, SA) devuelve el conjunto de todas las rutas que pueden resultar de los agentes una estrategia colectiva de ejecución SA del estado q. La semántica de las fórmulas de Atlir se puede definir de la siguiente manera: m, q | = a ir fϕ iff hay una estrategia colectiva uniforme sa tal que, por cada a ∈ A, q tal que q ∼A q y λ ∈ Out (sa,,q), tenemos m, λ [1] | = ϕ;2 Esta es una desviación de la semántica original de ATL [3], donde las estrategias asignan opciones de agentes a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL ∗ completo ∗, y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), debe señalarse que ambos tipos de estrategias producen semánticas equivalentes para ATL puro (CF. [21]).898 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) m, q | = a ir2ϕ si existe sa tal que, por cada a ∈ A, q tal que Q ∼A Q y λ ∈ Out (Sa, Q), nosotros, nosotros, nosotros, nosotrostener m, λ [i] por cada i ≥ 0;M, q | = a irϕ u ψ si existan sa tal que, por cada a ∈ A, q tal que q ∼A q, y λ ∈ Out (sa, q), hay i ≥ 0 para el cual m, λ [i] | = ψ, y m, λ [j] | = ϕ por cada 0 ≤ j <i. Es decir, un IRϕ se mantiene si tiene una estrategia colectiva uniforme, de modo que para cada ruta que pueda resultar de la ejecución de la estrategia de acuerdo con al menos un agente de A, ϕ es el caso.3. Modelos y verificación de modelos En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden usarse para modelar y verificación de modelos. Creemos que los dos puntos de referencia más importantes son en este caso: (1) el formalismo de modelado (es decir, la lógica y la semántica que usamos) y (2) el fenómeno, o más generalmente, el dominio que vamos amodelo (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que está razonablemente cerca del mundo real (es decir, es suficientemente compacta y basada), y aún no muy lejos del formalismo (por lo que, por ejemplo, permite fácilmente un análisis teórico de problemas computacionales). Comenzamos con discutir los méritos de los modelos explícitos en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGS, presentados en la sección anterior.3.1 Modelos explícitos Obviamente, una ventaja de modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, son, en muchos sentidos, difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales generalmente tienen un número exponencial de estados con respecto a cualquier descripción de nivel superior (p. Ej. Variables booleanas, atributos N-ARY, etc.). Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones articulares (sincrónicas o asincrónicas) de varias entidades activas [15]. Para CGSS, la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si solucionamos el número de estados.3 En la práctica, esto significa que tales representaciones rara vez son muy escalables.• Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema;Las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién y de qué manera.• Las lógicas como ATL a menudo se anuncian como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, a uno le gustaría que los elementos de dicho sistema tengan la menor cantidad de interdependencias como sea posible, para que puedan enchufarlos sin mucha molestia, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema de múltiples agentes, la 3 otra clase de modelos ATL, los sistemas de transición alternativos [2] representan transiciones de una manera más sucinta. Si bien todavía tenemos exponencialmente muchos estados en un ATS, el número de transiciones es simplemente WRT cuadrática.a estados (como para modelos CTL). Desafortunadamente, los AT son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden extenderse fácilmente para manejar información incompleta (cf. [9]).La necesidad es quizás aún más obvia. No solo necesitamos volver a aplicar varios diseños de un solo agente en la arquitectura general;Por lo general, también necesitamos cambiar (por ejemplo, aumentar) el número de agentes que actúan en un entorno determinado sin cambiar necesariamente el diseño de todo el sistema. Desafortunadamente, los modelos ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La comprobación de modelos CTL y CTLK se complete P, y se puede hacer en el tiempo O (ml), donde M es el número de transiciones en el modelo, y L es la longitud de la fórmula [5]. Alternativamente, se puede hacer en el tiempo O (N2 L), donde n es el número de estados. La verificación del modelo ATL es P-Complete WRT.M, L y ΔP 3 -complicado WRT.N, K, L (K es el número de agentes) [3, 12, 16]. La verificación del modelo ATLIR es ΔP 2Complete WRT.M, L y ΔP 3 -complicado WRT.N, K, L [21, 13].3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Dichos modelos ofrecen alguna esperanza de propiedades de verificación de modelos factibles de los sistemas abiertos/múltiples agentes, aunque es bien sabido que son compactos solo en una fracción de todos los casos.4 Sin embargo, son insuficientes por otra razón: sonRepresentaciones simplemente optimizadas de modelos explícitos. Por lo tanto, no están más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar la metodología de diseño o modelado.3.3 Sistemas interpretados Los sistemas interpretados [11, 7] están en poder de muchos como un excelente ejemplo de modelos de sistemas distribuidos computacionalmente fundamentados. Un sistema interpretado se puede definir como una tupla IS = ST1, ..., stk, stenv, r, π. ST1, ..., STK son espacios de estado locales de los agentes 1, ..., K, y Stenv es el conjunto de estados del medio ambiente. El conjunto de estados globales se define como ST = ST1 × ... × STK × STENV;R ⊆ st × st es una relación de transición, y π: π → p (st). Mientras que la relación de transición encapsula la (posible) evolución del sistema a lo largo del tiempo, la dimensión epistémica se define por los componentes locales de cada estado global: Q1, ..., Qk, Qenv ∼i Q1, ..., QK, QenVIFF qi = qi. Es fácil ver que tal representación es modular y compacta en lo que a nosotros nos preocupa los estados. Además, ofrece un enfoque natural (fundamentado) del conocimiento, y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que se representan las transiciones en los sistemas interpretados no es compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición articular, exactamente como en modelos explícitos. Esto no es sin una razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene representación exponencial. Y es casi tan difícil enchufar los componentes dentro y fuera de un sistema interpretado, como para un modelo CTL o ATL ordinario, ya que la actividad local de un agente se fusiona por completo con su interacción con el resto del sistema.3.4 Programas concurrentes La idea de programas concurrentes ha sido conocida durante mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, usamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado PI = STI, ACTI, RI, πi, πi, donde la ITS es el conjunto de estados locales del proceso 4 representación r de un modelo explícito es compactoSi el tamaño de R es logarítmico con respecto al tamaño de M. el sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 899 I, Acti es el conjunto de acciones locales, RI ⊆ STI × Acti × STI es una relación de transición, y πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P viene dado por el autómata del producto de P1, ..., PK bajo el supuesto de que los procesos funcionan de manera asincrónica, las acciones están entrelazadas y la sincronización se obtiene a través de nombres de acción comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (no solo los estados, sino que también las acciones son locales aquí). Además, permiten representar una interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional y la sincronización. Por otro lado, no permiten representar una interacción implícita, incidental o no completamente benevolente entre los procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo que parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Aún así, esta es una queja menor en el contexto de CTL, porque para las lógicas temporales solo estamos interesados en el flujo de transiciones, y no en las acciones subyacentes. Para el razonamiento temporal sobre los procesos asíncronos K sin interacción implícita, los programas concurrentes parecen casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), actuando juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en otros estados de agentes, etc. Pasar mensajes y/o los procedimientos de llamadas de ninguna manera es la única forma de interacción entre los agentes. Además, la disponibilidad de acciones (para un agente) no debe depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo: ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría suponer que los agentes actúan sincrónicamente. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y la autonomía de las acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se parezca mucho a los programas concurrentes, pero que permita modelar agentes que juegan sincrónicamente, y que permita el modelado de una interacción más sofisticada entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo se dirigirá en la Sección 4. Observamos que la comprobación de modelos de CTL contra programas concurrentes es completado con PSPACE en el número de estados locales y la longitud de la fórmula [15].3.5 CP sincrónico y módulos reactivos simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones que actualmente ejecutan los otros jugadores. Se puede definir una variante ligeramente diferente de los programas concurrentes a través del producto sincrónico de programas, de modo que todos los agentes juegan simultáneamente.5 Desafortunadamente, bajo dicha interpretación, no se puede modelar la interacción directa entre las acciones de los agentes. Definición 2. Un programa concurrente sincrónico consiste en k procesos concurrentes PI = STI, Acti, Ri, πi, πi con el siguiente 5 El concepto no es nuevo, por supuesto, y ya ha existido en el conocimiento popular, aunque no logramos encontrar una definición explícita en elliteratura.Inglocando a un CGS: Agt = {1, ..., k}, st = qk i = 1 sti, act = sk i = 1 acti, d (i, q1, ..., qk) = {αi |qi, αi, qi ∈ Ri para algunos qi ∈ STI}, o (Q1, ..., QK, α1, ..., αk) = Q1, ..., QK tal que Qi, αi, qi ∈ Ri paracada yo;Π = sk i = 1 πi, y π (p) = πi (p) para p ∈ πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden verse como una implementación particular de programas concurrentes sincrónicos. Definición 3. Un sistema SRML es una tupla σ, π, m1 ,..., mk, donde σ = {1 ,..., k} es un conjunto de módulos (o agentes), π es un conjunto de variables booleanas y, para cada i ∈ σ, tenemos mi = ctri, initi, updatei, donde ctri ⊆ π. Establece Initi y UpdateI consisten en comandos guardados de la forma φ;V1: = ψ1;...;vk: = ψk, donde cada vj ∈ Ctri, y φ, ψ1 ,..., ψk son fórmulas proposicionales sobre π. Se requiere que CTR1 ,...Particiones CTRK π. La idea es que el agente I controla las variables CTRI. Los comandos Init Protector se utilizan para inicializar las variables controladas, mientras que los comandos de actualización de actualización pueden cambiar sus valores en cada ronda. Se habilita un comando guardado si la guardia φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando guardado de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a VJ. Varios comandos protegidos se habilitan al mismo tiempo de elección del modelo no determinista. La comprobación de modelos de ATL para SRML se ha demostrado que ExptimeMecompletía en el tamaño del modelo y la longitud de la fórmula [22].3.6 Programas epistémicas concurrentes Los programas concurrentes (tanto asíncronos como sincrónicos) pueden usarse para codificar las relaciones epistémicas también, exactamente de la misma manera que los sistemas interpretados [20]. Es decir, al desarrollar un programa concurrente a un modelo de CTLK o Atlir, definimos que Q1, ..., qk ∼i Q1, ..., qk iff qi = qi. Comprobación de modelos CTLK contra programas epistémicos concurrentes es PSPACE-COMPLETO [20]. SRML también se puede interpretar de la misma manera;Luego, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general, son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre explotará el tamaño de dicho programa). Aún así, heredan todos los problemas de los programas concurrentes con información perfecta, discutidas en la Sección 3.4: Interacción limitada entre componentes, disponibilidad de acciones locales que dependen de la transición real, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes solo tienen un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de las lógicas que combinan propiedades estratégicas y epistémicas es la verificación de los protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que deseemos, por ejemplo, verificar la capacidad de los agentes para pasar una información entre ellos, sin dejar que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición;Simplemente buscamos un protocolo en el que nunca se lleva a cabo la transición de una intercepción exitosa. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas de múltiples agentes, y es realmente difícil imaginar modelos de lógicas estratégicas epistémicas, en las que no es posible representar la comunicación.3.7 Módulos reactivos Los módulos reactivos [1] pueden verse como un refinamiento de programas epistémicos concurrentes (utilizados principalmente por el controlador del modelo Mocha [4]), pero son mucho más potentes, expresivos y 900 el sexto INTL. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) fundamentados. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML está muy cerca de las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son solo valoraciones de variables;Los eventos/acciones son actualizaciones variables. Sin embargo, los conjuntos de variables controladas por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de las variables), aunque no es el foco principal de RML. Nuevamente, la relación entre los conjuntos de variables observables (y a los conjuntos de variables controladas) se deja principalmente al diseñador de un sistema. Los agentes pueden actuar sincrónicamente e asincrónicamente. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía existe la necesidad de una clase de representaciones más simple y ligeramente más abstracta. Primero, el marco de RML es técnicamente complicado, que implica un número de conceptos auxiliares y sus definiciones. En segundo lugar, no siempre es conveniente representar todo lo que está sucediendo en un sistema de múltiples agentes como lectura y/o escritura de/a las variables del programa. Esta visión de un sistema de múltiples agentes está posiblemente cerca de su implementación de computadora, pero generalmente bastante distante del dominio del mundo real, por lo tanto, la necesidad de un marco más abstracto y más flexible conceptualmente flexible. Tercero, la separación de la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretados, toma estas observaciones como el punto de partida. El marco propuesto se presenta en la Sección 4. 4. Sistemas interpretados modulares La idea detrás de los sistemas distribuidos (sistemas de múltiples agentes aún más) es que tratamos varios componentes libremente acoplados, donde la mayor parte del procesamiento continúa dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamientoocurre entre los componentes. La interacción es crucial (lo que hace que los programas concurrentes sean una herramienta de modelado insuficiente), pero generalmente consume mucho menos recursos de los agentes que los cálculos locales (lo que hace que las tablas de transición explícitas de CGS, CEG y sistemas interpretados sean excesivos). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control estricto de la complejidad de interacción. Definición 4. Un sistema modular interpretado (MIS) se define como una tupla s = agt, env, actuar, en, donde agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, el acto es un conjunto deAcciones, y en un conjunto de símbolos llamados alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = sti, di, outi, ini, oi, πi, πi, donde: • STI es un conjunto de estados locales, • DI: STI → P (ACT) define la disponibilidad local de acciones;Para conveniencia de la notación, también definimos el conjunto de acciones situadas como di = {qi, α |qi ∈ STI, α ∈ Di (qi)}, • outi, ini son funciones de interacción;Outi: Di → In se refiere a la influencia que una acción situada dada (del Agente AI) posiblemente puede tener en el mundo externo, e ini: STI × Ink → en traduce manifestaciones externas de los otros agentes (y el entorno) en la impresiónque realizan en la función de transición AIS dependiendo del estado local de Ai, • Oi: Di × in → STI es una función de transición local (determinista), • πi es un conjunto de proposiciones locales de agente ai donde requerimos que πi y πjestán disyuntados cuando i = j, y • πi: πi → P (ITS) es una valoración de estas proposiciones. El entorno env = stenv, outenv, inenv, oenv, πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, y que, por lo tanto, outenv: stenv → in y oenv: stenv × in → stenv. Dentro de nuestro marco, suponemos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un MIS como agente, al igual que en el caso de CGS y CEG. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada no parecen ser los puntos frágiles aquí: cuando se dan explícitamente como tablas, tienen WRT exponencial de tamaño.El número de agentes (y WRT lineal del tamaño de In). Sin embargo, podemos usar, por ejemplo, una construcción similar a la de [16] para representar funciones de interacción de manera más compacta. Definición 5. La función de entrada implícita para el estado q ∈ STI viene dada por una secuencia ϕ1, η1, ..., ϕn, ηn, donde cada ηj ∈ en es un símbolo de interacción, y cada ϕJ es una combinación booleana de proposiciones ˆηi, con η ∈ In;ˆΗi significa η es el símbolo actualmente generado por el agente i. La función de entrada ahora se define de la siguiente manera: ini (q, 1, ..., k, env) = ηj iff j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} | = ϕJ. Se requiere que ϕn ≡, de modo que el mapeo sea efectivo. Observación 1. Cada INI puede codificarse como una función de entrada implícita, con cada ϕj de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Tenga en cuenta que, para algunos dominios, la representación MIS de un sistema requiere exponencialmente muchos símbolos en el alfabeto de interacción. En tal caso, el problema es inherente al dominio, e INI tendrá un tamaño exponencial de WRT el número de agentes.4.1 Representar los sistemas de agentes con MIS STG = (QK I = 1 STI) × StenV es el conjunto de todos los estados globales posibles generados por un sistema modular interpretado S. Definición 6. El desarrollo de un mis s para los estados iniciales q ⊆ stg a un cegs cegs (s, q) = agt, st, π, π, act, d, o, ∼1, ..., ∼K se define de la siguiente manera:• AGT = {1, ..., k} y act = Act, • St es el conjunto de estados globales de STG que se pueden accesibles de algún estado en Q a través de la relación de transición definida por O (abajo), • π = SKi = 1 πi ∪ πenv, • para cada q = q1 ,..., qk, qenv ∈ ST e i = 1, ..., k, env, definimos q ∈ π (p) iff p ∈ πi y qi ∈ πi (p), • d (i, q) = di (qi) para el estado global q = q1, ..., qk, qenv, • La función de transición se construye de la siguiente manera. Deje Q = Q1, ..., Qk, Qenv ∈ ST, y α = α1, ..., αK ser un perfil de acción S.T.αi ∈ D (i, Q). Definimos inputi (q, α) = ini `qi, out1 (q1, α1) ,..., outi - 1 (qi - 1, αi - 1), outi+1 (qi+1, αi+1) ,..., Outk (QK, αK), outenv (Qenv) ´ para cada agente i = 1 ,..., k, y inputenv (q, α) = inenv `qenv, out1 (q1, α1) ,..., Outk (QK, αK) ´. Entonces, O (Q, α) = O1 (Q1, α1, Input1 (Q, α)) ,..., OK (QK, αK, InputK (Q, α)), OenV (QENV, InputEnv (Q, α));El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi.6 Observación 2. Tenga en cuenta que Miss puede usarse como representaciones de CGSS también. En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el desarrollo de un error para los estados iniciales Q en un CGS por CGS (S, Q). Las proposiciones 3 y 5 establecen que los sistemas interpretados modulares pueden usarse como representaciones para modelos explícitos de sistemas de agentes múltiples. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las proposiciones 7 y 8. Proposición 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM, tal que CEGS (SM, Q) es isomórfico a M.7 Prueba. Sea M = {1 ,..., k}, st, act, d, o, π, π, ∼1 ,..., ∼K ser un CEGS. Construimos un mis sm = {a1 ,..., ak}, env, actúa, con agentes ai = sti, di, outi, ini, oi, πi, πi y ambiente env = stenv, outenv, inenv, oenv, πenv, πenv, más un conjunto Q ⊆ stg de globalEstados, como sigue.• In = Act ∪ st ∪ (actk - 1 × st), • sti = {[q] ∼i |q ∈ ST} para 1 ≤ i ≤ k (es decir, la ITS es el conjunto de clases de indistinguabilidad IS en m), • stenv = st, • di ([q] ∼i) = d (i, q) para 1 ≤ i≤ k (esto está bien definido ya que d (i, q) = d (i, q) siempre que q ∼i q), • outi ([q] ∼i, αi) = αi para 1 ≤ i ≤ k;outV (q) = q, • ini ([q] ∼i, α1, ..., αi - 1, αi+1, ..., αk, qenv) = α1 ,..., αi - 1, αi+1 ,..., αk, qenv para i ∈ {1 ,..., k};Inenv (Q, α1 ..., αk) = α1 ,..., αk;ini (x) e inenv (x) son arbitrarios para otros argumentos x, • oi ([q] ∼i, αi, α1, ..., αi - 1, αi+1, ..., αk, qenv) =[O (QenV, α1, ..., αk)] ∼i para 1 ≤ i ≤ k y αi ∈ Di ([Q] ∼i);Oenv (Q, α1, ..., αk) = O (Q, α1, ..., αk);OI y OENV son arbitrarios para otros argumentos, • πi = ∅ para 1 ≤ i ≤ k, y πenv = π, • πenv (p) = π (p) • q = {[q] ∼1 ,..., [Q] ∼K, Q: Q ∈ ST} Sea M = Cegs (Sm, Q) = Agt, ST, Act, D, O, π, π, ∼1 ,..., ∼K. Argumentamos que m y Primero mostramos que, para cualquier ˆq = [q] ∼1 ,..., [q] ∼k, q ∈ Q y cualquier α = α1 ,..., αk tal que αi ∈ D (i, ˆq), tenemos o (ˆq, α) = [q] ∼1 ,..., [q] ∼k, q donde q = o (q, α) (1) dejen ˆq = o (ˆq, α). Ahora, para cualquier i: inputi (ˆq, α) = ini ([q] ∼i, out1 ([q] ∼1, α1), ..., outi - 1 ([q] ∼i - 1, αi−1), outi+1 ([Q] ∼i+1, αi+1), ..., Outk ([q] ∼k, αk), outenv (q)) = ini ([q] ∼i, α1.../o acciones ..., αk, q) = α1 ,..., αi - 1, αi+1 ,..., αk, q. Del mismo modo, obtenemos esa entrada (ˆq, α) = α1 ,..., αk. Por lo tanto, obtenemos que O (ˆq, α) = O1 ([Q] ∼1, α1, input1 (ˆq, α)) ,..., OK ([Q] ∼K, αk, inputk (ˆq, α)), Oenv (Q, inputenv (ˆq, α)) = [o (Q, α1, ..., αk)] ∼1 ,..., [O (Q, α1, ..., αk)] ∼K, O (Q, α1, ..., αk). Por lo tanto, ˆq = [q] ∼1 ,..., [Q] ∼K, Q para Q = O (Q, α1, ..., αk), que completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ st. Sea ˆq ∈ ST;Debemos mostrar que ˆq ∈ Q. El argumento está en la inducción en la longitud de la ruta menor O de Q a ˆQ. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = O (ˆq, α) para algunos ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Así, st = Q. Ahora tenemos una correspondencia uno a uno entre ST y ST: R ∈ ST corresponde a [R] ∼1 ,..., [r] ∼k, r ∈ ST. Queda por demostrar que las otras partes de las estructuras mym coinciden en los estados correspondientes: • agt = agt, • act = act, • π = sk i = 1 πi ∪ πenv = π, • para p ∈ π = π: [Q] ∼1 ,..., [q] ∼k, q ∈ π (p) iff q ∈ πenv (p) iff q ∈ π (p) (las mismas valoraciones en los estados correspondientes), • d (i, [q] ∼1, ..,.[Q] ∼k, q) = di ([q] ∼i) = d (i, q), • sigue inmediatamente de (1), y el hecho de que q = st, que o ([q] ∼1, ..., [q] ∼k, q, α) = [r] ∼1 ,..., [r] ∼k, r iff o (q, α) = r (las transiciones en la misma acción conjunta en los estados correspondientes conducen a los estados correspondientes), • [Q] ∼1 ,..., [q] ∼k, q ∼i [r] ∼1 ,..., [r] ∼k, r iff [q] ∼i = [r] ∼i iff q ∼i r (las relaciones de accesibilidad relacionan los estados correspondientes), que completa la prueba. Corolario 4. Para cada CEGS M, hay un error equivalente de Atlir con los estados iniciales Q, es decir, para cada estado Q en M hay un estado Q en CEGS (S, Q) que satisface exactamente las mismas fórmulas de Atlir y viceversa. Proposición 5. Para cada CGS m, hay un mis SM y un conjunto de estados globales Q de SM de modo que CGS (SM, Q) es isomórfico para M. Prueba. Sea M = Agt, St, Act, D, O, π, π. Ahora, deje ˆm = agt, st, act, d, o, π, π, ∼1 ,..., ∼K para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Por la Proposición 3, existe un mis s ˆm con los estados globales Q tal que ˆm = cegs (s ˆm, q) es isomórfico a ˆm. Sea M el CGS obtenido eliminando las relaciones de accesibilidad de ˆm. Claramente, M es isomórfico a M. Corolario 6. Para cada CGS m, hay un error equivalente de ATL con los estados iniciales Q. Es decir, para cada estado Q en M hay un estado Q en CGS (s, Q) que satisface exactamente las mismas fórmulas ATL, y viceversa. Proposición 7. Los espacios de estado local en un MIS no siempre son compactos con respecto a la estructura de juegos epistémico concurrente subyacente. PRUEBA. Tome un CEGS M en el que el agente I siempre tenga información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular s de tal manera que M = CEGS (S, Q), tenemos que la ITS debe ser isomórfica con St. 902 el sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07), la propiedad anterior es parte del patrimonio de sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y los sistemas interpretados) permiten una interacción intensiva entre los agentes. Proposición 8. El tamaño de In in S es, en general, exponencial con respecto al número de estados locales y acciones locales. Este es el caso incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considere un CGS m con agentes agt = {1, ..., k}, estados globales st = qk i = 1 {qi 0, ..., qi i}, y acto de acciones = {0, 1}, todos habilitadosen todos lados. La función de transición se define como O (Q1 J1, ..., QK JK, α1, ..., αk) = Q1 L1, ..., QK LK, donde Li = (Ji + α1 + ... + αK) mod i. Tenga en cuenta que M puede representarse como un sistema interpretado modular con espacios de estado locales sucintos STI = {qi 0, ..., qi i}. Aún así, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos elementos a, outi, ini la capa de interacción de un sistema modular interpretado S;Los otros elementos de S constituyen la capa local del MIS. En este artículo, finalmente estamos interesados en verificar la complejidad del modelo con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinomial en el número de estados y acciones locales. Tenga en cuenta que, según las proposiciones 7 y 8, no todos los modelos explícitos se presentan a la representación compacta con un MIS. Aún así, como declaramos al comienzo de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes libremente acoplados, donde la interacción es esencial, pero la mayoría de los procesos se realizan localmente de todos modos. Más importante aún, el marco de MIS permite separar la interacción de los agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más fina que antes. Primero, podemos tratar de abstrae de la complejidad de una capa (por ejemplo, como en este documento, suponiendo que la otra capa se mantenga dentro de ciertos límites de complejidad). En segundo lugar, también podemos medir por separado la complejidad de interacción de diferentes agentes.4.2 Sistemas interpretados modulares vs. Módulos reactivos simples en esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. Definición 7. Dos representaciones son equivalentes si se desarrollan a las estructuras isomórficas de juegos epistémicos concurrentes. Son equivalentes de CGS si se desarrollan a los mismos CG. Proposición 9. Para cualquier SRML hay un MIS equivalente de CGS. PRUEBA. Considere un SRML R con m módulos y variables N. Construimos s = agt, actuamos, en agt = {a1, ..., ak}, act = {1, ..., n, ⊥1, ..., ⊥n}, y en = sk i =1 STI × STI (la ITS de los espacios de estado locales se definirá en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de I son de tipo γi, ψ: ψ;xi: =, o γ⊥ i, ψ: ψ;xi: = ⊥. Ahora, el agente ai en S tiene los siguientes componentes: STI = P (CTRI) (es decir, los estados locales de AI son valoraciones de variables controladas por I);di (qi) = {1, ..., r, ⊥1, ..., ⊥r};outi (qi, α) = qi, qi;ini (qi, q1, q1, ..., qi - 1, qi - 1, qi+1, qi+1, qk, qk) = {xi ∈ Ctri |Q1, ..., qk | = W γi, ψ ψ}, {xi ∈ Ctri |Q1, ..., qk | = W γ⊥ I, ψ ψ}. Para definir las transiciones locales, consideramos tres casos. Si t = F = ∅ (no se habilita la actualización), entonces Oi (Qi, α, T, F) = Qi para cada acción α. Si t = ∅, tomamos cualquier arbitrary ˆx ∈ T, y definimos oi (qi, j, t, f) = qi ∪ {xj} if xj ∈ T, y qi ∪ ∪ {ˆx} de lo contrario;oi (qi, ⊥j, t, f) = qi \ {xj} if xj ∈ F, y qi ∪ {ˆx} de lo contrario. Además, si t = ∅ = f, tomamos cualquier arbitrary ˆx ∈ F, y definimos oi (qi, j, t, f) = qi ∪ {xj} if xj ∈ T, y qi \ {ˆxx} de lo contrario;oi (qi, ⊥j, t, f) = qi \ {xj} if xj ∈ F, y qi \ {ˆx} de lo contrario. Finalmente, πi = ctri, y qi ∈ πi (xj) iff xj ∈ Qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que las variables locales de MIS del agente, doy lugar a los estados locales 2RI. En cierto modo, los módulos reactivos (tanto simples y completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos;A continuación, cada módulo puede verse como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, tenga en cuenta que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de la longitud total O (2 PK I = 1 RI). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) no más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Observamos finalmente que MIS son más generales, porque en SRML las acciones actuales de otros agentes no tienen influencia en el resultado del agente es la acción actual (aunque el resultado puede verse influenciado por los estados locales actuales de otros agentes).4.3 Comprobación de modelos Sistemas interpretados modulares Uno de nuestros objetivos principales fue estudiar la complejidad del modelo simbólico, comprobación de Atlir de una manera significativa. Siguiendo los comentarios de los revisores, establecemos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. Conjetura 10. La verificación de modelos de ATL para sistemas interpretados modulares es completado. Conjetura 11. La verificación del modelo Atlir para la clase de sistemas interpretados modulares es PSPACE-COMPLETO. En la tabla se proporciona un resumen de los resultados de complejidad para la verificación del modelo de lógica temporal y estratégica (con y sin componente epistémico). La tabla presenta resultados de integridad para varios modelos y configuraciones de parámetros de entrada. Los símbolos N, K, M representan el número de estados, agentes y transiciones en un modelo explícito;L es la longitud de la fórmula, y Nlocal es el número de estados locales en un programa concurrente o sistema modular interpretado. Los nuevos resultados, conjeturados en este documento, se imprimen en cursiva. Tenga en cuenta que el resultado para la verificación del modelo ATL contra sistemas interpretados modulares es una extensión del resultado de [22].M, L N, K, L Nlocal, K, L CTL P [5] P [5] Pspace [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] Exptime Atlir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si somos correctos, entonces los resultados para ATL y ATLIR forman un patrón intrigante. Cuando comparamos los agentes de verificación de modelos con información perfecta versus imperfecta, el primer problema parece ser mucho más fácil con los modelos explícitos medidos con el número de transiciones;A continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes;Finalmente, la comprobación del modelo de información imperfecta resulta más fácil que verificar el modelo de información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se desarrolla en CEG y CG de una manera diferente. En el primer caso, se supone que el MIS codifica las relaciones epistémicas explícitamente (lo que lo hace explotar cuando modelamos a los agentes con información perfecta o casi perfecta). En el último caso, la epistémica la sexta intl. Conf.En los agentes autónomos y los sistemas de múltiples agentes (AAMAS 07) se ignora el aspecto 903, lo que da un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación con el tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales;Para estrategias uniformes, generalmente hay mucho menos de ellas, pero aún así exponencialmente muchas en general. Por lo tanto, el hecho de que las estrategias de información perfectas se puedan sintetizar de manera incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta.5. Conclusiones Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes se pueden cambiar, reemplazar, eliminar o agregar, con la menor cantidad de cambios posible a toda la representación;más compactos que las representaciones explícitas tradicionales;y fundamentados, en el sentido de que las correspondencias entre las primitivas del modelo y las entidades que se modelan son más inmediatas, dando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de la capacidad estratégica de verificación de modelos para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones, propuestas en este documento, no son necesariamente perfectas (por ejemplo, las funciones de impresión que no son la principal fuente de no modularidad en mis, y tal vez se pueden mejorar), pero creemos que son un paso en el paso en eldirección correcta. Tampoco queremos afirmar que nuestras representaciones deberían reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que existe la necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más fácil que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios simples de múltiples agentes, especialmente para el diseño orientado a humanos (en oposición al diseño orientado a la computadora).6. Agradecimientos Agradecemos a los revisores anónimos y Andrzej Tarlecki por sus útiles comentarios. Thomas Ågotnes El trabajo en este documento fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega.7. Referencias [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos formales en el diseño del sistema, 15 (1): 7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica temporal de tiempo alterno. Notas de conferencia en informática, 1536: 23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica temporal de tiempo alterno. Journal of the ACM, 49: 672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de Mocha. En Proceedings of Cav98, Volumen 1427 de las notas de conferencias en informática, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. Sistla. Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones lógicas temporales. Transacciones ACM en lenguajes y sistemas de programación, 8 (2): 244-263, 1986. [6] E.A. Emerson y J.Y. Halpern.A veces y nunca revisado: en ramificación versus lógica temporal de tiempo lineal. En Actas del Simposio ACM anual sobre los principios de los lenguajes de programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ª Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparación de la semántica de la lógica para sistemas de múltiples agentes. Synthese, 139 (2): 241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. Halpern y R. Fagin. Modelado de conocimiento y acción en sistemas distribuidos. Computación distribuida, 3 (4): 159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación del modelo explote (computacionalmente)? En M. P˘Echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de las notas de conferencias en informática, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Modelo de comprobación de agentes: un aspecto más cercano. Presentado, 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: un informe preliminar. Informe técnico IFI-06-15, Universidad Tecnológica de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque teórico de autómata para la verificación del modelo de tiempo de ramificación. Journal of the ACM, 47 (2): 312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS & Ens Cachan, Francia, 2006. [17] K.L. McMillan. Verificación del modelo simbólico: un enfoque para el problema de explosión del estado. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica ilimitada del modelo. En Actas de Cav02, volumen 2404 de las notas de la conferencia en informática, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas de agentes múltiples a través de la verificación del modelo limitado. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press.[20] F. Raimondi y A. Lomuscio. La complejidad del modelo simbólico que verifica lógicas temporal-epistémicas. En L. CZaja, editor, Actas de CS y P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alterno con retiro imperfecto. Notas electrónicas en informática teórica, 85 (2), 2004. [22] W. van der Hoek, A. Lomuscio y M. Wooldridge. Sobre la complejidad de la verificación práctica del modelo ATL. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07)