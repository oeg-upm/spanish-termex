El almacenamiento en caché de la consistencia del contenido dinámico de la base de datos ∗ Niraj Tolia y M. Satyanarayanan Carnegie Mellon University {Ntolia, Satya}@cs.cmu.edu Resumen con el creciente uso de contenido web dinámico generado a partir de dataabases relacionales, soluciones de caché tradicionales para el rendimiento y la latenciaLas mejoras son ineficaces. Describimos una capa de middleware llamada Ganesh que reduce el volumen de datos transmitidos sin interpretación semántica de consultas o resultados. Logra esta reducción mediante el uso de hashing criptográfico para detectar similitudes con resultados anteriores. Estos beneficios no requieren ningún compromiso de la estricta semántica de consistencia proporcionada por la base de datos de back-end. Además, Ganesh no requiere modificaciones a aplicaciones, servidores web o servidores de bases de datos, y funciona con aplicaciones de código cerrado y bases de datos. Utilizando dos puntos de referencia representativos de sitios web dinámicos, las mediciones de nuestro prototipo muestran que puede aumentar el rendimiento de extremo a extremo hasta el doble para aplicaciones intensivas no de datos y hasta diez veces para las de datos intensivos. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: sistemas distribuidos;H.2.4 [Gestión de bases de datos]: Diseño de términos generales de sistemas, rendimiento 1. Introducción Una fracción creciente del contenido web se genera dinámicamente a partir de bases de datos relacionales de fondo. Incluso cuando el contenido de la base de datos permanece sin cambios, la localidad temporal de acceso no puede ser explotada porque el contenido dinámico no se puede almacenar en caché por los navegadores web o por servidores de almacenamiento de almacenamiento intermedio como los espejos de Akamai. En una arquitectura múltiple, cada solicitud web puede enfatizar el enlace WAN entre el servidor web y la base de datos. Esto hace que la experiencia del usuario sea muy variable porque no hay almacenamiento en caché para aislar al cliente de las cargas explosivas. Los intentos anteriores de almacenamiento en caché del contenido de la base de datos dinámica generalmente han debilitado la semántica transaccional [3, 4] o las modificaciones de la aplicación requeridas [15, 34]. Informamos sobre una nueva solución que toma la forma de una capa de middleware de diagnóstico de datos llamada Ganesh. Ganesh no hace ningún esfuerzo para interpretar semánticamente el contenido de las consultas o sus resultados. En cambio, se basa exclusivamente en el hash criptográfico para detectar similitudes con resultados anteriores. La detección de similitud basada en hash ha visto un uso creciente en los sistemas de archivos distribuidos [26, 36, 37] para mejorar el rendimiento en las redes de bajo ancho de banda. Sin embargo, estas técnicas no se han utilizado para bases de datos relacionales. A diferencia de los enfoques anteriores que utilizan métodos genéricos para detectar similitud, Ganesh explota la estructura de los resultados de la base de datos relacional para producir una mejora superior del rendimiento. Uno enfrenta al menos tres desafíos en la aplicación de la detección de similitud basada en el hash a las bases de datos de back-end. Primero, el trabajo previo en este espacio ha visto tradicionalmente el contenido de almacenamiento como bolsas de bits sin interpretación sin estructura interna. Esto permite que las técnicas basadas en el hash funcionen en largas y contiguas ejecuciones de datos para la máxima efectividad. En contraste, las bases de datos relacionales tienen una rica estructura interna que puede no ser tan susceptible de detección de similitud basada en el hash. En segundo lugar, las bases de datos relacionales tienen limitaciones de integridad y consistencia muy estrictas que no deben verse comprometidas por el uso de técnicas basadas en hash. En tercer lugar, el código fuente de bases de datos comerciales generalmente no está disponible. Esto contrasta con el trabajo anterior que presumió disponibilidad del código fuente. Nuestros experimentos muestran que Ganesh, aunque conceptualmente simple, puede mejorar el rendimiento significativamente en los anchos de banda representativos de Internet comercial de hoy. En los puntos de referencia modelando aplicaciones web multisetas, la mejora del rendimiento fue tan alta como diez veces para cargas de trabajo intensivas en datos. Para las cargas de trabajo que no eran intensivas en datos, se observaron mejoras de rendimiento de hasta dos veces. Incluso cuando el ancho de banda no era una restricción, Ganesh tuvo un bajo overos y no dañó el rendimiento. Nuestros experimentos también confirman que explotar la estructura presente en los resultados de la base de datos es crucial para esta mejora del rendimiento.2. Antecedentes 2.1 Generación de contenido dinámico A medida que la red mundial ha crecido, muchos sitios web han descentralizado sus datos y funcionalidad al empujarlos a los bordes de Internet. Hoy en día, los sistemas de ebusiness a menudo usan una arquitectura de tres niveles que consiste en un servidor web frontal, un servidor de aplicaciones y un servidor de base de datos de fondo. La Figura 1 ilustra esta arquitectura. Los dos primeros niveles se pueden replicar cerca de una concentración de clientes en el borde de Internet. Esto mejora la experiencia del usuario al reducir la latencia de extremo a extremo y reducir la exposición www 2007 / seguimiento: rendimiento y escalabilidad Sesión: sistemas escalables para contenido dinámico 311 Back-end de base de datos Servidor front-end servidores Figura 1: arquitectura de múltiples nivelesa la congestión del tráfico de la columna vertebral. También puede aumentar la disponibilidad y la escalabilidad de los servicios web. El contenido que se genera dinámicamente a partir de la base de datos de back-end no se puede almacenar en caché en los dos primeros niveles. Si bien las bases de datos se pueden replicar fácilmente en una LAN, esto es inviable en una WAN debido a la difícil tarea de proporcionar simultáneamente una fuerte consistencia, disponibilidad y tolerancia a las particiones de red [7]. Como resultado, las bases de datos tienden a ser centralizadas para cumplir con los fuertes requisitos de consistencia de muchas aplicaciones de ebusiness, como la banca, las finanzas y la venta minorista en línea [38]. Por lo tanto, la base de datos de fondo generalmente se encuentra lejos de muchos conjuntos de nodos de primer y segundo nivel [2]. En ausencia de almacenamiento en caché y replicación, el ancho de banda WAN puede convertirse fácilmente en un factor limitante en el rendimiento y la escalabilidad de las aplicaciones intensivas en datos.2.2 Los sistemas basados en hash Ganeshs El enfoque está en la transmisión eficiente de los resultados al descubrir similitudes con los resultados de consultas anteriores. Como las consultas SQL pueden generar grandes resultados, las técnicas basadas en hash se prestan bien al problema de transferir eficientemente estos grandes resultados a través de enlaces limitados de ancho de banda. El uso de técnicas basadas en hash para reducir el volumen de datos transmitidos ha surgido como un tema común de muchos sistemas de almacenamiento recientes, como se discutió en la Sección 8.2. Estas técnicas se basan en algunos supuestos básicos. Se supone que las funciones criptográficas hash son resistentes a la colisión. En otras palabras, es computacionalmente intratable encontrar dos entradas que hash a la misma salida. También se supone que las funciones son unidireccionales;Es decir, encontrar una entrada que resulte en una salida específica es computacionalmente inviable. Menezes et al.[23] Proporcione más detalles sobre estos supuestos. Los supuestos anteriores permiten que los sistemas basados en el hash asumen que las colisiones no ocurren. Por lo tanto, pueden tratar el hash de un elemento de datos como su identificador único. Una colección de elementos de datos se vuelve efectivamente en dirección de contenido, lo que permite que un hash pequeño sirva como un código de código para un elemento de datos mucho más grande en el almacenamiento permanente o la transmisión de red. La suposición de que las colisiones son tan raras como para ser efectivamente inexistentes recientemente ha sido criticado [17]. Sin embargo, como explicó Black [5], creemos que estos problemas no forman una preocupación para Ganesh. Toda la comunicación es entre partes de confianza del sistema y un adversario no tiene forma de obligar a Ganesh a aceptar datos no válidos. Además, Ganesh no depende críticamente de ninguna función de hash específica. Si bien actualmente usamos SHA-1, reemplazarlo con una función hash diferente sería simple. No habría impacto en el rendimiento como funciones hash más fuertes (p. SHA256) solo agregue unos pocos bytes adicionales y los hashes generados siguen siendo órdenes de magnitud más pequeñas que los elementos de datos que representan. No se requiere rehacer el almacenamiento permanente ya que Ganesh solo usa hashing en datos volátiles.3. Diseño e implementación Ganesh explota la redundancia en el flujo de resultados para evitar transmitir fragmentos de resultados que ya están presentes en el sitio de la consulta. La redundancia puede surgir naturalmente de muchas maneras diferentes. Por ejemplo, una consulta repetida después de un cierto intervalo puede devolver un resultado diferente debido a las actualizaciones de la base de datos;Sin embargo, puede haber una comunidad significativa entre los dos resultados. Como otro ejemplo, un usuario que está refinando una búsqueda puede generar una secuencia de consultas con resultados superpuestos. Cuando Ganesh detecta la redundancia, suprime la transmisión de los fragmentos de resultados correspondientes. En cambio, transmite un resumen mucho más pequeño de esos fragmentos y permite que el sitio de la consulta reconstruya el resultado a través de la búsqueda hash en un caché de resultados anteriores. En efecto, Ganesh utiliza el cálculo en los bordes para reducir la comunicación por Internet. Nuestra descripción de Ganesh se centra en cuatro aspectos. Primero explicamos nuestro enfoque para detectar la similitud en los resultados de la consulta. A continuación, discutimos cómo la arquitectura Ganesh es completamente invisible para todos los componentes de un sistema de múltiples niveles. Luego describimos el enfoque basado en el poder de Ganeshs y el flujo de datos para detectar similitud.3.1 Detección de similitud Una de las decisiones clave de diseño en Ganesh es cómo se detecta la similitud. Hay muchas formas potenciales de descomponer un resultado en fragmentos. La forma óptima es, por supuesto, la que resulta en el objeto más pequeño posible para la transmisión para los resultados de consultas dados. Encontrar esta descomposición óptima es un problema difícil debido al gran espacio de posibilidades y porque la elección óptima depende de muchos factores, como el contenido del resultado de las consultas, la historia de los resultados recientes y el algoritmo de gestión de caché. Cuando un objeto es opaco, el uso de huellas digitales Rabin [8, 30] para detectar datos comunes entre dos objetos se ha mostrado con éxito en el pasado por sistemas como LBFS [26] y Casper [37]. Rabin huellas dactilares utiliza una ventana deslizante sobre los datos para calcular un hash rodante. Suponiendo que la función hash se distribuye uniformemente, se define un límite de fragmento cada vez que los bits de orden inferior del valor hash son igual a algún valor predeterminado. El número de bits de orden inferior utilizado define el tamaño promedio de la fragmentación. Estos fragmentos subdivididos del objeto se convierten en la unidad de comparación para detectar similitud entre diferentes objetos. Como las ubicaciones de los límites encontrados mediante el uso de huellas digitales Rabin se determinan estocásticamente, generalmente no pueden alinearse con las propiedades estructurales de los datos subyacentes. Por lo tanto, el algoritmo se ocupa de las actualizaciones, inserciones y deleciones en el lugar. Sin embargo, funciona mal en presencia de cualquier reordenamiento de datos. La Figura 2 muestra un ejemplo en el que dos resultados, A y B, que constan de tres filas, tienen los mismos datos pero tienen diferentes atributos de tipo. En el caso extremo, las huellas dactilares de Rabin pueden no poder encontrar datos similares debido a la forma en que detecta los límites del fragmento. Afortunadamente, Ganesh puede usar un conocimiento específico del dominio para una detección de límites más precisa. La información que explotamos es que un resultado de consulta refleja la estructura de una base de datos relacional donde todos los datos están organizados como tablas y filas. Por lo tanto, es simple verificar la similitud con resultados anteriores en dos granularidades: primero todo el resultado y luego las filas individuales. El final de una fila en un resultado sirve como un límite de fragmento natural. Es importante tener en cuenta que el uso de la estructura tabular en los resultados solo implica una interpretación superficial de los datos. Ganesh no realiza ninguna interpretación semántica más profunda, como comprender los tipos de datos, el esquema de resultados o las restricciones de integridad. Sintonizar las huellas dactilares de Rabin para una carga de trabajo también puede ser difícil. Si el tamaño promedio de fragmentos es demasiado grande, los trozos pueden abarcar múltiples filas de resultados. Sin embargo, seleccionar un tamaño de fragmento promedio más pequeño aumenta la cantidad de metadatos requeridos para describir los resultados. WWW 2007 / Track: Sesión de rendimiento y escalabilidad: Sistemas escalables para contenido dinámico 312 Figura 2: Huellas dactilares de Rabin vs. Ganeshs Chunning esto, a su vez, disminuiría los ahorros obtenidos a través de su uso. La huella digital de Rabin también necesita dos pases de costo computacional sobre los datos: una vez para determinar los límites de fragmentos y uno nuevamente para generar hashes criptográficos para los trozos. Ganesh solo necesita un solo pase para la generación hash, ya que la estructura natural de los datos proporciona los límites del fragmento. La comparación de rendimiento en la Sección 6 muestra que el algoritmo basado en la fila de Ganesh supera a las huellas dactilares de Rabin. Dado que el trabajo anterior ya ha demostrado que la huella digital de Rabin funciona mejor que GZIP [26], no comparamos los algoritmos de compresión Ganesh en este documento.3.2 Transparencia El factor clave que influyó en nuestro diseño fue la necesidad de que Ganesh fuera completamente transparente para todos los componentes de un sistema de ebusiness típico: servidores web, servidores de aplicaciones y servidores de bases de datos. Sin esto, Ganesh tiene pocas posibilidades de tener un impacto significativo en el mundo real. Requerir modificaciones a cualquiera de los componentes anteriores elevaría la barrera para la entrada de Ganesh en un sistema existente y, por lo tanto, reduciría sus posibilidades de adopción. Preservar la transparencia se simplifica por el hecho de que Ganesh es puramente una mejora del rendimiento, no una funcionalidad o mejora de la usabilidad. Elegimos la interposición del agente como el enfoque arquitectónico para realizar nuestro objetivo. Este enfoque se basa en la existencia de una interfaz de programación compacta que ya es ampliamente utilizada por el software Target. También se basa en un mecanismo para agregar fácilmente un nuevo código sin interrumpir la estructura del módulo existente. Estas condiciones se cumplen fácilmente en nuestro contexto debido a la popularidad de Java como el lenguaje de programación para los sistemas de ébase. La API de conectividad de base de datos Java (JDBC) [32] permite que las aplicaciones Java accedan a una amplia variedad de bases de datos e incluso otros repositorios de datos tabulares, como archivos planos. El acceso a estas fuentes de datos es proporcionado por los controladores JDBC que se traducen entre la API JDBC y el mecanismo de comunicación de la base de datos. La Figura 3 (a) muestra cómo JDBC se usa típicamente en una aplicación. Como la interfaz JDBC está estandarizada, uno puede sustituir un controlador JDBC por otro sin modificaciones de aplicación. El controlador JDBC se convierte así en el módulo natural para explotar para la interposición del código. Como se muestra en la Figura 3 (b), el controlador JDBC nativo se reemplaza con un controlador JDBC Ganesh que presenta la misma interfaz estandarizada. El controlador Ganesh mantiene un alijo en memoria de fragmentos de resultados de consultas anteriores y realiza un reensamblaje de resultados. En la base de datos, agregamos un nuevo proceso llamado proxy de Ganesh. Este proxy, que puede ser compartido por múltiples nodos frontales, consta de dos partes: código para detectar similitud en los fragmentos de resultados y el controlador JDBC nativo original que se comunica con la base de datos. El uso de un proxy en la base de datos hace que la base de datos Ganesh sea agnóstica y simplifica la prototipos y la experimentación. Por lo tanto, Ganesh puede trabajar con una amplia gama de bases de datos y aplicaciones, que no requiere modificaciones a ninguno de los dos.3.3 El almacenamiento en caché basado en el proxy El controlador JDBC nativo que se muestra en la Figura 3 (a) es un componente de código ligero suministrado por el proveedor de la base de datos. Su principal base de datos Funclient Web y el servidor de aplicaciones Native JDBC Wan (a) Arquitectura nativa Base de datos de clientes Ganesh Proxy JDBC JDBC Wan Wan Wan y Servidor de aplicaciones Ganesh JDBC Driver (B) Ganeshs Arquitectura basada en la interposición Figura 3: Native vs. Ganesh arquitectura es IS es espara mediar la comunicación entre la aplicación y la base de datos remota. Reenvía consultas, amortigua los resultados completos y responde a las solicitudes de aplicación para ver partes de los resultados. El controlador Ganesh JDBC que se muestra en la Figura 3 (b) presenta la aplicación con una interfaz idéntica a la proporcionada por el controlador nativo. Proporciona la capacidad de reconstruir los resultados de las descripciones compactas basadas en hash enviadas por el proxy. Para realizar esta reconstrucción, el conductor mantiene un caché en memoria de resultados recientemente recientemente recientemente. Este caché solo se usa como fuente de fragmentos de resultados en la reconstrucción de resultados. El controlador o proxy de Ganesh no se intenta para rastrear las actualizaciones de la base de datos. La falta de consistencia del caché no perjudica la corrección ya que una descripción de los resultados siempre se obtiene del proxy; en el peor de los casos, no habrá beneficio de rendimiento al usar Ganesh. Los datos obsoletos simplemente se superarán del caché con el tiempo. El proxy Ganesh accede a la base de datos a través del controlador JDBC nativo, que permanece sin cambios entre las Figuras 3 (a) y (b). La base de datos no se da cuenta de la existencia del proxy. El proxy no examina ninguna consulta recibida del conductor de Ganesh, sino que las pasa al conductor nativo. En cambio, el proxy es responsable de inspeccionar la salida de la base de datos recibida del controlador nativo, detectar resultados similares y generar codificaciones basadas en hash de estos resultados cuando se encuentra suficiente similitud. Si bien esta arquitectura no disminuye la carga en una base de datos, como se mencionó anteriormente en la Sección 2.1, es mucho más fácil replicar las bases de datos para la escalabilidad en una LAN que en una WAN. Para generar una codificación basada en hash, el proxy debe ser consciente de qué fragmentos de resultados están disponibles en el caché de controladores Ganesh. Un enfoque es ser optimista y suponer que todos los fragmentos de resultados están disponibles. Esto dará como resultado la transmisión inicial más pequeña posible de un resultado. Sin embargo, en los casos en que hay poca superposición con los resultados anteriores, el conductor de Ganesh tendrá que hacer muchas llamadas al poder durante la reconstrucción para obtener fragmentos de resultados faltantes. Para evitar esta situación, el proxy rastrea libremente el estado de la caché de los conductores de Ganesh. Dado que ambos componentes están bajo nuestro control, es relativamente simple hacerlo sin recurrir a técnicas de cajas grises o comunicación explícita para mantener la coherencia de la caché. En cambio, el proxy simula el algoritmo de gestión de caché de los controladores de Ganesh y usa esto para mantener una lista de hashes para los cuales el conductor de Ganesh probablemente posee los fragmentos de resultados. En el caso de la tracking, no habrá pérdida de corrección, pero habrá retrasos adicionales de ida y vuelta para obtener los fragmentos faltantes. Si el cliente detecta la pérdida de sincronización con el proxy, puede pedirle al proxy que restablezca el estado compartido entre ellos. También tenga en cuenta que el proxy no necesita mantener los fragmentos de resultados ellos mismos, solo sus hashes. Esto permite que el proxy permanezca escalable incluso cuando es compartido por muchos nodos frontales. Www 2007 / rastreando: rendimiento y escalabilidad Sesión: sistemas escalables para contenido dinámico 313 SALIDA DE OBJETIVO Convertir Resultset Objeto de entrada Flujo Convertir el conjunto de resultados Todos los datos Receta de datos All Data ResultSet Network Ganesh Proxy Ganesh JDBC Conjunto Conjunto de resultados Conjunto de resultados Conjunto de resultados Sí Sí No No GaneshinputStream GaneshoutputStreamFigura 4: Flujo de datos para el manejo de resultados 3.4 Resultados de codificación y decodificación El proxy de Ganesh recibe la salida de la base de datos como objetos Java del controlador JDBC nativo. Examina esta salida para ver si está presente un objeto Java de Tipo de resultado. La interfaz JDBC utiliza este tipo de datos para almacenar los resultados de las consultas de la base de datos. Si se encuentra un objeto de conjunto de resultados, se reduce como se discute a continuación. Todos los demás objetos Java se pasan a través de no modificados. Como se discutió en la Sección 3.1, el proxy utiliza los límites de fila definidos en el conjunto de resultados para dividirlo en fragmentos que consisten en filas de resultados únicos. Todos los objetos del conjunto de resultados se convierten en objetos de un nuevo tipo llamado ReciperSultSet. Utilizamos el término receta para esta descripción compacta de un resultado de la base de datos debido a su similitud con una receta de archivo en el sistema de archivos CASPER [37]. La conversión reemplaza a cada fragmento de resultados que probablemente esté presente en el caché de los conductores de Ganesh por un hash SHA-1 de ese fragmento. Los fragmentos de resultados previamente invisibles se conservan textualmente. El proxy también conserva los hash para los nuevos fragmentos de resultados, ya que estarán presentes en el caché de los conductores en el futuro. Tenga en cuenta que el proxy solo almacena hash para los fragmentos de resultados y no almacena recetas de almacenamiento en caché. El proxy construye un conjunto de recetas al verificar la similitud en todo el resultado y luego el nivel de fila. Si se predice que todo el resultado estará presente en el caché de los controladores de Ganesh, el receptor de la venta es simplemente un hash único de todo el resultado. De lo contrario, contiene hashes para las filas previstas que están presentes en ese caché;Todas las demás filas se conservan textualmente. Si el proxy estima un ahorro de espacio general, transmitirá el receptor de la venta. De lo contrario, se transmite el conjunto de resultados original. Los objetos ReciperSultSet se transforman nuevamente en los objetos de resultados de resultados por el controlador Ganesh. La Figura 4 ilustra el manejo del conjunto de resultados en ambos extremos. Cada hash SHA-1 que se encuentra en un conjunto de recetas de Cache de fragmentos de resultados locales. En un golpe, el hash se reemplaza por el fragmento correspondiente. En una falla, el conductor contacta al poder de Ganesh para buscar el fragmento. Todos los fragmentos de resultados previamente invisibles que el proxy se retuvo a pie por el proxy y se agregan al caché de resultados. Debería haber muy pocas fallas si el proxy ha rastreado con precisión el estado de caché de los conductores Ganesh. Una optimización futura sería lanzar la obtención de fragmentos faltantes. Esto sería valioso cuando hay muchos pequeños fragmentos faltantes en una WAN de alta latencia. Una vez que se completa la transformación, el objeto de conjunto de resultados totalmente reconstruido se transmite a la aplicación.4. Validación experimental Tres preguntas se deducen de los objetivos y el diseño de Ganesh: • Primero, ¿se puede mejorar significativamente al explotar la similitud entre los resultados de la base de datos? Detalles del conjunto de datos de referencia 500,000 usuarios, 12,000 historias Bboard 2.0 GB 3,298,000 Comentarios Subasta 1.3 GB 1,000,000 Usuarios, 34,000 elementos Tabla 1: Detalles del conjunto de datos de referencia • Segundo, ¿qué tan importante es la detección de similitud estructural de Ganeshs relativo a las huellas dedo de Rabin Detección de similitud?• Tercero, ¿es aceptable la sobrecarga del diseño basado en el poder? Nuestra evaluación responde a estas preguntas a través de experimentos controlados con el prototipo Ganesh. Esta sección describe los puntos de referencia utilizados, nuestro procedimiento de evaluación y la configuración experimental. Los resultados de los experimentos se presentan en las Secciones 5, 6 y 7. 4.1 puntos de referencia Nuestra evaluación se basa en dos puntos de referencia [18] que otros investigadores han utilizado ampliamente para evaluar varios aspectos de las arquitecturas de múltiples niveles y ebusiness [9]. El primer punto de referencia, Bboard, se modela después de Slashdot, un sitio de noticias orientado a la tecnología. El segundo punto de referencia, la subasta, se modela después de eBay, un sitio de subastas en línea. En ambos puntos de referencia, la mayoría del contenido se genera dinámicamente a partir de la información almacenada en una base de datos. Los detalles de los conjuntos de datos utilizados se pueden encontrar en la Tabla 1. 4.1.1 El punto de referencia Bboard El punto de referencia Bboard, también conocido como Rubbos [18], Models Slashdot, un sitio web popular orientado a la tecnología. SlashDot agregue los enlaces a noticias y otros temas de interés que se encuentran en otras partes de la web. El sitio también sirve como un tablón de anuncios al permitir a los usuarios comentar las historias publicadas en un formulario de conversación enhebrada. No es raro que una historia reúna cientos de comentarios en cuestión de horas. El punto de referencia Bboard es similar al sitio y modela las actividades de un usuario, incluidas las operaciones de lectura, como navegar por las historias del día, navegar por las categorías de historias y ver comentarios, así como operaciones de escritura, como el registro de nuevos usuarios, agregar y moderar comentarios.y sumisión de historia. El punto de referencia consta de tres fases diferentes: una fase de calentamiento corta, una fase de tiempo de ejecución que representa el cuerpo principal de la carga de trabajo y una fase de enfriamiento corta. En este artículo solo informamos los resultados de la fase de tiempo de ejecución. La fase de calentamiento es importante para establecer el estado del sistema dinámico, pero las mediciones de esa fase no son significativas para nuestra evaluación. La fase de enfriamiento es únicamente para permitir que el punto de referencia se cierre. El calentamiento, el tiempo de ejecución y las fases de enfriamiento son 2, 15 y 2 minutos respectivamente. El número de clientes simulados fue 400, 800, 1200 y 1600. El punto de referencia está disponible en una versión de Java Servlets y PHP y tiene diferentes conjuntos de datos;Evaluamos a Ganesh usando la versión Java Servlets y el conjunto de datos expandido. El punto de referencia Bboard define dos cargas de trabajo diferentes. El primero, la mezcla de autor, consta de operaciones de solo lectura del 70% y el 30% de operaciones de lectura-escritura. El segundo, la mezcla de navegación, contiene solo operaciones de solo lectura y no actualiza la base de datos.4.1.2 El punto de referencia de la subasta El punto de referencia de la subasta, también conocido como Rubis [18], Models eBay, el sitio de subastas en línea. El sitio web de eBay se utiliza para comprar y vender artículos a través de un formato de subasta. Las principales actividades de un usuario incluyen navegar, vender o ofertar por artículos. Modelado las actividades en este sitio, este punto de referencia incluye actividades de solo lectura, como los elementos de navegación por categoría y por región, así como lectura-escritura www 2007 / pista: sesión de rendimiento y escalabilidad: sistemas escalables para contenido dinámico 314 netem enrutador ganesh proxyCLIENTES SERVICIO DE BASE DE LA WEB y APLICACIÓN SERVICIO Figura 5: Actividades de configuración experimentales, como ofertar por artículos, comprar y vender artículos, y dejar comentarios. Al igual que con Bboard, el punto de referencia consta de tres fases diferentes. Las fases de calentamiento, tiempo de ejecución y enfriamiento para este experimento son 1.5, 15 y 1 minutos respectivamente. Probamos a Ganesh con cuatro configuraciones de clientes donde el número de clientes de prueba se estableció en 400, 800, 1200 y 1600. El punto de referencia está disponible en un Enterprise Java Bean (EJB), Servlets Java y la versión PHP y tiene diferentes conjuntos de datos;Evaluamos a Ganesh con la versión Java Servlets y el conjunto de datos ampliado. El punto de referencia de subastas define dos cargas de trabajo diferentes. El primero, la mezcla de ofertas, consta de operaciones de solo lectura del 70% y del 30% de operaciones de lectura-escritura. El segundo, la mezcla de navegación, contiene solo operaciones de solo lectura y no actualiza la base de datos.4.2 Procedimiento experimental Ambos puntos de referencia implican una carga de trabajo sintética de clientes que acceden a un servidor web. El número de clientes emulados es un parámetro experimental. Cada cliente emulado ejecuta una instancia del punto de referencia en su propio hilo, utilizando una matriz para hacer la transición entre diferentes estados de referencia. La matriz define un modelo estocástico con probabilidades de transición entre los diferentes estados que representan acciones de usuario típicas. Una transición de ejemplo es un usuario que inicia sesión en el sistema de subastas y luego decide si debe publicar un artículo para la venta o ofertar en subastas activas. Cada cliente también modela el tiempo de pensamiento del usuario entre solicitudes. El tiempo de Think se modela como una distribución exponencial con una media de 7 segundos. Evaluamos a Ganesh a lo largo de dos ejes: número de clientes y ancho de banda WAN. Las cargas más altas son especialmente útiles para comprender el rendimiento de Ganeshs cuando la CPU o el disco del servidor de la base de datos o proxy es el factor limitante. Un estudio anterior ha demostrado que aproximadamente el 50% de los cuellos de botella de Internet de área amplia observados tenían un ancho de banda disponible por debajo de 10 MB/s [1]. Según este trabajo, centramos nuestra evaluación en el ancho de banda WAN de 5 MB/s con 66 ms de latencia de ida y vuelta, representante de rutas de red severamente limitadas y 20 MB/s con 33 ms de latencia de viaje redondo, representante deuna ruta de red moderadamente limitada. También informamos el rendimiento de Ganeshs a 100 MB/s sin latencia de ida y vuelta agregada. Este ancho de banda, representativo de una red no restringida, es especialmente útil para revelar cualquier potencial de Ganesh en situaciones donde el ancho de banda WAN no es el factor limitante. Para cada combinación de número de clientes y ancho de banda WAN, medimos los resultados de las dos configuraciones enumeradas a continuación: • Nativo: esta configuración corresponde a la Figura 3 (a). Native evita a Ganeshs sobre la cabeza en el uso de un proxy y la realización de objetos de Java.• Ganesh: esta configuración corresponde a la Figura 3 (b). Para un número determinado de clientes y ancho de banda WAN, la comparación de estos resultados con los resultados nativos correspondientes ofrece el beneficio de rendimiento debido al sistema de middleware Ganesh. La métrica utilizada para cuantificar la mejora en el rendimiento es el número de solicitudes de clientes que pueden ser atendidas por segundo. La métrica utilizada para cuantificar la sobrecarga de Ganeshs es el tiempo de respuesta promedio para una solicitud del cliente. Para todos los experimentos, el controlador Ganesh utilizado por el servidor de aplicaciones utilizó un tamaño de caché de 100,000 elementos1. El proxy fue efectivo para rastrear el estado de caché de los conductores Ganesh;Para todos nuestros experimentos, la tasa de fallas en el conductor nunca excedió el 0.7%.4.3 Configuración experimental La configuración experimental utilizada para los puntos de referencia se puede ver en la Figura 5. Todas las máquinas eran Pentium 4S de 3.2 GHz (con hyperthreading habilitado). Con la excepción del servidor de la base de datos, todas las máquinas tenían 2 GB de SDRAM y ejecutaban la distribución Fedora Core Linux. El servidor de la base de datos tenía 4 GB de SDRAM. Utilizamos Apaches Tomcat como el servidor de aplicaciones que alojó los servlets Java y el servidor web. Ambos puntos de referencia utilizaron servlets Java para generar el contenido dinámico. El servidor de la base de datos utilizó la base de datos MySQL de código abierto. Para los controladores JDBC nativos, utilizamos los controladores Connector/J proporcionados por MySQL. El servidor de aplicaciones utilizó Suns Java Virtual Machine como el entorno de tiempo de ejecución para los servlets Java. La herramienta SysStat se utilizó para monitorear la CPU, la red, el disco y la utilización de la memoria en todas las máquinas. Las máquinas estaban conectadas por una red de Gigabit Ethernet conmutada. Como se muestra en la Figura 5, la web y el servidor de aplicaciones frontal se separaron del servidor proxy y de la base de datos por un enrutador Netem [16]. Este enrutador nos permitió controlar el ancho de banda y la configuración de latencia en la red. El enrutador Netem es una PC estándar con dos tarjetas de red que ejecutan el software de control de tráfico y emulación de red de Linux. El ancho de banda y las restricciones de latencia solo se aplicaron al enlace entre el servidor de aplicaciones y la base de datos para el caso nativo y entre el servidor de aplicaciones y el proxy para el caso Ganesh. No hay comunicación entre el servidor de aplicaciones y la base de datos con Ganesh a medida que todos los datos fluyen a través del proxy. Como nuestro enfoque estaba en el enlace WAN entre el servidor de aplicaciones y la base de datos, no había restricciones en el enlace entre los clientes de prueba simulados y el servidor web.5. Tiempo de rendimiento y respuesta En esta sección, abordamos la primera pregunta planteada en la Sección 4: ¿Puede el rendimiento se puede mejorar significativamente al explotar la similitud entre los resultados de la base de datos? Para responder a esta pregunta, utilizamos los resultados del bordero y los puntos de referencia de subastas. Utilizamos dos métricas para cuantificar la mejora del rendimiento que se puede obtener mediante el uso de Ganesh: rendimiento, desde la perspectiva del servidor web y el tiempo de respuesta promedio, desde la perspectiva del cliente. El rendimiento se mide en términos de la cantidad de solicitudes de clientes que pueden ser atendidas por segundo.5.1 Resultados y análisis de bordero 5.1.1 Autorando las Figuras de la mezcla 6 (a) y (b) presentan el número promedio de solicitudes atendidas por segundo y el tiempo de respuesta promedio para estas solicitudes según lo perciben los clientes para la mezcla de autor de los clientes. Como muestra la Figura 6 (a), el nativo satura fácilmente el enlace de 5 MB/S. Con 400 clientes, la solución nativa ofrece 29 solicitudes/seg con un tiempo de respuesta promedio de 8.3 segundos. El rendimiento de los nativos cae con un aumento en los clientes de prueba como tiempo de espera de los clientes debido a la congestión en el servidor de aplicaciones. Los estudios de usabilidad han demostrado que los tiempos de respuesta superiores a los 10 segundos hacen que el usuario pase a 1 ya que Java carece de un operador sizeOf (), los cachés de Java limitan su tamaño en función de la cantidad de objetos. El tamaño de los vertederos de caché tomados al final de los experimentos nunca excedió los 212 MB. WWW 2007/Track: Rendimiento y escalabilidad Sesión: Sistemas escalables para contenido dinámico 315 0 50 100 150 200 250 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S Solicitudes de clientes de prueba/Sec Native Ganesh 0.001 0.01 0.1 1 10 100 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S CLIENTES DE PRUEBA AVG.Rendimiento: Mezcla de autor (b) Tiempo de respuesta: Mezcla de autoría 0 50 100 150 200 250 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S Solicitudes de clientes de prueba/SEC Native Ganesh 0.000010.01 0.1 1 10 100 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S CLIENTES DE PRUEBA AVG.(d) Tiempo de respuesta: Media de mezcla de navegación de tres ensayos. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue del 9.8% y el 11.9% de la media correspondiente. Figura 6: punto de referencia Bboard: rendimiento y tiempo de respuesta promedio otras tareas [24]. Según estos números, aumentar el número de clientes de prueba hace que el sistema nativo sea inutilizable. Sin embargo, Ganesh a 5 MB/s ofrece una mejora doble con 400 clientes de prueba y una mejora de cinco veces a 1200 clientes. El rendimiento de Ganeshs cae ligeramente a 1200 y 1600 clientes, ya que la red está saturada. En comparación con los nativos, la Figura 6 (b) muestra que los tiempos de respuesta de Ganeshs son sustancialmente más bajos con los tiempos de respuesta subsecondios a 400 clientes. La Figura 6 (a) también muestra que para 400 y 800 clientes de prueba Ganesh a 5 MB/s tienen el mismo rendimiento y tiempo de respuesta promedio que nativo a 20 MB/s. Solo a 1200 y 1600 clientes nativos a 20 MB/s ofrecen un rendimiento más alto que Ganesh a 5 MB/s. Comparando tanto a Ganesh como a nativo a 20 MB/s, vemos que Ganesh ya no está limitado y ofrece una mejora doble sobre nativo en 1600 clientes de prueba. Como Ganesh no satura la red con configuraciones de clientes de prueba más alta, a 1600 clientes de prueba, su tiempo de respuesta promedio es de 0.1 segundos en lugar de nativos 7.7 segundos. Como se esperaba, no hay ganancias visibles de Ganesh en el mayor ancho de banda de 100 MB/s, donde la red ya no es el cuello de botella. Ganesh, sin embargo, todavía rastrea nativo en términos de rendimiento.5.1.2 Figuras de mezcla de navegación 6 (c) y (d) Presentan el número promedio de solicitudes atendidas por segundo y el tiempo de respuesta promedio para estas solicitudes según lo perciben los clientes para la mezcla de navegación de Bboards. Independientemente de la configuración del cliente de prueba, la Figura 6 (c) muestra que el rendimiento de los nativos a 5 MB/s está limitado a 10 reqs/seg. Ganesh a 5 MB/s con 400 clientes de prueba, ofrece más de un aumento de seis veces en el rendimiento. La mejora aumenta a un aumento de once veces a los 800 clientes de prueba antes de que Ganesh sature la red. Además, la Figura 6 (d) muestra que el tiempo de respuesta promedio de los nativos de 35 segundos a 400 clientes de prueba hace que el sistema sea inutilizable. Estos altos tiempos de respuesta aumentan aún más con la adición de clientes de prueba. Incluso con la configuración del cliente de la prueba 1600, Ganesh ofrece un tiempo de respuesta promedio aceptable de 8.2 segundos. Debido a la naturaleza intensiva de datos de la mezcla de navegación, Ganesh a 5 MB/s sorprendentemente funciona mucho mejor que el nativo a 20 MB/s. Además, como se muestra en la Figura 6 (d), mientras que el tiempo de respuesta promedio para nativo a 20 MB/s es aceptable a 400 clientes de prueba, no es utilizado con 800 clientes de prueba con un tiempo de respuesta promedio de 15.8 segundos. Al igual que el caso de 5 MB/S, este tiempo de respuesta aumenta con la adición de clientes de prueba adicionales. Ganesh a 20 MB/s y tanto nativo como Ganesh a 100 MB/s no tienen un ancho de banda limitado. Sin embargo, el rendimiento se saturó después de 1200 clientes de prueba debido a que la CPU de la base de datos está saturada.5.1.3 Variante del filtro Nos sorprendió el rendimiento nativo del punto de referencia Bboard. En el ancho de banda de 5 MB/s, el rendimiento nativo fue más bajo de lo que esperábamos. Resultó que el código de referencia que muestra historias lee todos los comentarios asociados con la historia particular de la base de datos y solo entonces hizo algún postprocesamiento para seleccionar los comentarios que se mostrarán. Si bien este es exactamente el comportamiento de SlashCode, la base de código detrás del sitio web de Slashdot, decidimos modificar el punto de referencia para realizar un poco de filtrado en la base de datos. Este punto de referencia modificado, llamado la variante de filtro, modela un desarrollador que aplica optimizaciones a nivel SQL para transferir menos datos. En aras de la brevedad, solo resumimos brevemente los resultados de la mezcla de autoridad. Para la mezcla de autoridad, a 800 clientes de prueba a 5 MB/s, la Figura 7 (a) muestra que el rendimiento de los nativos aumenta en un 85% en comparación con el punto de referencia original, mientras que la mejora de Ganeshs es menor con un 15%. El rendimiento de los nativos cae por encima de los 800 clientes a medida que los clientes de la prueba tienen tiempo para el tiempo debido a los altos tiempos de respuesta. La ganancia más significativa para nativa se observa a 20 MB/s. Con 1600 clientes de prueba, en comparación con el punto de referencia original, Native ve una mejora del 73% en el rendimiento y una reducción del 77% en el tiempo de respuesta promedio. Mientras que www 2007/seguimiento: rendimiento y escalabilidad Sesión: sistemas escalables para contenido dinámico 316 0 50 100 150 200 250 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S Solicitudes de clientes de prueba/seg nativo Ganesh 0.001 0.01 0.1 1 10 100 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S CLIENTES DE PRUEBA DE) Rendimiento: mix de autor (b) Tiempo de respuesta: media de la mezcla de autor de tres ensayos. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue de 7.2% y 11.5% de la media correspondiente. Figura 7: Benchmark Bboard - Variante de filtro - Rendimiento y tiempo de respuesta promedio que Ganesh no ve una mejora en comparación con el original, todavía procesa un 19% más de solicitudes/seg que nativas. Por lo tanto, si bien las optimizaciones fueron más útiles para los nativos, Ganesh aún ofrece una mejora en el rendimiento.5.2 Resultados y análisis de la subasta 5.2.1 Bid de la mezcla de la mezcla 8 (a) y (b) presentan el número promedio de solicitudes atendidas por segundo y el tiempo de respuesta promedio para estas solicitudes según lo perciben los clientes para la mezcla de ofertas de subastas. Como se mencionó anteriormente, la mezcla de ofertas consiste en una mezcla de operaciones de lectura y escritura. El punto de referencia de subastas no es tan intensivo en los datos como Bboard. Por lo tanto, la mayoría de las ganancias se observan en el ancho de banda inferior de 5 MB/s. La Figura 8 (a) muestra que el aumento en el rendimiento debido a Ganesh varía del 8% a los 400 clientes de prueba al 18% con 1600 clientes de prueba. Como se ve en la Figura 8 (b), los tiempos de respuesta promedio para Ganesh son significativamente más bajos que los nativos que van desde una disminución del 84% a los 800 clientes de prueba hasta 88% a los clientes de prueba de 1600. La Figura 8 (a) también muestra que con un aumento cuatro veces del ancho de banda de 5 MB/s a 20 MB/s, el nativo ya no está limitado y no hay diferencia de rendimiento entre Ganesh y Native. Con las configuraciones del cliente de prueba más alta, observamos que el ancho de banda utilizado por Ganesh era más bajo que el nativo. Ganesh podría ser útil en estos escenarios no restringidos si el ancho de banda se compra de forma medida. Se observan resultados similares para el escenario de 100 MB/s.5.2.2 Mezcla de navegación para subastas Mezcla de navegación, Figuras 8 (c) y (d) presentan el número promedio de solicitudes atendidas por segundo y el tiempo de respuesta promedio para estas solicitudes según lo perciben los clientes. Nuevamente, la mayoría de las ganancias se observan en anchos de banda más bajos. A 5 MB/s, Native y Ganesh ofrecen tiempos de rendimiento y respuesta similares con 400 clientes de prueba. Si bien el rendimiento para ambos sigue siendo el mismo en 800 clientes de prueba, la Figura 8 (d) muestra que el tiempo de respuesta promedio de Ganeshs es 62% más bajo que el nativo. Nativo satura el enlace a 800 clientes y agregar clientes de prueba adicionales solo aumenta el tiempo de respuesta promedio. Ganesh, independientemente de la configuración del cliente de prueba, no se limita al ancho de banda y mantiene el mismo tiempo de respuesta. En 1600 clientes de prueba, la Figura 8 (c) muestra que el rendimiento de Ganeshs es casi el doble que el nativo. En los anchos de banda más altos de 20 y 100 MB/s, ni Ganesh ni Native son un ancho de banda limitado y ofrecen tiempos de rendimiento y respuesta equivalentes. Benchmark Orig. Tamaño Ganesh Tamaño Rabin Tamaño SelectSort1 223.6 MB 5.4 MB 219.3 MB SelectSort2 223.6 MB 5.4 MB 223.6 MB Tabla 2: Microbistios de similitud 6. Estructural vs.La similitud de Rabin En esta sección, abordamos la segunda pregunta planteada en la Sección 4: ¿Qué tan importante es la detección de similitud estructural de Ganeshs en relación con la detección de similitud basada en huellas dactilares de Rabin? Para responder a esta pregunta, utilizamos MicrobenchMigns y los puntos de referencia Bboard y Subasta. Como Ganesh siempre funcionó mejor que las huellas dactilares de Rabin, solo presentamos un subconjunto de los resultados aquí en interés de la brevedad.6.1 Microbenchmars Dos microbistres muestran un ejemplo de los efectos de la reordenamiento de datos en el algoritmo de huellas dactilares de Rabin. En el primer Microbenchmark, SelectSort1, una consulta con una orden de clasificación especificada selecciona 223.6 MB de datos distribuidos en aproximadamente 280 K filas. La consulta se repite con un atributo de tipo diferente. Si bien se devuelven el mismo número de filas y los mismos datos, el orden de las filas es diferente. En tal escenario, uno esperaría que se detecte una gran cantidad de similitud entre ambos resultados. Como muestra la Tabla 2, el algoritmo basado en la fila de Ganeshs logra una reducción del 97.6%, mientras que el algoritmo de huellas dactilares de Rabin, con el parámetro promedio de tamaño de fragmento establecido en 4 KB, solo logra una reducción del 1%. La razón, como se muestra anteriormente en la Figura 2, es que con las huellas dactilares de Rabin, los tramos de datos entre dos límites consecutivos generalmente cruzan los límites de la fila. Con el orden de las filas que cambian en el segundo resultado y las huellas digitales de Rabin ahora abarcan diferentes filas, el algoritmo no puede detectar una similitud significativa. La pequeña ganancia vista es principalmente para aquellas filas individuales que son lo suficientemente grandes como para romperse en múltiples trozos. SelectSort2, otro micro-benchmark ejecutó las mismas consultas pero aumentó el tamaño mínimo de la fragmentación del algoritmo de huellas dactilares Rabin. Como se puede ver en la Tabla 2, incluso la pequeña ganancia del Microbenchmark anterior desaparece ya que el tamaño mínimo de fragmentos fue mayor que el tamaño promedio de la fila. Si bien uno puede abordar parcialmente estos problemas variando dinámicamente los parámetros del algoritmo de huellas dactilares Rabin, esto puede ser computacionalmente costoso, especialmente en presencia de cambios de trabajo cambiantes.6.2 Los puntos de referencia de aplicaciones ejecutamos el punto de referencia Bboard descrito en la Sección 4.1.1 en dos versiones de Ganesh: la primera con huellas dactilares de Rabin utilizados como www 2007 / pista: sesión de rendimiento y escalabilidad: sistemas escalables para contenido dinámico 317 0 50 100 150 200 250 300350 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S Solicitudes de clientes de prueba/seg nativo Ganesh 0.001 0.01 0.1 1 10 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 5MB/S 20 MB/S 100 MB/S CLIENTES DE PRUEBA AVG.RESP.TIME (SEC) Native Ganesh Note logscale (a) Rendimiento: Mezcla de licitación (B) Tiempo de respuesta: Mezcla de oferta 0 50 100 150 200 250 300 350 400 800 800 8001200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S 20 MB/S 100 MB/S Solicitudes de clientes de prueba/seg nativo Ganesh 0.001 0.01 0.1 1 10 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 MB/S20 MB/S 100 MB/S CLIENTES DE PRUEBA AVG.ESP.TIME (SEC) Native Ganesh Note logscale (c) rendimiento: mezcla de navegación (d) Tiempo de respuesta: la mezcla de navegación media de tres ensayos. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue del 2.2% y el 11.8% de la media correspondiente. Figura 8: Benchmark de subasta: rendimiento y tiempo de respuesta promedio El algoritmo de fragmentación y el segundo con el algoritmo basado en la fila de Ganeshs. Los resultados de Rabins para la mezcla de navegación se normalizan a los resultados de Ganeshs y se presentan en la Figura 9. Como muestra la Figura 9 (a), a 5 MB/s, independientemente de la configuración del cliente de prueba, Rabin influye significativamente en Ganesh. Esto sucede debido a una combinación de dos razones. Primero, como se describe en la Sección 3.1, Rabin encuentra menos similitud ya que no explota los resultados de la información estructural. En segundo lugar, este punto de referencia contenía algunas consultas que generaban grandes resultados. En este caso, Rabin, con un pequeño tamaño de fragmento promedio, generó una gran cantidad de objetos que desalojan otros datos útiles del caché. En contraste, Ganesh pudo detectar estas grandes filas y aumentar correspondientemente el tamaño de los trozos. Esto se confirmó ya que las estadísticas de caché mostraron que la relación Ganeshs HIT fue aproximadamente tres veces la de Rabin. Las mediciones de rendimiento a 20 MB/s fueron similares con la excepción del rendimiento de Rabins con 400 clientes de prueba. En este caso, Ganesh no estaba limitado en la red y, de hecho, el rendimiento era el mismo que 400 clientes a 5 MB/s. Rabin, sin embargo, aprovechó el aumento del ancho de banda de 5 a 20 MB/s para ofrecer un rendimiento ligeramente mejor. A 100 MB/s, el rendimiento de Rabins era casi similar al de Ganesh, ya que el ancho de banda ya no era un cuello de botella. El tiempo de respuesta normalizado, presentado en la Figura 9 (b), muestra tendencias similares. A 5 y 20 MB/s, la adición de clientes de prueba disminuye el tiempo de respuesta normalizado a medida que el tiempo de respuesta promedio de Ganesh aumenta más rápido que Rabins. Sin embargo, en ningún momento Rabin supera a Ganesh. Tenga en cuenta que a 400 y 800 clientes a 100 MB/s, Rabin tiene una sobrecarga más alta incluso cuando no está limitado. Como se menciona en la Sección 3.1, esto se debe al hecho de que Rabin tiene que hash cada resultado de resultados dos veces. La sobrecarga desaparece con 1200 y 1600 clientes, ya que la CPU de la base de datos está saturada y limita el rendimiento de Ganesh y Rabin.7. Overhead proxy En esta sección, abordamos la tercera pregunta planteada en la Sección 4: ¿Es aceptable la sobrecarga del diseño basado en el poder de Ganeshs? Para responder a esta pregunta, nos concentramos en su rendimiento en los anchos de banda más altos. Nuestra evaluación en la Sección 5 mostró que Ganesh, en comparación con Native, puede ofrecer una mejora sustancial de rendimiento a anchos de banda más bajos. Es solo a anchos de banda más altos que la latencia, medida por el tiempo de respuesta promedio para una solicitud del cliente, y el rendimiento, medido por la cantidad de solicitudes de clientes que se pueden atender por segundo, se verían visibles. Mirando la mezcla de autoría del punto de referencia original de Bboard, no hay ganancias visibles de Ganesh a 100 MB/s. Ganesh, sin embargo, todavía rastrea nativo en términos de rendimiento. Si bien el tiempo de respuesta promedio es más alto para Ganesh, la diferencia absoluta está entre 0.01 y 0.04 segundos y sería imperceptible para el usuario final. La mezcla de navegación muestra una diferencia aún menor en los tiempos de respuesta promedio. Los resultados de la variante de filtro de los puntos de referencia Bboard son similares. Incluso para el punto de referencia de subastas, la diferencia entre el tiempo de respuesta nativo y de Ganesh a 100 MB/s nunca fue mayor de 0.02 segundos. La única excepción a los resultados anteriores se observó en la variante del filtro del punto de referencia Bboard donde Ganesh en 1600 clientes de prueba agregaron 0.85 segundos al tiempo de respuesta promedio. Por lo tanto, incluso para redes mucho más rápidas donde el enlace WAN no es el cuello de botella, Ganesh siempre ofrece un rendimiento equivalente a nativo. Si bien el diseño basado en el poder agrega cierta latencia adicional, generalmente es imperceptible.8. El trabajo relacionado con todo el conocimiento, Ganesh es el primer sistema que combina el uso de técnicas basadas en el hash con el almacenamiento en caché de los resultados de la base de datos para mejorar los tiempos de rendimiento y respuesta para aplicaciones con contenido dinámico. También creemos que también es el primer sistema en demostrar los beneficios del uso de información estructural para www 2007 / seguimiento: rendimiento y escalabilidad Sesión: sistemas escalables para contenido dinámico 318 0.0 0.2 0.4 0.6 0.8 1.0 400 800 1200 1600 400 800 1200 1600 400800 1200 1600 5 MB/S 20 MB/S 100 MB/S CLIENTES DE PRUEBA Norma. Atrando 31.8 3.8 2.8 2.3 23.8 32.8 5.8 3.6 1.8 2.1 1.1 1.0 0 5 10 15 20 25 30 35 400 800 1200 1600 400 800 1600 400 800 800 8001200 1600 5 MB/S 20 MB/S 100 MB/S Norma de clientes de prueba. Respensación (a) rendimiento normalizado: más alto es mejor (b) Tiempo de respuesta normalizado: más alto es peor para el rendimiento, un resultado normalizado mayor que 1 implica que Rabines mejor, para el tiempo de respuesta, un resultado normalizado mayor que 1 implica que Ganesh es mejor. Media de tres ensayos. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue del 9.1% y el 13.9% de la media correspondiente. Figura 9: Comparación normalizada de Ganesh vs. Rabin - BORRADA BLOBE DE BROWSING Detección de similitud. En esta sección, primero discutimos enfoques alternativos para almacenar en caché el contenido dinámico y luego examinamos otros usos de las primitivas basadas en el hash en los sistemas distribuidos.8.1 El contenido dinámico de almacenamiento en caché en la capa de base de datos, varios sistemas han abogado por el almacenamiento en caché de Middletier donde las partes de la base de datos se replican en el borde o servidor [3, 4, 20]. Estos sistemas almacenan en caché las tablas enteras en lo que es esencialmente una base de datos replicada o utilizan vistas materializadas de las respuestas de consulta anteriores [19]. Requieren una integración estrecha con la base de datos de back-end para garantizar un tiempo limitado a la propagación de actualizaciones. Estos sistemas también generalmente están dirigidos a cargas de trabajo que no requieren una consistencia estricta y pueden tolerar datos obsoletos. Además, a diferencia de Ganesh, algunas de estas soluciones de almacenamiento en caché de nivel medio [2, 3], sufren la complejidad de tener que participar en el procesamiento de la consulta y el procesamiento de consultas distribuidas. Gao et al.[15] propone el uso de una arquitectura de replicación de objetos distribuidos donde los requisitos de consistencia de los almacenes de datos se adaptan por aplicación. Estas soluciones requieren recursos sustanciales del desarrollador y una comprensión detallada de la aplicación que se está modificando. Si bien existen sistemas que intentan automatizar la partición y replicación de una base de datos de aplicaciones [34], no proporcionan semántica de transacciones completa. En comparación, Ganesh no debilita ninguna de las semánticas proporcionadas por la base de datos subyacente. El trabajo reciente en la evaluación de opciones de almacenamiento en caché de borde para sitios web dinámicos [38] ha sugerido que, sin una planificación cuidadosa, emplear estrategias de descarga complejas puede dañar el rendimiento. En cambio, el trabajo aboga por una arquitectura en la que todos los niveles, excepto la base de datos, se deben descargar al borde. Nuestra evaluación de Ganesh ha demostrado que beneficiaría a estos escenarios. Para mejorar la escalabilidad de las bases de datos, C-JDBC [10], SSS [22] y Ganymed [28] también abogan por el uso de una arquitectura basada en interposiciones para agrupar transparentemente y replicar las bases de datos a nivel de middleware. Los enfoques de estas arquitecturas y Ganesh son complementarios y se beneficiarían entre sí. Avanzando a la capa de presentación, ha habido una adopción generalizada del almacenamiento en caché basado en fragmentos [14], lo que mejora la utilización de caché al almacenar en caché por separado diferentes partes de las páginas web generadas. Mientras que el almacenamiento en caché basado en fragmentos funciona en The Edge, una propuesta reciente ha propuesto un ensamblaje de página web en movimiento a los clientes para optimizar la entrega de contenido [31]. Si bien Ganesh no se usa en la capa de presentación, se han aplicado los mismos principios en la detección de transferencias duplicadas [25] para aumentar la eficiencia del caché web, así como para el acceso web a través de enlaces limitados de ancho de banda [33].8.2 Los sistemas basados en hash en los últimos años han visto la aparición de muchos sistemas que explotan las técnicas basadas en el hash. En el corazón de todos estos sistemas está la idea de detectar similitud en los datos sin requerir la interpretación de esos datos. Esta idea simple pero elegante se basa en el hash criptográfico, como se discutió anteriormente en la Sección 2. Las aplicaciones exitosas de esta idea abarcan una amplia gama de sistemas de almacenamiento. Los ejemplos incluyen la copia de seguridad entre pares de archivos informáticos personales [11], archivo de datos de almacenamiento-eficiente [29] y encontrar archivos similares [21]. Spring y Wetherall [35] aplican principios similares a nivel de red. Utilizando cachés sincronizados en ambos extremos de un enlace de red, los datos duplicados se reemplazan por tokens más pequeños para la transmisión y luego se restauran en el extremo remoto. Este y otros sistemas basados en hash, como los sistemas de archivos Casper [37] y LBFS [26], y los optimizadores de ancho de banda de capa 2, como el lecho del río y el peribit, usan huellas dactilares de Rabin [30] para descubrir tramos de comunicación en los datos. Este enfoque es especialmente útil cuando los elementos de datos se modifican en el lugar a través de inserciones, deleciones y actualizaciones. Sin embargo, como muestra la Sección 6, el rendimiento de esta técnica puede mostrar una caída dramática en la presencia de reordenamiento de datos. En cambio, Ganesh usa límites de fila como divisores para detectar similitud. El uso más agresivo de las técnicas basadas en hash es por sistemas que utilizan hashes como identificadores principales para objetos en almacenamiento persistente. Los sistemas de almacenamiento como CFS [12] y pasado [13] que se han construido utilizando tablas de hash distribuidas entran en esta categoría. El almacenamiento de una sola instancia [6] y Venti [29] son otros ejemplos de tales sistemas. Como se discutió en la Sección 2.2, el uso de hashes criptográficos para abordar los datos persistentes representa un nivel más profundo de fe en su resistencia de colisión que el asumido por Ganesh. Si el tiempo revela deficiencias en el algoritmo hash, el esfuerzo involucrado en corregir el defecto es mucho mayor. En Ganesh, se trata simplemente de reemplazar el algoritmo hash.9. Conclusión El uso creciente del contenido web dinámico generado a partir de bases de datos relacionales coloca mayores demandas sobre el ancho de banda WAN. Las soluciones tradicionales de almacenamiento en caché para el ancho de banda y la reducción de la latencia a menudo son ineficaces para dicho contenido. Este documento muestra que el impacto de los accesos de WAN a las bases de datos puede reducirse sustancialmente a través de la arquitectura de Ganesh sin ningún compromiso de la estricta semántica de consistencia de las bases de datos. La esencia de la arquitectura de Ganesh es el uso del cálculo en los bordes para reducir la comunicación a través de Internet. Ganesh puede usar hashes criptográficos para detectar la similitud con resultados anteriores y enviar www 2007 / rastrear: sesión de rendimiento y escalabilidad: sistemas escalables para contenido dinámico 319 recetas compactas de resultados en lugar de resultados completos. Nuestro diseño utiliza la interposición para lograr una transparencia completa: los clientes, los servidores de aplicaciones y los servidores de bases de datos desconocen la presencia de Ganeshs y no requieren modificación. Nuestra evaluación experimental confirma que Ganesh, aunque conceptualmente simple, puede ser altamente efectiva para mejorar el rendimiento y el tiempo de respuesta. Nuestros resultados también confirman que explotar la estructura presente en los resultados de la base de datos para detectar la similitud es crucial para esta mejora del rendimiento.10. Referencias [1] Akella, A., Seshan, S. y Shaikh, A. Una evaluación empírica de cuellos de botella de Internet de área amplia. En Proc.Tercera conferencia ACM Sigcomm sobre medición de Internet (Miami Beach, FL, EE. UU., Oct. 2003), pp. 101-114.[2] Altinel, M., Bornh ¨ovd, C., Krishnamurthy, S., Mohan, C., Pirahesh, H. y Reinwald, B. Tablas de caché: allanando el camino para un caché de base de datos adaptativo. En Proc.de 29th VLDB (Berlín, Alemania, 2003), pp. 718-729.[3] Altinel, M., Luo, Q., Krishnamurthy, S., Mohan, C., Pirahesh, H., Lindsay, B. G., Woo, H. y Brown, L. Dbcache: caché de la base de datos para servidores de aplicaciones web. En Proc.2002 ACM Sigmod (2002), págs. 612-612.[4] Amiri, K., Park, S., Tewari, R. y Padmanabhan, S. DBProxy: un caché de datos dinámico para aplicaciones web. En Proc. Conferencia Internacional IEEE sobre Ingeniería de Datos (ICDE) (marzo de 2003).[5] Black, J. Compare-by-Hash: un análisis razonado. En Proc.2006 Conferencia técnica anual de USENIX (Boston, MA, mayo de 2006), pp. 85-90.[6] Bolosky, W. J., Corbin, S., Goebel, D., y Douceur, J. R. Almacenamiento de instancia única en Windows 2000. En Proc.4th Usenix Windows Systems Symposium (Seattle, WA, agosto de 2000), pp. 13-24.[7] Brewer, E. A. Lecciones de servicios a escala gigante. IEEE Internet Computing 5, 4 (2001), 46-55.[8] Broder, A., Glassman, S., Manasse, M. y Zweig, G. Agrupación sintáctica de la web. En Proc.6ª Conferencia Internacional de WWW (1997).[9] Cecchet, E., Chanda, A., Elnikety, S., Marguerite, J. y Zwaenepoel, W. Comparación de rendimiento de arquitecturas de middleware para generar contenido web dinámico. En Proc. Cuarta Conferencia Internacional de Middleware ACM/IFIP/Usenix (Río de Janeiro, Brasil, junio de 2003).[10] Cecchet, E., Marguerite, J. y Zwaenepoel, W. C-JDBC: middleware de agrupación de base de datos flexible. En Proc.Conferencia técnica anual de USENIX 2004 (Boston, MA, junio de 2004).[11] Cox, L. P., Murray, C. D. y Noble, B. D. Pastiche: hacer que la copia de seguridad sea barata y fácil. En OSDI: Simposio sobre diseño e implementación de sistemas operativos (2002).[12] Dabek, F., Kaashoek, M. F., Karger, D., Morris, R. y Stoica, I. Almacenamiento cooperativo de área ancha con CFS. En 18º Simposio ACM sobre principios de sistemas operativos (Banff, Canadá, octubre de 2001).[13] Druschel, P. y Rowstron, A. Pasado: una utilidad de almacenamiento de pares a gran escala a gran escala. En Hotos VIII (Schloss Elmau, Alemania, mayo de 2001), pp. 75-80.[14] El lado del borde incluye.http://www.esi.org.[15] Gao, L., Dahlin, M., Nayate, A., Zheng, J. e Iyengar, A. Replicación de datos específicos de la aplicación para servicios de borde. En www 03: Proc. Duodécima Conferencia Internacional sobre World Wide Web (2003), pp. 449-460.[16] Hemminger, S. Netem - emulando redes reales en el laboratorio. En Proc.2005 Linux Conference Australia (Canberra, Australia, abril de 2005).[17] Henson, V. Un análisis de comparación-by-hash. En Proc.Noveno taller sobre temas calientes en sistemas operativos (Hotos IX) (mayo de 2003), págs. 13-18.[18] JMOB Benchmarks.http://jmob.objectweb.org/.[19] Labrinidis, A. y Roussopoulos, N. Balancing de rendimiento y frescura de datos en servidores de bases de datos web. En Proc.29a Conferencia VLDB (septiembre de 2003).[20] Larson, P.-A., Goldstein, J. y Zhou, J. Estampado de almacenamiento de datos de nivel medio transparente en SQL Server. En Proc.2003 ACM Sigmod (2003), pp. 661-661.[21] Manber, U. Encontrar archivos similares en un sistema de archivos grande. En Proc. Usenix Winter 1994 Conferencia técnica (San Fransisco, CA, 17-21 1994), pp. 1-10.[22] Manjhi, A., Ailamaki, A., Maggs, B. M., Mowry, T. C., Olston, C. y Tomásico, A. Escalabilidad y seguridad simultáneas para aplicaciones web intensivas en datos. En Proc.2006 ACM Sigmod (junio de 2006), págs. 241-252.[23] Menezes, A. J., Vanstone, S. A. y Oorschot, P. C. V. Manual de criptografía aplicada. CRC Press, 1996. [24] Miller, R. B. Tiempo de respuesta en transacciones conversacionales de la computadora. En Proc. AFIPS Fall Computer Conference (1968), pp. 267-277.[25] Mogul, J. C., Chan, Y. M. y Kelly, T. Diseño, implementación y evaluación de la detección de transferencia duplicada en HTTP. En Proc. Primer simposio sobre diseño e implementación de sistemas en red (San Francisco, CA, marzo de 2004).[26] Muthitacharoen, A., Chen, B. y Mazieres, D. Un sistema de archivos de red de bajo ancho de banda. En Proc.18º Simposio ACM sobre principios de sistemas operativos (Banff, Canadá, octubre de 2001).[27] Pfeifer, D. y Jakschitsch, H. El almacenamiento en caché basado en métodos en aplicaciones de servidores de niveles múltiples. En Proc. Quinto Simposio internacional sobre objetos y aplicaciones distribuidas (Catania, Sicilia, Italia, noviembre de 2003).[28] Plattner, C. y Alonso, G. Ganymed: replicación escalable para aplicaciones web transaccionales. En Proc.5ª Conferencia Internacional de ACM/IFIP/Usenix sobre el middleware (2004), pp. 155-174.[29] Quinlan, S. y Dorward, S. venti: un nuevo enfoque para el almacenamiento de archivo. En Proc. Conferencia FAST 2002 sobre archivos y tecnologías de almacenamiento (2002).[30] Rabin, M. Huellas digitales por polinomios aleatorios. En el Informe técnico de la Universidad de Harvard University en Investigación en Tecnología de Computación TR-15-81 (1981).[31] Rabinovich, M., Xiao, Z., Douglis, F. y Kalmanek, C. El lado del borde en movimiento incluye al borde real: los clientes. En Proc.4to Simposio de Usenix sobre tecnologías y sistemas de Internet (Seattle, WA, marzo de 2003).[32] Reese, G. Programación de bases de datos con JDBC y Java, 1ª ed. Oreilly, junio de 1997. [33] Rhea, S., Liang, K. y Brewer, E. Almacenamiento web basado en el valor. En Proc. Duodécima Conferencia Internacional World Wide Web (mayo de 2003).[34] Sivasubramanian, S., Alonso, G., Pierre, G. y Van Steen, M. Globedb: replicación de datos autónomos para aplicaciones web. En www 05: Proc.14ª Conferencia web mundial internacional (mayo de 2005).[35] Spring, N. T. y Wetherall, D. una técnica independiente del protocolo para eliminar el tráfico de red redundante. En Proc.de ACM Sigcomm (agosto de 2000).[36] Tolia, N., Harkes, J., Kozuch, M. y Satyanarayanan, M. Integrando el almacenamiento portátil y distribuido. En Proc.Tercera conferencia de Usenix sobre archivos y tecnologías de almacenamiento (San Francisco, CA, marzo de 2004).[37] Tolia, N., Kozuch, M., Satyanarayanan, M., Karp, B., Perrig, A. y Bressoud, T. Uso oportunista del almacenamiento direccionable de contenido para sistemas de archivos distribuidos. En Proc.Conferencia técnica anual 2003 Usenix (San Antonio, TX, junio de 2003), pp. 127-140.[38] Yuan, C., Chen, Y. y Zhang, Z. Evaluación del almacenamiento en caché/descarga de borde para la entrega de contenido dinámico. En www 03: Proc. La Duodécima Conferencia Internacional sobre World Wide Web (2003), pp. 461-471. WWW 2007 / Track: Sesión de rendimiento y escalabilidad: sistemas escalables para contenido dinámico 320