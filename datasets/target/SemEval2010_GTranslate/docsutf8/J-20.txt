Algoritmos de compensación para mercados de intercambio de truequese: habilitando intercambios de riñón a nivel nacional David J. Abraham Departamento de Ciencias de la Computación Carnegie Mellon University dabraham@cs.cmu.edu Avrim Blum BLUM Ciencias de la Computación de Departamento de Ciencias de la Computación Carnegie Mellon Avrim@cs.cmu.edu Tuomas Departamento de Ciencias de la Informática de Sandholm Carnegie Mellon MellonUniversity sandholm@cs.cmu.edu Resumen en mercados de intercambio de trueque, los agentes buscan intercambiar sus artículos entre sí, para mejorar sus propias utilidades. Estos swaps consisten en ciclos de agentes, y cada agente recibe el elemento del siguiente agente en el ciclo. Nos centramos principalmente en el próximo mercado nacional de intercambio renal, donde los pacientes con enfermedad renal pueden obtener donantes compatibles cambiando sus propios donantes dispuestos pero incompatibles. Con más de 70,000 pacientes que ya esperan un riñón cadáver en los Estados Unidos, este mercado se considera la única forma ética de reducir significativamente las 4.000 muertes por año atribuidas a la enfermedad renal. El problema de compensación implica encontrar un intercambio de maximización de bienestar social cuando se soluciona la longitud máxima de un ciclo. Los ciclos largos están prohibidos, ya que, por razones de incentivos, todos los trasplantes en un ciclo deben realizarse simultáneamente. Además, en los intercambios de trueque en general, más agentes se ven afectados si uno cae de un ciclo más largo. Probamos que el problema de compensación con esta restricción de longitud del ciclo es NP-HARD. Resolverlo exactamente es uno de los principales desafíos para establecer un intercambio de riñón nacional. Presentamos el primer algoritmo capaz de limpiar estos mercados a escala nacional. La clave es la formulación de problemas incrementales. Adaptamos dos paradigmas para la tarea: generación de restricciones y generación de columnas. Para cada uno, desarrollamos técnicas que mejoran dramáticamente tanto el tiempo de ejecución como el uso de la memoria. Concluimos que la generación de columnas escala drásticamente mejor que la generación de restricciones. Nuestro algoritmo también apoya varias generalizaciones, como lo demandan los intercambios de riñón del mundo real. Nuestro algoritmo reemplazó a CPlex como el algoritmo de limpieza de la Alianza para la donación emparejada, uno de los principales intercambios de riñón. Las corridas de coincidencia se realizan cada dos semanas y los trasplantes basados en nuestras optimizaciones ya se han realizado. Categorías y descriptores de sujetos J.4 [Aplicaciones informáticas]: Ciencias Sociales y del Comportamiento-Economía;F.2 [Análisis de algoritmos y complejidad del problema]: [General] Algoritmos de términos generales, Economía 1. Introducción El papel de los riñones es filtrar los desechos de la sangre. La insuficiencia renal resulta en la acumulación de este desperdicio, lo que conduce a la muerte en meses. Una opción de tratamiento es la diálisis, en la que el paciente va a un hospital para que una máquina externa filtrada la sangre. Se requieren varias visitas por semana, y cada una lleva varias horas. La calidad de vida de la diálisis puede ser extremadamente baja, y de hecho, muchos pacientes optan por retirarse de la diálisis, lo que lleva a una muerte natural. Solo el 12% de los pacientes con diálisis sobreviven 10 años [23]. En cambio, el tratamiento preferido es un trasplante de riñón. Los trasplantes de riñón son, con mucho, el trasplante más común. Desafortunadamente, la demanda de riñones supera con creces la oferta. En los Estados Unidos en 2005, 4.052 personas murieron esperando un trasplante de riñón que salva vidas. Durante este tiempo, casi 30,000 personas fueron agregadas a la lista nacional de espera, mientras que solo 9,913 personas dejaron la lista después de recibir un riñón donante fallecido. La lista de espera actualmente tiene más de 70,000 personas, y el tiempo de espera promedio varía de 2 a 5 años, dependiendo del tipo de sangre.1 Para muchos pacientes con enfermedad renal, la mejor opción es encontrar un donante vivo, es decir, una persona sanadispuesto a donar uno de sus dos riñones. Aunque hay mercados para comprar y vender riñones de donantes vivos, la comercialización de los órganos humanos se considera casi universalmente como poco ético, y la práctica a menudo es explícitamente ilegal, como en los Estados Unidos. Sin embargo, en la mayoría de los países, la donación en vivo es legal, siempre que ocurra como un regalo sin compensación financiera. En 2005, había 6.563 donaciones en vivo en los Estados Unidos. El número de donaciones en vivo habría sido mucho mayor si no fuera por el hecho de que, con frecuencia, un potencial datos del donante 1 de United Network para compartir órganos [21].295 y su receptor previsto son de tipo sangre o de tipo tejido incompatible. En el pasado, el donante incompatible fue enviado a casa, dejando al paciente esperar un riñón de donantes fallecidos. Sin embargo, ahora hay algunos intercambios de riñón regionales en los Estados Unidos, en los que los pacientes pueden intercambiar sus donantes incompatibles entre sí, para cada uno obtener un donante compatible. Estos mercados son ejemplos de intercambios de trueque. En un mercado de intercambio de trueque, los agentes (pacientes) buscan intercambiar sus artículos (donantes incompatibles) entre sí. Estos swaps consisten en ciclos de agentes, y cada agente recibe el elemento del siguiente agente en el ciclo. Los intercambios de trueque son ubicuos: los ejemplos incluyen Peerflix (DVD) [11], léelo (libros) [12] e Intervac (casas de vacaciones) [9]. Durante muchos años, incluso ha habido un gran intercambio de zapatos en los Estados Unidos [10]. Las personas con pies de diferentes tamaños usan esto para evitar tener que comprar dos pares de zapatos. Los amputados de las piernas tienen un intercambio separado para compartir el costo de comprar un solo par de zapatos. Podemos codificar un mercado de intercambio de trueque como un gráfico dirigido g = (v, e) de la siguiente manera. Construya un vértice para cada agente. Agregue un borde ponderado E de un agente VI a otro VJ, si VI quiere el artículo de VJ. El peso que de E representa la utilidad a VI de obtener el elemento VJS. Un ciclo C en este gráfico representa un posible intercambio, con cada agente en el ciclo obteniendo el elemento del siguiente agente. El peso WC de un ciclo C es la suma de sus pesos de borde. Un intercambio es una colección de ciclos disjuntos. El peso de un intercambio es la suma de sus pesos de ciclo. Un intercambio de maximización de bienestar social es uno con el máximo peso. La Figura 1 ilustra un mercado de ejemplo con 5 agentes, {V1, V2 ,..., v5}, en el que todos los bordes tienen peso 1. El mercado tiene 4 ciclos, C1 = V1, V2, C2 = V2, V3, C3 = V3, V4 y C4 = V1, V2, V3, V4, V5 e dos (inclusión) Cambios máximos, a saber, M1 = {C4}y m2 = {c1, c3}. Exchange M1 tiene un peso máximo y cardinalidad máxima (es decir, incluye la mayoría de los bordes/vértices).V1 V2 V3 V4 V5 E1 E3 E5 C1 C2 C3 E8 E7 E6E4E2 C4 Figura 1: Ejemplo de mercado de intercambio de trueques. El problema de compensación es encontrar un intercambio de máximo peso que consiste en ciclos con longitud a lo sumo algunas pequeñas y constantes L. Esta restricción de longitud del ciclo surge naturalmente por varias razones. Por ejemplo, en un intercambio de riñones, todas las operaciones en un ciclo deben realizarse simultáneamente;De lo contrario, un donante podría retirarse después de que su pareja incompatible haya recibido un riñón.(No se puede escribir un contrato vinculante para donar un órgano). Esto da lugar a una restricción logística en el tamaño del ciclo: incluso si todos los donantes se operan en primera y el mismo personal y las instalaciones se utilizan para operar en el Dees, un ciclo K requiere entre 3k y 6k médicos, alrededor de 4K enfermeras,y casi 2k salas de operaciones. Debido a tales limitaciones de recursos, el próximo mercado nacional de intercambio de riñones probablemente permitirá solo ciclos de longitud 2 y 3. Otra motivación para los ciclos cortos es que si el ciclo no se cambia, se ven afectados menos agentes. Por ejemplo, las pruebas de último minuto en un intercambio de riñón a menudo revelan nuevas incompatibilidades que no se detectaron en las pruebas iniciales (en función de las cuales se construyó el gráfico de compatibilidad). En términos más generales, un agente puede abandonar un ciclo si sus preferencias han cambiado, o él/ella simplemente no cumple con sus obligaciones (como enviar un libro a otro agente en el ciclo) debido al olvido. En la Sección 3, mostramos que (la versión de decisión de) el problema de compensación es NP-completado para L ≥ 3. Entonces, un enfoque podría ser buscar un buen algoritmo heurístico o de aproximación. Sin embargo, por dos razones, apuntamos a un algoritmo exacto basado en una formulación del programa entero-lineal (ILP), que resolvemos utilizando la búsqueda especializada de árboles.• Primero, cualquier pérdida de optimización podría conducir a muertes innecesarias del paciente.• En segundo lugar, una característica atractiva del uso de una formulación ILP es que permite modelar fácilmente una serie de variaciones en el objetivo y agregar restricciones adicionales al problema. Por ejemplo, si se cree que 3 ciclos son más propensos a fallar que 2 ciclos, entonces se puede simplemente darles un peso que sea apropiadamente inferior a 3/2 el peso de un ciclo de 2. O, si por varias razones (por ejemplo, éticas) se requieren un intercambio de cardinalidad máximo, uno puede al menos en un segundo pase encontrar la solución (de todas las soluciones de cardinalidad máxima) que tiene la menor cantidad de 3 ciclos. Otras variaciones para las que se puede resolver incluyen encontrar varias formas de colecciones de ciclos tolerantes a fallas (no desanimadas) en el caso de que ciertos pares que se pensaba que eran compatibles resultan incompatibles después de todo. En este artículo, presentamos el primer algoritmo capaz de limpiar estos mercados a escala nacional. Las codificaciones ILP directas son demasiado grandes para construir incluso en el hardware actual, no para hablar sobre resolverlas. La clave es la formulación de problemas incrementales. Adaptamos dos paradigmas para la tarea: generación de restricciones y generación de columnas. Para cada uno, desarrollamos una serie de técnicas (principalmente específicas de problemas) que mejoran drásticamente tanto el tiempo de ejecución como el uso de la memoria.1.1 Trabajo previo Varios artículos recientes han utilizado simulaciones y algoritmos de mercado de mercado para explorar el impacto de un intercambio de riñón nacional [13, 20, 6, 14, 15, 17]. Por ejemplo, el uso del algoritmo de máxima coincidencia de Edmonds [4], [20] muestra que un mercado nacional de intercambio por pares (usando solo ciclos de longitud-2) daría como resultado más trasplantes, un tiempo de espera reducido y ahorros de $ 750 millones en Heath Carecuesta más de 5 años. Esos resultados son conservadores de dos maneras. En primer lugar, el mercado simulado contenía solo 4,000 pacientes iniciales, con 250 pacientes agregados cada 3 meses. Se nos ha informado que el mercado podría ser casi el doble de este tamaño. En segundo lugar, los intercambios se restringieron a los ciclos de longitud-2 (porque eso es todo lo que puede modelarse como una coincidencia máxima y se resolvieron usando el algoritmo Edmondss). Permitir ciclos de longitud-3 conduce a ganancias significativas adicionales. Esto se ha demostrado en los mercados de intercambio de riñones con 100 pacientes mediante el uso de CPLEX para resolver una codificación de programas enteros del problema de compensación [15]. En este artículo, presentamos un algoritmo alternativo para este programa entero que puede despejar los mercados con más de 10,000 pacientes (y el mismo número de donantes dispuestos). Permitir ciclos de longitud más de 3 a menudo no conduce a una mejora en el tamaño del intercambio [15].(Además, en un modelo teórico simplificado, cualquier intercambio renal se puede convertir en uno con ciclos de longitud como máximo 4 [15].) Si bien esto no es válido para los intercambios de trueque generales, o incluso para todos los mercados de intercambio renal, en la Sección 5.2.3 utilizamos la observación de que los ciclos cortos son suficientes para aumentar drásticamente la velocidad de nuestro algoritmo. En un nivel de alto nivel, el problema de compensación para los intercambios de trueque es similar al problema de compensación (también conocido como problema de determinación de ganadores) en subastas combinatorias. En ambos entornos, la idea es reunir toda la información pertinente sobre los agentes en un punto de compensación central y ejecutar un algoritmo de compensación centralizado para determinar la asignación. Ambos problemas son NP-Hard. Ambos se resuelven mejor utilizando técnicas de búsqueda de árboles. Desde 1999, se ha realizado un trabajo significativo en la investigación de la informática y las operaciones sobre algoritmos de búsqueda de árboles óptimos más rápidos para eliminar las subastas combinatorias.(Para una revisión reciente, ver [18].) Sin embargo, el problema de compensación de intercambio renal (con un límite de 3 o más sobre el tamaño del ciclo) es diferente del problema de compensación de subasta combinatoria de manera significativa. La diferencia más importante es que las formulaciones naturales del problema de la subasta combinatoria tienden a adaptarse fácilmente a la memoria, por lo que el tiempo es el cuello de botella en la práctica. Por el contrario, las formulaciones naturales del problema de intercambio renal (con L = 3) toman al menos espacio cúbico en el número de pacientes para que incluso modelen y, por lo tanto, la memoria se convierte en un cuello de botella mucho antes de que el tiempo lo haga cuando se usa la búsqueda de árboles estándar, como la rama.-Anly en cplex, para abordar el problema.(En una computadora de 1 GB y un generador de instancias estándar realista, discutido más adelante, CPlex 10.010 se queda fuera de la memoria en cinco de las diez instancias de 900 pacientes y diez de las diez instancias de 1,000 pacientes que generamos). Por lo tanto, los enfoques que se han desarrollado para subastas combinatorias no pueden manejar el problema de intercambio renal.1.2 Esquema de papel El resto del papel está organizado de la siguiente manera. La Sección 2 discute el proceso por el cual generamos datos realistas del mercado de intercambio renal, para comparar los algoritmos de compensación. La Sección 3 contiene una prueba de que el problema de la decisión de compensación del mercado es NP-Completo. Las secciones 4 y 5 contienen una formulación ILP del problema de compensación. También detallamos en esas secciones nuestras técnicas utilizadas para resolver esos programas en grandes casos. La Sección 6 presenta experimentos sobre las diversas técnicas. La Sección 7 discute el campo reciente de nuestro algoritmo. Finalmente, presentamos nuestras conclusiones en la Sección 8 y sugerimos futuras direcciones de investigación.2. Características del mercado y generador de instancias Probamos los algoritmos en los mercados simulados de intercambio renal, que son generados por un proceso descrito en Saidman et al.[17]. Este proceso se basa en los extensos datos a nivel nacional mantenidos por United Network for Organ Compartir (UNO) [21], por lo que genera una distribución de instancias realista. Varios documentos han utilizado variaciones de este proceso para demostrar la efectividad de un intercambio renal nacional (extrapolando de pequeñas instancias o restringiendo el claro a 2 ciclos) [6, 20, 14, 13, 15, 17]. Brevemente, el proceso implica generar pacientes con un tipo de sangre aleatoria, sexo y probabilidad de ser de tipo tejido incompatible con un donante elegido al azar. Estas probabilidades se basan en datos reales de población del mundo real. A cada paciente se le asigna un donante potencial con un tipo de sangre aleatoria y una relación con el paciente. Si el paciente y el donante potencial son incompatibles, los dos se ingresan al mercado. La información del tipo de sangre y el tipo de tejido se utiliza para decidir qué pacientes y donantes son compatibles. Una complicación, manejada por el generador, es que si el paciente es mujer y ha tenido un hijo con su posible donante, entonces la probabilidad de que los dos sean incompatibles aumentan.(Esto se debe a que la madre desarrolla anticuerpos para su pareja durante el embarazo). Finalmente, aunque nuestros algoritmos pueden manejar funciones de peso más generales, los pacientes tienen una utilidad de 1 para donantes compatibles, ya que su probabilidad de supervivencia no se ve afectada por la elección del donante [3]. Esto significa que el intercambio máximo de peso tiene la máxima cardinalidad. La Tabla 1 ofrece límites inferiores y superiores en el tamaño de un intercambio de máxima cardinalidad en el mercado de intercambio renal. Los límites inferiores se encontraron limpiando el mercado solo con ciclos de longitud-2, mientras que los límites superiores no tenían restricción en la duración del ciclo. Para cada tamaño del mercado, los límites se calcularon en 10 mercados generados al azar. Tenga en cuenta que puede haber una gran cantidad de variabilidad en los mercados: en un mercado de 5000 pacientes, menos de 1000 pacientes estaban en el intercambio de máxima cardinalidad. Tamaño de intercambio máximo Longitud-2 ciclos solo ciclos arbitrarios Pacientes Media MÁS MÁS MÁS MÁXIMA 100 4.00E+1 4.60E+1 5.30E+1 6.10E+1 500 2.58E+2 2.80E+2 2.79E+2 2.97E+2 10005.35e+2 6.22e+2 5.61e+2 6.30e+2 2000 1.05e+3 1.13e+3 1.09e+3 1.16e+3 3000 1.63e+3 1.70e+3 1.68e+3 1.73e+34000 2.15e+3 2.22e+3 2.20e+3 2.27e+3 5000 2.53e+3 2.87e+3 2.59e+3 2.92e+3 6000 3.26e+3 3.32e+3 3.35e+3 3.39e++3 7000 3.80e+3 3.86e+3 3.89e+3 3.97e+3 8000 4.35e+3 4.45e+3 4.46e+3 4.55e+3 9000 4.90e+3 4.96e+3 5.01e+3 5.07e+3 10000 5.47e+3 5.61e+3 5.59e+3 5.73e+3 Tabla 1: límites superior e inferior en el tamaño de intercambio. La Tabla 2 ofrece características adicionales del mercado de intercambio renal. Tenga en cuenta que un mercado con 5000 pacientes ya puede tener más de 450 millones de ciclos de longitud 2 y 3. Longitud de los bordes 2 y 3 ciclos Pacientes Media MÁS MÁS MÁXIMA 100 2.38E+3 2.79E+3 2.76E+3 5.90E+3 500 6.19E+4 6.68E+4 3.96E+5 5.27E+5 1000 2.44E+52.68e+5 3.31e+6 4.57e+6 2000 9.60e+5 1.02e+6 2.50e+7 3.26e+7 3000 2.19e+6 2.28e+6 8.70e+7 9.64e+7 4000 3.86e++6 3.97e+6 1.94e+8 2.14e+8 5000 5.67e+6 6.33e+6 3.60e+8 4.59e+8 6000 8.80e+6 8.95e+6 7000 1.19e+7 1.21e+7 8000 1.56E+7 1.59e+7 9000 1.98e+7 2.02e+7 10000 2.44e+7 2.51e+7 Tabla 2: Características del mercado.297 3. La complejidad del problema En esta sección, demostramos que (la versión de decisión de) el problema de compensación del mercado con ciclos cortos es NP-NP. Teorema 1. Dado un gráfico g = (v, e) y un número entero L ≥ 3, el problema de decidir si G admite una cubierta de ciclo perfecta que contiene ciclos de longitud en la mayoría de L es NP Completo. Prueba. Está claro que este problema está en NP. Para Nphardness, reducimos del partido 3D, que es el problema de, dados los conjuntos de disjunto X, Y y Z de tamaño Q, y un conjunto de triples t ⊆ x × y × z, decidir si hay un subconjunto de disjunto m deT con tamaño q. Una idea directa es construir un gráfico tripartito con conjuntos de vértices x ∪ y ∪ z y bordes dirigidos (xa, yb), (yb, zc) y (zc, xa) para cada triple ti = {xa, yb, zc}∈ T. Sin embargo, no es demasiado difícil ver que esta codificación falle porque una cubierta de ciclo perfecta puede incluir un ciclo sin triple correspondiente. En cambio, usamos la siguiente reducción. Dada una instancia de coincidencia 3D, construya un vértice para cada elemento en X, Y y Z. Para cada triple, ti = {xa, yb, zc} construye el gadget en la Figura 2, que es similar a uno en Garey y Johnson [5, pp 68-69]. Tenga en cuenta que los gadgets se cruzan solo en vértices en x ∪ y ∪ Z. Está claro que esta construcción se puede hacer en tiempo polinomial.1 ... 2 3 Y_B ... 2 3 Z_C Y_B^I Z_C^I L-1 L-1 L-1 X_A^I X_A ... 2 31 1 Figura 2: Gadget NP-Completness para Triple Ti y MáximoLongitud del ciclo L. Sea M una combinación 3D perfecta. Mostraremos que la construcción admite una cubierta de ciclo perfecta por ciclos cortos. Si ti = {xa, yb, zc} ∈ M, agregue del gadget los tres ciclos de longitud que contienen Xa, yb y Zc respectivamente. También agregue el ciclo ª xi a, yi b, zi c «. De lo contrario, si ti /∈ M, agregue los tres ciclos de longitud que contienen Xi A, Yi B y Zi C respectivamente. Está claro que todos los vértices están cubiertos, ya que M particionó X × Y × Z. Por el contrario, supongamos que tenemos una cubierta perfecta en ciclos cortos. Tenga en cuenta que la construcción solo tiene ciclos cortos de longitudes 3 y L, y ningún ciclo corto implica vértices distintos de dos dispositivos diferentes. Es fácil ver entonces que en una cubierta perfecta, cada gadget Ti contribuye con los ciclos de acuerdo con los casos anteriores: ti ∈ M, o ti /∈ M. Por lo tanto, existe una combinación 3D perfecta en la instancia original.4. Los enfoques de solución basados en una formulación de borde en esta sección, consideramos una formulación del problema de compensación como un ILP con una variable para cada borde. Esta codificación se basa en el siguiente algoritmo clásico para resolver el problema de la cubierta del ciclo dirigido sin restricciones de longitud de ciclo. Dado un mercado g = (v, e), construya un gráfico bipartito con un vértice para cada agente y un vértice para cada artículo. Agregue un borde EV con peso 0 entre cada agente V y su propio elemento. En este punto, la codificación es una coincidencia perfecta. Ahora, para cada borde e = (VI, VJ) en el mercado original, agregue un borde E con peso entre el Agente VI y el artículo de VJ. Las coincidencias perfectas en esta codificación corresponden exactamente a las cubiertas de ciclo, ya que cada vez que se toma un artículo de los agentes, debe recibir algún elemento de otros agentes. Se deduce que el problema de compensación sin restricciones se puede resolver en el tiempo polinomial al encontrar una coincidencia perfecta de peso máximo. La Figura 3 contiene la codificación del gráfico bipartito del mercado de ejemplo de la Figura 1. Los bordes de peso-0 están codificados por líneas discontinuas, mientras que los bordes del mercado están en negrita. Artículos Agentes V1 V2 V3 V4 V5 E1 E3 E8 E2 V1 V2 V3 V4 V5 E7E6 E5 E4 Figura 3: Codificación de coincidencia perfecta del mercado en la Figura 1. Alternativamente, podemos resolver el problema codificándolo como un ILP con una variable para cada borde en el gráfico de mercado original G. Esta ILP, que se da a continuación, tiene la ventaja de que se puede extender naturalmente para lidiar con las limitaciones de la longitud del ciclo. Por lo tanto, para el resto de esta sección, este es el enfoque que seguiremos.max e∈E wee tal que para todos vi ∈ V, la restricción de conservación eout = (vi, vj) eout - ein = (vj, vi) ein = 0 y la restricción de capacidad eout = (vi, vj) eout ≤ 1 están satisfechos. Si se permite que los ciclos tengan una longitud como máximo L, es fácil ver que solo necesitamos hacer los siguientes cambios en el ILP. Para cada ruta de longitud-L (en todo el documento, no incluimos ciclos en la definición de ruta) P = EP1, EP2 ,..., EPL, agregue una restricción EP1 + EP2 +...+ EPL ≤ L - 1, que impide que la ruta P esté en cualquier solución factible. Desafortunadamente, en un mercado con solo 1000 pacientes, el número de rutas de longitud-3 superan los 400 millones, por lo que ni siquiera podemos construir esta ILP sin quedarse sin memoria. Por lo tanto, utilizamos una búsqueda de árbol con un enfoque de formulación incremental. Específicamente, usamos CPLEX, aunque 298 agregamos restricciones como planos de corte durante el proceso de búsqueda de árboles. Comenzamos solo con un pequeño subconjunto de las limitaciones en el ILP. Dado que este ILP es pequeño, CPLEX puede resolver su relajación de LP. Luego verificamos si alguna de las restricciones faltantes es violada por la solución fraccional. Si es así, generamos un conjunto de estas restricciones, las agregamos a la ILP y repitemos. Incluso una vez que se cumplan todas las restricciones, puede que no haya una solución integral que coincida con el límite superior fraccional, e incluso si hubiera, el solucionador LP podría no encontrarla. En estos casos, CPLEX se ramifica en una variable (utilizamos la estrategia de ramificación predeterminada de CPLEXS) y genera un nuevo nodo de búsqueda correspondiente a cada uno de los niños. En cada nodo del árbol de búsqueda que se visita, se repite este proceso de resolver el LP y agregar restricciones. Claramente, este enfoque produce una solución óptima una vez que termina la búsqueda del árbol. Todavía necesitamos explicar los detalles del sembrador de restricciones (es decir, seleccionar qué restricciones para empezar) y la generación de restricciones (es decir, seleccionar cuáles violaron las restricciones para incluir). Los describimos brevemente en las siguientes dos subsecciones, respectivamente.4.1 Sembrador de restricción El semillero de restricción principal que desarrollamos prohíbe cualquier camino de longitud L - 1 que no tenga un borde que cierre el ciclo de su cabeza a su cola. Si bien es computacionalmente costoso encontrar estas restricciones, su adición enfoca la búsqueda lejos de las rutas que no pueden estar en la solución final. También intentamos sembrar el LP con una colección aleatoria de restricciones del ILP.4.2 Generación de restricciones Experimentamos con varios generadores de restricciones. En cada uno, dada una solución fraccional, construimos el subgrafo de bordes con valor positivo. Este gráfico es mucho más pequeño que el gráfico original, por lo que podemos realizar los siguientes cálculos de manera eficiente. En nuestro primer generador de restricciones, simplemente buscamos rutas de longitud-L con una suma de valor más que L-1. Para cualquier camino de este tipo, restringimos que su suma sea como máximo L - 1. Tenga en cuenta que si hay un ciclo c con longitud | c |> L, podría contener tantos como | c |Violando caminos. En nuestro segundo generador de restricciones, solo agregamos una restricción para tales ciclos: la suma de bordes en el ciclo puede ser como máximo | C | (L - 1)/L. Este generador hizo que el algoritmo fuera más lento, por lo que fuimos en la otra dirección en el desarrollo de nuestro generador final. Agrega una restricción por ruta de violación P, y además, agrega una restricción para cada ruta con los mismos vértices interiores (sin contar los puntos finales) como p.Esto mejoró la velocidad general.4.3 Rendimiento experimental Resultó que incluso con estas mejoras, el enfoque de formulación de borde no puede borrar un intercambio de riñón con 100 vértices en el tiempo que la formulación del ciclo (descrita más adelante en la Sección 5) puede borrar uno con 10,000 vértices. En otras palabras, los enfoques basados en la generación de columnas resultaron ser drásticamente mejores que los enfoques basados en la generación de restricciones. Por lo tanto, en el resto del documento, nos centraremos en la formulación del ciclo y los enfoques basados en la generación de columnas.5. Enfoques de solución basados en una formulación de ciclo en esta sección, consideramos una formulación del problema de compensación como un ILP con una variable para cada ciclo. Esta codificación se basa en el siguiente algoritmo clásico para resolver el problema de la cubierta del ciclo dirigido cuando los ciclos tienen longitud 2. Dado un mercado g = (v, e), construya un nuevo gráfico en V con un borde de peso WC para cada ciclo c de longitud 2. Es fácil ver que las coincidencias en este nuevo gráfico corresponden a las cubiertas de ciclo por ciclos de longitud-2 en el gráfico de mercado original. Por lo tanto, el problema de compensación del mercado con L = 2 se puede resolver en el tiempo polinomial al encontrar una coincidencia de peso máximo.C_1 V 1 V 2 V 3 V 4 C_3C_2 Figura 4: Codificación de correspondencia máxima del mercado en la Figura 1. Podemos generalizar esta codificación para L. Arbitrary Sea C (L) el conjunto de todos los ciclos de G con la longitud en la mayoría de L. Entonces la siguiente ILP encuentra la cubierta del ciclo de peso máximo por ciclos C (L): Max C∈C(L) WCC sujeto a c: vi∈C c ≤ 1 ∀vi ∈ V con c ∈ {0, 1} ∀c ∈ C (l) 5.1 Formulación de ciclo de borde vs En esta sección, consideramos los méritos de la formulación de borde yFormulación del ciclo. La formulación de borde se puede resolver en el tiempo polinomial cuando no hay restricciones en el tamaño del ciclo. La formulación del ciclo se puede resolver en el tiempo polinomial cuando el tamaño del ciclo es como máximo 2. Ahora consideramos el caso de ciclos cortos de longitud en la mayoría de L, donde L ≥ 3. Nuestros algoritmos de búsqueda de árboles utilizan la relajación de LP de estas formulaciones para proporcionar límites superiores en la solución óptima. Estos límites ayudan a podar subárboles y guiar la búsqueda de las formas habituales. Teorema 2. La relajación de LP de la formulación del ciclo domina débilmente la relajación de LP de la formulación de borde. Prueba. Considere una solución óptima a la relajación de LP de la formulación del ciclo. Mostramos cómo construir una solución equivalente en la formulación de borde. Para cada borde en el gráfico, establezca su valor como la suma de valores de todos los ciclos de los cuales es un miembro. Además, defina el valor de un vértice de la misma manera. Debido a las limitaciones del ciclo, las limitaciones de conservación y capacidad de la codificación de borde están claramente satisfechos. Queda por mostrar que no se violan ninguna de las limitaciones de ruta. Sea P cualquier ruta longitud-l en el gráfico. Dado que p tiene l - 1 vértices interiores (sin contar los puntos finales), la suma de valor de estos vértices interiores es como máximo L - 1. Ahora, para cualquier ciclo C de longitud en la mayoría de L, el número de bordes que tiene en P, que denotamos por EC (P), es como máximo el número de vértices interiores que tiene en P, que denotamos por VC (P). Por lo tanto, è e∈P e = è c∈C (l) c ∗ ec (p) ≤ è c∈C (l) c ∗ vc (p) = è v∈P v = l - 1.299 Lo contrario de este teorema no es cierto. Considere un gráfico que es simplemente un ciclo con n bordes. Claramente, la relajación de LP de la formulación del ciclo tiene un valor óptimo 0, ya que no hay ciclos de tamaño en la mayoría de L. Sin embargo, la formulación de borde tiene una solución de tamaño N/2, con cada borde con valor 1/2. Por lo tanto, la formulación del ciclo es más estricta que la formulación del borde. Además, para un gráfico con m bordes, la formulación de borde requiere restricciones O (M3), mientras que la formulación del ciclo requiere solo O (M2).5.2 Generación de columnas para la Tabla 2 de LP muestra cómo el número de ciclos de longitud en la mayoría de los 3 crece con el tamaño del mercado. Con una variable por ciclo en la formulación del ciclo, CPLEX ni siquiera puede limpiar los mercados con 1,000 pacientes sin quedarse sin memoria (ver Figura 6). Para abordar este problema, utilizamos un enfoque de formulación incremental. El primer paso en la búsqueda de árboles guiados por LP es resolver la relajación de LP. Dado que la formulación del ciclo no encaja en la memoria, esta etapa LP fallaría inmediatamente sin un enfoque de formulación incremental. Sin embargo, motivado por la observación de que una solución de intercambio puede incluir solo una pequeña fracción de los ciclos, exploramos el enfoque del uso de la generación de columna (es decir, ciclo). La idea de la generación de columnas es comenzar con un LP restringido que contiene solo un pequeño número de columnas (variables, es decir, ciclos), y luego agregar columnas repetidamente hasta que una solución óptima a este LP parcialmente formulada sea una solución óptima para el original (AKA Master) LP. Explicamos esto más a través de un ejemplo. Considere el mercado en la Figura 1 con L = 2. La Figura 5 proporciona el LP maestro, P, y su doble, D. Primal P Max 2C1 +2C2 +2C3 S.T.C1 ≤ 1 (V1) C1 +C2 ≤ 1 (V2) +C2 +C3 ≤ 1 (V3) +C3 ≤ 1 (V4) con C1, C2, C3 ≥ 0 dual d min v1 +v2 +v3 +v4 s.t v1+V2 ≥ 2 (C1) +V2 +V3 ≥ 2 (C2) +V3 +V4 ≥ 2 (C3) con V1, V2, V3, V4 ≥ 0 Figura 5: Formulación del ciclo. Sea P la restricción de P que contiene columnas C1 y C3 solamente. Sea D el dual de P, es decir, D es solo D sin la restricción C2. Debido a que P y D son pequeños, podemos resolverlos para obtener OPT (P) = OPT (D) = 4, con COP T (P) = C1 = C3 = 1 y Vop t (D) = V1 = V2 = V3 =V4 = 1. Mientras que COP T (P) debe ser una solución factible de P, resulta (afortunadamente) que Vop t (D) es factible para D, de modo que opta (D) ≥ Opt (D). Podemos verificar esto verificando que Vop t (d) satisface las restricciones de D que aún no están en DI.E.restricción c2. Se deduce que opt (p) = opt (d) ≥ opt (d) = opt (p), por lo que vop t (p) es probablemente una solución óptima para p, aunque P contiene un solo subconjunto estricto de las columnasde P. Por supuesto, puede resultar (desafortunadamente) que Vop t (d) no es factible para D. Esto puede suceder arriba si vop t (d) = v1 = 2, v2 = 0, v3 = 0, v4 =2. Aunque todavía podemos ver que OPT (D) = OPT (D), en general no podemos probar esto porque D y P son demasiado grandes para resolver. En cambio, debido a que se viola la restricción C2, agregamos la columna C2 a P, actualizamos D y repetimos. El problema de encontrar una restricción violada se llama problema de fijación de precios. Aquí, el precio de una columna (ciclo en nuestra configuración) es la diferencia entre su peso y la suma de doble valor de los vértices de los ciclos. Si alguna columna de P tiene un precio positivo, se viola su restricción correspondiente y aún no hemos demostrado una optimización. En este caso, debemos continuar generando columnas para agregar a P.5.2.1 Problema de precios Para casos más pequeños, podemos mantener una colección explícita de todos los ciclos factibles. Esto hace que el problema de precios sea fácil y eficiente para resolver: simplemente atravesamos la recolección de ciclos y buscamos ciclos con precio positivo. Incluso podemos encontrar ciclos con el precio más positivo, que son los más propensos a mejorar el valor objetivo del LP restringido [1]. Sin embargo, este enfoque no escala. Un mercado con 5000 pacientes puede tener hasta 400 millones de ciclos de longitud como máximo 3 (ver Tabla 2). Estos son demasiados ciclos para mantener en la memoria. Por lo tanto, para casos más grandes, tenemos que generar ciclos factibles mientras buscamos uno con un precio positivo. Hacemos esto utilizando un algoritmo de búsqueda de profundidad en el gráfico del mercado (ver Figura 1). Para hacer esta búsqueda más rápido, exploramos los vértices en un orden de valor no reducido, ya que es más probable que estos vértices pertenezcan a ciclos con peso positivo. También utilizamos varias reglas de poda para determinar si la ruta de búsqueda actual puede conducir a un ciclo de peso positivo. Por ejemplo, en un vértice dado en la búsqueda, podemos podar en función del hecho de que cada vértice que visitemos a partir de este punto tendrá valor al menos tan grande el vértice actual. Incluso con estas reglas de poda, la generación de columnas es un cuello de botella. Por lo tanto, también implementamos las siguientes optimizaciones. Cada vez que la búsqueda demuestra exhaustivamente que un vértice no pertenece a un ciclo de precio positivo, marcamos el vértice y no lo usamos como la raíz de una búsqueda de profundidad hasta que su doble valor disminuya. De esta manera, evitamos repetir innecesariamente nuestros esfuerzos computacionales de una iteración de generación de columna anterior. Finalmente, a veces puede ser beneficioso que la generación de columnas incluya varias columnas de precio positivo en una iteración, ya que puede ser más rápido generar una segunda columna, una vez que se encuentra la primera. Sin embargo, evitamos esto por la siguiente razón. Si intentamos encontrar columnas más positivas de precio que las que se encuentran, o si las columnas están muy separadas en el espacio de búsqueda, terminamos teniendo que generar y verificar una gran parte de la colección de ciclos factibles. En nuestros experimentos, hemos visto que esto ocurre en los mercados con cientos de millones de ciclos, lo que resulta en costos de cálculo prohibitivamente costosos.5.2.2 Sembrado de columna incluso si solo hay un pequeño espacio para la relajación maestra de LP, la generación de columnas requiere muchas iteraciones para mejorar el valor objetivo del LP restringido. Cada una de estas 300 iteraciones es costosa, ya que debemos resolver el problema de precios y volver a resolver el LP restringido. Por lo tanto, aunque podríamos comenzar sin columnas en el LP restringido, es mucho más rápido sembrar el LP con suficientes columnas para que el valor objetivo óptimo no esté demasiado lejos del LP maestro. Por supuesto, no podemos incluir tantas columnas que nos quedamos sin memoria. Experimentamos con varios sembradores de columna. En una clase de sembradora, usamos una heurística para encontrar un intercambio, y luego agregamos los ciclos de ese intercambio al LP restringido inicial. Implementamos dos heurísticas. El primero es un algoritmo codicioso: para cada vértice en un orden aleatorio, si se descubre, intentamos incluir un ciclo que lo contenga y otros vértices descubiertos. La otra heurística utiliza un código de correspondencia especializado de peso máximo [16] para encontrar una cubierta óptima por ciclos de longitud 2. Estas heurísticas funcionan extremadamente bien, especialmente teniendo en cuenta el hecho de que solo agregan un pequeño número de columnas. Por ejemplo, la Tabla 1 muestra que una cubierta óptima por ciclos de longitud-2 tiene casi tanto peso como el intercambio con el tamaño del ciclo sin restricciones. Sin embargo, tenemos suficiente memoria para incluir cientos de miles de columnas adicionales y, por lo tanto, acercarnos más al límite superior. Nuestro mejor sembrador de columna construye una colección aleatoria de ciclos factibles. Dado que un mercado con 5000 pacientes puede tener hasta 400 millones de ciclos factibles, lleva demasiado tiempo generar y atravesar todos los ciclos factibles, por lo que no incluimos una colección uniformemente aleatoria. En cambio, realizamos una caminata aleatoria en el gráfico del mercado (ver, por ejemplo, Figura 1), en la cual, después de cada paso de la caminata, probamos si hay una ventaja en nuestro camino que forma un ciclo factible. Si encontramos un ciclo, se incluye en el LP restringido, y comenzamos una nueva caminata desde un vértice aleatorio. En nuestros experimentos (ver Sección 6), usamos este algoritmo para sembrar el LP con 400,000 ciclos. Este último enfoque supera a los sembradores heurísticos descritos anteriormente. Sin embargo, en nuestro algoritmo, usamos una combinación que toma la unión de todas las columnas de las tres sembradoras. En la Figura 6, comparamos el rendimiento de la combinación de sembradora contra la combinación sin el sembrador de colección aleatoria. No trazamos el rendimiento del algoritmo sin ningún sembrador, ya que puede tomar horas eliminar los mercados que de otro modo podemos aclarar en unos minutos.5.2.3 Probar la optimización recuerde que nuestro objetivo es encontrar una solución óptima para la relajación maestra de LP. Usando la generación de columnas, podemos demostrar que una solución limitada a primeras es óptima una vez que todas las columnas tienen precios no positivos. Sin embargo, desafortunadamente, nuestro problema de compensación tiene el llamado efecto de cola de cola [1, Sección 6.3], en el cual, aunque el Primal restringido es óptimo en retrospectiva, se requiere una gran cantidad de iteraciones adicionales para demostrar la optimidad (es decir,, eliminar todas las columnas de precio positivo). No hay una buena solución general para el efecto de cola. Sin embargo, para mitigar este efecto, aprovechamos la siguiente observación específica del problema. Recuerde de la Sección 1.1 que, casi siempre, un intercambio de peso máximo con ciclos de longitud como máximo 3 tiene el mismo peso que un intercambio de peso máximo sin restricciones.(Esto no significa que el solucionador para el caso sin restricciones encontrará una solución con ciclos cortos, sin embargo). Además, el problema de limpieza sin restricciones se puede resolver en el tiempo polinomial (recuerdo de la sección 4). Por lo tanto, podemos calcular eficientemente un límite superior en la relajación maestra de LP y, cada vez que el Primal restringido logra este límite superior, ¡hemos demostrado optimización sin necesariamente tener que eliminar todas las columnas de precio positivo! Para que esto mejore el tiempo de ejecución del algoritmo general, necesitamos poder despejar el mercado sin restricciones en menos tiempo de lo que lleva la generación de columnas para eliminar todos los ciclos de precio positivo. A pesar de que el primer problema es la solución de tiempo polinómico, esto no es trivial para grandes casos. Por ejemplo, para un mercado con 10,000 pacientes y 25 millones de bordes, el código de correspondencia especializado de peso máximo [16] fue demasiado lento, y CPLEX se quedó sin memoria en la formulación de borde que codifica de la Sección 4. Para que esta idea funcione, utilizamos la generación de columnas para resolver la formulación de borde. Esto implica comenzar con un pequeño subconjunto aleatorio de los bordes, y luego agregar bordes de precio positivos uno por uno hasta que no quede ninguno. Llevamos a cabo esta generación de columna secundaria no en el gráfico de mercado original G, sino en el gráfico bipartito coincidente perfecto de la Figura 3. Hacemos esto para que solo necesitemos resolver el LP, no el ILP, ya que la brecha de integralidad en el gráfico bipartito coincidente perfecto es 1-I.E.Siempre existe una solución integral que logra el límite superior fraccional. La aceleración resultante del algoritmo general es dramático, como se puede ver en la Figura 6. 5.2.4 Managemento de columnas Si el valor óptimo del LP P P. está lejos del LP P Mast Master, entonces se genera una gran cantidad de columnas.antes de que se cierre la brecha. Esto lleva a problemas de memoria en los mercados con tan solo 4,000 pacientes. Además, incluso antes de que la memoria se convierta en un problema, las iteraciones de generación de columnas se vuelven lentas debido a la sobrecarga adicional de resolver un LP más grande. Para abordar estos problemas, implementamos un esquema de gestión de columnas para limitar el tamaño del LP restringido. Cada vez que agregamos columnas al LP, verificamos si contiene más de un número umbral de columnas. Si este es el caso, eliminamos selectivamente columnas hasta que esté nuevamente por debajo del umbral2. Como discutimos anteriormente, solo una pequeña fracción de todos los ciclos terminará en la solución final. Es poco probable que eliminemos ese ciclo, e incluso si lo hacemos, siempre se puede generar nuevamente. Por supuesto, no debemos ser demasiado agresivos con el umbral, porque hacerlo puede compensar las ganancias de rendimiento por iteración al aumentar significativamente el número de iteraciones necesarias para obtener una columna adecuada establecida en el LP al mismo tiempo. Hay algunas columnas que nunca eliminamos, por ejemplo, en las que hemos ramificado (ver Sección 5.3.2), o aquellas con un valor LP distinto de cero. Entre el resto, eliminamos aquellos con el precio más bajo, ya que las corresponden a las limitaciones duales que están más satisfechas. Este esquema de gestión de columnas funciona bien y nos ha permitido limpiar los mercados con 10,000 pacientes, como se ve en la Figura 6. 5.3 Búsqueda de sucursal y precio para el ILP dado un gran problema de compensación de mercado, podemos resolver con éxito su relajación de LP a la optimización porUso de las mejoras de generación de columnas descritas anteriormente. Sin embargo, las soluciones que encontramos suelen ser fraccionales. Por lo tanto, los siguientes 2 basados en el tamaño de la memoria, establecemos el umbral en 400,000.301 El paso implica realizar una búsqueda de árbol de rama y precio [1] para encontrar una solución integral óptima. Brevemente, esta es la idea de ramas y precios. Cada vez que establecemos una variable fraccional en 0 o 1 (rama), tanto el LP maestro como la restricción con la que estamos trabajando, se cambian (restringidos). Por defecto, debemos realizar la generación de columnas (pasar por el esfuerzo de precios) en cada nodo del árbol de búsqueda para demostrar que la restricción restringida es óptima para LP maestro restringido.(Sin embargo, como se discutió en la Sección 5.2.3, calculamos el límite superior integral para el nodo raíz basado en relajar por completo la restricción de la longitud del ciclo, y cada vez que cualquier nodo LP en el árbol logra ese valor, no necesitamos continuar con las columnas de fijación de preciosen ese nodo). Para el problema de compensación con ciclos de longitud en la mayoría de los 3, hemos descubierto que rara vez hay una brecha entre las soluciones integrales y fraccionales óptimas. Esto significa que podemos evitar en gran medida el costoso paso de precios por nodo: cada vez que el LP restringido restringido tiene el mismo valor óptimo que su padre en la búsqueda de árboles, podemos probar la optimización de LP, como en la Sección 5.2.3, sin tener que incluir ningún adicional.Columnas en el LP restringido. Aunque CPLEX puede resolver ILP, no admite ramas y precios (por ejemplo, porque puede haber problemas específicos que implican la interacción entre la regla de ramificación y el problema de los precios). Por lo tanto, implementamos nuestro propio algoritmo de rama y precio, que explora el árbol de búsqueda en el primer orden. También experimentamos con el orden de selección del nodo A* [7, 2]. Sin embargo, esta estrategia de búsqueda requiere significativamente más memoria, lo que encontramos que se empleó mejor para hacer que la fase de generación de columnas sea más rápida (ver Sección 5.2.2). Los componentes principales restantes del algoritmo se describen en las siguientes dos subsecciones.5.3.1 Heurística primaria Antes de ramificarse en una variable fraccional, utilizamos heurísticas primarias para construir una solución integral factible. Estas soluciones son límites más bajos en las soluciones integrales óptimas finales. Por lo tanto, cada vez que una solución fraccional restringida no es mejor que la mejor solución integral que se encuentra hasta ahora, podamos el subárbol actual. Una heurística primaria es efectiva si es eficiente y construye límites inferiores apretados. Experimentamos con dos heurísticas primarias. El primero es un algoritmo de redondeo simple [8]: incluya todos los ciclos con valor fraccional al menos 0.5, y luego, asegurando la viabilidad, agregue con codicia los ciclos restantes. Si bien esta heurística es eficiente, encontramos que los límites inferiores que construye rara vez permiten mucha poda. También intentamos usar CPlex como heurística primaria. En cualquier nodo dado del árbol de búsqueda, podemos convertir la relajación de LP restringida a un ILP reintroduciendo las restricciones de integralidad. CPLEX tiene varias heurísticas primarias incorporadas, que podemos aplicar a este ILP. Además, podemos usar la búsqueda de árboles de Cplexs Own para encontrar una solución integral óptima. En general, esta búsqueda de árboles es mucho más rápida que la nuestra. Si CPLEX encuentra una solución integral que coincide con el límite superior fraccional en el nodo raíz, estamos listos. De lo contrario, no existe dicha solución integral, o aún no tenemos la combinación correcta de ciclos en el LP restringido. Para los mercados de intercambio renal, generalmente es la segunda razón que se aplica (ver secciones 5.2.2 y 5.2.4). Por lo tanto, en algún momento de la búsqueda del árbol, una vez más columnas se han generado como resultado de la ramificación, la heurística CPlex encontrará una solución integral óptima. Aunque la búsqueda de árboles CPLEX es más rápida que la nuestra, no es tan rápido que podamos aplicarla a cada nodo de nuestro árbol de búsqueda. Por lo tanto, hacemos las siguientes optimizaciones. En primer lugar, agregamos una restricción que requiere que el valor objetivo de la ILP sea tan grande como el objetivo fraccional. Si este no es el caso, queremos abortar y proceder a generar más columnas con nuestra búsqueda de ramificación y precio. En segundo lugar, limitamos el número de nodos en el árbol de búsqueda de CPlexs. Esto se debe a que hemos observado que no existe una solución integral, CPLEX puede tardar mucho en demostrarlo. Finalmente, solo aplicamos la heurística CPLEX en un nodo si tiene un conjunto de ciclos suficientemente diferente de su padre. El uso de CPLEX como heurística primaria tiene un gran impacto porque hace que el árbol de búsqueda sea más pequeño, por lo que todo el trabajo de precios computacionalmente costoso se evita en los nodos que no se generan en este árbol más pequeño.5.3.2 Brancher de ciclo experimentamos con dos estrategias de ramificación, las cuales seleccionan una variable por nodo. La primera estrategia, ramificada por certeza, selecciona aleatoriamente una variable de aquellos cuyo valor de LP es más cercano a 1. La segunda estrategia, ramificada por incertidumbre, selecciona aleatoriamente una variable cuyo valor de LP es más cercano a 0.5. En cualquier caso, se generan dos hijos del nodo correspondiente a dos subárboles, uno en el que la variable se establece en 0, la otra en la que se establece en 1. Nuestra búsqueda en profundidad siempre elige explorar primero el subárbol en el que el valor de la variable está más cerca de su valor fraccional. Para nuestro problema de limpieza con ciclos de longitud en la mayoría de los 3, encontramos que la ramificación por incertidumbre es superior, y rara vez requiere cualquier retroceso.6. Resultados experimentales Todos nuestros experimentos se realizaron en Linux (Red Hat 9.0), utilizando una PC Dell con un procesador Intel Pentium 4 de 3GHz y 1 GB de RAM. Dondequiera que usamos CPLEX (por ejemplo, para resolver el LP y como heurística primaria, como se discutió en las secciones anteriores), utilizamos CPlex 10.010. La Figura 6 muestra el rendimiento del tiempo de ejecución de cuatro algoritmos de compensación. Para cada tamaño del mercado enumerado, generamos al azar 10 mercados e intentamos despejarlos utilizando cada uno de los algoritmos. El primer algoritmo es CPlex en la formulación de ciclo completo. Este algoritmo no puede borrar ningún mercado con 1000 pacientes o más. Además, su tiempo de ejecución en los mercados más pequeños que esto es significativamente peor que los otros algoritmos. Los otros algoritmos son las variaciones del enfoque de generación de columna incremental descrito en la Sección 5. Comenzamos con la siguiente configuración (todas las optimizaciones están encendidas): Categoría Configuración de la columna Combinación del intercambio codicioso y heurísticas correspondientes de peso máximo y sembradora de caminata aleatoria (400,000 ciclos). Columna generación una columna a la vez. Gestión de columnas en, con 400,000 columnas límite. Optimity Prover en. Redondeo heurístico primario y búsqueda de árboles CPLEX. Incertidumbre de la regla de ramificación.302 La combinación de estas optimizaciones nos permite despejar fácilmente los mercados con más de 10,000 pacientes. En cada uno de los siguientes dos algoritmos, realizamos una de estas optimizaciones para resaltar su efectividad. Primero, restringimos el sembrador para que solo comience con 10,000 ciclos. Esta configuración es más rápida para instancias más pequeñas, ya que las relajaciones de LP son más pequeñas y más rápidas de resolver. Sin embargo, con 5000 vértices, este efecto comienza a ser compensado por la generación de columnas adicional que debe realizarse. Para un caso más grande, este sembrador restringido es claramente peor. Finalmente, restauramos el sembrador a su configuración optimizada, pero esta vez, eliminamos el Prover de optimización descrito en la Sección 5.2.3. Como en muchos problemas de generación de columnas, el efecto de cola es sustancial. Al aprovechar las propiedades de nuestro problema, logramos borrar un mercado con 10,000 pacientes en aproximadamente el mismo tiempo que de otro modo habría tomado para eliminar un mercado de 6000 pacientes.7. Filmando la tecnología, nuestro algoritmo e implementación reemplazaron a CPlex como el algoritmo de compensación de la Alianza para la Donación Emparejada, uno de los principales intercambios de riñones, en diciembre de 2006. Llevamos a cabo una carrera de partido cada dos semanas, y los primeros trasplantes basados en nuestras soluciones ya se han realizado. Si bien hay (por razones políticas/interpersonales) al menos cuatro intercambios de riñones en los Estados Unidos actualmente, todos entienden que un intercambio nacional no fragmentado unificado salvaría más vidas. Estamos en conversaciones con intercambios de riñón adicionales que están interesados en adoptar nuestra tecnología. De esta manera, nuestra tecnología (y los procesos a su alrededor) servirán como un sustrato que eventualmente ayudará a unificar los intercambios. Al menos la escalabilidad computacional ya no es un obstáculo.8. Conclusión y FUTURURECERECHE en este trabajo Hemos desarrollado los algoritmos exactos más escalables para los intercambios de trueque hasta la fecha, con un enfoque especial en el próximo mercado nacional de intercambio renal en el que los pacientes con enfermedad renal serán emparejados con donantes compatibles al intercambiar sus propios donantes dispuestos pero incompatibles. Con más de 70,000 pacientes que ya esperan un riñón cadáver en los Estados Unidos, este mercado se considera la única forma ética de reducir significativamente las 4.000 muertes por año atribuidas a la enfermedad renal. Nuestro trabajo presenta el primer algoritmo capaz de limpiar estos mercados a escala nacional. Resuelve de manera óptima el problema de compensación de intercambio de riñones con 10,000 pares de donordonee. Por lo tanto, no hay necesidad de recurrir a soluciones aproximadas. La mejor tecnología previa (Vanilla CPlex) no puede manejar instancias más allá de aproximadamente 900 pares de donantes de donantes porque se queda sin memoria. La clave para nuestra mejora es la formulación de problemas incrementales. Adaptamos dos paradigmas para la tarea: generación de restricciones y generación de columnas. Para cada uno, desarrollamos una gran cantidad de técnicas que mejoran sustancialmente el tiempo de ejecución y el uso de la memoria. Algunas de las técnicas utilizan observaciones específicas del dominio, mientras que otras son independientes del dominio. Concluimos que la generación de columnas escala dramáticamente mejor que la generación de restricciones. Para la generación de columnas en el LP, nuestras mejoras incluyen técnicas de fijación de precios, técnicas de siembra de columna, técnicas para demostrar optimización sin tener que traer todas las columnas de precio positivo (y usar otro proceso de generación de columnas en una formulación diferente para hacerlo) y columnaTécnicas de eliminación. Para la búsqueda de ramificación y precio en el programa entero que rodea el LP, nuestras mejoras incluyen heurísticas primarias y también comparamos estrategias de ramificación. Sin lugar a dudas, se podrían usar una mayor ajuste de parámetros y quizás técnicas adicionales de mejora de velocidad para hacer que el algoritmo sea aún más rápido. Nuestro algoritmo también admite varias generalizaciones, como lo desean los intercambios de riñones del mundo real. Estos incluyen múltiples donantes alternativos por paciente, bordes ponderados en el gráfico del mercado (para codificar las diferencias en los años de vida esperados agregados en base a grados de compatibilidad, edad y peso del paciente, etc., así como la probabilidad de incompatibilidad de última hora), Angel-Las cadenas activadas (cadenas de trasplantes desencadenados por donantes altruistas que no tienen pacientes asociados con ellos, cada cadena que termina con un riñón sobrante) y problemas adicionales (como diferentes puntajes para guardar diferentes donantes altruistas o riñones sobrantes paraFuture Match se ejecuta en función del tipo de sangre, el tipo de tejido y la probabilidad de que el órgano no desaparezca del mercado por el donante obteniendo dudas). Debido a que utilizamos una metodología ILP, también podemos apoyar una variedad de limitaciones laterales, que a menudo juegan un papel importante en los mercados de la práctica [19]. También podemos apoyar a forzar parte de la asignación, por ejemplo, este adolescente muy enfermo tiene que obtener un riñón si es posible. Nuestro trabajo ha tratado el intercambio de riñones como un problema por lotes con información completa (al menos a corto plazo, los intercambios de riñones probablemente continuarán funcionando en modo lotes de vez en cuando). Dos instrucciones importantes para el trabajo futuro son abordar explícitamente los aspectos de información limitada y en línea del problema. El aspecto en línea es que Dones y los donantes llegarán al sistema con el tiempo, y puede ser mejor no ejecutar el intercambio miopicalmente óptimo ahora, sino que ahorrará parte del mercado actual para coincidencias posteriores. De hecho, se ha realizado algunos trabajos sobre esto en ciertos entornos restringidos [22, 24]. El aspecto de información limitada es que incluso en el modo por lotes, el gráfico proporcionado como entrada no es completamente correcto: una serie de pares de donantes-donee que se cree que son compatibles como incompatibles cuando se realizan pruebas de último minuto más caras. Por lo tanto, sería deseable realizar una optimización con esto en mente, como la producción de un subgrafio robusto de bajo grado que se probará antes de que se produzca la coincidencia final, o generar un plan de contingencia en caso de falla. Actualmente estamos explorando una serie de preguntas en este sentido, pero ciertamente hay mucho más que hacer. Agradecimientos Agradecemos a los economistas Al Roth y Utku Unver, así como al cirujano de trasplante de riñón Michael Rees, por alertarnos sobre el hecho de que la tecnología previa era inadecuada para el problema de compensación a escala nacional, suministrando conjuntos de datos iniciales y discusiones sobre los detalles delproceso de intercambio renal. También agradecemos a Don Sheehy por llamar nuestra atención la idea del intercambio de zapatos. Este trabajo fue apoyado en parte por la National Science Foundation bajo las subvenciones IIS-0427858 y CCF-0514922.9. Referencias [1] C. Barnhart, E. L. Johnson, G. L. Nemhauser, M. W. P. Savelsbergh y P. H. Vance.303 0 500 1000 1500 2000 2500 3000 3500 4000 0 2000 4000 6000 8000 10000 Claro Tiempo (segundos) Número de pacientes nuestro algoritmo Nuestro algoritmo con sembradora de columna restringida Nuestro algoritmo sin optimización Formulación de ciclo CPLEX Figura 6: Resultados experimentales: tiempo de ejecución promedio con estándar Estándarbarras de desviación. Branch-and-Price: Generación de columnas para resolver grandes programas enteros. Operations Research, 46: 316-329, mayo-junio de 1998. [2] R. Dechter y J. Pearl. Las mejores estrategias de búsqueda generalizadas y la optimización de A*. Journal of the ACM, 32 (3): 505-536, 1985. [3] F. L. Delmonico. Cambio de riñones: avances en el trasplante de donantes vivos. New England Journal of Medicine, 350: 1812-1814, 2004. [4] J. Edmonds. Camino, árboles y flores. Canadian Journal of Mathematics, 17: 449-467, 1965. [5] M. R. Garey y D. S. Johnson. Computadoras e intratabilidad;Una guía de la teoría de la completitud de NP.1990. [6] S. E. Gentry, D. L. Segev y R. A. Montgomery. Una comparación de poblaciones servidas por donación pareada de riñón y donación emparejada en lista. American Journal of Transplantation, 5 (8): 1914-1921, agosto de 2005. [7] P. Hart, N. Nilsson y B. Raphael. Una base formal para la determinación heurística de rutas de costos mínimos. Transacciones IEEE en Systems Science and Cybernetics, 4 (2): 100-107, 1968. [8] K. Hoffman y M. Padberg. Resolver problemas de programación de la tripulación de la aerolínea por ramificación y corte. Management Science, 39: 657-682, 1993. [9] Intervac.http://intervac-online.com/.[10] Intercambio nacional de zapatos impares.http://www.oddshoe.org/.[11] Peerflix.http://www.peerflix.com.[12] Léelo cambiarlo.http://www.readitswapit.co.uk/.[13] A. E. Roth, T. Sonmez y M. U. Unver. Intercambio de riñón. Quarterly Journal of Economics, 119 (2): 457-488, mayo de 2004. [14] A. E. Roth, T. Sonmez y M. U. Unver. Una casa de compensación de intercambio de riñones en Nueva Inglaterra. American Economic Review, 95 (2): 376-380, mayo de 2005. [15] A. E. Roth, T. Sonmez y M. U. Unver. Intercambio renal eficiente: coincidencia de necesidades en un mercado con preferencias basadas en compatibilidad. American Economic Review, de próxima publicación.[16] E. Rothberg. GABOWS N3 Algoritmo de correspondencia de peso máximo: una implementación. El primer desafío de implementación de Dimacs, 1990. [17] S. L. Saidman, A. E. Roth, T. Snmez, M. U. Unver y F. L. Delmonico. Aumentando la oportunidad de la donación de riñón vivo al igualar para intercambios de dos y tres vías. Transplantation, 81 (5): 773-782, 2006. [18] T. Sandholm. Algoritmos óptimos de determinación del ganador. En subastas combinatorias, Cramton, Shoham y Steinberg, eds. MIT Press, 2006. [19] T. Sandholm y S. Suri. Restricciones laterales y atributos no publicitarios en los mercados. En el taller IJCAI-2001 sobre el razonamiento de restricciones distribuidas, páginas 55-61, Seattle, WA, 2001. Aparecer en juegos y comportamiento económico.[20] D. L. Segev, S. E. Gentry, D. S. Warren, B. Reeb y R. A. Montgomery. Donación de riñón y optimización del uso de órganos de donantes en vivo. Journal of the American Medical Association, 293 (15): 1883-1890, abril de 2005. [21] United Network for Organ Compartir (UNO).http://www.unos.org/.[22] M. U. Unver. Intercambio de riñón dinámico. Hoja de trabajo.[23] Sistema de datos renales de los Estados Unidos (USRDS).http://www.usrds.org/.[24] S. A. Zenios. Control óptimo de un programa de intercambio de kidney emparejado. Management Science, 48 (3): 328-342, marzo de 2002. 304