On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030Renda, Italia ggreco@mat.unical.it Resumen El problema de determinación del ganador en las subastas combinatorias es el problema de determinar la asignación de los artículos entre los licitadores que maximiza la suma de los precios de oferta aceptados. Si bien este problema es en general Nphard, se sabe que es factible en el tiempo polinomial en aquellos casos cuyos gráficos de elementos asociados han limitado el ancho de árboles (llamados gráficos de elementos estructurados). Formalmente, un gráfico de elementos es un gráfico cuyos nodos están en correspondencia uno a uno con los elementos, y los bordes son tales que para cualquier oferta, los elementos que ocurren en él inducen un subgrafio conectado. Tenga en cuenta que muchos gráficos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de los bordes seleccionados para garantizar la conexión. De hecho, la capacidad de extracción de determinar si existe un gráfico de elementos estructurado de un ancho de árbol fijo (y de ser así, calcular uno) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un gráfico de elementos estructurados es computacionalmente intratable, incluso para el ancho de árboles 3. Motivado por esta mala noticia, investigamos diferentes tipos de requisitos estructurales que pueden usarse para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hipertree, una medida recientemente introducida de ciclicidad del hipergrafio, resulta ser más útil aquí. De hecho, mostramos que el problema de determinación del ganador se puede solucionar en el tiempo polinomial en instancias cuyas interacciones de postor pueden representarse con hipergrafos (duales) que han limitado el ancho de hipertree. Aún más sorprendente, mostramos que la clase de instancias manejables identificadas por medio de nuestro enfoque contiene adecuadamente la clase de instancias que tienen un gráfico de elementos estructurados. Categorías y descriptores de sujetos J.4 [Aplicaciones informáticas]: Ciencias Sociales y del Comportamiento-Economía;F.2 [Teoría de la computación]: Análisis de algoritmos y complejidad del problema 1. Introducción Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde los postores pueden ofertar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de los postores de un paquete de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de los agentes en varios dominios de aplicación (cf., por ejemplo, [21]) como los mercados de electricidad [13], las subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, b, donde i = {i1, ..., im} es el conjunto de artículos que el subastador tiene que vender, y b = {b1, ..., bn} es el conjuntode ofertas de los compradores interesados en los artículos en I. Cada oferta BI tiene el formulario Artículo (BI), Pay (BI), donde el pago (BI) es un número racional que denota el precio que un comprador ofrece para los artículos en el artículo (BI) ⊆ I. Un resultado para I, B es un subconjunto B de B tal que el ítem (bi) ∩Item (bj) = ∅, para cada par bi y bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado B ∗ que maximiza la suma de los precios de oferta aceptados (es decir, bi∈B ∗ Pay (BI)) sobre todos los resultados posibles. Se sabe que este problema, llamado problema de determinación del ganador (por ejemplo, [11]), es intratable, en realidad np-hard [17], e incluso no es aproximado en el tiempo polinomial a menos que np = zpp [19]. Por lo tanto, no sorprende que se hayan gastado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias en las que resolver el problema de determinación de ganadores es factibleen tiempo polinomial (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción del postor es útil para identificar clases de subastas combinatorias manejables. Gráficos de elementos. Actualmente, la clase más general de subastas combinatorias manejables se ha señalado modelando interacciones entre los postores con la noción de gráfico de elementos, que es un gráfico cuyos nodos están en correspondencia individual con elementos, y los bordes son tales que para cualquiera de152 Figura 1: Ejemplo MAXWSP Problema: (a) Hypergraph H i0, B0 y un empaque H para ello;(b) gráfico primario para H i0, B0;y, (c, d) dos gráficos de elementos para H i0, b0.Bid, los artículos que ocurren en él inducen un subgrafio conectado. De hecho, se demostró que el problema de determinación del ganador se soluciona en el tiempo polinomial si las interacciones entre los postores pueden representarse mediante un gráfico de elementos estructurados, es decir, un árbol o, en general, un gráfico que tiene una estructura similar a un árbol [3]-formalmenteancho de árbol delimitado [16]. Para tener cierta intuición sobre cómo se pueden construir gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B se puede representar mediante un hipergrafo H I, b de tal manera que su conjunto de nodos n (h i, b) coincide con el conjuntode los artículos I, y donde sus bordes E (H I, B) son precisamente las ofertas de los compradores {ítem (bi) |Bi ∈ B}. Un gráfico de elemento especial para I, B es el gráfico primario de H I, B, denotado por G (H I, B), que contiene un borde entre cualquier par de nodos en algún hiperedge de H I, B. Luego, cualquier gráfico de elementos para H I, B se puede ver como una simplificación de G (H I, B) obtenida eliminando algunos bordes, pero preservando la condición de conectividad en los nodos incluidos en cada hiperedge. Ejemplo 1. El hipergrafo H i0, B0 informado en la Figura 1. (a) es una codificación para una subasta combinatoria i0, b0, donde i0 = {i1, ..., i5} y item (bi) = hi, cada 1 ≤i ≤ 3. El gráfico primario para H i0, B0 se informa en la Figura 1. (b), mientras que se informan dos gráficos de elementos de ejemplo en la Figura 1. (c) y (d), donde los bordes necesarios para mantener la conectividad para H1 se representan en negrita.¡Abra el problema: calcular los gráficos de elementos estructurados de manera eficiente. El resultado de la tractabilidad mencionado anteriormente en gráficos de elementos estructurados resulta ser útil en la práctica solo cuando un gráfico de elementos estructurados se da o puede determinarse de manera eficiente. Sin embargo, exponencialmente, muchos gráficos de elementos pueden estar asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de un cierto ancho de árbol (constante), y de ser así, cómo calcular un gráfico de elementos tan estructurado de manera eficiente. Los algoritmos de tiempo polinomial para encontrar la mejor simplificación del gráfico primario hasta ahora solo se conocían por los casos en que el gráfico del elemento a construir es una línea [10], un ciclo [4] o un árbol [3], pero eraUn problema abierto importante (cf. [3]) si es manejable verificar si para una subasta combinatoria, un gráfico de elementos de ancho de árbol delimitado por un número natural fijo K existe y puede construirse en tiempo polinomial, si es así. Empacamiento de set ponderado. Observamos que la representación del hipergrafo H I, B de una subasta combinatoria I, B también es útil para hacer la analogía entre el problema de determinación del ganador y el problema máximo de empaquetado de set ponderado en hipergrafios claros (por ejemplo, [17]). Formalmente, un empaquetado H para un hipergrafo H es un conjunto de hiperedges de H tal que para cada par H, H ∈ H con H = H, sostiene que H ∩ H = ∅. Dejar que W sea una función de ponderación para h, es decir, una función computable de tiempo polinomialmente desde e (h) a números racionales, el peso de un empaque h es el número racional w (h) = h∈H w (h), donde w({}) = 0. Luego, el problema de embalaje del conjunto de ponderación máxima para H W.R.T.W, denotado por MaxWSP (H, W), es el problema de encontrar un embalaje para h que tiene el peso máximo sobre todos los empaques para H. para ver que MaxWSP es solo una formulación diferente para el problema de determinación del ganador, dada una subasta combinatoriaI, B, es suficiente definir la función de ponderación W I, B (ítem (BI)) = Pay (BI). Luego, el conjunto de soluciones para el problema de embalaje del conjunto ponderado para H I, B W.R.T.W I, B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, b. Ejemplo 2. Considere nuevamente el HyperGraph H i0, B0 informado en la Figura 1. (a). Un ejemplo de empaque para H i0, B0 es H = {H1}, que intuitivamente corresponde a un resultado para i0, B0, donde el subastador aceptó la oferta B1. Suponiendo que las ofertas B1, B2 y B3 son tales que el pago (B1) = Pay (B2) = Pay (B3), el empaque H no es una solución para el problema MAXWSP (H i0, B0, W i0, B0). De hecho, el embalaje h ∗ = {h2, h3} es tal que w i0, b0 (h ∗)> w i0, b0 (h).¡Contribuciones, el objetivo principal de este documento es identificar grandes clases manejables para el problema de determinación del ganador, que son, además, reconocibles polinómicamente. Hacia este objetivo, primero estudiamos gráficos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una muy mala noticia: está completa para verificar si una subasta combinatoria tiene un gráfico de elementos estructurados de ancho de árboles 3. Más formalmente, dejando que C (IG, K) denote la clase de todos los hipergrafos que tienen un árbol de elementos de ancho de árbol delimitado por K, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C (IG, 3)es NP-completado. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que se pueden verificar en tiempo polinomial y que aún se pueden usar para aislar clases manejables del problema de embalaje máximo del conjunto de peso o, de manera equivalente, el ganadorproblema de determinación. Nuestras investigaciones, esta vez, condujeron a muy buenas noticias que se resumen a continuación: para un hipergrafo H, su doble ¯h = (V, E) es tal que los nodos en V están en correspondencia uno a uno con hiperviges en H,y para cada nodo x ∈ N (h), {h |x ∈ H ∧ H ∈ 153 E (H)} está en E. Mostramos que MaxWSP es manejable en la clase de aquellas instancias cuyas hipergrafías duales tienen un ancho de hipertree [7] limitado por K (corto: Clase C (HW, K)de hipergrafos). Tenga en cuenta que una cuestión clave de la tractibilidad es considerar el ancho de hipertree del hipergrafio dual ¯h en lugar del hipergrafio de subasta H. De hecho, podemos demostrar que MaxWSP permanece np-Hard incluso cuando H es acíclico (es decir, cuando lo ha hechoAncho de hipertree 1), incluso cuando cada nodo está contenido en 3 hiperedges como máximo. Para algunas clases especiales relevantes de hipergrafos en C (HW, K), diseñamos un algoritmo altamente paralelo para MAXWSP. Específicamente, si las funciones de ponderación se pueden calcular en el espacio logarítmico y los pesos son polinómicos (por ejemplo, cuando todas las hiperegudes tienen pesos unitarios y uno está interesado en encontrar el empaque con el número máximo de bordes), mostramos que MaxWSP se puede resolverUn algoritmo LogCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son logspace reducibles a los idiomas libres de contexto, y que logcfl ⊆ nc2 ⊆ p (ver, por ejemplo, [9]). Sorprendentemente, mostramos que no se pierde nada en términos de generalidad al considerar la descomposición de la hipertree de los hipergrafios duales en lugar del ancho de árbol de los gráficos de los elementos. Por el contrario, el método de descomposición basado en hipertree propuesto es estrictamente más general que el método de los gráficos de elementos estructurados. De hecho, mostramos que las clases estrictamente más grandes de instancias son manejables de acuerdo con nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. Intuitivamente, la duración de NP de reconocer los gráficos de elementos estructurados del ancho limitado no se debe a su gran generalidad, sino a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos da una idea interesante de la noción de gráfico de elementos estructurados. De hecho, mostramos que los gráficos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hipertree del hipergrafo dual, que llamamos descomposiciones estrictas de hipertree. También se propone una caracterización del juego para la noción de ancho de hipertree estricto, que especializa el juego de ladrones y mariscales en [6] (propuesto para caracterizar el ancho de la hipertree), y lo que deja en claro los requisitos adicionales sobre las descomposiciones de hipertree. El resto del documento está organizado de la siguiente manera. La Sección 2 discute la intratabilidad de los gráficos de elementos estructurados. La Sección 3 presenta el algoritmo de tiempo polinomial para resolver MAXWSP en la clase de aquellos casos cuyos hipergrafos duales han limitado el ancho de hipertreos, y discute los casos en que el algoritmo también es muy paralelizado. La comparación entre las clases C (IG, K) y C (HW, K) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones al describir también instrucciones para futuras investigaciones.2. Complejidad de los gráficos de elementos estructurados que h sea un hipergrafo. Un gráfico g = (v, e) es un gráfico de elementos para h si v = n (h) y, para cada h ∈ E (h), el subgrafo de G inducido sobre los nodos en H está conectado. Una clase importante de gráficos de elementos es la de los gráficos de elementos estructurados, es decir, de aquellos gráficos de elementos que tienen el ancho de árbol delimitado como se formalizan a continuación. Una descomposición del árbol [16] de un gráfico G = (v, E) es un par t, χ, donde t = (n, f) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjuntode vértices χ (P) ⊆ V, de modo que se cumplan las siguientes condiciones: (1) para cada vértice B de G, existe p ∈ N tal que b ∈ χ (P);(2) Para cada borde {b, d} ∈ E, existe p ∈ N tal que {b, d} ⊆ χ (p);(3) Para cada vértice B de G, el conjunto {p ∈ N |b ∈ χ (p)} induce un subárbol conectado de T. El ancho de t, χ es el número maxp∈N | χ (p) - 1 |. El ancho de árbol de G, denotado por TW (g), es el ancho mínimo sobre todas sus descomposiciones de árboles. El problema de determinación del ganador se puede resolver en el tiempo polinomial en los gráficos de elementos que tienen el ancho de árbol delimitado [3]. Teorema 1 (cf. [3]). Suponga que se da una descomposición del árbol de ancho K, χ de un gráfico de elementos para H. Entonces, MaxWSP (H, W) se puede resolver en el tiempo O (| T | 2 × (| E (H) | +1) K+1). Muchos gráficos de elementos se pueden asociar con un hipergrafo. Como ejemplo, observe que el gráfico del elemento en la Figura 1. (c) tiene el ancho de árbol 1, mientras que la Figura 1. (d) informa un gráfico de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si para una constante K dada se puede verificar en el tiempo polinómico si existe un gráfico de elementos de ancho de árbol K, y si es así, si dicho gráfico de elementos se puede calcular de manera eficiente. Deje que C (IG, K) denote la clase de todos los hipergrafios que tienen un gráfico de elementos G de tal manera que tw (g) ≤ k.El resultado principal de esta sección es mostrar que la Clase C (IG, K) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C (IG, 3) es NP-Hard. La prueba de este resultado se basa en una reducción elaborada del problema de la ruta hamiltoniana HP (S, t) de decidir si hay una ruta hamiltoniana de un nodo a un nodo t en un gráfico dirigido g = (n, e). Para ayudar a la intuición, informamos aquí una descripción general de alto nivel de los ingredientes principales explotados en la prueba1. La idea general es construir un hipergrafo Hg de tal manera que haya un gráfico de elementos G para Hg con TW (g) ≤ 3 si y solo si HP (S, T) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver Figura 2. (a) Para una ilustración, donde el gráfico G consiste en los nodos S, X, Y y T, y el conjunto de sus bordes es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a Hg. Sea G = (N, E) un gráfico dirigido. Luego, el conjunto de nodos en Hg es tal que: para cada x ∈ N, N (Hg) contiene los nodos BSX, BTX, BX, BX, BDX;Para cada e = (x, y) ∈ E, N (Hg) contiene los nodos NSX, NSX, NTY, NTY, NSE X y NTE Y. Ningún otro nodo está en N (Hg). Las hiperedges en Hg son de tres tipos: 1) Para cada x ∈ N, E (Hg) contiene las hipedges: • Sx = {BSX} ∪ ∪ {nse x |e = (x, y) ∈ E};• tx = {btx} ∪ {nte x |e = (z, x) ∈ E};• a1 x = {bdx, bx}, a2 x = {bdx, bx} y a3 x = {bx, bx} -notice que estas hipermedges inducen una camarilla en los nodos {bx, bx, bdx};1 pruebas detalladas se pueden encontrar en el apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf.154 Figura 2: Prueba del teorema 2: (a) de g a Hg - hiperedges en 1) y 2) se informan solo;(b) Un esqueleto para una descomposición de árbol TD para Hg.• Sa1 x = {bsx, bx}, sa2 x = {bsx, bx}, sa3 x = {bsx, bdx} -notice que estos hipervedes más a1 x, a2 x y a3 x inducen una camarilla en los nodos {bsx, BX, BX, BDX};• ta1 x = {btx, bx}, ta2 x = {btx, bx}, y ta3 x = {btx, bdx} -notice que estos hiperedges más a1 x, a2 x y a3 x inducen una clique en los nodos {BTX, BX, BX, BDX};2) Para cada e = (x, y) ∈ E, E (Hg) contiene las hipedges: • shx = {nsx, nsx};• Thy = {nty, nty};• Ver = {nsx, nse x} y ver = {nsx, nse x} -notice que estas dos hipedges más shx inducen una camarilla en los nodos {nsx, nsx, nse x};• tee = {nty, nte y} y tee = {nty, nte y} -notice que estos dos hipedges más tuyos inducen una camarilla en los nodos {nty, nty, nte y}. Observe que cada una de las hiperedias anteriores, pero las de la forma SX y TX contienen exactamente dos nodos. Como ejemplo de las hiperedges de la especie 1) y 2), el lector puede referirse a la construcción de ejemplo informada en la Figura 2. (a), y notar, por ejemplo, que sx = {bsx, nse2 x, nse3 x} yque tt = {btt, nte4 t, nte3 t}.3) Finalmente, denotamos por DG el conjunto que contiene las hiperedges en E (Hg) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperedges que satisfacen las cuatro condiciones que se analizan a continuación. Deje que PG sea el conjunto de los siguientes | PG |≤ | n |+ 3 × | E |pares: pg = {(bx, bx) |x ∈ N} ∪ {(nsx, nsx), (nty, nty), (nse x, nte y) |e = (x, y) ∈ E}. Además, que i (v) denote el conjunto {h ∈ E (h) |v ∈ H} de las hiperedges de H que son tocadas por V;y, para un conjunto v ⊆ n (h), que i (v) = v∈V i (v). Entonces, DG tiene que ser un conjunto tal que: (C1) ∀ (α, β) ∈ PG, I (α) ∩ I (β) ∩ DG = ∅;(c2) ∀ (α, β) ∈ Pg, I (α) ∪ I (β) ⊇ DG;(c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ Pg o (β, α) ∈ Pg, es necesario: I (α) ∩ Dg = ∅;y, (c4) ∀s ⊆ n tal que | S |≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ Pg, es el caso que: i (s) ⊇ dg. Intuitivamente, el conjunto DG es tal que cada una de sus hiperedges es tocada exactamente por uno de los dos nodos en cada par 155 de PG - cf.(C1) y (C2). Además, las hiperedges en DG Touch solo los vértices incluidos en al menos un par de PG - cf.(C3);Y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se puede construir a partir de él pertenece a PG - cf.(C4). El lector ahora puede preguntar si existe un DG establecido en absoluto satisfactorio (C1), (C2), (C3) y (C4). En el siguiente lema, respondemos positivamente esta pregunta y remitimos al lector a su prueba para una construcción de ejemplo. Lema 1. Un conjunto DG, con | DG |= 2 × | PG |+ 2, condiciones satisfactorias (C1), (C2), (C3) y (C4) se pueden construir en el tiempo O (| Pg | 2). Ingredientes principales. Ahora estamos en la posición de presentar una descripción general de los ingredientes clave de la prueba. Sea G un gráfico de elementos arbitrarios para Hg, y TD = T, χ sea una descomposición de un árbol de 3 anchos de G (tenga en cuenta que, debido a las camarillas, por ejemplo, en los nodos {BSX, BX, BX, BDX},Cualquier gráfico de elementos para HG tiene al menos el ancho de árbol 3). Hay tres observaciones básicas que cumplen el propósito de probar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértice. Específicamente, para cada nodo x ∈ N, TD contiene un vértice BS (x) tal que χ (BS (X)) ⊇ {BSX, BX, BX, BDX} y un vértice BT (x) tal que χ (BT (BT (BT (BT (x)) ⊇ {btx, bx, bx, bdx}. Y, para cada borde e = (x, y) ∈ E, td contiene un vértice ns (x, e) tal que χ (ns (x, e)) ⊇ {nse x, nsx, nsx} y un vértice nt(y, e) tal que χ (nt (y, e)) ⊇ {nte y, nty, nty}. Intuitivamente, estos vértices son necesarios para cubrir las camarillas de Hg asociadas con las hiperedges de la especie 1) y 2). Cada uno de estos vértices juega un papel específico en la reducción. De hecho, cada borde dirigido e = (x, y) ∈ E está codificado en TD por medio de los vértices: ns (x, e), que representa con precisión que E comienza desde x;y, nt (y, e), representando precisamente que E termina en y. Además, cada nodo x ∈ N está codificado en TD medias de los vértices: BS (x), que representa el punto de partida de los bordes originados desde x;y, bt (x), que representa el punto de terminación de los bordes que terminan en x. Como ejemplo, la Figura 2. (b) informa el esqueleto de un árbol de descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipergrafo Hg en la Figura 2. (a) - Otros bloques en él (de la forma w (x, y)) se definen a continuación. Conexión entre bloques y singularidad de las conexiones: la segunda observación crucial es que en la ruta que conecta un vértice de la forma BS (X) (resp., Bt (y)) con un vértice de la forma NS (X, E)(resp., nt (y, e)) Hay un vértice especial de la forma w (x, y) tal que: χ (w (x, y)) ⊇ ⊇ {nse x, nte y}, para algún borde e= (x, y) ∈ E. Garantizar la existencia de uno de esos vértices es precisamente el papel desempeñado por las hipedges en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que i (χ (BS (x))) ∩ I (χ (NS (X, E))) ⊇ DG ∪ {SX} e I (χ (Bt (y))) ∩ I (χ (nt (y, e))) ⊇ dg ∪ {ty}. Luego, mostramos una propiedad que indica que para un par de vértices consecutivos P y Q en la ruta que conecta BS (X) y NS (X, E) (resp., Bt (y) y Nt (y, E)), I(χ (P) ∩ χ (Q)) ⊇ I (χ (BS (X))) ∩ I (χ (NS (X, E)) (resp., I (χ (P) ∩ χ χ (Q)) ⊇ I (χ (Bt (x))) ∩ I (χ (NT (y, E)))). Por lo tanto, tenemos: I (χ (P) ∩ χ (Q)) ⊇ DG ∪ {SX} (resp., I (χ (P) ∩χ (Q)) ⊇ Dg ∪ {Ty}). Según esta observación, y al explotar las propiedades de las hiperedges en DG, no es difícil demostrar que cualquier par de vértices consecutivos P y Q deben compartir dos nodos de Hg que formen un par en PG, y debe tocar SX (resp.., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w (x, y), en este camino es tal que χ (W (x, y)) ⊇ {nse x, nte y}, para algún bordee = (x, y) ∈ E - a este extremo, tenga en cuenta que nse x ∈ Sx, nte t ∈ Ty e i (χ (W (x, y))) ⊇ dg. En particular, w (x, y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay más vértice de la forma w (x, z), para z = y (resp., W (z, y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w (x, y) en TD corresponde a la selección de un borde desde el nodo x al nodo y en la ruta hamiltoniana. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de una ruta hamiltoniana para G y los vértices de la forma w (x, y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w (s, x), w (x, y) y w (y, t) están en td, y gt d muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w (x, y), para un borde e = (x, y) ∈ E no está en TD (es decir, si el borde(x, y) no pertenece a la ruta hamiltoniana), entonces el bloque correspondiente ns (x, e) (resp., nt (y, e)) puede agregarse arbitrariamente en el subárbol enraizado en el bloque ns (x,e) (resp., nt (y, e)), donde e es el borde de la forma e = (x, z) (resp., e = (z, y)) tal que w (x, z) (resp., W (z, y)) está en td. Por ejemplo, la figura 2. (a) muestra W (x, t), que no se usa en TD, y la Figura 2. (b) muestra cómo se pueden organizar los bloques NS (X, E3) y NT (T, E3)en TD para garantizar la condición de conexión.3. Casos manejables a través de descomposiciones de hipertree Dado que la construcción de gráficos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden usarse para soltar clases de instancias MAXWSP manejables. Con este fin, nos centramos en la noción de descomposición de hipertree [7], que es una generalización natural de la aciclicidad del hipergrafio y que se ha utilizado de manera rentable en otros dominios, por ejemplo, satisfacción de restricciones y evaluación de consultas de bases de datos, para identificar islas de tractabilidad para NP-problemas difíciles. Un hipertree para un hipergrafo H es un triple t, χ, λ, donde t = (n, e) es un árbol enraizado, y χ y λ son funciones de etiquetado que asocian cada vértice p ∈ N con dos conjuntos χ (p) ⊆N (h) y λ (p) ⊆ e (h). Si t = (n, e) es un subárbol de t, definimos χ (t) = v∈N χ (v). Denotamos el conjunto de vértices n de t por vértices (t). Además, para cualquier p ∈ N, TP denota el subárbol de t enraizado en p.Definición 1. Una descomposición de hipertree de un hipergrafo H es un hipertree HD = t, χ, λ para H que satisface todas las condiciones siguientes: 1. Para cada borde H ∈ E (H), existe p ∈ Vértices (t) tal que H ⊆χ (P) (decimos que P cubre h);156 Figura 3: Ejemplo MAXWSP Problema: (a) Hypergraph H1;(b) Hypergraph ¯h1;(b) Una descomposición hipertree de 2 anchas de ¯h1.2. Para cada nodo y ∈ N (h), el conjunto {p ∈ Vértices (t) |Y ∈ χ (P)} induce un subárbol (conectado) de t;3. Para cada p ∈ Vértices (t), χ (P) ⊆ N (λ (P));4. Para cada p ∈ Vértices (t), n (λ (p)) ∩ χ (TP) ⊆ χ (P). El ancho de una descomposición de hipertree t, χ, λ es maxp∈vertices (t) | λ (p) |. El ancho de hipertree HW (H) de H es el ancho mínimo sobre todas sus descomposiciones de hipertree. Un hipergrafo H es acíclico si HW (H) = 1. P Ejemplo 3. El hipergrafo H i0, B0 informado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergrafos H1 como ¯h1 que se muestran en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su ancho de hipertree es 2. En la Figura 3. (c) se informa una descomposición de hipertreas de 2 anchas para ¯h1. En particular, observe que H1 se ha obtenido agregando las dos hiperedges H4 y H5 a H i0, B0 para modelar, por ejemplo, que se han propuesto dos nuevas ofertas, B4 y B5, respectivamente, al subastador.¡A continuación, en lugar de trabajar en el hipergrafo H asociado con un problema MAXWSP, trataremos con su dual ¯h, es decir, con el hipergrafo de tal manera que sus nodos están en correspondencia uno a uno con las hiperedges de H,y donde para cada nodo x ∈ N (h), {h |x ∈ H ∧ H ∈ E (H)} está en E (¯h). Como ejemplo, el lector puede querer verificar nuevamente el hipergrafo H1 en la Figura 3. (a) y observe que el hipergrafo en la Figura 3. (b) es de hecho su doble. La justificación de esta elección es que emitir restricciones en el hipergrafio original es una garantía para la tractabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP es (1) en P si cada nodo ocurre en dos hipedges como máximo;y, (2) NP-Hard, incluso si cada nodo está contenido en tres hiperedges como máximo.3.1 La descomposición de hipertree en los problemas de empaque de doble hipergrafo y manejo de una constante fija K, Sea C (HW, K) denota la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hipertree limitado por K.El problema máximo de empaquetado de set ponderado se puede resolver en el tiempo polinomial en la Clase C (HW, K) por medio del algoritmo ComputesetPackingk, que se muestra en la Figura 4. El algoritmo recibe en la entrada A HyperGraph H, una función de ponderación W y una descomposición de hipertreos de ancho K HD = T = (N, E), χ, λ de ¯h. Para cada vértice v ∈ N, deje que HV sea el hipergrafo cuyo conjunto de nodos n (HV) ⊆ N (H) coincide con λ (V), y cuyo conjunto de bordes E (HV) ⊆ E (H) coincide con χ (v). En un paso de inicialización, el algoritmo equipa cada vértice V con todos los empaques posibles para HV, que se almacenan en el conjunto HV. Tenga en cuenta que el tamaño de HV está limitado por (| E (H) | + 1) K, ya que cada nodo en λ (v) se deja descubierto en un embalaje o está cubierto con precisamente uno de los hiperedges en χ (V)⊆ E (H). Luego, COTSESETPACKINGK está diseñado para filtrar estos empaques reteniendo solo aquellos que se ajustan con algún empaque para HC, para cada niños C de V en T, como se formalizó a continuación. Deje que HV y HC sean dos empaques para HV y HC, respectivamente. Decimos que HV se ajusta con HC, denotado por HV ≈ Hc If: para cada h ∈ Hc ∩ E (HV), H está en HV;y, para cada h ∈ (E (HC) - HC), H no está en HV. Ejemplo 4. Considere nuevamente la descomposición hipertree de ¯h1 informada en la Figura 3. (c). Luego, el conjunto de todos los empaques posibles (que se construyen en el paso de inicialización de COMPUTSETPackingk), para cada uno de sus vértices, es Refigurar 5: Aplicación de ejemplo de algoritmo ComputSetPackingk.157 Entrada: H, W, y una descomposición de hipertreos de ancho K hd = t = (n, e), χ, λ de ¯h;Salida: una solución a maxwsp (h, w);var hv: conjunto de paquetes para HV, para cada v ∈ N;H ∗: Embalaje para H;V HV: número racional, para cada empaquetado parcial HV para HV;HHV, C: Embalaje parcial para HC, para cada empaquetado parcial HV para HV, y para cada uno (V, C) ∈ E;---------------------------------------Comience realizado: = el conjunto de todas las hojas de t;mientras que ∃v ∈ T tal que (i) v ∈ Hecho, y (ii) {c |C es el niño de V} ⊆ Do Do para cada C tal que (V, C) ∈ E do HV: = HV - {HV |∃hc ∈ Hc S.T.HV ≈ HC};Para cada hv ∈ Hv do v Hv: = W (HV);para cada c tal que (v, c) ∈ E do ¯hc: = arg maxhc∈Hc | hv≈ hc c hc - w (hc ∩ hv);hhv, c: = ¯hc;( * Establecer el mejor empaque *) v Hv: = V HV + C ¯HC - W (¯HC ∩ HV);finalizar para finalizar para: = hecho ∪ {v};terminar mientras final;----------------------------------------------- Begin ( * principal *) paraCada vértice v in t do hv: = {hv empaque para hv};De abajo hacia arriba;Sea r la raíz de t;¯hr: = arg maxhr∈Hr r hr;h ∗: = ¯hr;( * incluye empacar *) t opdown (r, hr);return h ∗;fin. Procedimiento t opdown (v: vértice de n, ¯hv ∈ Hv);Comience para cada c ∈ N S.T.(v, c) ∈ E do ¯hc: = h¯hv, c;h ∗: = h ∗ ∪ ¯hc;( * incluye empacar *) t opdown (c, ¯hc);fin para fin;Figura 4: Algoritmo COMPUTSETPACKINGK.Portado en la Figura 5. (a). Por ejemplo, la raíz v1 es tal que hv1 = {{}, {h1}, {h3}, {h5}}. Además, una flecha de un empaque HC a HV denota que HV se ajusta con HC. Por ejemplo, el lector puede verificar que el embalaje {H3} ∈ HV1 se ajuste con el embalaje {H2, H3} ∈ Hv3, pero no se ajuste con {H1} ∈ Hv3.¡COMPLETSETPACKINGK crea una solución atravesando T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas a la raíz R, mediante el procedimiento de abajo. Para cada nodo V procesado, el HV SET se actualiza preliminar al eliminar todos los empaques HV que no se ajustan a ningún embalaje para algunos de los niños de v. Después de realizar este filtrado, el peso HV se actualiza. Intuitivamente, V HV almacena el peso del mejor embalaje parcial para H calculado utilizando solo las hipermedias que ocurren en χ (TV). De hecho, si V es una hoja, entonces V HV = W (HV). De lo contrario, para cada niño C de V en T, V HV se actualiza con el máximo de C HC - W (HC ∩ HV) sobre todos los paquetes HC que se ajusta con HV (resueltos de articulación arbitrariamente). El embalaje ¯hc para el cual se logra este máximo se almacena en la variable HHV, c. En la segunda fase, el árbol T se procesa a partir de la raíz. En primer lugar, se selecciona el embalaje H ∗ que maximiza el peso equipado con los empaquetados en HR. Luego, el procedimiento Topdown se usa para extender H ∗ a todos los otros empaques parciales para los vértices de T. En particular, en cada vértice V, H ∗ se extiende con el empaquetado HHV, C, para cada hijo C de v. Ejemplo 5. Suponga que, en su ejemplo de ejecución, w (h1) = w (h2) = con (h3) = v (h4) = 1. Luego, una ejecución de ComputesEtpackingk se representa gráficamente en la Figura 5. (b), donde se usa una flecha de un HC de embalaje a un HV de embalaje para denotar que HC = HHV, c. Específicamente, las opciones realizadas durante el cálculo son tales que se calcula el embalaje {H2, H3}. En particular, durante la fase ascendente, tenemos que: (1) V4 se procesa, y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0;(2) V3 se procesa y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0;(3) V2 se procesa, y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2, h3} = 2 y v3 {} = 0;(4) V1 se procesa y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, tenga en cuenta que v1 {h5} = 2 ya que {h5} se ajusta con el empaque {h4} de HV2 tal que v2 {h4} = 1. Luego, al comienzo de la fase de arriba hacia abajo, COMPTESETPackingk selecciona {H3} como un embalaje para HV1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo puede haber elegido {H5}. Como un ejemplo adicional, la forma en que la solución {H1} se obtiene por el algoritmo cuando W (H1) = 5 y W (H2) = W (H3) = W (H4) = 1 se informa en la Figura 5. (C). Observe que, esta vez, en la fase de arriba hacia abajo, COMPTESETPackingk comienza a seleccionar {H1} como el mejor empaque para HV1.¡Teorema 4. Sea h un hipergrafo y sea una función de ponderación para ello. Sea hd = t, χ, λ una descomposición completa de hipertreos de width k-width de ¯h. Luego, COMPTESETPackingk en la entrada H, W y HD emite correctamente una solución para MaxWSP (H, W) en el tiempo O (| T | × (| E (H) | + 1) 2K). Prueba.[Sketch] Observamos que H ∗ (calculado por ComputesetPackingk) es un embalaje para H. De hecho, considere un par de hipermedges H1 y H2 en H ∗, y suponga, en aras de la contradicción, que H1 ∩ H2 = ∅. Sea V1 (resp., V2) un vértice arbitrario de T, para el cual COMPTESETPackingk incluyó H1 (resp., H2) en H ∗ en el cálculo de abajo hacia abajo. Por construcción, tenemos H1 ∈ χ (V1) y H2 ∈ χ (V2).158 Sea un elemento en H1 ∩ H2. En el dual HyperGraph H, I es una hiperedge en E (¯h) que cubre los nodos H1 y H2. Por lo tanto, por condición (1) en la definición 1, hay un vértice V ∈ Vértices (t) tal que {H1, H2} ⊆ χ (V). Tenga en cuenta que, debido a la condición de conexión en la definición 1, también podemos suponer, w.l.o.g., que V está en la ruta que conecta V1 y V2 en T. deje que Hv ∈ Hv denote el elemento agregado por CompanSetPackingkkfase. Dado que los elementos en HV son empaques para HV, es el caso que H1 ∈ Hv o H2 ∈ HV. Suponga, w.l.o.g., que h1 ∈ Hv, y observe que cada vértice w en t en la ruta que conecta V a V1 es tal que H1 ∈ χ (W), debido a la condición de conexión. Por lo tanto, debido a la definición de conformidad, el empaquetado HW seleccionado por ComputesetPackingk para agregarse en el vértice W en h ∗ debe ser tal que h1 ∈ HW. Esto se mantiene en particular para W = V1. Contradicción con la definición de V1. Por lo tanto, H ∗ es un embalaje para H. Sigue para demostrar que tiene el peso máximo sobre todos los empaquetados para H. Para este objetivo, podemos usar la inducción estructural en t para demostrar que, en la fase ascendente,La variable V HV se actualiza para contener el peso del empaque en los bordes en χ (TV), que contiene HV y que tiene el peso máximo sobre todos estos empaquetados para los bordes en χ (TV). Luego, el resultado sigue, ya que en la fase de arriba hacia abajo, la FC de embalaje que da el peso máximo sobre χ (TR) = E (H) primero se incluye en H ∗, y luego se extiende en cada nodo C con el HHV de empaquetado,C conforme con HV y tal que se logra el valor máximo de V HV. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto HV, para cada vértice V, y cada conjunto tiene tamaño (| E (H) | + 1) K como máximo. Luego, la función inferior verifica la conformidad entre estrategias en HV con estrategias en HC, para cada par (v, c) ∈ E, y actualiza el peso V HV. Estas tareas se pueden llevar a cabo en el tiempo o ((| e (h) | + 1) 2k) y deben repetirse para cada borde en t, es decir, o (| t |) tiempos. Finalmente, la función Topdown se puede implementar en tiempo lineal en el tamaño de t, ya que solo requiere actualizar H ∗ accediendo a la variable HHV, c. El resultado anterior muestra que si se da una descomposición de hipertree de ancho k, el problema MAXWSP se puede resolver de manera eficiente. Además, de manera diferente al caso de los gráficos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree con unida a K y calculando uno (si es que hay) son problemas que pueden resolverse eficientemente en el tiempo polinomial [7]. Por lo tanto, el Teorema 4 testigos de que la Clase C (HW, K) en realidad constituye una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP (H, W) es incluso altamente paralelable. Llamemos a una función de ponderación suave si es lo de logspace computable y si todos los pesos son polinomiales (y, por lo tanto, solo requieren bits o (log n) para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf.[9]. La versión funcional de LOGCFL es LLOGCFL, que se obtiene equipando un transductor logSpace con un Oracle en LOGCFL. Teorema 5. Sea H un hipergrafo en C (HW, K), y sea W una función de ponderación suave para ello. Luego, MaxWSP (H, W) está en Llogcfl.4. Descomposiciones de hipertree versus gráficos de elementos estructurados dado que la Clase C (HW, K) ha demostrado ser una isla de tractabilidad para el problema de determinación del ganador, y dado que la Clase C (IG, K) se ha demostrado que no es reconocible de manera eficiente, uno puede estar inclinado a pensar que hay casos que tienen un ancho de hipertrees ilimitado, pero admitiendo un gráfico de elementos del ancho del árbol limitado (de modo que la intratabilidad de los gráficos de elementos estructurados se encuentra en su generalidad). Sorprendentemente, establecemos que este no es el caso. La línea de la prueba es mostrar primero que los gráficos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hipertreas del hipergrafo dual, que llamaremos estricto. Luego, el resultado seguirá demostrando que las estrictas descomposiciones de hipertreas de Width Width son menos poderosas que las descomposiciones de Kwith Hypertree.4.1 Las estrictas descomposiciones de hipertreas sean h un hipergrafo, y que v ⊆ n (h) sea un conjunto de nodos y x, y ∈ N (h). X es [v]-adjacente a y si existe un borde h ∈ E (h) tal que {x, y} ⊆ (h-v). A [v] -path π de x a y es una secuencia x = x0 ,..., X = y de variables tal que: xi es [v] -adjacente a xi+1, para cada i ∈ [0 ... -1]. Un conjunto w ⊆ n (h) de nodos está conectado [v] si ∀x, y ∈ W hay una pata [v] de x a y. A [V] -Component es un conjunto máximo no vacío conectado [V] de nodos W ⊆ (N (H)-V). Para cualquier [V] -Componente C, Sea E (C) = {H ∈ E (H) |H ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = t, χ, λ de H es estricto si las siguientes condiciones se mantienen: 1. Para cada par de vértices R y S en vértices (t) de modo que S es un niño de R, y para cada uno [χ ((χ ((χ ((R)]-Componente CR S.T. Cr ∩ χ (TS) = ∅, Cr es un [χ (R) ∩ N (λ (R) ∩ λ (S))]-Componente;2. Para cada borde H ∈ E (H), hay un vértice P tal que h ∈ λ (P) y H ⊆ χ (P) (decimos que P cubre fuertemente h);3. Para cada borde h ∈ E (h), el conjunto {p ∈ Vértices (t) |H ∈ λ (p)} induce un subárbol (conectado) de T. El estricto ancho de hipertreos shw (h) de h es el ancho mínimo sobre todas sus estrictas descomposiciones de hipertree. P La relación básica entre las buenas descomposiciones de hipertreas y los gráficos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea h un hipergrafo tal que para cada nodo v ∈ N (h), {v} está en e (h). Luego, existe una descomposición del árbol de ancho k de un gráfico de elementos para h si y solo si ¯h tiene una descomposición de hipertree estricta de urbanización (k + 1 )2. Tenga en cuenta que, en lo que respecta al problema máximo de empaquetado de set ponderado, dado un hipergrafo H, siempre podemos suponer que para cada nodo v ∈ N (h), {v} está en e (h). De hecho, si esta hiperedge no está en el hipergrafo, entonces se puede agregar sin pérdida de generalidad, configurando w ({v}) = 0. Por lo tanto, dejar que C (Shw, K) denota la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con el máximo 2, el término +1 solo juega el papel técnico de cuidar la definición diferente de ancho para las descomposiciones de los árboles y las descomposiciones de hipertree. 159. 159.Los problemas de embalaje del conjunto ponderado) tienen un estricto ancho de hipertreos limitado por K, tenemos esa c (shw, k + 1) = c (ig, k). Por definición, las estrictas descomposiciones de hipertreas son descomposiciones especiales de hipertree. De hecho, podemos demostrar que las condiciones adicionales en la definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C (IG, K) = C (Shw, K + 1) ⊂ C (HW, K + 1). Una vista teórica del juego. Arrojamos más luces sobre las estrictas descomposiciones de hipertree discutiendo una caracterización interesante basada en el estricto juego de ladrones y mariscales, definido adaptando el juego de ladrones y mariscales definidos en [6], que caracteriza el ancho de la hipertree. El juego es jugado en un hipergrafo H por un ladrón contra K Marshals que actúan en coordinación. Los alguaciles se mueven sobre las hipermedes de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve dónde los mariscales tienen la intención de moverse, y reacciona moviéndose a otro nodo que está conectado con su posición actual y a través de una ruta en G (H)que no usa ningún nodo contenido en una hiperedge que esté ocupada por los mariscales antes y después de su movimiento, digamos que estas hiperedias están bloqueadas. Tenga en cuenta que en el juego básico definido en [6], el ladrón no puede moverse en los vértices que están ocupados por los mariscales antes y después de su movimiento, incluso si no pertenecen a hiperedias bloqueadas. Es importante destacar que los mariscales deben jugar monotónicamente, es decir, no pueden ocupar una ventaja que anteriormente estaba ocupada en el juego, y que actualmente no. Los mariscales ganan el juego si capturan al ladrón, ocupando un borde que cubre un nodo donde está el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea h un hipergrafo tal que para cada nodo v ∈ N (h), {v} está en e (h). Entonces, ¯h tiene una estricta descomposición de hipertreas de Width si y solo si K Marshals puede ganar el estricto juego de ladrones y mariscales en ¯h, sin importar los movimientos de los ladrones.5. Conclusiones Hemos resuelto la cuestión abierta de determinar la complejidad de calcular un gráfico de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP complete verificar si una subasta combinatoria tiene un gráfico de elementos estructurados, incluso para el ancho de árboles 3. Motivado por este resultado, investigamos el uso de la descomposición de la hipertree (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es manejable en la clase de aquellos casos cuyos hipergrafos duales han limitado el ancho de hipertree. Para algunos casos especiales pero relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también surgió que la clase de gráficos de elementos estructurados está correctamente contenida en la clase de instancias que ha limitado el ancho de hipertree (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, el último resultado se establece mostrando una relación precisa entre los gráficos de ítems estructurados y las formas restringidas de descomposiciones de hipertree (en el hipergrafo dual), llamadas descomposiciones de consulta (ver, por ejemplo, [7]). A la luz de esta observación, observamos que probar algunos resultados de aproximación para los gráficos de elementos estructurados requiere una comprensión profunda de la aproximación de las descomposiciones de consulta, que actualmente falta en la literatura. Como una vía de investigación adicional, sería relevante mejorar el algoritmo que COMPUTSETPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, para evitar la dependencia cuadrática de (| e (h) | + 1) k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el documento pueden usarse para tratar eficientemente las generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicaciones para diseñar algoritmos que pueden encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y cuando el subastador se satisface cuando al menos un número dado de copias se vende realmente. Reconocimiento El trabajo de G. Gottlobs fue apoyado por el Centro de Competencia EC3 - E -Commerce (Viena) y por un Premio a la Royal Society Wolfson Research Merit. En particular, este premio permitió a Gottlob invitar a G. Greco a una visita de investigación a Oxford. Además, G. Greco es respaldado por ICAR-CNR y por M.I.U.R.bajo Project Tocai.it.6. Referencias [1] I. Adler, G. Gottlob y M. Grohe. Hipertree-ancho e invariantes de hipergrafio relacionados. En Proc.de EuroComb05, páginas 5-10, 2005. [2] C. Boutilier. Resolución de problemas de subasta combinatorios expresados de manera concisa. En Proc.de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con gráficos de elementos estructurados. En Proc.de AAAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O (N2) para el reconocimiento de gráficos de arco circular. En Proc.de Soda93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown e Y. Shoham. Domesticar la complejidad computacional de las subastas combinatorias: óptimo y aproximado. En Proc.de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, mariscales y guardias: caracterizaciones teóricas y lógicas del juego del ancho de hipertree. Journal of Computer and System Sciences, 66 (4): 775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hipertree y consultas manejables. Journal of Computer and System Sciences, 63 (3): 579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolución de subastas combinatorias utilizando búsqueda local estocástica. En Proc.de AAAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de la informática teórica, Volumen A: algoritmos y complejidad, páginas 67-161.1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer gráficos de intervalos. Siam Journal on Computing, 18 (1): 68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El problema de determinación del ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, subastas combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. Ocallaghan e Y. Shoham. Revelación de la verdad en 160 subastas combinatorias aproximadamente eficientes. J. ACM, 49 (5): 577-602, 2002. [13] R. McAfee y J. McMillan. Análisis de la subasta de ondas aéreas. Journal of Economic Perspectives, 10 (1): 159175, 1996. [14] J. McMillan. Venta de derechos de espectro. Journal of Economic Perspectives, 8 (3): 145-62, 1994. [15] N. Nisan. Licitación y asignación en subastas combinatorias. En Proc.de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Graph Minors II.Aspectos algorítmicos del ancho del árbol. Journal of Algorithms, 7: 309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Management Science, 44: 1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo NET del contrato basado en cálculos de costos marginales. En Proc.de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para una determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135 (1-2): 1-54, 2002. [20] T. Sandholm. Algoritmos de determinación del ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, subastas combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. BOB: Determinación mejorada del ganador en subastas y generalizaciones combinatorias. Inteligencia Artificial, 7: 33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc.de AAAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximado eficiente para subastas combinatorias. En Proc.de EC01, páginas 125-136, 2001. 161