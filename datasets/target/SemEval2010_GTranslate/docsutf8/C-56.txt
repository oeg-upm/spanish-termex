Un soporte de ejecución de procesos jerárquicos para la computación de la red Fábio R. L. Cicerre Instituto de Computación de la Universidad Estatal de Campinas Campinas, Brasil fcicerre@ic.unicamp.br Edmundo R. M. Madeira Instituto de Computación de la Computación de la Universidad Estatal de Campinas, Brasil edmundo@ic.unicamp.br Luiz E E. Buzato Institute of Computing State University of Campinas Campinas, Brasil Buzato@ic.unicamp.Br Abstract Grid es una infraestructura emergente utilizada para compartir recursos entre las organizaciones virtuales de una manera perfecta y proporcionar un poder informático innovador a bajo costo. Hoy en día hay docenas de productos académicos y comerciales que permiten la ejecución de tareas aisladas en las redes, pero pocos productos respaldan la promulgación de procesos de larga duración de manera distribuida. Para abordar dicho tema, este documento presenta un modelo de programación y una infraestructura que programa jerárquicamente las actividades de procesos utilizando nodos disponibles en un entorno de cuadrícula amplio. Sus ventajas son la distribución automática y estructurada de las actividades y el fácil monitoreo y dirección de procesos. Categorías y descriptores de sujetos C.2.4 [Redes de comunicación por computadora]: aplicaciones distribuidas distribuidas Términos generales Diseño, rendimiento, gestión, algoritmos 1. Introducción La computación de la cuadrícula es un modelo para la computación distribuida y paralela de área amplia a través de redes heterogéneas en múltiples dominios administrativos. Este campo de investigación tiene como objetivo promover el intercambio de recursos y proporciona poder informático innovador sobre esta amplia red de organizaciones virtuales de manera perfecta [8]. Tradicionalmente, como en Globus [6], Condor-G [9] y Legion [10], existe una infraestructura mínima que proporciona intercambio de recursos de datos, gestión de utilización de recursos computacionales y ejecución distribuida. Específicamente, considerando la ejecución distribuida, la mayoría de las infraestructuras de cuadrícula existentes admiten la ejecución de tareas aisladas, pero no consideran las interdependencias de sus tareas como en los procesos (flujos de trabajo) [12]. Esta deficiencia restringe mejores algoritmos de programación, coordinación de ejecución distribuida y recuperación de ejecución automática. Hay pocas infraestructuras de middleware propuestas que admiten la ejecución del proceso a través de la cuadrícula. En general, modelan procesos interconectando sus actividades a través de control y dependencias de datos. Entre ellos, Webflow [1] enfatiza una arquitectura para construir procesos distribuidos;Opera-G [3] proporciona recuperación de ejecución y dirección, Gridflow [5] se centra en los algoritmos de programación mejorados que aprovechan las dependencias de actividades, y Swindew [13] admite la ejecución totalmente distribuida en redes entre pares. Sin embargo, tales infraestructuras contienen algoritmos de programación que están centralizados por el proceso [1, 3, 5] o completamente distribuidas, pero difíciles de monitorear y controlar [13]. Para abordar tales restricciones, este documento propone un modelo de programación estructurado para la descripción del proceso y una infraestructura jerárquica de ejecución del proceso. El modelo de programación emplea un flujo de control estructurado para promover la ejecución de la actividad controlada y contextualizada. Complementaria, la infraestructura de soporte, que ejecuta una especificación de proceso, aprovecha la estructura jerárquica de un proceso específico para distribuir y programar actividades dependientes fuertes como una unidad, lo que permite un mejor rendimiento de ejecución y tolerancia a fallas y proporcionar comunicación localizada. El modelo de programación y la infraestructura de soporte, llamada X Avantes, están en implementación para mostrar la viabilidad del modelo propuesto y demostrar sus dos ventajas principales: promover la ejecución y programación de procesos ampliamente distribuidas, pero en una programación controlada, estructurada y localizada.forma. La siguiente sección describe el modelo de programación y la Sección 3, la infraestructura de soporte para el modelo de computación de la cuadrícula propuesto. La Sección 4 demuestra cómo la infraestructura de soporte ejecuta procesos y distribuye actividades. Los trabajos relacionados se presentan y se comparan con el modelo propuesto en la Sección 5. La última sección concluye este documento que abarca las ventajas del soporte de ejecución de procesos jerárquicos propuesto para el área informática de la red y enumera algunos trabajos futuros.87 Middleware 2004 Controlador de actividades de procesamiento de procesamiento complementario 1 * 1 * Figura 1: Marco de alto nivel del modelo de programación 2. Modelo de programación El modelo de programación diseñado para la arquitectura informática de la cuadrícula es muy similar al especificado al lenguaje de ejecución de procesos de negocios (BPEL) [2]. Ambos describen procesos en documentos XML [4], pero el primero especifica procesos estrictamente sincrónicos y estructurados, y tiene más construcciones para el control paralelo estructurado. La razón detrás de su diseño es la posibilidad de distribuir jerárquicamente el control y la coordinación del proceso basado en construcciones estructuradas, de manera diferente a BPEL, que no permite la composición jerárquica de los procesos. En el modelo de programación propuesto, un proceso es un conjunto de actividades interdependientes organizadas para resolver un cierto problema. En detalle, un proceso está compuesto por actividades, subprocesos y controladores (ver Figura 1). Las actividades representan tareas simples que se ejecutan en nombre de un proceso;Los subprocesos son procesos ejecutados en el contexto de un proceso principal;y los controladores son elementos de control utilizados para especificar la orden de ejecución de estas actividades y subprocesos. Al igual que los lenguajes estructurados, los controladores pueden anidarse y luego determinar la orden de ejecución de otros controladores. Los datos se intercambian entre los elementos de proceso a través de los parámetros. Se pasan por valor, en caso de objetos simples, o por referencia, si son objetos remotos compartidos entre elementos del mismo controlador o proceso. Se puede acceder a datos externos a través de fuentes de datos, como bases de datos relacionales o objetos distribuidos.2.1 Controladores Los controladores son construcciones de control estructuradas utilizadas para definir el flujo de control de los procesos. Hay controladores secuenciales y paralelos. Los tipos de controlador secuencial son: bloque, interruptor, para y mientras. El controlador de bloque es una construcción secuencial simple, y los otros imitan construcciones de lenguaje de programación estructurado equivalente. Del mismo modo, los tipos paralelos son: PAR, Parswitch, Parfor y Parver. Extienden las contrapartes secuenciales respectivas para permitir la ejecución paralela de elementos de proceso. Todos los tipos de controlador paralelo desembolsan la ejecución de uno o más elementos de proceso, y luego, espere a que finalice cada ejecución. De hecho, contienen un tenedor y una unión de ejecución. Con el objetivo de implementar una unión condicional, todos los tipos de controlador paralelo contienen una condición de salida, evaluada todo el tiempo que termina una ejecución de elementos, para determinar cuándo debe terminar el controlador. El Parfor y Parwhile son las versiones iterativas de los tipos de controlador paralelo. Ambas ejecuciones de bifurcación, mientras que la condición de iteración es verdadera. Esto proporciona flexibilidad para determinar, en tiempo de ejecución, el número de elementos de proceso para ejecutar simultáneamente. En comparación con los idiomas de flujo de trabajo, los tipos de controlador paralelo representan versiones estructuradas de los constructores de control del flujo de trabajo, ya que pueden anidar otros controladores y también pueden expresar horquillas y uniones fijas y condicionales, presentes en tales idiomas.2.2 Ejemplo del proceso Esta sección presenta un ejemplo de una aplicación de búsqueda de números primos que recibe una cierta gama de enteros y devuelve un conjunto de primos contenidos en este rango. Todo el cálculo se realiza mediante un proceso, que utiliza un controlador paralelo para comenzar y enviar varias actividades concurrentes del mismo tipo, para encontrar números primos. La parte del documento XML que describe el proceso y los tipos de actividad se muestra a continuación.<Process_type name = findPrimes> <in_parameter type = int name = min/> <in_parameter type = int name = max/> <in_parameter type = int name = numPrimes/> <in_parameter type = int name = numacts/> <body> <body> <body>Pre_code> setPrimes (new RemoteHashSet ());parfor.setmin (getmin ());parfor.setMax (getMax ());parfor.setNumPrimes (getNumPrimes ());parfor.setNumacts (getNumacts ());parfor.setPrimes (getPrimes ());parfor.setCounterbegin (0);parfor.setCounterend (getNumacts ()-1);</Pre_code> <parfor name = parfor> <in_parameter type = int name = min/> <in_parameter type = int name = max/> <in_parameter type = int name = numPrimes/> <in_parameter type = int name = numacts/><In_parameter type = remotecollection name = primes/> <iterate> <pre_code> int range = (getMax ()-getmin ()+1)/getNumacts ();int minnum = range*getCounter ()+getmin ();int maxnum = minnum+range-1;if (getCounter () == getNumacts ()-1) maxnum = getmax ();findpimes.setmin (minnum);findpimes.setMax (maxnum);findprimes.setNumPrimes (getNumPrimes ());findpimes.setPrimes (getPrimes ());</Pre_code> <Activity type = findPrimes name = findPrimes/> </terate> </pfor> </body> <ut_parameter type = remotecollection name = primes/> </oCESS_TYPE> Middleware para la reducción de la red 88 <Activity_Type name = findPrimes> <In_parameter type = int name = min/> <in_parameter type = int name = max/> <in_parameter type = int name = numPrimes/> <in_parameter type = remotecollection name = primes/> <code> for (int num = getmins(); num <= getMax (); num ++) {// detener, el número de primos requerido se encontró si (primos.size ()> = getNumPrimes ()) break;boolean prime = verdadero;for (int i = 2; i <num; i ++) {if (num % i == 0) {prime = false;romper;}} if (prime) {primes.add (nuevo entero (num));}} </code> </activity_type> En primer lugar, se define un tipo de proceso que encuentra números primos, llamado FindPrimes. Recibe, a través de sus parámetros de entrada, una gama de enteros en los que se deben encontrar números primos, el número de primos que se devolverán y el número de actividades que se ejecutarán para realizar este trabajo. Al final, los números primos encontrados se devuelven como una colección a través de su parámetro de salida. Este proceso contiene un controlador PARFOR con el objetivo de ejecutar un número determinado de actividades paralelas. Se itera de 0 a getNumacts () - 1, que determina el número de actividades, comenzando una actividad paralela en cada iteración. En tal caso, el controlador divide todo el rango de números en subranges del mismo tamaño y, en cada iteración, comienza una actividad paralela que encuentra números primos en un subrangule específico. Estas actividades reciben un objeto compartido por referencia para almacenar los números primos que se acaba de encontrar y controlar si se ha alcanzado el número de números primos requeridos. Finalmente, se define el tipo de actividad, FindPrimes, utilizado para encontrar números primos en cada subrangule. Recibe, a través de sus parámetros de entrada, el rango de números en los que tiene que encontrar números primos, el número total de números primos que se encuentran por todo el proceso y, aprobado por referencia, un objeto de colección para almacenar los números primos encontrados.. Entre sus marcadores de código, hay un código simple para encontrar números primos, que itera sobre el rango especificado y verifica si el entero actual es un primo. Además, en cada iteración, el código verifica si el número requerido de primos, insertado en la colección de primos por todas las actividades concurrentes, se ha alcanzado y sale si es cierto. La ventaja de usar controladores es la posibilidad de que la infraestructura de soporte determine el punto de ejecución en el que se encuentra el proceso, permitiendo la recuperación y el monitoreo automáticos, y también la capacidad de instanciar y enviar elementos del proceso solo cuando hay suficientes recursos informáticos disponibles, reduciendo la sobrecarga innecesaria. Además, debido a su naturaleza estructurada, se pueden componer fácilmente y la infraestructura de soporte puede aprovechar esto para distribuir jerárquicamente los controladores anidados al grupo Group Group Java Virtual Machine RMI JDBC Group Manager Process Server Java Virtual Machine Virtual Machine RMI JDBC Process CoordinatorWorker Java Virtual Machine RMI Activity Manager Repositorio Figura 2: Arquitectura de infraestructura Diferentes máquinas sobre la red, lo que permite una mayor escalabilidad y tolerancia a fallas.3. Infraestructura de soporte La infraestructura de soporte comprende herramientas para especificaciones y servicios para la ejecución y monitoreo de procesos estructurados en entornos de cuadrícula altamente distribuidos, heterogéneos y autónomos. Tiene servicios para monitorear la disponibilidad de recursos en la red, interpretar procesos y actividades y controladores de programación, y para ejecutar actividades.3.1 Arquitectura de infraestructura La arquitectura de infraestructura de soporte está compuesta por grupos de máquinas y repositorios de datos, lo que preserva su autonomía administrativa. En general, las máquinas y repositorios localizados, como en las redes o grupos locales, forman un grupo. Cada máquina en un grupo debe tener una máquina virtual Java (JVM) [11], y una biblioteca de tiempo de ejecución de Java, además de una combinación de los siguientes servicios de soporte de cuadrícula: gerente de grupo (GM), coordinador de procesos (PC) y gerente de actividades (AM AM). Esta combinación determina qué tipo de nodo de grupo representa: un servidor de grupo, un servidor de procesos o simplemente un trabajador (ver Figura 2). En un grupo hay uno o más gerentes grupales, pero solo uno actúa como primario y los demás, como réplicas. Son responsables de mantener la información de disponibilidad de las máquinas grupales. Además, los gerentes grupales mantienen referencias a los recursos de datos del grupo. Utilizan repositorios grupales para persistir y recuperar la ubicación de los nodos y su disponibilidad. Para controlar la ejecución del proceso, hay uno o más coordinadores de procesos por grupo. Son responsables de instanciar y ejecutar procesos y controladores, seleccionar recursos y programar y enviar actividades a los trabajadores. Para persistir y recuperar la ejecución y los datos del proceso, y también cargar la especificación del proceso, utilizan repositorios de grupos. Finalmente, en varios nodos grupales hay un gerente de actividades. Es responsable de ejecutar actividades en la máquina alojada en nombre de los coordinadores de procesos grupales e informar la disponibilidad actual de la máquina asociada a los gerentes de grupo. También tienen colas de actividad colgantes, que contienen actividades que se ejecutarán.3.2 Relaciones entre grupos Para modelar la arquitectura de la red real, la infraestructura debe comprender varias redes locales, potencialmente todas, como lo hacen Internet. Con el objetivo de satisfacer esta intención, los grupos locales son 89 Middleware 2004 Companion GM GM GM GM GM Figura 3: Relaciones entre grupos conectadas a otros, directa o indirectamente, a través de sus gerentes grupales (ver Figura 3). Cada gerente de grupo se ocupa de las solicitudes de su grupo (representado por elipses discontinuos), para registrar máquinas locales y mantener la disponibilidad de corresponsales. Además, los gerentes grupales se comunican con los gerentes grupales de otros grupos. Cada gerente de grupo exporta información de disponibilidad gruesa a gerentes grupales de grupos adyacentes y también recibe solicitudes de otros servicios externos para proporcionar información detallada de disponibilidad. De esta manera, si hay recursos disponibles en grupos externos, es posible enviar procesos, controladores y actividades a estos grupos para ejecutarlos en coordinadores de procesos externos y gerentes de actividades, respectivamente.4. Ejecución del proceso En la arquitectura de la red propuesta, se especifica un proceso en XML, utilizando controladores para determinar el flujo de control;hacer referencia a otros procesos y actividades;y pasar objetos a sus parámetros para definir el flujo de datos. Después de especificado, el proceso se compila en un conjunto de clases, que representan tipos de proceso, actividad y controlador específicos. En este momento, puede ser instanciado y ejecutado por un coordinador de proceso.4.1 Modelo dinámico Para ejecutar un proceso especificado, debe instanciarse haciendo referencia a su tipo en un servicio de coordinador de proceso de un grupo específico. Además, los parámetros iniciales deben pasarse a él, y luego se puede iniciar. El coordinador del proceso lleva a cabo el proceso ejecutando los elementos del proceso incluidos en su cuerpo secuencialmente. Si el elemento es un proceso o un controlador, el coordinador del proceso puede optar por ejecutarlo en la misma máquina o pasarlo a otro coordinador de proceso en una máquina remota, si está disponible. De lo contrario, si el elemento es una actividad, pasa a un administrador de actividades de una máquina disponible. Los coordinadores de procesos solicitan al gerente de grupo local que encuentre máquinas disponibles que contengan el servicio requerido, el coordinador de procesos o el administrador de actividades, para ejecutar un elemento de proceso. Luego, puede devolver una máquina local, una máquina en otro grupo o ninguno, dependiendo de la disponibilidad de dicho recurso en la red. Devuelve un trabajador externo (máquina del gerente de actividades) si no hay trabajadores disponibles en el grupo local;Y devuelve un servidor de procesos externo (máquina coordinadora de procesos), si no hay servidores de procesos disponibles o trabajadores en el grupo local. Obedeciendo esta regla, los gerentes de grupos intentan encontrar servidores de procesos en el mismo grupo de los trabajadores disponibles. Dicho procedimiento es seguido de manera recursiva por todos los procesos COGM Find -Primes Activity Am Find Primes Activity Am FindPrimes Activity Am FindPrimes Process PC Figura 4: Find Primess Process Execution Ordinators que ejecutan subprocesos o controladores de un proceso. Por lo tanto, debido a que los procesos están estructurados por elementos del proceso de anidación, la ejecución del proceso se distribuye automáticamente jerárquicamente a través de uno o más grupos de cuadrícula de acuerdo con la disponibilidad y localidad de los recursos informáticos. La ventaja de este modelo de distribución es la amplia ejecución del área, lo que aprovecha potencialmente todos los recursos de la cuadrícula;y la comunicación localizada de los elementos del proceso, porque los elementos dependientes fuertes, que están bajo el mismo controlador, se colocan en los mismos grupos o cercanos. Además, admite un fácil monitoreo y dirección, debido a sus controladores estructurados, que mantienen el estado y el control sobre sus elementos internos.4.2 Ejemplo de ejecución del proceso revisando el ejemplo que se muestra en la Sección 2.2, se especifica un tipo de proceso para encontrar números primos en un cierto rango de números. Para resolver este problema, crea una serie de actividades utilizando el controlador PARFOR. Cada actividad, entonces, encuentra primos en una parte determinada del rango de números. La Figura 4 muestra una instancia de este tipo de proceso que se ejecuta sobre la infraestructura propuesta. Se crea una instancia de proceso FindPrimes en un coordinador de proceso disponible (PC), que comienza a ejecutar el controlador PARFOR. En cada iteración de este controlador, el coordinador del proceso solicita al gerente del grupo (GM) un administrador de actividades disponible (AM) para ejecutar una nueva instancia de la actividad de FindPrimes. Si hay algún AM disponible en este grupo o en uno externo, el Coordinador del proceso envía la clase de actividad y los parámetros iniciales a este administrador de actividades y solicita su ejecución. De lo contrario, si no hay administrador de actividades disponible, el controlador ingresa en un estado de espera hasta que se ponga a disposición un administrador de actividades o se cree. Paralelamente, cada vez que termina una actividad, su resultado se envía de regreso al Coordinador del proceso, que lo registra en el controlador PARFOR. Luego, el controlador espera hasta que todas las actividades que se hayan iniciado se terminen, y termina. En este punto, el coordinador del proceso verifica que no hay otro elemento de proceso para ejecutar y finalizar el proceso.5. Trabajo relacionado Hay varios productos académicos y comerciales que prometen admitir la informática de la red, con el objetivo de proporcionar interfaces, protocolos y servicios para aprovechar el uso de un ampliamente middleware para la computación de la red 90 recursos distribuidos en redes heterogéneas y autónomas. Entre ellos, Globus [6], Condor-G [9] y Legion [10] son ampliamente conocidos. Con el objetivo de estandarizar las interfaces y servicios a la red, se ha definido la arquitectura de servicios de cuadrícula abierta (OGSA) [7]. Las arquitecturas de la red generalmente tienen servicios que administran recursos informáticos y distribuyen la ejecución de tareas independientes en las disponibles. Sin embargo, las arquitecturas emergentes mantienen dependencias de tareas y ejecutan automáticamente las tareas en un orden correcto. Aprovechan estas dependencias para proporcionar una recuperación automática y una mejor distribución y algoritmos de programación. Siguiendo dicho modelo, WebFlow [1] es una herramienta de especificación de proceso y un entorno de ejecución construido sobre CORBA que permite la composición gráfica de las actividades y su ejecución distribuida en un entorno de cuadrícula. Opera-G [3], como WebFlow, utiliza un lenguaje de especificación de proceso similar al diagrama de flujo de datos y los idiomas de flujo de trabajo, pero proporciona la recuperación de ejecución automática y la dirección limitada de la ejecución del proceso. Las arquitecturas previamente referidas y otros que promulgan procesos sobre la red tienen una coordinación centralizada. Para superar esta limitación, sistemas como Swindew [13] propusieron una ejecución de procesos ampliamente distribuida, en la que cada nodo sabe dónde ejecutar la próxima actividad o unir actividades en un entorno entre pares. En el área específica de distribución y programación de la actividad, enfatizado en este trabajo, el flujo de grid [5] es notable. Utiliza una programación de dos niveles: global y local. En el nivel local, tiene servicios que predicen la utilización de recursos informáticos y la duración de la actividad. Según esta información, GridFlow emplea una técnica pertinente que intenta pronosticar la hora y duración de la ejecución de la actividad para programarlos mejor los recursos disponibles. La arquitectura propuesta en este documento, que abarca un modelo de programación y una infraestructura de soporte de ejecución, está ampliamente descentralizada, de manera diferente al flujo web y la ópera-G, es más escalable y tolerante a fallas. Pero, como este último, está diseñado para admitir la recuperación de la ejecución. En comparación con Swindew, la arquitectura propuesta contiene coordinadores de procesos ampliamente distribuidos, que coordinan los procesos o partes de ellos, de manera diferente a Swindew donde cada nodo tiene una visión limitada del proceso: solo la actividad que comienza a continuación. Esto hace que sea más fácil monitorear y controlar procesos. Finalmente, la infraestructura de soporte rompe el proceso y sus subprocesos para la ejecución de la red, lo que permite que un grupo requiera otro grupo para la coordinación y ejecución de los elementos del proceso en nombre del primero. Esto es diferente de GridFlow, que puede ejecutar un proceso en la mayoría de los dos niveles, con el nivel global como el único responsable de programar subprocesos en otros grupos. Esto puede limitar el rendimiento general de los procesos y hacer que el sistema sea menos escalable.6. La conclusión y la computación de la red de trabajo futura es un campo de investigación emergente que tiene la intención de promover la computación distribuida y paralela a través de la amplia red de dominios administrativos heterogéneos y autónomos de una manera perfecta, similar a lo que Internet hace al intercambio de datos. Existen varios productos que admiten la ejecución de tareas independientes sobre la red, pero solo unos pocos admiten la ejecución de procesos con tareas interdependientes. Para abordar dicho tema, este documento propone un modelo de programación y una infraestructura de soporte que permita la ejecución de procesos estructurados de una manera ampliamente distribuida y jerárquica. Esta infraestructura de soporte proporciona una distribución automática, estructurada y recursiva de los elementos de proceso sobre grupos de máquinas disponibles;mejor uso de recursos, debido a su creación a demanda de elementos de proceso;Monitoreo y dirección de proceso fácil, debido a su naturaleza estructurada;y comunicación localizada entre los elementos de proceso dependientes fuertes, que se colocan bajo el mismo controlador. Estas características contribuyen a una mejor escalabilidad, tolerancia a fallas y control para la ejecución de los procesos a través de la red. Además, abre puertas para mejores algoritmos de programación, mecanismos de recuperación y también esquemas de modificación dinámica. El próximo trabajo será la implementación de un mecanismo de recuperación que utiliza el estado de ejecución y datos de los procesos y controladores para recuperar la ejecución del proceso. Después de eso, es deseable avanzar en el algoritmo de programación para pronosticar el uso de la máquina en el mismo u otros grupos y prever la hora de inicio de los elementos del proceso, a fin de usar esta información para asignar recursos y, luego, obtener una mejor ejecución del procesoactuación. Finalmente, es interesante investigar esquemas de modificación dinámica de procesos a través de la red, para evolucionar y adaptar procesos a largo plazo al entorno de la red cambiante continuamente.7. Agradecimientos Nos gustaría agradecer a Paulo C. Oliveira, del Departamento del Tesoro del Estado de Sao Paulo, por su profundamente revisión y sus comentarios perspicaces.8. Referencias [1] E. Akarsu, G. C. Fox, W. Furmanski y T. Haupt. Flujo web: entorno de programación de alto nivel y kit de herramientas de autoría visual para computación distribuida de alto rendimiento. En Actas de Supercom Puting (SC98), 1998. [2] T. Andrews y F. Curbera. Especificación: lenguaje de ejecución de procesos comerciales para WB EB Services V ersion 1.1. IBM Developerworks, 2003. Disponible en http://www-106.ibm.com/developerworks/library/wsbpel.[3] W. Bausch. O Pera -G: A M icrokernelfor com putationalg rids. Tesis doctoral, Swiss Federal Institute of Technology, Zurich, 2004. [4] T. Bray y J. Paoli. Lenguaje M Arkup (x m l) 1.0. XML Core WG, W3C, 2004. Disponible en http://www.w3.org/tr/2004/rec-xml-20040204.[5] J. Cao, S. A. Jarvis, S. Saini y G. R. Nudd. GRIDFLOW: Gestión de flujo de trabajo para la computación de la red. En Actas del Simposio Internacional sobre Computación de Clúster y GRid (CCG Rid 2003), 2003. [6] I. Foster y C. Kesselman. Globus: un kit de herramientas de infraestructura metacomputación. Intl.J. Aplicaciones de supercomputador, 11 (2): 115-128, 1997. [7] I. Foster, C. Kesselman, J. M. Nick y S. Tuecke. La fisiología de la grida: y los servicios de Pen G Rid una rchitectura para la integración del Sistema Distribuido.91 Middleware 2004 Companion Open Grid Service Infraestructura WG, Global Grid Forum, 2002. [8] I. Foster, C. Kesselman y S. Tuecke. La anatomía de la cuadrícula: habilitación de organización virtual escalable. The Intl.Journalofh iGh actúa Ance Com Puting a Pplications, 15 (3): 200-222, 2001. [9] J. Frey, T. Tannenbaum, M. Livny, I. Foster y S. Tuecke. Condor-G: un agente de gestión computacional para cuadrículas multiinstitucionales. En los procedimientos del décimo intl.sym POSIUM sobre la realización de la presunción de coma de ejecución (H PD C-10). IEEE, 2001. [10] A. S. Grimshaw y W. A. Wulf. Legión: una vista desde 50,000 pies. En Actas del Quinto INTL. Simposio sobre la presunción distribuida de alto rendimiento. IEEE, 1996. [11] T. Lindholm y F. Yellin. La especificación Java v irtualm achine. Sun Microsystems, Segunda edición, 1999. [12] B. R. Schulze y E. R. M. Madeira. Computación de cuadrícula con servicios activos. Concurrencia y comoción: Practice and Experience Journal, 5 (16): 535-542, 2004. [13] J. Yan, Y. Yang y G. K. Raikundalia. Promulgar procesos comerciales en un entorno descentralizado con soporte de flujo de trabajo basado en P2P. En Actas del Cuarto Intl.Conferencia sobre la información de la Información de W Eb (W AM 2003), 2003. Middleware para la computación de la cuadrícula 92