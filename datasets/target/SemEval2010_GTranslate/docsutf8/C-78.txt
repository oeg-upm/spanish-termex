Un marco arquitectónico y un middleware para cooperar componentes inteligentes ∗ Ant´Onio Casimiro U.Lisboa casim@di.fc.ul.pt J¨org Kaiser U.ulm kaiser@informatik.uniulm.de Paulo Ver´ıssimo U.Lisboa PJV@DI.FC.UL.PT Resumen En un mundo físico en red en el futuro, una miríada de sensores y actuadores inteligentes evalúa y controlan aspectos de sus entornos y actúa de forma autónoma en respuesta a ello. Los ejemplos varían en telemática, gestión del tráfico, robótica del equipo o automatización del hogar, por nombrar algunos. En gran medida, dichos sistemas operan de manera proactiva e independiente del control humano directo impulsado por la percepción del entorno y la capacidad de organizar los cálculos respectivos dinámicamente. Las características desafiantes de estas aplicaciones incluyen sensibilidad y autonomía de los componentes, cuestiones de capacidad de respuesta y criticidad de seguridad, dispersión geográfica, movilidad y evolución. Una decisión de diseño crucial es la elección de las abstracciones apropiadas y los mecanismos de interacción. Mirando a los bloques de construcción básicos de tales sistemas, podemos encontrar componentes que comprenden componentes mecánicos, hardware y software y una interfaz de red, por lo tanto, estos componentes tienen diferentes características en comparación con los componentes de software puro. Pueden difundir espontáneamente la información en respuesta a los eventos observados en el entorno físico o a los eventos recibidos de otro componente a través de la interfaz de red. Los componentes autónomos más grandes pueden componerse de manera recursiva de estos bloques de construcción. El documento describe un marco arquitectónico y un middleware que admite un sistema basado en componentes y una visión integrada sobre la comunicación basada en eventos que comprende los eventos del mundo real y los eventos generados en el sistema. Comienza por un esquema de la construcción del sistema basado en componentes. Se introduce el equipo de arquitectura de eventos genéricos que describe la interacción basada en eventos entre los componentes a través de una capa de evento genérico. La capa de eventos genéricos oculta los diferentes canales de comunicación que incluyen ∗ este trabajo fue parcialmente respaldado por la CE, a través del Proyecto IST-2000-26031 (Cortex) y el FCT, a través del Laboratorio de Sistemas Informáticos a gran escala (LASIGE) y Project POSI/1999/CHS/33996 (derrotas).las interacciones a través del medio ambiente. Se presenta un middleware apropiado que refleja estas necesidades y permite especificar eventos que tienen atributos de calidad para expresar restricciones temporales. Esto se complementa con la noción de canales de eventos que son abstracciones de la red subyacente y permiten hacer cumplir los atributos de calidad. Se establecen antes de la interacción para reservar los recursos computacionales y de red necesarios para la difusión de eventos altamente predecible. Categorías y descriptores de sujetos c.2.4 [Redes de comunicación por computadora]: aplicaciones distribuidas de sistemas distribuidos;C.3 [Sistemas de uso especial y basados en aplicaciones]: Sistemas Real e Ingredidos Términos generales Diseño 1. Introducción En los últimos años, hemos visto la mejora continua de las tecnologías que son relevantes para la construcción de sistemas integrados distribuidos, incluidos la sensación de confianza, auditiva y de ubicación confiable [11], comunicación y procesamiento. Creemos que en un mundo físico en red en red surgirá una nueva clase de aplicaciones, compuesta por una miríada de sensores y actuadores inteligentes para evaluar y controlar aspectos de sus entornos y actuar autónomos en respuesta a ello. Las características desafiantes anticipadas de estas aplicaciones incluyen autonomía, capacidad de respuesta y criticidad de seguridad, gran escala, dispersión geográfica, movilidad y evolución. Para enfrentar estos desafíos, es de importancia fundamental utilizar modelos, abstracciones y paradigmas de interacción de alto nivel adecuados. Desafortunadamente, cuando se enfrenta a las características específicas de los sistemas objetivo, las deficiencias de las arquitecturas actuales y los paradigmas de interacción de middleware se hacen evidentes. Mirando a los bloques de construcción básicos de tales sistemas, podemos encontrar componentes que comprenden piezas mecánicas, hardware, software y una interfaz de red. Sin embargo, los modelos clásicos de eventos/objetos suelen estar orientados al software y, como tal, cuando Trans28 se transfiere a una configuración de sistemas integrados en tiempo real, su armonía está abarrotada por el conflicto entre, por un lado, enviar/recibir eventos de software (basado en mensajes), y por otro lado, entrada/salida de hardware o eventos del mundo real, basados en registros. En términos de paradigmas de interacción, y aunque el uso de modelos basados en eventos parece ser una solución conveniente [10, 22], a menudo carecen del soporte apropiado para requisitos no funcionales como confiabilidad, puntualidad o seguridad. Este documento describe un marco arquitectónico y un middleware, que admite un sistema basado en componentes y una visión integrada sobre la comunicación basada en eventos que comprende los eventos del mundo real y los eventos generados en el sistema. Al elegir el paradigma de interacción apropiado, es de importancia fundamental abordar los problemas desafiantes de las solicitudes sensibles previstas. A diferencia de los enfoques clásicos que limitan las posibles interacciones a los límites de la aplicación, es decir, a sus componentes, consideramos que el entorno que rodea la aplicación también juega un papel relevante a este respecto. Por lo tanto, el documento comienza aclarando varios problemas relacionados con nuestra visión del sistema, sobre las interacciones que pueden tener lugar y sobre los flujos de información. Esta vista se complementa al proporcionar un esquema de la construcción del sistema basada en componentes y, en particular, al demostrar que es posible componer aplicaciones más grandes a partir de componentes básicos, siguiendo un enfoque de composición jerárquica. Esto proporciona los antecedentes necesarios para introducir la arquitectura de eventos genéricos (Gear), que describe la interacción basada en eventos entre los componentes a través de una capa de evento genérico al tiempo que permite la integración perfecta de los flujos de información física e informática. De hecho, la capa de evento genérico oculta los diferentes canales de comunicación, incluidas las interacciones a través del entorno. Además, la abstracción de la capa de eventos también es adecuada para el manejo adecuado de los requisitos no funcionales, a saber, la confiabilidad y la puntualidad, que son particularmente estrictas en los entornos en tiempo real. El documento dedica especial atención a este problema al discutir los aspectos temporales de las interacciones y las necesidades de previsibilidad. Se presenta un middleware apropiado que refleja estas necesidades y permite especificar eventos que tienen atributos de calidad para expresar restricciones temporales. Esto se complementa con la noción de canales de eventos (CE), que son abstracciones de la red subyacente mientras la capa de eventos abstrae. De hecho, los canales de eventos juegan un papel fundamental en la obtención de las propiedades funcionales y no funcionales (por ejemplo, confiabilidad y puntualidad) de las aplicaciones previstas, es decir, para permitir la aplicación de los atributos de calidad. Se establecen antes de la interacción para reservar los recursos computacionales y de red necesarios para la difusión de eventos altamente predecible. El papel está organizado de la siguiente manera. En la Sección 3 presentamos las nociones y abstracciones fundamentales que adoptamos en este trabajo para describir las interacciones que tienen lugar en el sistema. Luego, en la Sección 4, describimos el enfoque basado en componentes que permite la composición de objetos. El equipo se describe luego en la Sección 5 y la Sección 6 se centra en aspectos temporales de las interacciones. La Sección 7 describe el middleware cósmico, que puede usarse para especificar la interacción entre objetos sensibles. Un ejemplo simple para resaltar las ideas presentadas en el documento aparece en la Sección 8 y la Sección 9 concluye el documento.2. Trabajo relacionado Nuestro trabajo considera un mundo físico cableado en el que cooperan una gran cantidad de componentes autónomos. Está inspirado en muchos esfuerzos de investigación en áreas muy diferentes. Se han introducido sistemas basados en eventos en general para cumplir con los requisitos de las aplicaciones en las que las entidades generan información y la difunden [1, 25, 22]. Destinados a sistemas grandes y que requieren infraestructuras bastante complejas, estos sistemas de eventos no consideran aspectos de calidad estrictos como la puntualidad y los problemas de confiabilidad. En segundo lugar, no se crean para apoyar la interoperabilidad entre pequeños dispositivos inteligentes con limitaciones sustanciales de recursos. En [10] se ha introducido un sistema de eventos en tiempo real para Corba. Los eventos se enrutan a través de un servidor de eventos centrales que proporciona funciones de programación para admitir los requisitos en tiempo real. Tal componente central no está disponible en una infraestructura prevista en la arquitectura de nuestro sistema y el Tao de middleware desarrollado (el orbe ACE) es bastante complejo e inadecuado para estar directamente integrado en dispositivos inteligentes. Hay esfuerzos para implementar CORBA para redes de control, adaptadas para conectar los componentes del sensor y el actuador [15, 19]. Están dirigidos al bus CAN [9], una red popular desarrollada para la industria automotriz. Sin embargo, en estos enfoques, el apoyo a los problemas de puntualidad o confiabilidad no existe o solo es muy limitado. Se propone un nuevo esquema para integrar dispositivos inteligentes en un entorno CORBA en [17] y ha llevado a la propuesta de un estándar por parte del grupo de gestión de objetos (OMG) [26]. Los transductores inteligentes están organizados en grupos que están conectados a un sistema CORBA por una puerta de enlace. Los grupos forman subredes aislados. Un nodo maestro especial impone las propiedades temporales en la subred de clúster. Una puerta de enlace de Corba permite acceder a los datos del sensor y escribir datos del actuador mediante un sistema de archivos de interfaz (IFS). La estructura básica es similar a la estructura WAN de CANS que se ha introducido en el Proyecto Cortex [4]. Las islas de control estricto pueden ser realizados por una red de control y cooperar a través de redes cableadas o inalámbricas que cubren una gran cantidad de estas subredes. Sin embargo, en contraste con el modelo de canal de eventos introducido en este documento, toda la comunicación dentro de un clúster se basa en una sola solución técnica de un canal de comunicación sincrónica. En segundo lugar, aunque el comportamiento temporal de un solo clúster está rigurosamente definido, no se proporciona ningún modelo para especificar propiedades temporales para las interacciones ClusterTo-Corba o Cluster-to Cluster.3. Flujo de información y modelo de interacción En este documento consideramos un modelo de sistema basado en componentes que incorpora trabajos previos desarrollados en el contexto del proyecto IST Cortex [5]. Como se mencionó anteriormente, una idea fundamental subyacente al enfoque es que las aplicaciones pueden estar compuestas por una gran cantidad de componentes inteligentes que pueden sentir su entorno circundante e interactuar con él. Estos componentes se denominan objetos sensibles, una metáfora elaborada en la corteza e inspirada en el concepto genérico de informática sensible introducida en [12]. Los objetos sintientes aceptan eventos de entrada de una variedad de fuentes diferentes (incluidos los sensores, pero no limitados a eso), procesanlos y producen eventos de salida, por lo que actúan sobre el entorno y/o interactúan con otros objetos. Por lo tanto, los siguientes tipos de interacciones pueden tener lugar en el sistema: interacciones de entorno a objeto: corresponden a un flujo de información del entorno a los objetos de aplicación, informando sobre el estado de la primera y/o notificación sobre los eventos que tienen lugaren esto. Interacciones de objeto a objeto: corresponde a un flujo de información entre objetos sensibles, cumpliendo dos propósitos. El primero está relacionado con la complementación de la evaluación de cada objeto individual sobre el estado del espacio circundante. El segundo está relacionado con la colaboración, en el que el objeto intenta influir en otros objetos para que contribuyan a un objetivo común, o a reaccionar a una situación inesperada. Interacciones de objeto a ambiente: corresponde a un flujo de información de un objeto al entorno, con el propósito de forzar un cambio en el estado de este último. Antes de continuar, necesitamos aclarar algunos problemas con respecto a estas posibles formas de interacción. Consideramos que el entorno puede ser un productor o consumidor de información mientras interactúa con objetos sensibles. El entorno es el mundo real (físico) que rodea un objeto, no necesariamente cerca del objeto o limitado a ciertos límites. Claramente, la información producida por el entorno corresponde a la representación física de las entidades en tiempo real, de las cuales los ejemplos típicos incluyen temperatura, distancia o el estado de una puerta. Por otro lado, la actuación en el medio ambiente implica la manipulación de estas entidades en tiempo real, como aumentar la temperatura (aplicar más calor), cambiar la distancia (aplicando algún movimiento) o cambiar el estado de la puerta (cerrar o abrirla). Las transformaciones requeridas entre las representaciones del sistema de estas entidades en tiempo real y sus representaciones físicas se realizan, genéricamente, por sensores y actuadores. Además, consideramos que puede existir sensores y actuadores tontos, que interactúan con los objetos mediante la difusión o captura de la información del transductor sin procesar, y los sensores y actuadores inteligentes, con capacidades de procesamiento mejoradas, capaces de hablar un dialecto de eventos más elaborado (consulte las Secciones 5 y 6.1). Por lo tanto, la interacción con el entorno se realiza a través de sensores y actuadores, que pueden o no ser parte de objetos sensibles, como se discutió en la Sección 4.2. Los cambios de estado o estado en el medio ambiente se consideran eventos, capturados por sensores (en el entorno o dentro de los objetos sensibles) y se difunden aún más a otros objetos sensibles potencialmente interesados en el sistema. En consecuencia, es bastante natural basar la comunicación y la interacción entre los objetos sensibles y con el medio ambiente en un modelo de comunicación basado en eventos. Además, las propiedades típicas de los modelos basados en eventos, como la comunicación anónima y no bloqueada, son altamente deseables en los sistemas donde los objetos sensibles pueden ser móviles y donde las interacciones son naturalmente muy dinámicas. Un aspecto distintivo de nuestro trabajo de muchos de los enfoques existentes es que consideramos que los objetos sintientes pueden comunicarse indirectamente entre sí a través del medio ambiente, cuando actúan en consecuencia. Por lo tanto, el entorno constituye un canal de interacción y comunicación y está en el bucle de control y conciencia de los objetos. En otras palabras, cuando un objeto sensible actúe en el entorno, podrá observar los cambios de estado en el entorno mediante eventos capturados por los sensores. Claramente, otros objetos también podrían capturar los mismos eventos, estableciendo así la ruta de comunicación indirecta mencionada anteriormente. En los sistemas que involucran interacciones con el entorno, es muy importante considerar la posibilidad de comunicación a través del medio ambiente. Se ha demostrado que los canales ocultos que se desarrollan a través de este último (por ejemplo, bucles de retroalimentación) pueden obstaculizar los algoritmos basados en software que los ignoran [30]. Por lo tanto, cualquier solución al problema requiere la definición de abstracciones convenientes y construcciones arquitectónicas apropiadas. Por otro lado, para lidiar con el flujo de información a través de todo el sistema informático y el entorno de una manera perfecta, manejando un software y eventos de hardware de manera uniforme, también es necesario encontrar abstracciones adecuadas. Como se discutió en la Sección 5, la arquitectura de eventos genéricos introduce el concepto de evento genérico y una abstracción de la capa de eventos que tiene como objetivo tratar, entre otros, con estos problemas.4. Composición de objetos sensibles En esta sección, analizamos los problemas más relevantes relacionados con el paradigma de los objetos sintientes y la construcción de sistemas compuestos por objetos sensibles.4.1 Construcción del sistema basado en componentes Los objetos sensibles pueden tomar varias formas diferentes: simplemente pueden ser componentes basados en software, pero también pueden comprender piezas mecánicas y/o de hardware, entre las cuales el aparato muy sensorial que correge la sensibilidad, mezclados con los componentes de software.cumplir con su tarea. Refinamos esta noción considerando un objeto sensible como una entidad encapsulante, un componente con lógica interna y elementos de procesamiento activo, capaz de recibir, transformar y producir nuevos eventos. Esta interfaz oculta la estructura interna de hardware/software del objeto, que puede ser compleja, y protege el sistema de los detalles funcionales y temporales de bajo nivel de controlar un sensor o actuador específico. Además, dada la complejidad inherente de las aplicaciones previstas, el número de eventos de entrada simultáneos y el tamaño interno de los objetos sensibles pueden volverse demasiado grandes y difíciles de manejar. Por lo tanto, debería ser posible considerar la composición jerárquica de objetos sensibles para que la lógica de la aplicación pueda separarse en tan pocos o tantos objetos como sea necesario. Por otro lado, la composición de objetos sensibles normalmente debe estar limitado por la estructura de componentes de hardware real, evitando la posibilidad de componer arbitrariamente objetos sensibles. Esto se ilustra en la Figura 1, donde un objeto sensible se compone internamente de algunos otros objetos sensibles, cada uno de ellos consumiendo y produciendo eventos, algunos de los cuales solo se propagaron internamente. Observando la figura y recordando nuestra discusión anterior sobre las posibles interacciones, identificamos todas ellas aquí: una interacción de objeto a ambiente ocurre entre el objeto que controla un transmisor WLAN y algún receptor WLAN en el entorno;Una interacción de entorno a objeto tiene lugar cuando el objeto responsable del GPS 30 G P S R E C E P T I O N W I R E L E S S T R A N S M I S S I O N D O P P P L E R R A D A R P H Y S I C A L F E E E D B A C K O B J E C T T S B O D Y I N T E R N A L N E T W O R K FIGURA 1: COMPONELE.La recepción de la señal utiliza la información transmitida por los satélites;Finalmente, las interacciones explícitas del objeto al objeto ocurren internamente en el objeto del contenedor, a través de una red de comunicación interna. Además, es interesante observar que también puede ocurrir una comunicación implícita, si la retroalimentación física se desarrolla a través del entorno interno al objeto del contenedor (como se muestra) o a través del entorno externo a este objeto. Sin embargo, hay una diferencia sutil entre ambos casos. Mientras que en el primero, la retroalimentación solo puede ser percibida por objetos internos del contenedor, limitando la medida en que se debe garantizar la consistencia, tales límites no existen en el último. De hecho, la noción de objeto sintiente como entidad encapsulante puede cumplir con otros fines (por ejemplo, el confinamiento de la retroalimentación y la propagación de los eventos), más allá de la mera composición jerárquica de los objetos. Para dar un ejemplo más concreto de dicha composición del objeto consciente de los componentes, consideramos un escenario de robots cooperantes. Cada robot está hecho de varios componentes, correspondientes, por ejemplo, a los controladores de eje y manipulador. Junto con el software de control, cada uno de estos controladores puede ser un objeto sensible. Por otro lado, un robot en sí es un objeto sensible, compuesto por los objetos materializados por los controladores, y el entorno interno a su propia estructura o cuerpo. Esto significa que debería ser posible definir actividades de cooperación utilizando los eventos producidos por los objetos sensibles de los robots, sin la necesidad de conocer la estructura interna de los robots, o los eventos producidos por los objetos del cuerpo o por sensores inteligentes dentro del cuerpo. Sin embargo, desde el punto de vista de la ingeniería, esto también significa que el objeto sensible del robot puede tener que generar nuevos eventos que reflejen su estado interno, lo que requiere la definición de una puerta de enlace para hacer el puente entre los entornos internos y externos.4.2 Encapsulación y alcance Ahora una pregunta importante es sobre cómo representar y difundir eventos en un mundo en red a gran escala. Como hemos visto anteriormente, cualquier evento generado por un objeto sensible podría, en principio, ser visible en cualquier parte del sistema y, por lo tanto, recibido por cualquier otro objeto sensible. Sin embargo, existen obstáculos sustanciales para tales interacciones universales, que se originan en la heterogeneidad de los componentes en tal entorno a gran escala. En primer lugar, los componentes pueden tener restricciones de rendimiento severas, particularmente porque queremos integrar sensores y actuadores inteligentes en dicha arquitectura. En segundo lugar, el ancho de banda de las redes participantes puede variar en gran medida. Dichas redes pueden ser de baja potencia, negocios de campo de bajo ancho de banda o redes inalámbricas más potentes, así como columnas de alta velocidad. En tercer lugar, las redes pueden tener características de confiabilidad y puntualidad muy diferentes. Considere un pelotón de vehículos cooperantes. Dentro de un vehículo puede haber un bus de campo como CAN [8, 9], TTP/A [17] o LIN [20], con un ancho de banda relativamente bajo. Por otro lado, los vehículos se comunican con otros en el pelotón a través de un enlace inalámbrico directo. Finalmente, puede haber múltiples pelotones de vehículos que están coordinados por una capa de red inalámbrica adicional. En el nivel de abstracción de objetos sensibles, dicha heterogeneidad se refleja por la noción de cuerpo-ambiente. En el nivel de red, asumimos que la estructura WAN-of-CANS [27] modela las diferentes redes. La noción de cuerpo y entorno se deriva del modelo de objetos basado en componentes recursivamente definidos. Un cuerpo es similar a una membrana celular y representa un contenedor de calidad de servicio para los objetos sensibles en el interior. En el nivel de red, puede estar asociado con los componentes acoplados por cierto CAN. A CAN define la calidad de difusión que los objetos cooperantes pueden esperar. En el ejemplo anterior, un vehículo puede ser un objeto sensible, cuyo cuerpo está compuesto por los respectivos objetos de nivel inferior (sensores y actuadores) que están conectados por la red interna (ver Figura 1). En consecuencia, el pelotón puede verse a sí mismo como un objeto compuesto por una colección de vehículos cooperantes, siendo su cuerpo el entorno encapsulado por la zona de pelotón. En el nivel de red, la red inalámbrica representa la lata respectiva. Sin embargo, varios pelotones unidos por sus latas pueden interactuar entre sí y objetos más lejos, a través de un sustrato de red fijo de rango más amplio, posible, de ahí el concepto de WAN-of-CANS. Las nociones de ambiente corporal y WAN de CAN son muy útiles al definir las propiedades de interacción a través de tales límites. Su introducción obedeció a nuestra creencia de que un solo mecanismo para proporcionar medidas de calidad para las interacciones no es apropiada. En cambio, se necesita una construcción de alto nivel para la interacción entre los límites que permite especificar la calidad de la difusión y explotar el conocimiento sobre el cuerpo y el medio ambiente para evaluar la viabilidad de las limitaciones de calidad. Como veremos en la siguiente sección, la noción de un canal de eventos representa esta construcción en nuestra arquitectura. Difusión de eventos y permite la especificación independiente de la red de atributos de calidad. Estos atributos deben asignarse a las propiedades respectivas de la estructura de red subyacente.5. Una arquitectura de eventos genéricos Para aplicar con éxito modelos orientados a objetos basados en eventos, que aborda los desafíos enumerados en la introducción de este documento, es necesario utilizar construcciones arquitectónicas adecuadas que permitan la aplicación de propiedades fundamentales como la oportunidad o la confiabilidad. Proponemos la arquitectura de eventos genéricos (Gear), representados en la Figura 2, que describimos brevemente en lo que sigue (para una descripción más detallada, consulte [29]). La estructura en forma de L es crucial para garantizar algunas de las propiedades descritas. Medio ambiente: el entorno físico, remoto y cercano, sólido y eterial, de objetos sensibles.31 c o m m sc o m m sc o m m s t r a n s l a t i o n l a y e r t r a n s l a t i o n l a y e r b o d y e n v i r o n m e n t b o d y e n v i r o n m e n t b o d y e n v i r o n m e n t (i n c l u d i n g o p e r a r a n o n o n o o o o o o o n o n o o o o o o o o o o n n) j e c t o r o b j e c t c o m p o u n d) t r a n s l a t i o n l a y e r t r a n s l a t i o n s e n t i e n t o b j e c t s e n t i e n t o b j e c t se n t i e n t o b j e c t r e g u l a r n e t w o r k c o n s u m ep r o d u c e e v e n t l a y e r e v e n t l a y e r e v e n t l a y e r s e n t i e n t o b j e c t th figura 2: arquitectura de evaluación de genics. Cuerpo: la realización física de un objeto sensible (por ejemplo, el hardware donde reside un controlador mecatrónico, la estructura física de un automóvil). Tenga en cuenta que debido al enfoque compositivo adoptado en nuestro modelo, parte de lo que es entorno a un objeto más pequeño visto individualmente, se convierte en cuerpo para un objeto que contiene más grande. De hecho, el cuerpo es el entorno interno del objeto. Esta capas de arquitectura permite que la composición tenga lugar sin problemas, en lo que se refiere al flujo de información. Dentro de un cuerpo también puede haber un conocimiento implícito, que puede explotarse para hacer que la interacción sea más eficiente, como el conocimiento sobre el número de entidades cooperantes, la existencia de una red de comunicación específica o el hecho simple de que todos los componentes están ubicados y, por lo tanto,Los eventos respectivos no necesitan especificar la ubicación en sus atributos de contexto. Dicha información intrínseca no está disponible fuera de un cuerpo y, por lo tanto, una información más explícita debe ser llevada por un evento. Capa de traducción: la capa responsable de la transformación de eventos físicos de/a su forma nativa al dialecto del canal de eventos, entre el entorno/cuerpo y un canal de eventos. Esencialmente, uno que realiza operaciones de observación y actuación en el lado inferior, y realiza transacciones de descripciones de eventos en el otro. En el lado inferior, esta capa también puede interactuar con sensores de tontos o actuadores, por lo tanto, hablar el lenguaje del dispositivo específico. Estas interacciones se realizan a través de redes operativas (de ahí el símbolo de la antena en la figura). Capa de eventos: la capa responsable de la propagación de eventos en todo el sistema, a través de varios canales de eventos (EC):. En términos concretos, esta capa es un tipo de middleware que proporciona importantes servicios de procesamiento de eventos que son cruciales para cualquier sistema realista basado en eventos. Por ejemplo, algunos de los servicios que implican el procesamiento de eventos pueden incluir publicar, suscribirse, discriminación (zonificación, filtrado, fusión, rastreo) y cola. Capa de comunicación: la capa responsable de envolver eventos (de hecho, descripciones de eventos en el dialecto EC) en mensajes de eventos de transporte, que se transportará a lugares remotos. Por ejemplo, un evento de detección generado por un sensor inteligente está envuelto en un mensaje de evento y difundido, para ser atrapado por quien esté preocupado. Lo mismo se mantiene para un evento de actuación producido por un objeto sensible, para ser entregado a un actuador inteligente remoto. Del mismo modo, esto puede aplicarse a un mensaje de eventos de un objeto sensible a otro. Los sensores tontos y los actuadores no envían mensajes de eventos, ya que no pueden comprender el dialecto EC (no tienen una capa de eventos ni una capa de comunicación: se comunican, si es necesario, a través de redes operativas). Red regular: esto se representa en el eje horizontal del diagrama de bloques por la capa de comunicación, que abarca los protocolos habituales de LAN, TCP/IP y tiempo real, aumentados deseablemente con transmisión confiable y/u ordenada y otros protocolos. El Gear presenta algunas ideas innovadoras en la arquitectura de sistemas distribuidos. Mientras sirve un modelo de objetos basado en la producción y el consumo de eventos genéricos, trata los eventos producidos por varias fuentes (medio ambiente, cuerpo, objetos) de manera homogénea. Esto es posible debido al uso de un dialecto básico común para hablar de eventos y debido a la existencia de la capa de traducción, que realiza la traducción necesaria entre la representación física de una entidad en tiempo real y el formato compatible con la CE. Crucial a la arquitectura es la capa de eventos, que utiliza canales de eventos para propagar eventos a través de infraestructuras de red regulares. La capa de eventos se realiza por el middleware cósmico, como se describe en la Sección 7. 5.1 Flujo de información En marcha El flujo de información (entorno externo y parte computacional) es compatible con la arquitectura en forma de L. Ocurre de diferentes maneras, lo que demuestra la expresividad del modelo con respecto a las formas necesarias de información encontradas en los sistemas cooperativos e integrados en tiempo real. Los sensores inteligentes producen eventos que informan sobre el entorno. Los sensores corporales producen eventos que informan sobre el cuerpo. Se diseminan por el módulo de capa de eventos local, en un canal de eventos (EC) propagado a través de la red regular, a cualquier módulo de capa de eventos remoto relevante donde las entidades mostraban un interés en ellos, normalmente, objetos sensibles adjuntos a los respectivos módulos de eventos locales de eventos locales.. Los objetos sintientes consumen eventos que están interesados, los procesan y producen otros eventos. Algunos de estos eventos están destinados a otros objetos sensibles. Se publican en una CE utilizando el mismo dialecto EC que sirve, por ejemplo, eventos originados por el sensor. Sin embargo, estos eventos son semánticamente de un tipo de tal manera que deben ser suscritos por los objetos sensibles relevantes, por ejemplo, los objetos sensibles que componen un sistema de controlador de robot o, en un nivel superior, los objetos sensibles que componen los robots reales en 32una aplicación cooperativa. Los actuadores inteligentes, por otro lado, simplemente consumen eventos producidos por objetos sensibles, por los cuales aceptan y ejecutan comandos de actuación. Alternativamente, para hablar con otros objetos sensibles, los objetos sensibles pueden producir eventos de un nivel inferior, por ejemplo, comandos de actuación en el cuerpo o el entorno. Publican estos exactamente de la misma manera: en un canal de eventos a través del representante local de la capa de eventos. Ahora, si estos comandos son preocupantes para las unidades de actuador local (por ejemplo, cuerpo, incluidas las redes operativas internas), se transmiten a la capa de traducción local. Si son preocupantes para un actuador inteligente remoto, se difunden a través de la capa de eventos distribuidos, para llegar a la primera. En cualquier caso, si también son de interés para otras entidades, como otros objetos sensibles que desean ser informados del comando de actuación, también se diseminan a través de la CE a estos objetos sensibles. Una ventaja clave de esta arquitectura es que los mensajes de eventos y los eventos físicos se pueden ordenar a nivel mundial, si es necesario, ya que todos pasan por la capa de eventos. El modelo también ofrece oportunidades para resolver un problema duradero en tiempo real, control de la computadora y sistemas integrados: la inconsistencia entre los subsistemas de flujo de información del bucle de mensajes de retroalimentación.6. Aspectos temporales de las interacciones Cualquier interacción necesita alguna forma de previsibilidad. Si se consideran escenarios críticos de seguridad como se realiza en la corteza, los aspectos temporales se vuelven cruciales y deben hacerse explícitos. El problema es cómo definir restricciones temporales y cómo hacerlas cumplir con el uso apropiado de recursos en un entorno ad-hoc dinámico. En un sistema donde las interacciones son espontáneas, también puede ser necesario determinar dinámicamente las propiedades temporales. Para hacer esto, la información temporal respectiva debe establecerse explícitamente y disponible durante el tiempo de ejecución. En segundo lugar, no siempre se asegura que se puedan cumplir las propiedades temporales. En estos casos, se deben proporcionar adaptaciones y notificación de falla de tiempo [2, 28]. En la mayoría de los sistemas en tiempo real, la noción de una fecha límite es el esquema predominante para expresar y hacer cumplir la puntualidad. Sin embargo, una fecha límite solo refleja débilmente las características temporales de la información que se maneja. En segundo lugar, una fecha límite a menudo incluye conocimiento implícito sobre el sistema y las relaciones entre las actividades. En un entorno cerrado bastante bien definido, es posible hacer tales suposiciones implícitas y asignarlos a los tiempos de ejecución y los plazos. P.ej.El ingeniero sabe cuánto tiempo se puede usar una posición de vehículo antes de que el movimiento del vehículo se desanime con esta información. Por lo tanto, mapea esta dependencia entre la velocidad y la posición en una fecha límite que luego asegura que se suponga que el error de posición está limitado. En un entorno abierto, este mapeo implícito ya no es posible porque, como una razón obvia, la relación entre la velocidad y la posición, y por lo tanto el error, el error, no puede ser fácilmente diseñado a reverso desde una fecha límite. Por lo tanto, nuestro modelo de evento incluye atributos de calidad explícitos que permiten especificar los atributos temporales para cada evento individual. Esto es, por supuesto, una sobrecarga en comparación con el uso del conocimiento implícito, pero en un entorno dinámico se necesita dicha información. Para ilustrar el problema, considere el ejemplo de la posición de un vehículo. Una posición es un ejemplo típico para el tiempo, la entidad de valor [30]. Por lo tanto, la posición es útil si podemos determinar un límite de error que está relacionado con el tiempo, p.Si queremos un error de posición por debajo de 10 metros para establecer una propiedad de seguridad entre los automóviles cooperantes que se mueven con 5 m/seg, la posición tiene un tiempo de validez de 2 segundos. En una entidad de entidad de valor, podemos intercambiar el tiempo con la precisión del valor. Esto se conoce como valor en el tiempo y el tiempo sobre el valor [18]. Una vez que haya establecido la relación de valor en el tiempo y capturado en los atributos del evento, los suscriptores de este evento pueden decidir localmente sobre la utilidad de una información. En la arquitectura de Gear Architecture, la validez temporal se utiliza para razonar sobre las propiedades de seguridad en un sistema basado en eventos [29]. Revisaremos brevemente las nociones respectivas y veremos cómo se explotan en nuestro middleware de evento cósmico. Considere la línea de tiempo de generar un evento que representa una entidad en tiempo real [18] desde su ocurrencia hasta la notificación de un cierto objeto sensible (Figura 3). La entidad en tiempo real se captura en la interfaz del sensor del sistema y debe transformarse en una forma que pueda ser tratada por una computadora. Durante el intervalo de tiempo T0, el sensor lee la entidad en tiempo real y una marca de tiempo se asocia con el valor respectivo. El tiempo derivado, la entidad de valor representa una observación. Puede ser necesario realizar cálculos locales sustanciales para obtener información relevante de la aplicación de los datos del sensor sin procesar. Sin embargo, debe tenerse en cuenta que la marca de tiempo de la observación está asociada con el tiempo de captura y, por lo tanto, independiente del procesamiento de señales y la generación de eventos. Esta estrecha relación entre el tiempo de captura y el valor asociado es compatible con los sensores inteligentes descritos anteriormente. La información del sensor procesada se ensambla en una estructura de datos de eventos después de que TS se publique en un canal de eventos. Como se describe más adelante, el evento incluye la marca de tiempo de generación y la validez temporal como atributos. La validez temporal es una medida definida por la aplicación para la expiración de un valor, valor. Como explicamos en el ejemplo de una posición anterior, puede variar dependiendo de los parámetros de aplicación. La validez temporal es un concepto más general que el de una fecha límite. Es independiente de una cierta implementación técnica de un sistema. Si bien los plazos pueden usarse para programar los pasos respectivos en una generación y difusión de eventos, una validez temporal es una propiedad intrínseca de una entidad de valor de tiempo transportada en un evento. Una validez temporal permite razonar sobre la utilidad de la información y es beneficioso incluso en sistemas en los que no se puede aplicar la difusión oportuna de los eventos porque permite la detección de fallas de tiempo en el consumidor del evento. Es obvio que los plazos o períodos pueden derivarse de la validez temporal de un evento. Es necesario establecer una fecha límite, el conocimiento de una implementación, los peores tiempos de ejecución de los casos o las latencias de difusión de mensajes. Por lo tanto, en la línea de tiempo de la Figura 3, cada intervalo puede tener una fecha límite. Difusión de eventos a través de canales suaves en tiempo real en explotación cósmica de la validez temporal para definir los plazos de difusión. Los atributos de calidad se pueden definir, por ejemplo, en términos de intervalo de validez, pares de grado de omisión. Estos permiten caracterizar la utilidad del evento para una determinada aplicación, en un determinado contexto. Debido a eso, los atributos de calidad de un evento dependen claramente de problemas de nivel superior, como la naturaleza del objeto sensible o del sensor inteligente que produjo el evento. Por ejemplo, un evento que contiene una indicación de alguna velocidad del vehículo debe tener atributos de calidad diferentes dependiendo del tipo de observación del evento del mundo real: <Sello de tiempo> Valor> Evento generado listo para ser transmitido Notificación de evento recibido, a T Productor de eventoscommunication network event consumer event channel push <event> , ts , tm , tt , tn , t o : t i m e t o o b t a i n a n o b s e r v a t i o n , t s : t i m e t o p r o c e s s s e n s o r r e a d i n g , t m : t i m e t o a s s e m b l e a n e v e n t m e s s a g e , t t : t i m e t o t r a n s f e r t h e e v e n t o n t h e r e g u l a r n e t w o r k , t n : t i m e f o r n o t i f i c a t i o n o n t h e c o n s u m e r s i t e Figure 3: Event processing and dissemination.desde el cual se originó, o dependiendo de su velocidad actual. Lo mismo ocurre con el evento de posición del ejemplo del automóvil anterior, cuya validez depende de la velocidad actual y de una precisión previamente requerida. Sin embargo, dado que los atributos de calidad están estrictamente relacionados con la semántica de la aplicación o, al menos, con algún conocimiento de alto nivel del propósito del sistema (a partir del cual se puede derivar la validez de la información), la definición de estos atributos de calidad puedehacerse explotando la información proporcionada en la interfaz de programación. Por lo tanto, es importante comprender cómo el programador del sistema puede especificar requisitos no funcionales en la API y cómo estos requisitos se traducen en atributos de calidad asignados a los eventos. Si bien la validez temporal se identifica como una propiedad de eventos intrínsecos, que se explota para decidir sobre la utilidad de los datos en un cierto momento, todavía es necesario proporcionar una instalación de comunicación que pueda difundir el evento antes de que la validez expire. En una estructura de red WAN-of-CANS tenemos que hacer frente a las características de la red muy diferentes y la calidad de las propiedades de servicio. Por lo tanto, al cruzar los límites de la red, se perderán las garantías de calidad de servicio disponibles en una determinada red y será muy difícil, costoso y quizás imposible lograr estas propiedades en la siguiente área más grande de la estructura WAN-de Cails. Cortex tiene un par de abstracciones para hacer frente a esta situación (zonas de red, cuerpo/entorno) que se han discutido anteriormente. Desde el punto de vista temporal, necesitamos una abstracción de alto nivel como la validez temporal para el evento individual ahora para expresar nuestros requisitos de calidad de la difusión sobre la red. El par de cobertura límite, introducido en relación con el TCB [28] parece ser un enfoque apropiado. Considera la incertidumbre inherente de las redes y permite intercambiar la calidad de la difusión contra los recursos necesarios. En relación con el modelo de canal de eventos discutido más adelante, el par de cobertura límite permite especificar las propiedades de calidad de un canal de eventos independientemente de problemas técnicos específicos. Dados los entornos típicos en los que operarán las aplicaciones sensibles, donde es difícil o incluso imposible proporcionar garantías de puntualidad o confiabilidad, propusimos una forma alternativa de manejar los requisitos de aplicación no funcionales, en relación con el enfoque TCB [28]. El enfoque propuesto explota las características intrínsecas de las aplicaciones, como la seguridad fallida o la elasticidad del tiempo, para asegurar las especificaciones de QoS de la cobertura de forma unida. En lugar de construir sistemas que se basan en límites garantizados, la idea es usar (posiblemente cambiando) límites que están asegurados con una probabilidad constante en toda la ejecución. Obviamente, esto requiere una aplicación para poder adaptarse a las condiciones cambiantes (y/o los límites cambiantes) o, si esto no es posible, para poder realizar algunos procedimientos de seguridad cuando las condiciones operativas se degradan a un nivel insoportable. Los límites que mencionamos anteriormente se refieren esencialmente a los límites de la puntualidad asociados a la ejecución de actividades locales o distribuidas, o combinaciones de los mismos. De estos límites es posible derivar los atributos de calidad, en particular los intervalos de validez que caracterizan los eventos publicados en el canal de eventos.6.1 El papel de los sensores y actuadores inteligentes de los dispositivos inteligentes encapsulan el hardware, el software y los componentes mecánicos y proporcionan información y un conjunto de funciones bien especificadas y que están estrechamente relacionadas con la interacción con el entorno. Los componentes computacionales incorporados y la interfaz de red permiten la implementación de una interfaz de alto nivel bien definida que no solo proporciona datos de transductor sin procesar, sino un conjunto de eventos procesados y relacionados con la aplicación. Además, exhiben un comportamiento espontáneo autónomo. Se diferencian de los nodos de propósito general porque están dedicados a una determinada funcionalidad que cumple con sus capacidades de detección y actuación, mientras que el nodo de propósito general puede ejecutar cualquier programa. Con respecto al modelo de objetos sintientes, los sensores y actuadores inteligentes pueden ser objetos sensibles básicos en sí mismos, consumiendo eventos del entorno del mundo real y produciendo los eventos genéricos respectivos para la capa de eventos de sistemas o 34 viceversa que consumen un evento genérico y la convierte en unEvento del mundo real por una actuación. Por lo tanto, los componentes inteligentes constituyen la periferia, es decir, la interfaz del mundo real de un objeto sensible más complejo. El modelo de objetos sensibles también constituye el marco para construir sensores virtuales más complejos al relacionar múltiples sensores (es decir, sensores que detectan directamente una entidad física) sensores. Los componentes inteligentes traducen eventos del entorno a una forma apropiada disponible en la capa de eventos o, viceversa, transforman un evento del sistema en una actuación. Para los componentes inteligentes podemos suponer que: • Los componentes inteligentes tienen recursos dedicados para realizar una función específica.• Estos recursos no se utilizan para otros fines durante la operación normal en tiempo real.• No se producen conflictos temporales locales que cambiarán el comportamiento temporal observable.• Las funciones de un componente generalmente solo se pueden cambiar durante un procedimiento de configuración que no se realiza cuando el componente está involucrado en operaciones críticas.• Una observación del entorno como un par, se puede obtener un par de valor con una jitter acotada en el tiempo. Muchos problemas de previsibilidad y programación surgen del hecho de que los comportamientos de tiempo de muy bajo nivel deben manejarse en un solo procesador. Aquí, la encapsulación temporal de las actividades es difícil debido a los posibles efectos secundarios al compartir un solo recurso de procesador. Considere el control de un detector de rango IR simple que se utiliza para evitar obstáculos. Dependiendo de su rango y la velocidad de un vehículo, debe ser encuestado para evitar que el vehículo se caiga en un obstáculo. En un solo procesador central, esta actividad crítica debe coordinarse con muchas funciones similares, posiblemente menos críticas. Significa que un horario de grano muy fino debe derivarse basándose exclusivamente en los artefactos del control del dispositivo de bajo nivel. En un componente de sensor inteligente, todo este comportamiento de tiempo de bajo nivel se puede optimizar y encapsularse. Por lo tanto, podemos asumir una encapsulación temporal similar a la información oculta en el dominio funcional. Por supuesto, todavía existe el problema que garantiza que los componentes del sistema respectivos se difundan y reconocerán un evento a su debido tiempo, pero esto se relaciona con eventos relacionados con la aplicación en lugar de los bajos artefactos de un momento de tiempo. La responsabilidad principal de proporcionar garantías de puntualidad se transfiere a la capa de eventos donde se difunden estos eventos. Los sensores inteligentes conducen al modelo de sistema centrado en la red. La red constituye el recurso compartido que debe programarse de manera predecible. El middleware cósmico introducido en la siguiente sección es un enfoque para proporcionar una difusión de eventos predecibles para una red de sensores y actuadores inteligentes.7. Un modelo de evento y Middleware para dispositivos inteligentes cooperantes Un modelo de evento y un middleware adecuado para componentes inteligentes deben admitir una comunicación oportuna y confiable y también debe ser eficiente en los recursos. Cosmic (dispositivos inteligentes cooperantes) tiene como objetivo apoyar la interacción entre esos componentes de acuerdo con los conceptos introducidos hasta ahora. Basado en el modelo de una WAN de CAN, suponemos que los componentes están conectados a alguna forma de CAN como un bus de campo o una red de sensores inalámbricos especiales que proporciona propiedades de red específicas. P.ej.Una bus de campo desarrollada para aplicaciones de control generalmente incluye mecanismos para la comunicación predecible, mientras que otras redes solo admiten la mejor difusión de esfuerzo. Una puerta de enlace conecta estas latas al siguiente nivel en la jerarquía de red. El sistema de eventos debe permitir la interacción dinámica sobre una jerarquía de tales redes y cumplir con el modelo general de eventos genéricos de la corteza. Los eventos son portadores de información escrita y se difunden en un estilo de editor/ suscriptor [24, 7], que es particularmente adecuado porque admite la comunicación generativa y anónima [3] y no crea dependencias de control artificiales entre los productores de información y los consumidores. Este desacoplamiento en el espacio (no se necesitan referencias ni nombres de remitentes o receptores para la comunicación) y el desacoplamiento de flujo (no se produce transferencia de control con una transferencia de datos) son bien conocidos [24, 7, 14] y propiedades cruciales para mantener la autonomía de los componentese interacciones dinámicas. Es obvio que no todas las redes pueden proporcionar las mismas garantías de QoS y, en segundo lugar, las aplicaciones pueden tener requisitos muy diferentes para la difusión de eventos. Además, cuando se esfuerza por la previsibilidad, los recursos deben reservarse y las estructuras de datos deben configurarse antes de que se realice la comunicación. Por lo tanto, estas cosas no se pueden hacer previsiblemente sobre la marcha mientras difunden un evento. Por lo tanto, introdujimos la noción de un canal de eventos para hacer frente a diferentes propiedades y requisitos y tenemos un objeto al que podemos asignar recursos y reservas. El concepto de un canal de eventos no es nuevo [10, 25], sin embargo, aún no se ha utilizado para reflejar las propiedades de las redes y mecanismos de comunicación heterogéneos subyacentes según lo descrito por la arquitectura de engranajes. Más bien, el evento de eventos existente permite especificar las prioridades o plazos de eventos manejados en un servidor de eventos. Los canales de eventos permiten especificar las propiedades de comunicación en el nivel del sistema de eventos de manera fina. Un canal de eventos se define por: canal de eventos: = sujeto, atributante de calidad, manejadores, el sujeto determina los tipos de eventos que se pueden emitir al canal. Los atributos de calidad modelan las propiedades de la red de comunicación subyacente y el esquema de difusión. Estos atributos incluyen especificaciones de latencia, restricciones de difusión y parámetros de confiabilidad. La noción de zonas que representan una calidad de servicio garantizada en una subred admite este enfoque. Nuestro objetivo es manejar las especificaciones temporales como unidos, pares de cobertura [28] ortogonales a las preguntas más técnicas sobre cómo lograr una cierta propiedad de sincronía de la infraestructura de difusión. Actualmente, apoyamos los atributos de calidad de los canales de eventos en un entorno Can-Bus representado por clases de sincronía explícitas. El middleware cósmico mapea las propiedades del canal a los protocolos de nivel inferior de la red regular. Basado en nuestro trabajo anterior sobre protocolos predecibles para el bus CAN, Cosmic define una red abstracta que proporciona clases de mensajes duros, suaves y no en tiempo real [21]. En consecuencia, distinguimos tres clases de canales de eventos de acuerdo con sus propiedades de sincronía: canales duros en tiempo real, canales suaves en tiempo real y canales no en tiempo real. Los canales duros en tiempo real (HRTC) garantizan la propagación del evento dentro de las limitaciones de tiempo definidas en presencia 35 de un número especificado de fallas de omisión. Los HRTEC están respaldados por un esquema de reserva que es similar al esquema utilizado en protocolos activados por el tiempo como TTP [16] [31], TTP/A [17] y TTCAN [8]. Sin embargo, una ventaja sustancial sobre un esquema TDMA es que debido a las propiedades del bus de canales, el ancho de banda que fue reservado pero que no es necesario por un HRTEC puede ser utilizado por un tráfico menos crítico [21]. Los canales suaves en tiempo real (SRTC) explotan el intervalo de validez temporal de los eventos para obtener plazos para la programación. El intervalo de validez define el punto en el tiempo después del cual un evento se vuelve temporalmente inconsistente. Por lo tanto, en un sistema en tiempo real, un evento es inútil después de este punto y que me descarte. La fecha límite de transmisión (DL) se define como el último punto en el tiempo en que un mensaje debe transmitirse y se especifica en un intervalo de tiempo que se deriva del tiempo de vencimiento: Tevent Ready <dl <texpiration - ∆notification Texpiration define el punto entiempo en que expira la validez temporal.Lanotificación es la latencia esperada de extremo a extremo que incluye el tiempo de transferencia a través de la red y el tiempo en que el evento puede retrasarse mediante el manejo de eventos locales en los nodos. Como se dijo antes, los plazos de eventos se utilizan para programar la difusión de SRTEC. Sin embargo, los plazos pueden perderse en situaciones de sobrecarga transitoria o debido a los tiempos de llegada arbitrarios de los eventos. Por el lado del editor, el controlador de excepciones de aplicaciones se llama cada vez que la fecha límite del evento expira antes de la transmisión del evento. En este momento, tampoco se espera que el evento llegue al lado del suscriptor antes de que expire la validez. Por lo tanto, el evento se elimina de la cola de envío. Por el lado del suscriptor, el tiempo de vencimiento se utiliza para programar la entrega del evento. Si el evento no se puede entregar hasta su tiempo de vencimiento, se elimina de las colas respectivas asignadas por el middleware cósmico. Esto evita que el sistema de comunicación se cargue por mensajes obsoletos. Los canales que no son de tiempo real no asumen ninguna especificación temporal y difunen eventos de la mejor manera. Se crea una instancia de un canal de eventos localmente, cada vez que un editor hace un anuncio para su publicación o un suscriptor de suscriptor para una notificación de eventos. Cuando un editor anuncia la publicación, el middleware crea las estructuras de datos respectivas de un canal de eventos. Cuando un suscriptor se suscribe a un canal de eventos, puede especificar los atributos de contexto de un evento que se utilizan para filtrar eventos localmente. P.ej.Un suscriptor solo puede estar interesado en los eventos generados en un lugar determinado. Además, el suscriptor especifica las propiedades de calidad del canal de eventos. Se puede encontrar una descripción más detallada de los canales de eventos en [13]. Actualmente, Cosmic maneja todos los canales de eventos que difunden eventos más allá del límite de la red CAN como canales de eventos no en tiempo real. Esto se debe principalmente a que usamos el protocolo TCP/IP para difundir eventos sobre enlaces inalámbricos o al Ethernet estándar. Sin embargo, hay una serie de mejoras posibles que se pueden integrar fácilmente en el modelo de canal de eventos. La base de computación oportuna (TCB) [28] puede explotarse para la detección de fallas de sincronización y, por lo tanto, proporcionaría conciencia sobre la diseminación de eventos en entornos donde no se puede aplicar la entrega oportuna de eventos. Además, hay protocolos inalámbricos que pueden proporcionar una entrega de mensajes oportuna y confiable [6, 23] que pueden explotarse para las clases de canales de eventos respectivas. Los eventos son los operadores de información que se intercambian entre objetos sensibles a través de canales de eventos. Para hacer frente a los requisitos de un entorno ad-hoc, un evento incluye la descripción del contexto en el que se ha generado y los atributos de calidad que definen los requisitos para la difusión. Esto es particularmente importante en un entorno abierto y dinámico donde un evento puede viajar a través de múltiples redes. Se especifica una instancia de evento como: Evento: = Sujeto, Contexto Atributelista, Attributalista de calidad, Contenido Un sujeto define el tipo de evento y está relacionado con el contenido del evento. Admite la comunicación anónima y se utiliza para enrutar un evento. El sujeto tiene que coincidir con el tema del canal del evento a través del cual se difunde el evento. Los atributos son complementarios al contenido del evento. Describen propiedades funcionales y no funcionales individuales del evento. Los atributos de contexto describen el entorno en el que se ha generado el evento, p.una ubicación, un modo operativo o un momento de ocurrencia. Los atributos de calidad especifican aspectos de puntualidad y confiabilidad en términos de intervalo de validez, pares de grado de omisión. El intervalo de validez define el punto en el tiempo después del cual un evento se vuelve temporalmente inconsistente [18]. Como se describió anteriormente, la validez temporal se puede asignar a una fecha límite. Sin embargo, generalmente un plazo es un artefacto de ingeniería que se utiliza para la programación, mientras que la validez temporal es una propiedad general de una entidad de valor de tiempo. En un entorno en el que no se puede hacer cumplir un plazo, un consumidor de un evento eventualmente debe decidir si el evento aún es temporalmente consistente, es decir, representa una entidad de valor válida de tiempo.7.1 La arquitectura del middleware cósmico a nivel arquitectónico, cósmico distinga tres capas representadas aproximadamente en la Figura 4. Dos de ellos, la capa de eventos y la capa de red abstracta son implementadas por el middleware cósmico. La capa de eventos proporciona la API para la aplicación y se da cuenta de la abstracción de los canales de eventos y eventos. La red abstracta implementa clases de mensajes en tiempo real y adapta los requisitos de calidad a la red real subyacente. Un controlador de canales de eventos reside en cada nodo. Admite la interfaz de programación y proporciona las estructuras de datos necesarias para la comunicación basada en eventos. Cada vez que un objeto se suscribe a un canal o un editor anuncia un canal, el controlador de canales de eventos está involucrado. Inicia la unión del sujeto de los canales, que está representado por un identificador único independiente de la red a una dirección de la red abstracta subyacente para habilitar la comunicación [14]. El controlador de canales del evento luego coopera estrechamente con los respectivos manejadores de la capa de red abstracta para difundir eventos o recibir notificaciones de eventos. Cabe señalar que las propiedades de QoS de la capa de eventos en general dependen de lo que pueda proporcionar la capa de red abstracta. Por lo tanto, no siempre es posible, p.Admite canales de eventos en tiempo real duros porque la capa de red abstracta no puede proporcionar las garantías respectivas. En [13], describimos los protocolos y servicios de la capa de red abstracta, particularmente para el bus CAN. Como se puede ver en la Figura 4, la clase de mensaje en tiempo real (HRT) es compatible con un controlador dedicado que puede proporcionar la difusión de mensajes activados por el tiempo.36 Notificaciones de eventos Lista HRT-MSG SRT-MSG Queue NRT-MSG Queue HRT-MSG Calendario HRTC Handler S/NRTC La capa de red abstracta de control puede capacitar el búfer RX Buffer TX RX, TX, Error interrumpe las especificaciones del canal de eventos. Mensajes de la capa de evento Enviar mensajes Excepciones de notificación de excepción, notificaciones ECH: controlador de canales de eventos P u b l i s h a n n o u n c e s u b s c r i b e b i n d i n g p r o t o c o l c o n f i g.P R O T O C O L Notificaciones del evento de tiempo global HRT-MSG LIST SRT-MSG Cola NRT-MSG Queue HRT-MSG Calendario HRTC Handler S/NRTC Handler Resumen La capa de red puede colocar RX Buffer RX TX Buffer RX, TX, Error interrumpir el canal de eventos. Mensajes de la capa de evento Enviar mensajes Excepciones de notificación de excepción, notificaciones ECH: controlador de canales de eventos P u b l i s h a n n o u n c e s u b s c r i b e b i n d i n g p r o t o c o l c o n f i g.P R O T O C O L SERVICIO DE TIEMPO GLOBAL Figura 4: Capas de arquitectura de cósmico. El controlador HRT mantiene la lista de mensajes HRT, que contiene una entrada para cada mensaje HRT local que se enviará. La entrada contiene los parámetros para el mensaje, el estado de activación y la información de enlace. Los mensajes están programados en el bus de acuerdo con el calendario de mensajes HRT que comprende la hora de inicio precisa para cada intervalo de tiempo asignado para un mensaje. Las colas de mensajes en tiempo real suave ordenan mensajes salientes de acuerdo con sus plazos de transmisión derivados del intervalo de validez temporal. Si se excede la fecha límite de transmisión, el mensaje del evento se purga de la cola. La aplicación respectiva se notifica a través de la interfaz de notificación de excepción y puede tomar medidas como tratar de publicar el evento nuevamente o publicarlo en un canal de otra clase. Los mensajes de eventos entrantes se ordenan de acuerdo con su validez temporal. Si llega un mensaje de evento, se notifican las aplicaciones respectivas. Por el momento, se elimina un mensaje obsoleto de la cola y si la cola se queda sin espacio, el mensaje más antiguo se descarta. Sin embargo, hay otras políticas posibles según los atributos del evento y el espacio de memoria disponible. Los mensajes que no son en tiempo real se ordenan FIFO en un búfer circular de tamaño fijo.7.2 Estado de Cosmic El objetivo para desarrollar Cosmic era proporcionar una plataforma para integrar perfectamente componentes pequeños inteligentes en un sistema grande. Por lo tanto, Cosmic debe funcionar también en los pequeños dispositivos de restricción de recursos que se construyen alrededor de 16 bits o incluso microcontroladores de 8 bits. El middleware cósmico distribuido se ha implementado y probado en varias plataformas. Bajo RT-Linux, apoyamos los canales en tiempo real sobre el bus de lata como se describió anteriormente. La versión RTLinux se ejecuta en procesadores Pentium y actualmente se evalúa antes de que intentemos transferirla a un sensor o actuador inteligente. Para la interoperabilidad en un entorno WAN-of-CANS, solo proporcionamos canales no en tiempo real en este momento. Esta versión incluye una puerta de enlace entre el Canbus y una red TCP/IP. Nos permite usar una red inalámbrica 802.11 estándar. La versión no en tiempo real de Cosmic está disponible en Linux, RT-Linux y en las familias de microcontroladores C167 (Infineon) y 68HC908 (Motorola). Ambos microcontroladores tienen un controlador de lata integrado y, por lo tanto, no requieren componentes de hardware adicionales para la red. La huella de memoria de Cosmic es de aproximadamente 13 kbyte en un C167 y un poco más en el 68HC908 donde encaja en la memoria flash a bordo sin problemas. Debido a que solo se requieren unos pocos canales en un sensor de este tipo o componente de actuador, el requisito de RAM (que es un recurso escaso en muchos sistemas de chips individuales) para mantener las estructuras de datos dinámicas de un canal es bajo. El middleware cósmico hace que sea muy fácil incluir nuevos sensores inteligentes en un sistema existente. En particular, la aplicación que se ejecuta en un sensor inteligente para acondicionar y procesar los datos físicos sin procesar no debe tener en cuenta ningún detalle específico de red de bajo nivel. Interactúa sin problemas con otros componentes del sistema exclusivamente a través de canales de eventos. El ejemplo de demostración, descrito brevemente en el próximo capítulo, es utilizar una infraestructura distribuida de pequeños sensores inteligentes y actuadores que cooperan directamente a través de canales de eventos a través de redes heterogéneas.8. Un ejemplo ilustrativo, un ejemplo simple para muchas propiedades importantes del sistema propuesto que muestra la coordinación a través del entorno y los eventos difundidos sobre la red es la demostración de dos robots cooperantes representados en la Figura 5. Cada robot está equipado con sensores de distancia inteligentes, sensores de velocidad, sensores de aceleración y uno de los robots (la guía (KURT2) al frente (Figura 5)) tiene una cámara de seguimiento que permite seguir una línea blanca. Los robots forman un sistema WAN-of-CANS en el que sus latas locales están interconectadas a través de una red inalámbrica 802.11. Cosmic proporciona la capa de eventos para una interacción perfecta. El robot ciego (N.N.) está buscando en la guía al azar. Cada vez que el robot ciego detecta (por sus sensores de distancia frontal) un obstáculo, verifica si esta puede ser la guía. Para este propósito, se suscribe dinámicamente al canal de eventos que difunden eventos de distancia desde los sensores de distancia traseros de las guías y los compara con los eventos de distancia desde sus sensores frontales locales. Si la distancia es aproximadamente la misma, infiere que realmente está detrás de una guía. Ahora N.N.También se suscribe a los canales de eventos de la cámara de seguimiento y los sensores de velocidad 37 Figura 5: robots cooperantes.Para seguir la guía. La aplicación de demostración destaca las siguientes propiedades del sistema: 1. Interacción dinámica de robots que no se conoce de antemano. En principio, los dos robots desconocidos a priori pueden cooperar. Todo lo que los editores y suscriptores deben saber para interactuar dinámicamente en este entorno es el tema de la clase de eventos respectivas. Un problema será recibir solo los eventos del robot que está más cerca. Una identidad robot no ayuda mucho a resolver este problema. Más bien, la posición de la entidad de generación de eventos que se captura en los atributos respectivos se puede evaluar para filtrar el evento relevante fuera del flujo de eventos. Meier y Cahill [22] han propuesto un protocolo inalámbrico adecuado que utiliza proximidad a los eventos de filtro en el proyecto Cortex.2. Interacción a través del medio ambiente. La cooperación entre los robots se controla detectando la distancia entre los robots. Si la guía detecta que la distancia crece, se ralentiza. Respectivamente, si el robot ciego se acerca demasiado, reduce su velocidad. Los sensores de distancia locales producen eventos que se difunden a través de un canal de eventos de baja latencia y altamente predecible. El tiempo de reacción respectivo se puede calcular como función de la velocidad y la distancia de los robots y definir una fecha límite de difusión dinámica para los eventos. Por lo tanto, la interacción a través del entorno asegurará las propiedades de seguridad de la aplicación, es decir, el seguidor no se bloqueará en la guía y la guía no puede perder el seguidor. Además, los robots tienen suscripciones remotas a los eventos de distancia respectivos que se utilizan para verificarlo con las lecturas de sensores locales para validar que realmente siguen la guía que detectan con sus sensores locales. Debido a que puede haber latencias y omisiones más largas, este cheque ocasionalmente no será posible. La falta de disponibilidad de los eventos remotos disminuirá la calidad de la interacción y probablemente y ralentice los robots, pero no afectará las propiedades de seguridad.3. Detección cooperativa. El robot ciego se suscribe a los eventos de la cámara de seguimiento de la línea. Por lo tanto, puede ver a través del ojo de la guía. Debido a que sabe la distancia a la guía y la velocidad también, puede prever los movimientos necesarios. El sistema propuesto proporciona el marco arquitectónico para tal cooperación. El objeto sensible respectivo que controla la actuación del robot recibe como entrada la posición y la orientación de la línea blanca a rastrear. En el caso del robot guía, esta información se entrega directamente como un evento de cuerpo con una baja latencia y una alta confiabilidad sobre la red interna. Para el robot seguidor, la información también viene a través de un canal de eventos pero con diferentes atributos de calidad. Estos atributos de calidad se reflejan en la descripción del canal del evento. El objeto sensible que controla la actuación del seguidor es consciente del aumento de la latencia y una mayor probabilidad de omisión.9. Conclusión y trabajo futuro El documento aborda problemas de construir grandes sistemas distribuidos que interactúan con el entorno físico y se componen de una gran cantidad de componentes inteligentes. No podemos asumir que la arquitectura de red en dicho sistema es homogénea. Más bien, múltiples redes de borde se fusionan con una red de área amplia jerárquica y heterogénea. Conectan los pequeños sensores y actuadores que perciben el medio ambiente y proporcionan sensibilidad a la aplicación. Además, la movilidad y la implementación dinámica de componentes requieren la interacción dinámica sin esquemas fijos de direccionamiento y enrutamiento a priori conocidos. El trabajo presentado en el documento es una contribución hacia la interacción perfecta en un entorno que no debe estar restringido por obstáculos técnicos. Más bien debería ser posible controlar el flujo de información especificando explícitamente restricciones de difusión funcional y temporal. El documento presentó el modelo general de un objeto sensible para describir la composición, la encapsulación y la interacción en dicho entorno y desarrolló el equipo de arquitectura de eventos genéricos que integra la interacción a través del entorno y la red. Si bien las abstracciones apropiadas y los modelos de interacción pueden ocultar la heterogeneidad funcional de las redes, es imposible ocultar las diferencias de calidad. Por lo tanto, una de las principales preocupaciones es definir propiedades temporales en una infraestructura tan abierta. Se ha introducido la noción de un canal de eventos que permite especificar aspectos de calidad explícitamente. Se pueden verificar en la suscripción y definir un límite para la difusión de eventos. El middleware cósmico es un primer intento de poner en funcionamiento estos conceptos. Cosmic permite la interoperabilidad de pequeños componentes en múltiples límites de red y admite la definición de diferentes clases de canales de eventos en tiempo real. Hay muchas preguntas abiertas que surgieron de nuestro trabajo. Una dirección de la investigación futura será la inclusión de canales de comunicación del mundo real establecidos entre sensores y actuadores en el análisis temporal y el orden de tales eventos en una cadena de causa-efecto. Además, la provisión de detección de fallas de tiempo para la adaptación de las interacciones estará en el enfoque de nuestra investigación. Para reducir el tráfico de red y solo difundir esos eventos a los suscriptores en los que realmente están interesados y que tienen la oportunidad de llegar a tiempo, la encapsulación y los esquemas de alcance deben transformarse en las respectivas reglas de filtrado de niveles múltiples. Los atributos del evento que describen aspectos del contexto y las limitaciones temporales para la difusión se explotarán para este propósito. Finalmente, está destinado a integrar los resultados en el middleware cósmico para habilitar la evaluación experimental.38 10. Referencias [1] J. Bacon, K. Moody, J. Bates, R. Hayton, C. Ma, A. McNeil, O. Seidel y M. Spiteri. Soporte genérico para aplicaciones distribuidas. IEEE Computer, 33 (3): 68-76, 2000. [2] L. B. Becker, M. Gergeleit, S. Schemmer y E. Nett. Uso de una estrategia de programación flexible en tiempo real en una aplicación integrada distribuida. En Proc.de la novena Conferencia Internacional IEEE sobre tecnologías emergentes y automatización de fábrica (ETFA), Lisboa, Portugal, septiembre de 2003. [3] N. Carriero y D. Gelernter. Linda en contexto. Comunicaciones de la ACM, 32 (4): 444-458, abril de 1989. [4] A. Casimiro (ed.). Definición preliminar de la arquitectura del sistema de la corteza. Proyecto Cortex, IST-2000-26031, Entrezable D4, abril de 2002. [5] Anexo 1 del Proyecto Cortex 1, Descripción del trabajo. Informe técnico, Proyecto Cortex, IST-2000-26031, octubre de 2000. http://cortex.di.fc.ul.pt.[6] R. Cunningham y V. Cahill. Control de acceso medio del tiempo limitado para redes ad-hoc. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil (POMC02), Páginas 1-8, Toulouse, Francia, octubre de 2002. ACM Press.[7] P. T. Eugster, P. Felber, R. Guerraoui y A.-M.Kermarrec. Las muchas caras de publicar/suscribirse. Informe técnico DSC ID: 200104, EPFL, Lausana, Suiza, 2001. [8] T. F¨uhrer, B. M¨uller, W. Dieterle, F. Hartwich, R. Hugel y M.Walther. Comunicación desencadenada de tiempo en Can, 2000. http://www.can-cia.org/can/ttcan/fuehrer.pdf.[9] R. B. Gmbh. CAN ESPECIFICACIÓN Versión 2.0. Informe técnico, septiembre de 1991. [10] T. Harrison, D. Levine y D. Schmidt. El diseño y el rendimiento de un servicio de eventos Corba en tiempo real. En Actas de la Conferencia de 1997 sobre sistemas de programación orientados a objetos, idiomas y aplicaciones (OOPSLA), páginas 184-200, Atlanta, Georgia, EE. UU., 1997. ACM Press.[11] J. Hightower y G. Borriello. Sistemas de ubicación para computación ubicua. IEEE Computer, 34 (8): 57-66, agosto de 2001. [12] A. Hopper. La conferencia Clifford Paterson, 1999 Sentient Computing. Transacciones filosóficas de la Royal Society London, 358 (1773): 2349-2358, agosto de 2000. [13] J. Kaiser, C. Mitidieri, C. Brudna y C. Pereira. Cósmico: un middleware para la interacción basada en eventos en Can. En Proc.Conferencia IEEE 2003 sobre tecnologías emergentes y automatización de fábrica, Lisboa, Portugal, septiembre de 2003. [14] J. Kaiser y M. Mock. Implementación del modelo de editor/suscriptor en tiempo real en la red del área del controlador (CAN). En Actas del 2º Simposio Internacional sobre Computación distribuida en tiempo real orientada a objetos (Isorc99), Saint-Malo, Francia, mayo de 1999. [15] K. Kim, G. Jeon, S. Hong, T. Kim y S. Kim. Integrando las comunicaciones basadas en suscripción y orientadas a la conexión en el Corba integrado para el autobús CAN. En Actas del Simposio de tecnología y aplicación en tiempo real IEEE, mayo de 2000. [16] H. Kopetz y G. Gr¨unsteidl. TTP: un protocolo activado por el tiempo para sistemas en tiempo real tolerantes a fallas. Informe técnico TR-12-92, Institut Für Technische Informatik, Technische Universit¨at Wien, Treilstr.3/182/1, A-1040 Viena, Austria, 1992. [17] H. Kopetz, M. Holzmann y W. Elmenreich. Una interfaz de transductor inteligente universal: TTP/A. International Journal of Computer System, Science Engineering, 16 (2), marzo de 2001. [18] H. Kopetz y P. Ver´ıssimo. Conceptos en tiempo real y confiabilidad. En S. J. Mullender, editor, Sistemas distribuidos, 2ª edición, ACM-Press, Capítulo 16, páginas 411-446. Addison-Wesley, 1993. [19] S. Lankes, A. Jabs y T. Bemmerl. Integración de un modelo de comunicación orientado a la conexión basado en la lata en CORBA en tiempo real. En taller sobre sistemas en tiempo real paralelo y distribuido, Niza, Francia, abril de 2003. [20] Red de interconexión local: Revisión del paquete de especificaciones LIN 1.2. Informe técnico, noviembre de 2000. [21] M. Livani, J. Kaiser y W. Jia. Programación de comunicación en tiempo real dura y suave en la red del área del controlador. Control Engineering, 7 (12): 1515-1523, 1999. [22] R. Meier y V. Cahill. Steam: middleware basado en eventos para redes ad-hoc inalámbricas. En Actas del Taller Internacional sobre sistemas distribuidos basados en eventos (ICDCS/DEBS02), páginas 639-644, Viena, Austria, 2002. [23] E. Nett y S. Schemmer. Comunicación confiable en tiempo real en aplicaciones móviles cooperativas. Transacciones IEEE en computadoras, 52 (2): 166-180, febrero de 2003. [24] B. Oki, M. Pfluegl, A. Seigel y D. Skeen. El bus de información: una arquitectura para sistemas distribuidos extensibles. Revisión de sistemas operativos, 27 (5): 58-68, 1993. [25] O. M. G. (OMG). Corebaservices: Especificación de servicios de objetos comunes - Especificación del servicio de notificación, versión 1.0, 2000. [26] O. M. G. (OMG). Interfaz Smart Transducer, presentación inicial, junio de 2001. [27] P. Ver´ıssimo, V. Cahill, A. Casimiro, K. Cheverst, A. Friday y J. Kaiser. Cortex: hacia el apoyo a las entidades sensibles autónomas y cooperantes. En Actas de European Wireless 2002, Florencia, Italia, febrero de 2002. [28] P. Ver´ıssimo y A. Casimiro. El modelo y arquitectura base de computación oportuna. Transacciones en computadoras: número especial en sistemas asincrónicos en tiempo real, 51 (8): 916-930, agosto de 2002. [29] P. Ver´ıssimo y A. Casimiro. Soporte basado en eventos de objetos sensibles en tiempo real. En Actas del 8º Taller Internacional IEEE sobre sistemas confiables en tiempo real orientados a objetos, Guadalajara, México, enero de 2003. [30] P. Ver´ıssimo y L. Rodrigues. Sistemas distribuidos para arquitectos de sistemas. Kluwer Academic Publishers, 2001. 39