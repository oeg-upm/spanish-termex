Redes de contribución marginal: un esquema de representación compacta para juegos de coalición ∗ Samuel ieg † Departamento de informática de la Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Informática de la Ciencias de la Computación Stanford Stanford, CA 94305 Shoham@stanford.Edu Resumen. Presentamos un nuevoEnfoque para representar juegos de coalición basados en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en el tiempo lineal en el tamaño de la entrada. El vacío del núcleo se puede determinar en el tiempo exponencial solo en el ancho de árbol de una interpretación gráfica de nuestra representación. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial distribuida]: sistemas multiagentes;J.4 [Ciencias sociales y conductuales]: Economía;F.2 [Análisis de algoritmos y complejidad de problemas] Algoritmos de términos generales, Economía 1. Los agentes de introducción a menudo pueden beneficiarse coordinando sus acciones. Los juegos de coalición capturan estas oportunidades de coordinación modelando explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos de coalición asignan una recompensa a cada grupo de agentes en el juego. Esta recompensa está destinada a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas opciones de primitivas están en contraste con las de los juegos no cooperativos, de los cuales los agentes se modelan de forma independiente, y sus pagos dependen críticamente de las acciones elegidas por los otros agentes.1.1 Juegos de coalición y juegos de coalición de comercio electrónico han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al.Use juegos de coalición para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y los beneficios de descubrir sobre ellos. Los pagos a grupos de agentes son el número total de artículos distintos conocidos por sus miembros. Dada este juego de coalición, Kleinberg et al.Calcule el valor de la información privada de los agentes vale la pena para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la Sección 2). Estos valores se pueden usar para determinar cuánto debe recibir cada agente para participar en el sistema. Como otro ejemplo, considere la economía detrás de la formación de la cadena de suministro. El mayor uso de Internet como medio para realizar negocios ha disminuido los costos para que las empresas coordinen sus acciones y, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Suponga que cada fabricante compre sus materias primas de algún conjunto de proveedores y que los proveedores ofrecen un mayor descuento con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores más baratos, y facilitará la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto de cada proveedor compra cada coalición, podemos asignar pagos a las coaliciones dependiendo del descuento que reciba. El juego resultante se puede analizar utilizando la teoría de juegos de coalición, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coalición combinatoria, se ha estudiado previamente en [8].1.2 Criterios de evaluación para la representación del juego de coalición para capturar los juegos de coalición descritos anteriormente y realizar cálculos en ellos, primero debemos encontrar una representación para estos juegos. La solución Na¨ıve es enumerar los pagos a cada conjunto de agentes, por lo que requiere espacio 193 exponencial en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede exceder fácilmente cien;Este enfoque na¨ıve no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos de coalición. Creemos que la calidad de un esquema de representación debe evaluarse por cuatro criterios. Expresividad: la amplitud de la clase de juegos de coalición cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debe ser completamente expresiva, es decir, debe ser capaz de representar cualquier juego de coalición, usar el menor espacio posible, tener algoritmos eficientes para el cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos de coalición es O (2n), no todos los juegos pueden representarse de manera concisa utilizando un solo esquema debido a limitaciones teóricas de la información. Para cualquier clase de juegos, uno puede desarrollar un esquema de representación adaptado y más compacto que un esquema general. Por ejemplo, para el juego del sistema de recomendación, una representación altamente compacta sería una que simplemente establece qué agentes conocen qué productos, y les deja los algoritmos que operan en la representación para calcular los valores de las coaliciones adecuadamente. Sin embargo, para algunos problemas, puede no haber algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que lo acompañan, la representación será útil como una herramienta de creación de prototipos para estudiar nuevas situaciones económicas.1.3 Trabajo previo La cuestión de la representación del juego coalición solo se ha explorado escasamente en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se centraron en la complejidad de diferentes conceptos de solución en juegos de coalición definidos en gráficos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm analizaron el problema de determinar el vacío del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para tales juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo se extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Daremos una revisión más detallada de estos documentos en la Sección 2.2 después de cubrir los antecedentes técnicos.1.4 Resumen de nuestras contribuciones • Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala según la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.• Desarrollamos un algoritmo para calcular el valor de Shapley de los juegos de coalición bajo esta representación que se ejecuta en el tiempo lineal en el tamaño de la entrada.• Bajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pago está en el núcleo y el vacío del núcleo en el tiempo exponencial solo en el ancho de árbol del gráfico.2. Preliminares En esta sección, revisaremos brevemente los conceptos básicos de la teoría del juego de coalición y sus dos conceptos de solución principales, el valor de Shapley y el núcleo.1 También revisaremos trabajos anteriores sobre la representación del juego de coalición con más detalle. A lo largo de este artículo, asumiremos que la recompensa a un grupo de agentes se puede distribuir libremente entre sus miembros. Esta suposición a menudo se conoce como la suposición de utilidad transferible.2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible por el par n, v, donde • n es el conjunto de agentes;y • V: 2n → R es una función que mapea a cada grupo de agentes s ⊆ n a una recompensa de valor real. Esta representación se conoce como la forma característica. Como hay exponencialmente muchos subconjuntos, tomará espacio exponencial en el número de agentes para describir un juego de coalición. Un resultado en un juego de coalición especifica los servicios públicos que reciben los agentes. Un concepto de solución asigna a cada juego de coalición un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la Gran Coalición (es decir, N). La División de Recompensa al Agente I es la contribución marginal promedio del agente I sobre todas las permutaciones posibles de los agentes. Formalmente, deje que φi (v) denote el valor de Shapley de I bajo la función característica V, luego2 φi (v) = s⊂n s!(N - S - 1)!¡norte!(V (S ∪ {i}) - V (s)) (1) El valor de Shapley es un concepto de solución que satisface muchas propiedades agradables, y se ha estudiado ampliamente en la literatura económica y teórica del juego. Tiene una caracterización axiomática muy útil. Eficiencia (ef) Se distribuye un total de V (n) a los agentes, es decir, i∈N φi (v) = V (n). Simetría (SYM) si los agentes I y J son intercambiables, entonces φi (v) = φJ (v).1 Los materiales y la terminología se basan en los libros de texto de Mas-Colell et al.[9] y Osborne y Rubinstein [11].2 Como conveniencia de notación, utilizaremos la letra de caso inferior para representar la cardinalidad de un conjunto denotado por la letra de caso superior correspondiente.194 Dummy (DUM) Si el agente I es un jugador ficticio, es decir, su contribución marginal a todos los grupos s son iguales, φi (v) = V ({i}). Aditividad (agregar) para cualquier dos juegos de coalición V y W definidos sobre el mismo conjunto de agentes n, φi (v + w) = φi (v) + φi (w) para todos los i ∈ N, donde el juego v + w esdefinido como (v + w) (s) = v (s) + w (s) para todos s ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra prueba de corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación enSección 4. El núcleo es otro concepto de solución importante para los juegos de coalición. Es un concepto de solución descriptivo que se centra en los resultados que son estables. La estabilidad bajo núcleo significa que ningún conjunto de jugadores puede desviarse conjuntamente para mejorar sus pagos. Formalmente, deje que x (s) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀s ⊆ n x (s) ≥ v (s) (2) el núcleo fue uno de los primeros conceptos de solución propuestos para los juegos de coalición, y se había estudiado en detalle. Una pregunta importante para un juego de coalición dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación con la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe satisfacer la propiedad de la equilibrio, definida de la siguiente manera. Deje 1s ∈ Rn denota el vector característico de s dado por (1s) i = 1 si i ∈ S 0 de lo contrario, de lo contrario (λs) S⊆n sea un conjunto de pesos de modo que cada λs esté en el rango entre 0 y 1. Este conjunto de pesos, (λs) s⊆n, es una colección equilibrada si para todos los i ∈ N, s⊆n λs (1s) i = 1 un juego está equilibrado si para todas las colecciones equilibradas de pesos, s⊆n λsv (S) ≤ V (n) (3) Por el teorema de Bondereva-Shapley, el núcleo de un juego de coalición no está vacío si y solo si el juego está equilibrado. Por lo tanto, podemos usar la programación lineal para determinar si el núcleo de un juego está vacío.Maximice λ∈R2n S⊆n λSV (s) sujeto a S⊆n λs1s = 1 ∀i ∈ N λs ≥ 0 ∀s ⊆ n (4) Si el valor óptimo de (4) es mayor que el valor de la Gran Coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en el número de jugadores en el juego y, por lo tanto, un algoritmo que opera directamente en este programa sería inviable en la práctica. En la Sección 5.4, describiremos un algoritmo que responde la cuestión del vacío del núcleo que funciona en el dual de este programa.2.2 Trabajo previo revisado Deng y Papadimitriou analizó la complejidad de varios conceptos de soluciones en juegos de coalición jugados en gráficos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del gráfico, y el valor de un conjunto de agentes s es la suma de los pesos de los bordes abarcados por ellos. Observe que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O (N2). Sin embargo, esta representación no es general;No podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego mayoritario, donde un grupo de agentes tendrá valor de 1 si y solo si s> n/2. Por otro lado, hay un algoritmo eficiente para calcular el valor de Shapley del juego, y para determinar si el núcleo está vacío bajo la restricción de pesos de borde positivo. Sin embargo, en el caso sin restricciones, determinar si el núcleo no está vacío es COMPLETO. Conitzer y Sandholm en [2] consideraron juegos de coalición que son superaditivos. Describieron un esquema de representación conciso que solo establece el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes s, v (s) = max {t1, t2, ..., tn} ∈π i v (ti) donde π es el conjunto de todas las particiones posibles deS. El valor V (s) solo se especifica explícitamente para S si V (S) es mayor que todos los particiones de S distintos de la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos de coalición que no puede representar. Por ejemplo, no podrá representar ningún juego con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego unitario, donde v (s) = 1 siempre que s = ∅. Según esta representación, los autores mostraron que determinar si el núcleo no está vacío es COMPLETO. De hecho, incluso determinar el valor de un grupo de agentes es NP complete. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego de coalición en una serie de subjuegos cuya suma se suma al juego original [3]. Los pagos en estos subgamas están representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego determinado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores mostraron que la complejidad es lineal en la descripción de entrada;En particular, si el subjuego más grande (medido por el número de agentes) es de tamaño n y el número de subgamas es M, entonces su algoritmo se ejecuta en el tiempo O (m2n), donde el tamaño de entrada también será O (m2n). Por otro lado, el problema de determinar si un determinado resultado está en el núcleo es COMPLETO.3. Nets de contribución marginal En esta sección, describiremos el esquema de representación de redes de contribución marginal. Mostraremos que la idea es flexible, y podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, mostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4].3.1 Reglas y MarginalContributionNets La idea básica detrás de las redes de contribución marginal (NET MC) es representar juegos de coalición utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica 195: Patrón → Valor Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de la misma. El valor de un grupo de agentes se define como la suma sobre los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v ({a}) = 0, v ({b}) = 2, y v ({a, b}) = =5 + 2 = 7. MC-NET es un esquema de representación muy flexible, y se puede extender de diferentes maneras. Una forma simple de extenderlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que usaremos durante el resto del papel es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como sustituibilidad o valores predeterminados. Formalmente, expresamos tales patrones por {P1 ∧ P2 ∧...∧ PM ∧ ¬n1 ∧ ¬n2 ∧...∧ ¬nn} que tiene la semántica de que dicha regla se aplicará a un grupo s solo si {pi} m i = 1 ∈ S y {nj} n j = 1 /∈ S. llamaremos {pi} m i = 1 en elPatrón arriba de los literales positivos, y {nj} n j = 1 los literales negativos. Tenga en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón y, por lo tanto, V (∅) puede no ser cero en presencia de literales negativos. Para demostrar el aumento de la concisión de la representación, considere el juego unitario descrito en la Sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor −1 para que cada par de agentes contrarreste el doble conteo, unRegla de valor 1 para cada triplete de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, utilizando literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representativos pueden ser exponenciales en el número de agentes. Dado un juego representado como una red MC, podemos interpretar el conjunto de reglas que componen el juego como un gráfico. Llamamos a este gráfico el gráfico del agente. Los nodos en el gráfico representarán a los agentes en el juego, y para cada regla en el MCNET, conectamos todos los agentes en la regla juntos y asignamos un valor a la camarilla formada por el conjunto de agentes. Observe que para acomodar literales negativos, necesitaremos anotar la camarilla adecuadamente. Esta visión alternativa de las redes MC será útil en nuestro algoritmo para la membresía de núcleo en la Sección 5. Nos gustaría terminar nuestra discusión sobre el esquema de representación mencionando una compensación entre la expresividad de los patrones y el espacio requerido para representarlos. Para representar un juego de coalición en forma característica, uno necesitaría especificar todos los valores 2N - 1. No hay sobrecarga además de eso ya que hay un orden natural de los grupos. Sin embargo, para las redes MC, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de manera compacta, pueden terminar abrumando los ahorros de tener menos valores para especificar. El espacio requerido para los patrones también conduce a una compensación entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber una estructura suficiente en el problema de modo que nuestra representación logre un ahorro neto sobre la forma característica.3.2 Ejemplo: Juego de recomendación Como ejemplo, usaremos MC-NET para representar el juego de recomendación discutido en la introducción. Para cada producto, como el beneficio de saber sobre el producto contará solo una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto puede ser capturado por un juego de unidad a escala. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay agentes de Ni, denotados por {xj i}, que saben sobre el producto, el juego para el producto puedo ser representado como las siguientes reglas: {x1 i} →vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni - 1 i ∧ · · · ∧ ¬x1 I} → VI Todo el juego se puede construir a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O (Mn ∗), donde M es el número de productos en el sistema, y n ∗ es el número máximo de agentes que conocen el mismo producto.3.3 Poder de representación discutiremos la expresividad y la concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación totalmente expresivo. Prueba. Considere un juego de coalición arbitrario N, V en la representación de forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos de singleton y construyendo el conjunto de reglas. Para cualquier conjunto de singleton {i}, creamos una regla {i} → V (i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v ({i, j}) - v ({i}) - v ({j}. Podemos continuar aumentando reglas de manera similar al principio de exclusión-exclusión de inclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Utilizando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación de múltiples problemas de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal usan como máximo un factor lineal (en el número de agentes) más espacio que la representación de múltiples problemas para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subgamas, que se representan en forma característica en [3], con un conjunto de reglas.196 Luego construimos el Grand Game incluyendo todas las reglas de los subgamas. Tenga en cuenta que nuestra representación puede requerir un espacio más grande por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos que el número exponencial de reglas para cada subjuego, dependiendo de la estructura de estos subgamas y, por lo tanto, puede ser más conciso que la representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representar bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación de múltiples problemas para ciertos juegos. Prueba. Considere un juego de unidades sobre todos los agentes N. Como se explica en 3.1, este juego puede representarse en espacio lineal usando redes MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subgamas más pequeños, requerirá que el espacio O (2n) represente este juego bajo la representación multifonse. Bajo la interpretación del gráfico del agente de las redes MC, podemos ver que MC-Nets es una generalización de la representación gráfica en [4], a saber, desde gráficos ponderados hasta hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, g, para cada borde (i, j) con peso wij en el gráfico, creamos una regla {i, j} → wij. Claramente, esto toma exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. Calculando el valor de Shapley dado una red MC, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Teniendo en cuenta cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, resumimos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de suma calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de MC-Nets, V (S) se define como la suma sobre los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, por el axioma (agregado) discutidoEn la Sección 2, el valor de Shapley del juego creado a partir de agregar todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta restante es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para las reglas que solo tienen literales positivos, el valor de Shapley de los agentes es V/M, donde V es el valor de la regla y M es el número de agentes en la regla. Esta es una consecuencia directa del (sym) axioma del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para las reglas que tienen literales positivos y negativos, podemos considerar los literales positivos y negativos por separado. Para un literario positivo dado dado, la regla se aplicará solo si ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, deje que φi denote el valor de Shapley de I, p denota la cardinalidad del conjunto positivo, y n denota la cardinalidad del conjunto negativo, luego φi = (p - 1)! N!(P + N)!V = V p p+n n para un literal negativo J, J será responsable de cancelar la aplicación de la regla si todos los literales positivos vienen antes de los literales negativos en el pedido, y J es el primero entre los literales negativos. Por lo tanto, φJ = P!(N - 1)!(P + N)!(−v) = −v n p+n p por el axioma (sym), todos los literales positivos tendrán el valor de φi y todos los literales negativos tendrán el valor de φJ. Tenga en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperar ya que estas reglas contribuyen 0 a la Gran Coalición. El hecho de que estas reglas no tengan ningún efecto en la Gran Coalición puede parecer extraña al principio. Pero esto se debe a que la presencia de tales reglas es definir los valores de las coaliciones más pequeños que la Gran Coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en eltamaño de la entrada.5. Responder las preguntas relacionadas con el núcleo Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos centraremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego de coalición y un vector de pago X, determine si X está en el núcleo. Definición 2. (núcleo-no vacío) Dado un juego de coalición, determine si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son completos y conp-hard, respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de los árboles, ya que se usará ampliamente en nuestro algoritmo para la membresía de núcleo. A continuación, presentaremos el algoritmo para la membresía del núcleo, y mostraremos que el algoritmo se ejecuta en tiempo polinomial para gráficos de ancho de árbol limitado. Terminamos extendiendo este algoritmo para responder la pregunta de la vacío de Corenon en el tiempo polinomial para los gráficos de ancho de árbol delimitado.5.1 Complejidad computacional La dureza de la membresía del núcleo y la no prueba del núcleo se deriva directamente de los resultados de la dureza de los juegos sobre gráficos ponderados en [4].197 Proposición 6. La membresía de núcleo para juegos representados como redes de contribución marginal es COMPLETA. Prueba. La membresía central en MC-Nets está en la clase de Conp, ya que cualquier conjunto de agentes de los cuales V (S)> X (s) servirá como un certificado para mostrar que X no pertenece al núcleo. En cuanto a su dureza, dada cualquier instancia de membership coreM para un juego en forma gráfica de [4], podemos codificar el juego en exactamente el mismo espacio usando MC-Net debido a la Propuesta 4. Dado que la membresía de núcleo para juegos en forma gráfica es completa, la membresía de núcleo en las redes MC es costa. Proposición 7. El núcleo no vacío para los juegos representados como redes de contribución marginal es consecutiva. Prueba. El mismo argumento para la dureza entre los juegos en las redes gráficas de FRM y MC es válida para el problema de Corenon-Extiness. No sabemos de un certificado para mostrar que el núcleo de núcleo está en la clase de Conp a partir de ahora. Tenga en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou mostraron la satisfacción del núcleo de núcleo a través de una caracterización combinatoria, a saber, que el núcleo no está vacío si y solo si no hay un corte negativo en el gráfico. En las redes MC, sin embargo, no es necesario que haya un hipercut negativo en el gráfico para que el núcleo esté vacío, como lo demuestra el siguiente juego (n = {1, 2, 3, 4}): v (s) =   1 si s = {1, 2, 3, 4} 3/4 si s = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0de lo contrario (5) aplicando el teorema de Bondereva-Shapley, si dejamos λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado y, por lo tanto, el núcleo está vacío. Por otro lado, este juego se puede representar con Mc-Nets de la siguiente manera (Peso en hiperedges): W ({1, 2}) = W ({1, 3}) = W ({1, 4}) = 3/4 W ({1, 2, 3}) = W ({1, 2, 4}) = W ({1, 3, 4}) = −6/4 W ({2, 3, 4}) =3/4 W ({1, 2, 3, 4}) = 10/4 No importa cómo se divide el conjunto, la suma sobre los pesos de las hiperedges en el corte siempre es no negativa. Para superar la dureza computacional de estos problemas, hemos desarrollado algoritmos que se basan en técnicas de descomposición de árboles. Para la membresía del núcleo, nuestro algoritmo se ejecuta en el tiempo exponencial solo en el ancho de árbol del gráfico del agente. Por lo tanto, para gráficos de ancho de árbol pequeño, como los árboles, tenemos una solución manejable para determinar si un vector de pago está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal que está relacionado con el núcleo no vacía utilizando el método elipsoide, podemos obtener un algoritmo de tiempo polinómico paraNúcleo no vacía para gráficos de ancho de árbol limitado.5.2 Revisión de la descomposición del árbol Como nuestro algoritmo para la membresía del núcleo depende en gran medida de la descomposición del árbol, primero revisaremos brevemente las ideas principales en la descomposición de los árboles y el ancho de árboles.3 Definición 3. Una descomposición del árbol de un gráfico g = (v, e) es un par (x, t), donde t = (i, f) es un árbol y x = {xi |i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de t, de modo que • i∈I xi = V;• Para todos los bordes (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi;y • (ejecutar la propiedad de intersección) para todos los i, j, k ∈ I: si J está en el camino de i a k en t, entonces xi ∩ xk ⊆ xj. El ancho de árbol de la descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en x, menos uno. El ancho de árbol de un gráfico se define como el ancho de árbol mínimo sobre todas las descomposiciones de los árboles del gráfico. Dada una descomposición del árbol, podemos convertirlo en una buena descomposición del árbol del mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol es buena si T está enraizado y tiene cuatro tipos de nodos: los nodos de hoja I son hojas de t con | xi |= 1. Introducir nodos Tengo un hijo J tal que xi = xj ∪ {V} de algunos v ∈ V. Olvídese de nodos Tengo un hijo j tal que xi = xj \ {v} para algunos v ∈ Xj. Nodos unidos tengo dos hijos j y k con xi = xj = xk. Un ejemplo de una descomposición del árbol (parcial) agradable junto con una clasificación de los diferentes tipos de nodos se encuentra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos y nodos en el gráfico de agentes como agentes.5.3 Algoritmo para membresía central Nuestro algoritmo para la membresía central toma como una entrada una buena descomposición del árbol T del gráfico de agente y un vector de pago x. Por definición, si X pertenece al núcleo, entonces para todos los grupos S ⊆ N, X (S) ≥ V (S). Por lo tanto, la diferencia x (s) −v (s) mide cuán cerca está el grupo S de violar la condición central. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, E (S), se define como X (S) - V (S). Un enfoque de fuerza bruta para determinar si un vector de pago pertenece al núcleo tendrá que verificar que los excesos de todos los grupos no sean negativos. Sin embargo, este enfoque ignora la estructura en el gráfico de agentes que permitirá que un algoritmo inferirá que ciertos grupos tienen excesos no negativos debido a 3, esto se basa en gran medida en los materiales de un documento de encuesta de Bodlaender [1].198 i J K l nm introducir nodo: xj = {1, 4} xk = {1, 4} Olvidar nodo: xl = {1, 4} introducir nodo: xm = {1, 2, 4} xn = {4} nodo de hoja:Nodo de unión: xi = {1, 3, 4} Nodo de unión: Figura 1: Ejemplo de un árbol (parcial) agradable Descomposición de los excesos calculados en otra parte del gráfico. La descomposición del árbol es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos r ⊆ U no son negativos, y nos gustaría verificar si la adición de un agente I al conjunto U creará un grupo con exceso negativo. Una solución na¨ıve será calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (r ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera e (r ∪ {i}) = e (r) + xi - v (c) (6) donde c es el corte entreR e I, y V (c) es la suma de los pesos de los bordes en el corte. Sin embargo, supongamos que desde la descomposición del árbol, sabemos que solo estoy conectado a un subconjunto de U, digamos S, que llamaremos la entrada establecida en U. Idealmente, debido a que no comparto ningún bordes con miembros de ¯U = (u \ s), esperamos que un algoritmo pueda aprovechar esta estructura verificando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi −v (c)) en la ecuación de actualización de (6) no depende de ¯u. Sin embargo, no podemos simplemente ignorar ¯u ya que los miembros de ¯u aún pueden influir en los excesos de los grupos que incluyen el agente I a través del grupo S. específicamente, si existe un grupo t ⊃ s tal que e (t) <e (s),Entonces, incluso cuando E (S ∪ {i}) tiene un exceso no negativo, E (t ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse drenado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición en relación con una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todos T: S ⊆ T ⊆ U. Denotamos este valor por R (S, U). Nos referiremos al Grupo T que tiene el exceso mínimo como Arg R (S, U). También te llamaremos el conjunto limitante de la reserva y el conjunto base de la reserva. Nuestro algoritmo funciona al realizar un seguimiento de las reservas de todos los subconjuntos no vacíos que pueden formar los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo I, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto las de (xi (xi\S). Los agentes en (xi \ s) están excluidos para garantizar que S sea un conjunto de entrada. Específicamente, S es la entrada establecida en ((ti \ xi) ∪ s). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente M y un conjunto S en el nodo I ahora se refiere al corte entre el agente m, set s y establecido ¬ (xi \ s), y su valor debe calcularse en consecuencia. Además, cuando se introduce un agente M en un grupo en un nodo introducido, también necesitaremos considerar el cambio en las reservas de grupos que no incluyen M debido a un posible recorte que involucra ¬M y el grupo. Como ejemplo de los valores de reserva que realizamos un seguimiento en un nodo de árbol, considere el nodo I del árbol en la Figura 1. En el nodo I, realizaremos un seguimiento de lo siguiente: R ({1}, {1, 2, ...}) r ({3}, {2, 3, ...}) r ({4},{2, 4, ...}) r ({1, 3}, {1, 2, 3, ...}) r ({1, 4}, {1, 2, 4, ..})r ({3, 4}, {2, 3, 4, ...}) r ({1, 3, 4}, {1, 2, 3, 4, ...Para los agentes enraizados en el nodo m. Para uso de notacional, usaremos RI (s) para denotar R (S, U) en el nodo I donde U es el conjunto de agentes en el subárbol enraizado en el nodo I excluyendo los agentes en (xi \S). A veces nos referimos a estos valores como los valores R de un nodo. Los detalles de los cálculos de valor R están en el algoritmo 1. Para determinar si el vector de pago X está en el núcleo, durante el cálculo del valor R en cada nodo, podemos verificar si todos los valores R no son negativos. Si esto es así para todos los nodos en el árbol, el vector de pago X está en el núcleo. La exactitud del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pago X no está en el núcleo si y solo si los valores R en algún nodo I para algunos grupos S son negativos. Prueba.(⇐) Si la reserva en algún nodo I para algunos grupos es negativo, entonces existe una coalición t para la cual E (t) = x (t) - v (t) <0, por lo tanto, x no está en el núcleo.(⇒) Suponga que x no está en el núcleo, entonces existe algunos grupos r ∗ de modo que E (r ∗) <0. Deje que Xroot sea el conjunto de nodos en la raíz. Considere cualquier conjunto S ∈ Xroot, Rroot (s) tendrá el conjunto base de S y el conjunto limitante de ((n \ xroot) ∪ s). La unión sobre todos estos rangos incluye todos los conjuntos u para los cuales u ∩ xroot = ∅. Por lo tanto, si R ∗ no es disjunto de XROOT, el valor R para algún grupo en la raíz es negativo. Si r ∗ es disjunto de u, considere el bosque {ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot.199 Algoritmo 1 subproceduras para el nodo de hoja de membresía de membresía (i) 1: RI (xi) ← E (xi) Introducción (i) 2: J ← Child of I 3: M ← Xi \ xj {el nodo introducido} 4: Para todos S ⊆ XJ, S = ∅ Do 5: C ← Todas las hiperedges en el corte de M, S y ¬ (xi \ s) 6: Ri (S ∪ {x}) ← Rj (S) + XM -V (c) 7: C ← Todas las hiperedges en el corte de ¬m, s y ¬ (xi \ s) 8: ri (s) ← rj (s) - v (c) 9: final para 10: r (r (r ({M}) ← E ({M}) Nodo olvidado (i) 11: J ← Child of I 12: M ← Xj \ xi {el nodo olvidado} 13: para todos s ⊆ xi, s = ∅ do 14:ri (s) = min (rj (s), rj (s ∪ {m})) 15: final para nodo unido (i) 16: {j, k} ← {izquierda, derecha} hijo de i 17: paraTodos S ⊆ xi, s = ∅ do 18: ri (s) ← rj (s) + rk (s) - e (s) 19: finalizar por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles son desunidas. Por lo tanto, si el conjunto r ∗ = i si para algunos si ∈ Ti, e (r ∗) = i e (si) <0 implica algunos grupos s ∗ i también tiene un exceso negativo. Por lo tanto, solo necesitamos verificar los valores R de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos de hoja de la descomposición del árbol original, por ejemplo, para el agente i. Si r ∗ = {i}, entonces r ({i}) = e ({i}) <0. Por lo tanto, por inducción, si E (R ∗) <0, algunos se reservan en algún nodo sería negativo. Luego explicaremos la intuición detrás de la corrección de los cálculos para los valores R en los nodos de los árboles. Se puede encontrar una prueba detallada de corrección de estos cálculos en el apéndice en Lemmas 1 y 2. Proposición 9. El procedimiento en el algoritmo 1 calcula correctamente los valores R en cada uno de los nodos de los árboles. Prueba.(Sketch) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árboles en una buena descomposición de árboles. Nodos de hoja (i) El único valor de reserva a calcular es RI (XI), que es igual a R (Xi, Xi), y por lo tanto es solo el exceso del Grupo XI. Olvídese de los nodos (i con el niño J) Sea M el nodo olvidado. Para cualquier subconjunto S ⊆ xi, se deben elegir argumentos entre los grupos de S y S ∪ {M}, y por lo tanto elegimos entre los dos de los dos de los valores R en el nodo j. Introducir nodos (i con el niño J) Sea M el nodo introducido. Para cualquier subconjunto t ⊆ xi que incluya m, déjen s denote (t \ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren a M y agentes del subárbol enraizado en el nodo I, excepto aquellos que involucran M y agentes en XI. Como el conjunto base y el conjunto limitante de los valores R del nodo J y el nodo I difieren en {M}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto limitante del nodo I, el exceso del grupo Vdifieren en una cantidad constante del grupo correspondiente (v \ {m}) en el nodo j. Por lo tanto, el conjunto arg ri (t) es igual al conjunto arg rj (s) ∪ {m}, y ri (t) = rj (s) + xm - v (corte), donde v (cortado) es el valor de laReglas en el corte entre M y S. Para cualquier subconjunto s ⊂ xi que no incluya M, debemos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, la recompensa XM no contribuirá al Grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumenta anteriormente, podemos mostrar que RI (S) = RJ (S) - V (CUT). Unirse nodos (I con el niño izquierdo J y el niño derecho K) para cualquier conjunto S ⊆ xi, considere los valores R de ese conjunto en J y K.Si arg rj (s) o arg rk (s) incluyen agentes que no están en S, entonces argrj (s) y argrk (s) serán desarticulados entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer argumentos en tres conjuntos, (arg rj (s) \ s) a la izquierda, s en el medio y ((s) \ s) a la derecha. Los RJ (s) de reserva cubrirán los excesos de la izquierda y en el medio, mientras que la (s) RK (s) de reserva cubrirán los de la derecha y en el medio, por lo que los excesos en el medio están dobles. Ajustamos la doble conteo restando los excesos en el medio desde la suma de las dos reservas RJ (s) y RK (s). Finalmente, tenga en cuenta que cada paso en el cálculo de los rValues de cada nodo I toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el ancho de árbol del gráfico.5.4 Algoritmo para la no expulsión del núcleo Podemos extender el algoritmo para la membresía del núcleo en un algoritmo para el núcleo-no-vacía. Como se describe en la Sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el doble del programa tiene solo n variables, y se puede escribir de la siguienteFuerte dualidad, el valor óptimo de (7) es igual al valor óptimo de (4), el programa Primal descrito en la Sección 2. Por lo tanto, por el teorema de Bondereva-Shapley, si el valor óptimo de (7) es mayor que V (N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método elipsoide con la membresía del núcleo como un oráculo de separación, es decir, un procedimiento para devolver una restricción que se viola. Tenga en cuenta que una extensión simple al algoritmo de membresía central nos permitirá realizar un seguimiento del conjunto T para el cual E (t) <0 durante el cálculo de los valores R, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, el núcleo-no vacío puede ejecutarse en el tiempo polinomio en el tiempo de ejecución de la membresía del núcleo, que a su vez se ejecuta en 200 tiempo exponencial solo en el ancho de árbol del gráfico. Tenga en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo.6. Observaciones finales Hemos desarrollado un esquema de representación completamente expresivo para juegos de coalición de los cuales el tamaño depende de la complejidad de las interacciones entre los agentes. Nuestro enfoque en la representación general está en contraste con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la membresía de núcleo para MC-NET es COMPLETO, hemos desarrollado un algoritmo para la membresía coreM que se ejecuta en el tiempo exponencial solo en el ancho de árbol del gráfico del agente. También hemos extendido el algoritmo para resolver el núcleo-no vacía. Aparte del algoritmo para el núcleo-no-vacía en [4] bajo la restricción de pesos de borde no negativos, y que en [2] para juegos superaditivos cuando se da el valor de la Gran Coalición, no tenemos conocimiento de ninguna explícitaDescripción de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con una serie de áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRF) de la comunidad de Nets Bayes. Ambos abordan el tema de la concisión de la representación mediante el uso de la estructura combinatoria de los hipergrafos ponderados. De hecho, Kearns et al.Primero aplique esta idea a la teoría de los juegos mediante la introducción de un esquema de representación derivado de Bayes Net para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en los juegos de coalición están estrechamente relacionados con el problema de expresar valoraciones en las subastas combinatorias [5, 10]. El lenguaje OR-Bid, por ejemplo, está fuertemente relacionado con la superadditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de la expresión booleana [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podemos desarrollar representaciones y algoritmos más eficientes para los juegos de coalición. Finalmente, nos gustaría terminar con algunas ideas para extender el trabajo en este documento. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes de Bayes a modelos relacionales probabilísticos. El concepto de simetría prevalece en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de desagradables representaciones asimétricas de juegos simétricos en nuestra representación. A lo largo de la línea de explotación de simetría, como los agentes dentro de la misma clase son simétricos con respecto a los demás, podemos extender la idea anterior permitiendo una descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los retornos decrecientes marginales (MDRS). Sin el uso de funciones, el espacio necesario para describir las MDR entre las N agentes en las redes MC es O (N). Con el uso de funciones, el espacio requerido puede reducirse a O (1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen ciertas reglas no se pueden aplicar simultáneamente. Esto es útil en situaciones en las que un cierto agente representa un tipo de recurso agotable y, por lo tanto, las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente I en el sistema significa carbón, podemos usarlo como combustible para una planta de energía o como entrada a una fábrica de acero para hacer acero, pero no para ambos al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de las aplicaciones de diferentes reglas. La semántica aumentada puede simplificar la representación especificando cuándo no se pueden aplicar reglas juntas.7. Reconocimiento Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por sus fructíferas discusiones, y a los revisores anónimos por sus útiles comentarios en el documento.8. Referencias [1] H. L. Bodlaender. Valor de árboles: técnicas y resultados algorítmicos. En Proc.22 Symp.Sobre la Fundación Matemática de las Ciencias de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer y T. Sandholm. Complejidad de determinar la no vacuna del núcleo. En Proc.18º int. Conf.Sobre inteligencia artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Computar valores de Shapley, manipular esquemas de división de valor y verificar la membresía central en dominios de múltiples problemas. En Proc.19 nat. Conf.Sobre inteligencia artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación Res., 19: 257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown e Y. Shoham. Domestica la complejidad computacional de las subastas combinatorias: enfoques óptimos y aproximados. En Proc.16º int. Conf.sobre inteligencia artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para la teoría de juegos. En Proc.17º conf.Sobre la incertidumbre en la inteligencia artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc.8º conf.Sobre los aspectos teóricos de la racionalidad y el conocimiento, las páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de la coalición combinatoria y la división de pago en un mercado electrónico. Informe técnico, Insitute de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Licitación y asignación en subastas combinatorias. En Proc.2º ACM Conf.en el comercio electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de teoría de juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987. 201 Apéndice mostraremos formalmente la corrección del cálculo del valor R en el Algoritmo 1 de nodos introducidos y nodos unidos. Lema 1. El procedimiento para calcular los valores R de los nodos introducidos en el algoritmo 1 es correcto. Prueba. Deje que el nodo M sea el agente recién introducido en i. Deje que denotes el conjunto de agentes en el subárbol enraizado en i. Según la propiedad de intersección en ejecución, todas las interacciones (las hiperedges) entre M y U deben estar en el nodo i. Para todos los s ⊆ xi: m ∈ S, deje r denote (u \ xi) ∪ s), y q denote (r \ {m}).ri (s) = r (s, r) = min t: s⊆t ⊆r e (t) = min t: s⊆t ⊆r x (t) - v (t) = min t: s⊆t ⊆R x (t \ {m}) + xm - v (t \ {m}) - v (CUT) = min t: s \ {m} ⊆t ⊆q e (t) + xm - v (Cut) =RJ (S) + XM - V (CUT) El argumento para los conjuntos S ⊆ xi: m /∈ S es simétrico excepto que XM no contribuirá a la reserva debido a la ausencia de m.Lema 2. El procedimiento para calcular los valores R de los nodos de unión en el algoritmo 1 es correcto. Prueba. Considere cualquier conjunto S ⊆ xi. Deje que UJ denote el subárbol enraizado en el niño izquierdo, rj denote ((uj \ xj) ∪ s) y qj denote (uj \ xj). Deje que el Reino Unido, RK y QK se definan análogos para el niño adecuado. Deje que R denote (u \ xi) ∪ s).ri (s) = r (s, r) = min t: s⊆t ⊆r x (t) - v (t) = min t: s⊆t ⊆r x (s) + x (t ∩ qj) + +x (t ∩ qk) - v (s) - v (corta (s, t ∩ qj) - v (corta (s, t ∩ qk) = min t: s⊆t ⊆r x (t ∩ qj) - v(cortar (s, t ∩ qj)) + min t: s⊆t ⊆r x (t ∩ qk) - v (corta (s, t ∩ qk)) + (x (s) - v (s)) (*) = min t: s⊆t ⊆r x (t ∩ qj) + x (s) - v (corta (s, t ∩ qj)) - v (s) + min t: s⊆t ⊆r x (T ∩ qk) + x (s) - v (corta (s, t ∩ qk)) - v (s) - (x (s) - v (s)) = min t: s⊆t ⊆r e (t∩ rj) + min t: s⊆t ⊆r e (t ∩ rk) - e (s) = min t: s⊆t ⊆rj e (t) + min t: s⊆t ⊆rk e (t) - - -e (s) = rj (s) + rk (s) - e (s) donde (*) es verdadero ya que t ∩ qj y t ∩ qk son disjunto debido a la propiedad de la intersección de la descomposición del árbol, y por lo tanto, el mínimo deLa suma se puede descomponer en la suma de los mínimos. 202