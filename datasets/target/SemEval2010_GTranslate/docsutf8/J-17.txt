Diseño del mecanismo veraz para la programación multidimensional a través de la monotonicidad del ciclo Ron Lavi Ingeniería y gestión industrial La técnica - Instituto de Tecnología de Israel ronlavi@ie.technion.ac.il Chaitanya Swamy Combinatorics and Optimization University of Waterloo cswamy@math.uwaterloo.ca Abstract We We We We We WeConsidere el problema de la minimización de HACHEPAN en las máquinas no relacionadas en el contexto del diseño del mecanismo algorítmico, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización de HACHEPAN en dicho dominio son los mecanismos veraz de O (M) de acroimentación [22, 20]. Estudiamos un caso especial bien motivado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos dependen del trabajo y dependen del trabajo. Esto conserva la multidimensionalidad del dominio y generaliza la configuración de máquinas restringidas (es decir, {PJ, ∞}) en la programación. Le damos una técnica general para convertir cualquier algoritmo de acerca de C-APROMACIÓN a un mecanismo de 3CPROXATION VERDADA-IN-Expectation. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera negra. Cuando los valores bajos y altos son los mismos para todos los trabajos, diseñamos un mecanismo veraz de 2 de acerca determinista. Estos son los primeros mecanismos veraces con garantías de rendimiento no trivial para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitas para demostrar la veracidad;En cambio, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonicidad del ciclo [23] es una condición necesaria y suficiente para la veracidad, es una generalización del valor monotonicidad para dominios multidimensionales. Sin embargo, mientras que el valor de la monotonicidad se ha utilizado amplia y con éxito para diseñar mecanismos veraces en dominios individuales, el nuestro es el primer trabajo que aprovecha la monotonicidad del ciclo en el entorno multidimensional. En segundo lugar, nuestros mecanismos aleatorios se obtienen construyendo primero un mecanismo veraz fraccional para una relajación fraccional del problema, y luego convertirlo en un mecanismo de expectación de la verdad. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionales en el diseño del mecanismo veraz. Categorías y descriptores de sujetos F.2 [Análisis de algoritmos y complejidad de problemas];J.4 [Ciencias sociales y conductuales]: Economía Algoritmos de términos generales, Economía, Teoría 1. Introducción Mecanismo Diseño Estudios de construcciones algorítmicas bajo la presencia de jugadores estratégicos que contienen los aportes al algoritmo. El diseño del mecanismo algorítmico se ha centrado principalmente en los entornos que el planificador social o el diseñador desea maximizar el bienestar social (o de manera equivalente, minimizar el costo social), o en los entornos de subasta donde la rentabilidad es el objetivo principal. Los objetivos de optimización alternativos, como los que incorporan criterios de equidad (que se han investigado algorítmicamente y en la teoría de la elección social) han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de las máquinas, a saber, la minimización de la marca. Hay N trabajos o tareas que deben asignarse a Máquinas M, donde cada trabajo debe asignarse exactamente a una máquina. Asignando un trabajo j a una máquina I incurre en una carga (costo) de PIJ ≥ 0 en la máquina I, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella;El objetivo es programar los trabajos para minimizar la carga máxima de una máquina, que se denomina makepan del horario. La minimización de MakePan es un objetivo común en los entornos de programación, y se ha estudiado bien algorítmicamente tanto en las comunidades de investigación en ciencias de la computación y en las operaciones (ver, por ejemplo, la encuesta [12]). Después del trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador o agente estratégico que conoce en privado su propio tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido.). Por lo tanto, abordamos el problema a través del diseño del mecanismo: el diseñador social, que posee el conjunto de trabajos que se asignarán, debe especificar, además de un cronograma, pagos adecuados a los jugadores para incentivarlos para revelar sus verdaderos tiempos de procesamiento. Tal mecanismo se llama mecanismo veraz. El objetivo de la minimización de la marca es bastante diferente del objetivo clásico de la maximización del bienestar social, donde uno quiere maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, 252 corresponde a maximizar el bienestar mínimo y la noción de justicia máxima, y parece ser un problema mucho más difícil desde el punto de vista del diseño del mecanismo. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para la minimización de Hacerpan está fuertemente relacionada con los supuestos en los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron la configuración de máquinas no relacionadas donde los valores de PIJ pueden ser arbitrarios. Este es un dominio multidimensional, ya que un valor privado de los jugadores es todo su vector de tiempos de procesamiento (PIJ) j. Se conocen muy pocos resultados positivos para los dominios multidimensionales en general, y los únicos resultados positivos conocidos por la programación multidimensional son los mecanismos veraz de la acroimentación de O (M) [22, 20]. Hacemos hincapié en que, independientemente de las consideraciones computacionales, incluso la existencia de un mecanismo veraz con una relación de aproximación significativamente mejor (que m) no se conoce por dicho dominio de programación. En el lado negativo, [22] mostró que ningún mecanismo determinista veraz puede alcanzar una relación de aproximación mejor que 2, y fortaleció este inferior límite a M para dos clases específicas de mecanismos deterministas. Recientemente, [20] extendió este límite inferior a los mecanismos aleatorios, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, los resultados positivos mucho más fuertes (y muchos más) son conocidos por un caso especial del problema de las máquinas no relacionadas, a saber, el entorno de máquinas relacionadas. Aquí, tenemos PIJ = PJ/Si para cada i, J, donde PJ es conocimiento público, y la velocidad Si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de reproductores sea único dimensional. La veracidad en tales dominios es equivalente a una condición de monotonicidad del valor conveniente [21, 3], lo que parece hacer que sea significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] consideraron por primera vez la configuración de máquinas relacionadas y dieron un mecanismo aleatorizado de 3 de la promulgación de 3 de accesorios. La brecha entre los dominios de una sola dimensión y multidimensional es quizás mejor ejemplificada por el hecho de que [3] demostró que existe un mecanismo veraz que siempre genera un horario óptimo.(Recuerde que en el entorno de máquinas no relacionadas multidimensionales, es imposible obtener un mecanismo veraz con una relación de aproximación mejor que 2.) Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o han mejorado la relación de aproximación. Tales dificultades para pasar de la configuración de una sola dimensión a la multidimensional también surgen en otras configuraciones de diseño del mecanismo (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden influir en el contexto más general del diseño del mecanismo veraz para los dominios multidimensionales. En este documento, consideramos el problema de la minimización MakePan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {lj, hj} para cada i, j, donde los valores de LJ, Hj se conocen públicamente (LJ ≡Low, Hj ≡High). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza la configuración clásica de máquinas restringidas, donde Pij ∈ {lj, ∞} que ha sido bien estudiada algorítmicamente. Un caso especial de nuestro modelo es cuando LJ = L y Hj = H para todos los trabajos J, que denotamos simplemente como el modelo de programación de dos valores. Ambos dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y en lo alto de la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son bajos y altos en ella. Por lo tanto, conservan la propiedad central subyacente a la dureza del diseño del mecanismo veraz para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros resultados y técnicas presentamos varios resultados positivos para nuestros dominios de programación multidimensionales. Nuestro primer resultado es un método general para convertir un algoritmo de aproximación para el establecimiento de dos valores dependientes del trabajo en un mecanismo de apropiación de 3C. Este es uno de los pocos resultados conocidos que usan un algoritmo de aproximación de manera negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de expectación de la verdad de 3 de acerca para el entorno LJ-HJ. Curiosamente, la prueba de veracidad no se basa en el suministro de precios explícitos, y nuestra construcción no produce necesariamente precios eficientemente computables (pero la regla de asignación es eficientemente computable). Nuestro segundo resultado se aplica a la configuración de TwoValues (LJ = L, Hj = H), para lo cual mejoramos tanto la relación de aproximación como fortalecemos la noción de veracidad. Obtuvimos un mecanismo veraz de 2-Apromentación determinista (junto con los precios) para este problema. Estos son los primeros mecanismos veraces con garantías de rendimiento no trivial para un dominio de programación multidimensional. Complementando esto, observamos que incluso esta configuración aparentemente simple no admite mecanismos veraces que devuelven un horario óptimo (a diferencia del caso de las máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinista veraz puede obtener una relación de aproximación mejor que 1.14 a la marca (independientemente de las consideraciones computacionales). La técnica principal, y una de las novedades, subyacentes a nuestras construcciones y pruebas, es que no confiamos en especificaciones de precios explícitas para demostrar la veracidad de nuestros mecanismos. En su lugar, explotamos ciertas condiciones de monotonicidad algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual los precios garantizan la veracidad, y luego encontrar estos precios (al profundizar aún más en la prueba de implementación). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para los dominios individuales, donde la monotonicidad del valor produce una caracterización conveniente que permite concentrarse en el lado algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para los dominios multidimensionales, casi todos los resultados positivos se han basado en especificaciones de precios explícitas para demostrar la veracidad (una excepción es el trabajo de jugadores desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brechaEn nuestra comprensión de dominios multidimensionales versus unicamensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonicidad para el diseño del mecanismo veraz en dominios arbitrarios. La condición de monotonicidad que usamos, que a veces se llama monotonicidad del ciclo, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonicidad del valor y caracteriza completamente la veracidad en cada dominio. Nuestros métodos y análisis demuestran los beneficios potenciales 253 de esta caracterización, y muestran que la monotonicidad del ciclo puede utilizarse de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Considere, por ejemplo, nuestro primer resultado que demuestre que cualquier algoritmo de acerca de C-C-APROMACIÓN se puede exportar a un mecanismo de apertura de 3C. Al nivel de generalidad de un algoritmo de aproximación arbitraria, parece poco probable que uno pueda obtener precios para demostrar la veracidad del mecanismo construido. Pero, la monotonicidad del ciclo nos permite probar tal declaración. De hecho, alguna de estas condiciones basadas solo en el algoritmo subyacente (y no en los precios) parece necesaria para demostrar una declaración tan general. El método para convertir los algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorizado se obtiene construyendo primero un mecanismo veraz que devuelve un horario fraccional. Pasar a un dominio fraccional nos permite enchufar la veracidad en el algoritmo de aproximación de una manera bastante simple, al tiempo que perdemos un factor de 2 en la relación de aproximación. Luego usamos un procedimiento de redondeo aleatorio adecuado para convertir la asignación fraccional en una asignación integral aleatoria. Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al.[14] que se adapta a la programación de máquinas no relacionadas. Esto conserva la veracidad, pero perdemos otro factor aditivo igual a la relación de aproximación. Nuestra construcción usa y extiende algunas observaciones de Lavi y Swamy [16], y demuestra aún más los beneficios de los mecanismos fraccionales en el diseño del mecanismo sincero. El trabajo relacionado Nisan y Ronen [22] consideraron por primera vez el problema de la minimización de la marca para máquinas no relacionadas. Dieron un resultado positivo de la Acroximación M y demostraron varios límites inferiores. Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la relación de aproximación que se puede lograr con mecanismos veraces en expectación, y Christodoulou, Koutsoupias y Vidali [8] demostró un (1 + √ 2) con destino a la deterministaLos mecanismos veraces. Archer y Tardos [3] consideraron primero el problema de las máquinas relacionadas y dieron un mecanismo de 3-APROMACIÓN AUTERITLE-in-Expectation. Esto se ha mejorado en [2, 4, 1, 13] a: un mecanismo aleatorizado de 2 de la acercamiento [2];Un FPTA para cualquier número fijo de máquinas dadas por Andelman, Azar y Sorani [1], y un mecanismo determinista de 3 de la acerca de Kov´ACS [13]. El problema algorítmico (es decir, sin requerir la veracidad) de la minimización de la marca en máquinas no relacionadas se entiende bien y se conocen varios algoritmos de 2 de acrochación de 2. Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo. Shmoys y Tardos [25] más tarde dieron un algoritmo de 2 apropiación para el problema de asignación generalizada, una generalización donde hay un CIJ de costo por asignar un trabajo J a una máquina I, y el objetivo es minimizar el costo sujeto a un límite en el Makepan. Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] dieron un algoritmo de redondeo aleatorio que produce los mismos límites. Utilizamos su procedimiento en nuestro mecanismo aleatorizado. Rochet [23] (ver también Gui et al. [11]). Esto generaliza la condición de monotonicidad del valor para los dominios de una sola dimensión que fue dada por Myerson [21] y redescubierta por [3]. Como se mencionó anteriormente, esta condición se ha explotado en numerosas ocasiones para obtener mecanismos veraz para dominios de una sola dimensión [3, 7, 4, 1, 13]. Para los dominios convexos (es decir, cada conjunto de valores privados es convexo), se sabe que la monotonicidad del ciclo está implícita en una condición más simple, llamada monotonicidad débil [15, 6, 24]. Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño del mecanismo veraz para problemas multidimensionales. Los objetivos distintos de la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño del mecanismo. En el contexto de las subastas combinatorias, los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación de minimización de envidia se han estudiado brevemente. Lavi, Mualem y Nisan [15] mostraron que el objetivo anterior no se puede implementar con sinceridad;Bezakova y Dani [5] dieron un mecanismo de 0.5-acroximación para dos jugadores con valoraciones aditivas. Lipton et al.[19] mostró que el último objetivo no se puede implementar con sinceridad. Estos límites inferiores se fortalecieron en [20].2. Preliminares 2.1 El dominio de programación En nuestro problema de programación, se nos da a n trabajos y máquinas M, y cada trabajo debe asignarse exactamente a una máquina. En la configuración de máquinas no relacionadas, cada máquina I se caracteriza por un vector de tiempos de procesamiento (PIJ) J, donde PIJ ∈ R≥0 ∪ {∞} denota es el tiempo de procesamiento para el trabajo J con el valor ∞ que especifica que no puedo procesar J. Consideramos dos casos especiales de este problema: 1. El caso de dos valores dependiente del trabajo, donde se conocen pij ∈ {lj, hj} para cada i, j, con lj ≤ hj, y los valores lj, hj son conocidos. Esto generaliza el modelo de programación clásico de máquinas restringidas, donde HJ = ∞.2. El caso de dos valores, que es un caso especial de arriba donde lj = ly hj = h para todos los trabajos j, es decir, pij ∈ {l, h} para cada i, j. Decimos que un trabajo j es bajo en la máquina i si pij = lj y alto si pij = hj. Usaremos el cronograma de los términos y la asignación indistintamente. Representamos un horario determinista por un vector x = (xij) i, j, donde xij es 1 si el trabajo j se asigna a la máquina I, por lo tanto, tenemos xij ∈ {0, 1} por cada i, j, p i xij =1 para cada trabajo j. También consideraremos algoritmos y algoritmos aleatorios que devuelven una asignación fraccional. En ambas configuraciones, volveremos a especificar una asignación de un vector x = (xij) i, j con p j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j. Para un algoritmo aleatorizado, XIJ es simplemente la probabilidad de que J se asigne a I (por lo tanto, X es una combinación convexa de asignaciones enteras). Denotamos la carga de la máquina I (bajo una asignación dada) por Li = P J Xijpij, y el creador de un horario se define como la carga máxima en cualquier máquina, es decir, Maxi Li. El objetivo en el problema de la minimización de Makepan es asignar los trabajos a las máquinas para minimizar el creador del horario.2.2 Diseño del mecanismo Consideramos el problema de la minimización de la marca en los dominios de programación anteriores en el contexto del diseño del mecanismo. Mecanismo Diseño de estudios de estudios estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico. Tras el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes. El diseñador social posee el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas. Cada máquina es una entidad egoísta, que en privado conoce su propio tiempo de procesamiento para cada trabajo.En una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo. Consideramos los mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de los tiempos de procesamiento, el mecanismo calcula un horario y entrega los pagos a los jugadores (es decir, máquinas) para compensarlos por el costo en el que incurren en el procesamiento de su asignado sus asignadostrabajos. Un mecanismo (de revelación directa) consiste así en una tupla (x, p): x especifica el cronograma, y p = {pi} especifica los pagos entregados a las máquinas, donde tanto X como el PI son funciones del procesamiento informadoTimes P = (PIJ) I, J. El objetivo de los mecanismos es calcular un cronograma que tenga un creador casi óptimo con respecto a los verdaderos tiempos de procesamiento;Sin embargo, una máquina I solo está interesada en maximizar su propia utilidad, PI - Li, donde Li es su carga bajo la asignación de salida y puede declarar tiempos de procesamiento falsos si esto podría aumentar su utilidad. Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores para que revelen sinceramente sus tiempos de procesamiento a través de los pagos. Esto se hace preciso utilizando la noción de veracidad de estrategia dominante. Definición 2.1 (veracidad) Un mecanismo de programación es veraz si, para cada máquina, cada vector de tiempos de procesamiento de las otras máquinas, P-I, cada verdadero vector de procesamiento P1 I y cualquier otro vector P2 I de la máquina I, nosotros, nosotros, nosotros, nosotros, nosotros, nosotros,tener: p1 i - x j x1 ijp1 ij ≥ p2 i - x j x2 ijp1 ij, (1) donde (x1, p1) y (x2, p2) son respectivamente el horario y los pagos cuando las otras máquinas declaran p - i yLa máquina I declara p1 I y P2 I, es decir, x1 = x (p1 i, p - i), p1 i = pi (p1 i, p - i) y x2 = x (p2 i, p - i), p2 i= PI (P2 I, P - I). Para decirlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad al declarar un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas. También consideraremos mecanismos fraccionales que devuelven una asignación fraccional y mecanismos aleatorios que se les permite arrojar monedas y donde la asignación y los pagos pueden ser variables aleatorias. La noción de veracidad para un mecanismo fraccional es la misma que en la definición 2.1, donde x1, x2 ahora son tareas fraccionales. Para un mecanismo aleatorizado, consideraremos la noción de veracidad en la expectativa [3], lo que significa que una máquina (jugador) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento. La desigualdad (1) también define la veracidad en la excepción para un mecanismo aleatorizado, donde P1 I, P2 ahora denota los pagos esperados realizados al Jugador I, X1, X2 son las tareas fraccionadas que denotan el cronograma de algoritmos aleatorios (es decir, XK IJ IS IS ISLa probabilidad de que J se asigne a I en la salida del cronograma para (PK I, P - I)). Para nuestros dos dominios de programación, la suposición informativa es que los valores LJ, HJ son conocidos públicamente. La información privada de una máquina es qué trabajos tienen valor LJ (o L) y cuáles tienen valor HJ (o H) en ella. Hacemos hincapié en que ambos dominios son multidimensionales, ya que cada máquina que necesito especificar un vector que dice qué trabajos son bajos y altos.3. Monotonicidad del ciclo Aunque la veracidad se define en términos de pagos, resulta que la veracidad en realidad se reduce a una cierta condición algorítmica de la monotonicidad. Esto parece haber sido observado por primera vez para los dominios multidimensionales por Rochet [23] en 1987, y se ha utilizado con éxito en el diseño del mecanismo algorítmico varias veces, pero para dominios individuales. Sin embargo, para los dominios multidimensionales, la condición de monotonicidad está más involucrada y no ha habido éxito en emplearla en el diseño de mecanismos veraces. La mayoría de los resultados positivos para los dominios multidimensionales se han basado en especificaciones de precios explícitas para demostrar la veracidad. Una de las principales contribuciones de este documento es demostrar que la condición de monotonicidad para entornos multidimensionales, que a veces se llama monotonicidad del ciclo, puede utilizarse de manera efectiva para idear mecanismos veraces. Incluimos una breve exposición al completarlo. La exposición aquí se basa en gran medida en [11]. La monotonicidad del ciclo se describe mejor en la configuración de elección social abstracta: hay un conjunto finito A de alternativas, hay m reproductores y cada jugador tiene un tipo privado (función de valoración) v: a → r, donde vi (a) debe serinterpretado como es valor para la alternativa a. En el dominio de programación, A representa todas las tareas posibles de trabajos a las máquinas, y VI (a) es la carga negativa de IS en el Anexo a. Deje que VI denote el conjunto de todos los tipos posibles de jugador i. Un mecanismo es una tupla (F, {Pi}) donde F: V1 × · · · × VM → A es el algoritmo para elegir la alternativa, y PI: V1 × · · · × VM → A es el precio cobrado al jugador de reproductorYo (en el entorno de programación, el mecanismo paga a los jugadores, lo que corresponde a los precios negativos). El mecanismo es sincero si cada i, cada v - i ∈ V - i = q i = i vi, y cualquier vi, vi ∈ Vi tenemos vi (a) - pi (vi, v - i) ≥ vi (b (b) - PI (VI, V - I), donde a = F (VI, V - I) y B = F (VI, V - I). Una pregunta básica que surge se da un algoritmo F: V1 × · · · × VM → A, ¿existen precios que harán que el mecanismo resultante sea sincero? Es bien sabido (ver, por ejemplo, [15]) que el precio Pi solo puede depender de la alternativa elegida y las declaraciones de las demás, es decir, podemos escribir PI: V - I × A → R. Por lo tanto, la veracidad implica que para cada uno para cada uno.i, cada v - i ∈ V - i, y cualquier vi, vi ∈ Vi con f (vi, v - i) = a y f (vi, v - i) = b, tenemos vi (a) - pi (A, V - I) ≥ Vi (B) - PI (B, V - I). Ahora arregle un jugador I y arregle las declaraciones v - i de las otras. Buscamos una asignación a las variables {pa} a∈A tal que vi (a) - vi (b) ≥ pa - pb por cada a, b ∈ A y vi ∈ Vi con f (vi, v - i) = a.(Estrictamente hablando, deberíamos usar a = f (vi, v - i) en lugar de un aquí). Define ΔA, B: = inf {vi (a) - vi (b): vi ∈ Vi, f (vi, v - i) = a}. Ahora podemos reformular el problema de asignación de precios anterior: buscamos una asignación a las variables {pa} a∈A tal que pa-pb ≤ Δa, b ∀a, b ∈ A (2) esto se resuelve fácilmente mirando elGráfico de asignación y aplicando un resultado básico estándar de la teoría de gráficos. Definición 3.1 (Gui et al. [11]) El gráfico de asignación de F es un gráfico ponderado dirigido g = (a, e) donde e = a × a y el peso de un borde b → a (para cualquier a, b ∈A) es ΔA, b. Teorema 3.2 Existe una asignación factible a (2) si el gráfico de asignación no tiene ciclos de longitud negativa. Además, si todos los ciclos no son negativos, una asignación factible se obtiene 255 de la siguiente manera: corrige un nodo arbitrario a ∗ ∈ A y establece que PA sea la longitud de la ruta más corta de A ∗ a a. Esto lleva a la siguiente definición, que es otra forma de redactar la condición de que el gráfico de asignación no tenga ciclos negativos. Definición 3.3 (monotonicidad del ciclo) Una función de elección social f satisface la monotonicidad del ciclo si para cada jugador i, cada v - i ∈ V - i, cada entero k k y cada v1 i ,..., vk i ∈ Vi, kx k = 1 h vk i (ak) - vk i (ak+1) i ≥ 0 donde ak = f (vk i, v - i) para 1 ≤ k ≤ k y ak+1= A1. Corolario 3.4 Existen precios P de tal manera que el mecanismo (F, P) es sincero si Satisface la monotonicidad del ciclo.1 Ahora consideramos nuestro dominio de programación específico. Arregle un jugador I, P - I y cualquier P1 I ,..., PK i. Sea x (pk i, p - i) = xk para 1 ≤ k ≤ k, y deje xk+1 = x1, pk+1 = p1.XK podría ser una asignación {0, 1} o una asignación fraccional. Tenemos vk i (xk) = - p j xk ijpk ij, por lo que la monotonicidad del ciclo se traduce en pk k = 1 ˆ - p j xk ijpk ij + p j xk + 1 ij pk ij ˜ ≥ 0. Reorganizando, obtenemos kx k = 1 x j xk+1 ij `pk ij - pk+1 ij ´ ≥ 0. (3) Así (3) reduce nuestro problema de diseño de mecanismo a un problema algorítmico de concreto. Para la mayor parte de este documento, en consecuencia ignoraremos cualquier consideración estratégica y nos centraremos en diseñar un algoritmo de aproximación para minimizar MakePan que satisface (3).4. Una técnica general para obtener mecanismos aleatorios en esta sección, consideramos el caso de los valores de LJ, HJ dependientes del trabajo (con LJ ≤ Hj), que generaliza el modelo clásico de máquinas restringidas (donde HJ = ∞). Mostramos el poder de la aleatorización, al proporcionar una técnica general que convierte cualquier algoritmo de abroximación C en un mecanismo de apropiación 3C, sincera en la expectación. Este es uno de los pocos resultados que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces cuando el algoritmo se da como una caja negra. Nuestra construcción y prueba son simples y se basan en dos ideas. Primero, como se describió anteriormente, demostramos la veracidad utilizando la monotonicidad del ciclo. Parece poco probable que para un algoritmo de aproximación arbitraria dado solo como una caja negra, uno podría encontrar pagos para demostrar la veracidad;Pero la monotonicidad del ciclo nos permite probar con precisión esto. En segundo lugar, obtenemos nuestro mecanismo aleatorizado (a) moviéndose primero a un dominio fraccional, y construyendo un mecanismo veraz fraccional que puede devolver asignaciones fraccionales;Luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros. Esto se basa en un tema introducido por Lavi y Swamy [16], a saber, el de usar mecanismos fraccionados para obtener mecanismos veraces de expectación.1 No está claro si el teorema 3.2, y por lo tanto, esta declaración, mantén si A no es finito. Sin embargo, debemos señalar que uno no puede simplemente conectar los resultados de [16]. Sus resultados son válidos para los problemas sociales deximización y confían en usar VCG para obtener un mecanismo veraz fraccional. Sin embargo, VCG no se aplica a la minimización de HAKEPAN, y en nuestro caso, incluso la existencia de un mecanismo veraz fraccional casi óptimo se desconoce. Usamos el siguiente resultado adaptado de [16]. Lema 4.1 (Lavi y Swamy [16]) Sea M = (x, p) un mecanismo veraz fraccional. Sea A un algoritmo de redondeo aleatorio que dio una asignación fraccional x, emite una asignación aleatoria x tal que e ˆ xij ˜ = xij para todos los i, j. Luego existen pagos p de tal manera que el mecanismo M = (a, p) es sincero en las expectativas. Además, si M es individualmente racional, entonces M es individualmente racional para cada realización de los lanzamientos de monedas. Deje OPT (P) denotar el Makepan óptimo (sobre los horarios enteros), por ejemplo, p.Como nuestro primer paso, tomamos un algoritmo de capproximación y lo convertimos en un mecanismo veraz fraccional de 2C. Esta conversión funciona incluso cuando el algoritmo de aproximación devuelve solo un horario fraccional (que satisface ciertas propiedades) de MakePan como máximo c · opt (p) para cada caso p.Probamos la veracidad al mostrar que el algoritmo fraccional satisface la monotonicidad del ciclo (3). Observe que el conjunto alternativo de nuestro mecanismo fraccional es finito (aunque el conjunto de todas las asignaciones fraccionales es infinita): su cardinalidad es como máximo la de InputDomain, que es como máximo 2 mn en el caso de dos valores. Por lo tanto, podemos aplicar el Corolario 3.4 aquí. Para convertir este mecanismo veraz fraccional en un mecanismo veraz aleatorizado, necesitamos un procedimiento de redondeo aleatorizado que satisfaga los requisitos del Lema 4.1. Afortunadamente, tal procedimiento ya está proporcionado por Kumar, Marathe, Parthasarathy y Srinivasan [14]. Lemma 4.2 (Kumar et al. [14]) Dada una asignación fraccional x y un vector de tiempo de procesamiento P, existe un procedimiento de redondeo aleatorizado que produce una asignación (aleatoria) x tal que, 1. para cualquier i, j, e ˆXij ˜ = xij.2. Para cualquier I, P J xijpij <p j xijpij + max {j: xij ∈ (0,1)} PIJ con probabilidad 1. La propiedad 1 se utilizará para obtener la veracidad en la expectativa, y la propiedad 2 nos permitirá probar una garantía de aproximación. Primero mostramos que cualquier algoritmo que devuelva una asignación fraccional que tenga ciertas propiedades satisface la monotonicidad del ciclo. Lemma 4.3 Sea A un algoritmo que para cualquier entrada P, emite una asignación (fraccional) x tal que, si pij = hj entonces xij ≤ 1/m, y si Pij = lj entonces xij ≥ 1/m. Entonces un ciclo de ciclo satisface. Prueba. Arregle un jugador I y el vector de los tiempos de procesamiento de los otros jugadores P - I. Necesitamos probar (3), es decir, PK K = 1 P J XK+1 IJ `PK IJ - PK+1 IJ ´ ≥ 0 por cada P1 I ,..., Pk I, donde el índice K = K + 1 se considera K = 1. Mostraremos que para cada trabajo j, pk k = 1 xk+1 ij `pk ij - pk+1 ij ´ ≥ 0. Si PK IJ es lo mismo para todos los k (siempre LJ o siempre HJ), entonces la desigualdad anterior es claramente válida. De lo contrario, podemos dividir los índices 1 ,..., K, en segmentos máximos, donde un segmento máximo es un conjunto máximo de índices consecutivos K, K + 1 ,..., k - 1, k (donde k + 1 ≡ 1) tal que pk ij = hj ≥ pk +1 ij ≥ · · · ≥ pk ij = lj. Esto sigue porque debe haber algunos k tal que pk ij = hj> pk - 1 ij = lj. Tomamos k = k y luego seguimos incluidos los índices en este segmento hasta que llegamos a un k tal que PK ij = lj y pk+1 ij = hj. Establecimos k = k, y luego comenzamos un nuevo segmento máximo con el índice K + 1. Tenga en cuenta que K = K y K + 1 = K - 1. Ahora tenemos un subconjunto de índices y podemos continuar de manera recursiva. Entonces, todos los índices se incluyen en algún segmento máximo. Mostraremos que por cada segmento máximo K, K +1 ,..., k, p k −1≤k <k xk+1 ij `pk ij - pk+1 ij ´ ≥ 0. Agregar esto para cada segmento produce la desigualdad deseada. Así que ahora concéntrese en un segmento máximo K, K + 1 ,..., k - 1, k. Por lo tanto, hay algunos k ∗ tal que para k ≤ k <k ∗, tenemos pk ij = hj, y para k ∗ ≤ k ≤ k, tenemos pk ij = lj. Ahora el lado izquierdo de la desigualdad anterior para este segmento es simplemente xk ij (lj −hj)+xk ∗ ij (hj −lj) ≥ 0, ya que xk ij ≤ 1 m ≤ xk ∗ ij como pk ij = hj y pk∗ ij = lj. Ahora describimos cómo usar un algoritmo de acerca de C-C-APROBACIÓN para obtener un algoritmo que satisfaga la propiedad en Lemma 4.3. Para simplificar, primero suponga que el algoritmo de aproximación devuelve un horario integral. La idea es simplemente difundir este horario. Tomamos cada trabajo j asignado a una máquina alta y la asignamos hasta un punto 1/m en todas las máquinas;Para cada trabajo J asignado a una máquina baja, digamos I, asignamos 1/M-fracción a las otras máquinas donde es baja, y asigna su fracción restante (que es al menos 1/m) a i. La asignación resultante satisface claramente las propiedades deseadas. También observe que la carga en cualquier máquina ha aumentado en lo máximo de 1 m · (carga en otras máquinas) ≤ MakePan, y por lo tanto, el Makepan se ha duplicado como máximo. Esta extensión también se puede hacer si el horario inicial es fraccional. Ahora describimos el algoritmo con precisión. Algoritmo 1 Sea A cualquier algoritmo que en cualquier entrada P salga una asignación posiblemente fraccional x tal que xij> 0 implica que Pij ≤ t, donde t es la marca de x.(En particular, tenga en cuenta que cualquier algoritmo que devuelva una asignación integral tiene estas propiedades). Nuestro algoritmo, que llamamos a, devuelve la siguiente tarea xf. Inicializar xf ij = 0 para todo i, j. Para cada i, j, 1. Si pij = hj, establece xf ij = p i: pi j = hj xi j/m;2. Si pij = lj, establece xf ij = xij + p i = i: pi j = lj (xi j −xij)/m + p i: pi j = hj xi j/m. Teorema 4.4 Suponga que el algoritmo A satisface las condiciones en el algoritmo 1 y devuelve una marca de como máximo c · opt (p) por cada p.Luego, el algoritmo A construido anteriormente es un algoritmo fraccional de monótonos de 2c sobre ciclo. Además, si xf ij> 0 en la entrada p, entonces Pij ≤ c · opt (p). Prueba. Primero, tenga en cuenta que XF es una tarea válida: para cada trabajo J, P i xf ij = p i xij + p i, i = i: pij = pi j = lj (xi j - xij)/m = p i xij =1. También tenemos eso si PIJ = Hj entonces xf ij = p i: pi j = hj xi j/m ≤ 1/m. Si pij = lj, entonces xf ij = xij (1 - /m) + p i = i xi j /m where = | {i = i: pi j = lj} |≤ m - 1;entonces xf ij ≥ p i xi j/m ≥ 1/m. Por lo tanto, por Lema 4.3, A satisface la monotonicidad del ciclo. La carga total en cualquier máquina I bajo XF es en Mostp J: PIJ = Hj P I: Pi J = Hj HJ · XI J M + P J: PIJ = LJ LJ `XIJ + P I = I XI J M ´, que es como máximoP J PIJXIJ + P I = I P J PI JXI J/M ≤ 2C · OPT (P). Finalmente, si xf ij> 0 y pij = lj, entonces pij ≤ opt (p). Si pij = hj, entonces para algunos i (posiblemente i) con pi j = hj tenemos xi j> 0, por lo que por suposición, pi j = hj = pij ≤ c · opt (p). Teorema 4.4 Combinado con Lemmas 4.1 y 4.2, ofrece un mecanismo 3C de abarrosión, veraz en la expectación. El cálculo de los pagos dependerá del algoritmo de aproximación real utilizado. Sin embargo, la Sección 3 proporciona un procedimiento explícito para calcular los pagos que garantizan la veracidad, aunque quizás no en tiempo polinomial. Teorema 4.5 El procedimiento en el Algoritmo 1 convierte cualquier algoritmo fraccional de la Apreciación C en un mecanismo de apropiación 3C, veraz en la expectación. Tomando un algoritmo 1 para ser el algoritmo que devuelve una asignación de LP-Optimum que satisface las condiciones requeridas (ver [18, 25]), obtenemos un mecanismo de 3-APROMACIÓN. Corolario 4.6 Existe un mecanismo veraz en expectación con la relación de aproximación 3 para el entorno LJ-HJ.5. Un mecanismo determinista para el caso de dos valores ahora presentamos un mecanismo veraz de 2-acroximación determinista para el caso donde pij ∈ {l, h} para todo i, j. En la secuela, a menudo diremos que J se asigna a una baja máquina para denotar que J se asigna a una máquina I donde Pij = L. Llamaremos a un trabajo J un trabajo bajo de la máquina I if Pij = l;La baja carga de I es la carga en I debido a sus bajos trabajos, es decir, P J: PIJ = L xijpij. Como en la Sección 4, nuestro objetivo es obtener un algoritmo de aproximación que satisfaga la monotonicidad del ciclo. Primero obtenemos una simplificación de la condición (3) para nuestro dominio de programación de dos valores {L, H} (Proposición 5.1) que será conveniente para trabajar. Describimos nuestro algoritmo en la Sección 5.1. En la Sección 5.2, vinculamos su garantía de aproximación y demostramos que satisface la monotonicidad del ciclo. En la Sección 5.3, calculamos los pagos explícitos que dan un mecanismo veraz. Finalmente, en la Sección 5.4 mostramos que ningún mecanismo determinista puede lograr la marca óptima. Define nk, h = ˛ ˛ {j: xk ij = 1, pk ij = l, pij = h} ˛ ˛ (4) nk, l = ˛ ˛ {j: xk ij = 1, pk ij = h, pij =L} ˛ ˛.(5) Entonces, P J XK+1 IJ (PK IJ - PK+1 IJ) = (NK+1, K H - NK+1, K L) (H - L). Conectando esto en (3) y dividiendo por (H - L), obtenemos lo siguiente. La monotonicidad del ciclo de la Proposición 5.1 en el dominio de programación de dos valores es equivalente a la condición de que, para cada jugador I, cada P-I, cada entero K y cada P1 I ,..., Pk I, Kx K = 1 `nk+1, k h-nk+1, k l ´ ≥ 0. (6) 257 5.1 Algoritmo de aproximación de aciclo-monótono ahora describimos un algoritmo que satisface la condición (6) y logra A2-ACOMAXIMACIÓN. Asumiremos que L, H son enteros, que no tienen pérdida de generalidad. Un componente central de nuestro algoritmo será un procedimiento que toma un umbral de carga entero T y calcula una asignación parcial entera X de trabajos a máquinas de tal manera que (a) un trabajo solo se asigna a una máquina baja;(b) la carga en cualquier máquina es como máximo t;y (c) se maximiza el número de trabajos asignados. Dicha tarea se puede calcular resolviendo un problema de flujo máximo: construimos un gráfico bipartito dirigido con un nodo para cada trabajo j y cada máquina i, y un borde (j, i) de capacidad infinita si Pij = L. también nosotros tambiénAgregue un nodo de origen S con bordes (s, j) con capacidad 1 y nodo de sumisión T con bordes (i, t) con capacidad t/l. Claramente, cualquier flujo entero en esta red corresponde a una asignación parcial entera válida x de hacer hazmas en la mayoría de t, donde xij = 1 iff hay un flujo de 1 en el borde de j a i. Por lo tanto, usaremos la asignación de los términos y fluiremos indistintamente. Además, siempre hay un flujo máximo integral (ya que todas las capacidades son enteros). A menudo nos referiremos a un flujo máximo como el flujo máximo para (P, T). Necesitamos un concepto adicional antes de describir el algoritmo. Potencialmente podría haber muchas flujos máximos y estaremos interesados en los más equilibrados, que definimos formalmente de la siguiente manera. Arregle un poco de flujo máximo. Sea Ni P, T la cantidad de flujo del borde (i, t) (o de manera equivalente el número de trabajos asignados a i en el horario correspondiente), y que NP, t sea el tamaño total del flujo máximo, es decir, es decir,np, t = p i ni p, t. Para cualquier t ≤ t, defina ni p, t | t = min (ni p, t, t), es decir, truncamos el flujo/asignación en i para que la carga total en i sea como máximo t. Definir np, t | t = p i ni p, t | t. Definimos un flujo o asignación de prefijo-máxima para T de la siguiente manera. Definición 5.2 (flujo de prefijo-maximal) Un flujo para la red anterior con umbral t es prefijo máxima si para cada entero t ≤ t, tenemos np, t | t = np, t. Es decir, en un flujo de prefijo-máxima para (P, T), si truncamos el flujo en algún t ≤ t, nos queda un flujo máximo para (P, T). Un hecho elemental sobre flujos es que si una asignación/flujo x no es un flujo máximo para (p, t), entonces debe haber una ruta de aumento P = (s, j1, i1, ..., jk, ik, t)En el gráfico residual que nos permite aumentar el tamaño del flujo. La interpretación es que en la asignación actual, J1 no está asignado, xi j = 0, que se denota por los bordes delanteros (j, i) y xi j +1 = 1, que se denota por los bordes inversos (i, j+1). El aumento x usando P cambia la asignación para que cada j se asigne a I en la nueva asignación, lo que aumenta el valor del flujo en 1. Una ruta de aumento simple no disminuye la carga de ninguna máquina;Por lo tanto, se puede argumentar que siempre existe un flujo de prefijo máxima para un umbral T. Primero calculamos un flujo máximo para el umbral 1, usamos rutas de aumento simples para aumentarlo a un flujo máximo para el umbral 2, cada vez que aumenta el flujo máximo para el umbral anterior T a un flujo máximo para el umbral T.+ 1 Uso de rutas de aumento simples. Algoritmo 2 Dado un vector de tiempos de procesamiento P, construya una asignación de trabajos a máquinas de la siguiente manera.1. Calcule t ∗ (p) = min ˘ t ≥ h, t múltiple de l: np, t · l + (n - np, t) · h ≤ m · t ¯. Tenga en cuenta que NP, T · L+(N - NP, T) · H −M · T es una función decreciente de T, por lo que T ∗ (P) se puede calcular en tiempo polinómico a través de la búsqueda binaria.2. Calcule un flujo de prefijo-máxima para el umbral T ∗ (p) y la asignación parcial correspondiente (es decir, J se asigna a I IFF hay 1 unidad de flujo en el borde (j, i)).3. Asigne los trabajos restantes, es decir, los trabajos no asignados en la fase de flujo, de manera codiciosa de la siguiente manera. Considere estos trabajos en un orden arbitrario y asigne cada trabajo a la máquina con la carga más baja actual (donde la carga incluye los trabajos asignados en la fase de flujo). Nuestro algoritmo necesita calcular una asignación de prefijo máxima para el umbral t ∗ (p). La prueba que muestra la existencia de un flujo máximo prefijo solo produce un algoritmo de tiempo pseudopolinomial para calcularlo. Pero observe que el flujo máximo sigue siendo el mismo para cualquier t ≥ t = n · L., por lo que un flujo de prefijo máxima para t también es un prefijo máximo para cualquier t ≥ t. Por lo tanto, solo necesitamos calcular un flujo de prefijo máxima para t = min {t ∗ (p), t}. Esto se puede hacer en el tiempo polinomial utilizando el algoritmo iterativo de latas de augumento en la prueba de existencia para calcular iterativamente el máximo flujo para los polinómicamente muchos múltiplos de L hasta (e incluyendo) t. Teorema 5.3 Uno puede calcular eficientemente los pagos que cuando se combinan con el algoritmo 2 producen un mecanismo veraz de 2 de approximación determinista para el dominio de programación de dos valores.5.2 Análisis Deje OPT (P) denotar el MakePan óptimo para P.Ahora demostramos que el algoritmo 2 es un algoritmo de 2 de acerca de 2 que satisface la monotonicidad del ciclo. Esto luego nos permitirá calcular los pagos en la Sección 5.3 y probar el Teorema 5.3.5.2.1 Prueba de reclamo de aproximación 5.4 Si opta (p) <h, el makepan es como máximo opt (p). Prueba. Si opta (p) <h, debe ser que el cronograma óptimo asigne todos los trabajos a máquinas bajas, por lo tanto, NP, OPT (P) = n.Por lo tanto, tenemos t ∗ (p) = l · h l. Además, dado que calculamos un flujo de prefijo máxima para el umbral t ∗ (p) tenemos np, t ∗ (p) | opt (p) = np, opt (p) = n, lo que implica que la carga en cada máquina escomo máximo opt (p). Entonces, en este caso, el MakePan es como máximo (y por lo tanto exactamente) optar (P). Reclamación 5.5 Si opta (p) ≥ h, entonces t ∗ (p) ≤ l · opt (p) l ≤ opt (p) + l. prueba. Deje que NOPT (P) sea el número de trabajos asignados a máquinas bajas en un horario óptimo. La carga total en todas las máquinas es exactamente NOPT (P) · L + (N - NOPT (P)) · H, y es como máximo M · Opt (P), ya que cada máquina tiene carga como máximo OPT (P). Entonces, tomando t = l · opt (p) l ≥ h, ya que np, t ≥ nopt (p) tenemos que np, t · l+(n - np, t) · h ≤ m · t. Por lo tanto, t ∗ (p), la t más pequeña, es como máximo l · opt (p) l. Reclamación 5.6 Cada trabajo asignado en el paso 3 del algoritmo se asigna a una máquina alta.258 Prueba. Supongamos que J se asigna a la máquina I en el paso 3. Si Pij = L, entonces debemos tener Ni P, T ∗ (P) = T ∗ (P), de lo contrario podríamos haber asignado J a I en el Paso 2 para obtener un flujo de mayor valor. Entonces, en el punto justo antes de que J se asigne en el paso 3, la carga de cada máquina debe ser al menos t ∗ (p). Por lo tanto, la carga total después de J se asigna es al menos m · t ∗ (p) + l> m · t ∗ (p). Pero la carga total también es como máximo np, t ∗ (p) · l + (n - np, t ∗ (p)) · h ≤ m · t ∗ (p), produciendo una contradicción. LEMMA 5.7 El algoritmo anterior devuelve un horario con MakePan en la mayoría de los OPT (P)+Max ˘ L, H (1- 1 M) ¯ ≤ 2 · Opt (P). Prueba. Si opta (p) <h, entonces por el reclamo 5.4, terminamos. Entonces, supongamos que OPT (P) ≥ H. por reclamo 5.5, sabemos que t ∗ (p) ≤ opt (p) + L.(p) y terminamos. Entonces, suponga que hay algunos trabajos no asignados después del paso 2. Mostraremos que el MakEpan después del paso 3 es como máximo T +H `1- 1 m ´ donde t = min ˘ t ∗ (p), opt (p) ¯. Supongamos que el reclamo es falso. Sea la máquina con la carga máxima, por lo que li> t + h `1 - 1 m ´. Sea J el último trabajo asignado a I en el Paso 3, y considere el punto justo antes de que se asigne a i. Entonces li> t - h/m en este punto. Además, dado que J se asigna a I, por nuestra regla codiciosa, la carga en todas las otras máquinas debe ser al menos Li. Entonces, la carga total después de J se asigna J, es al menos H + M · Li> M · T (ya que PIJ = H por reclamo 5.6). Además, para cualquier asignación de trabajos a las máquinas en el paso 3, la carga total es como máximo np, t ∗ (p) · l + (n - np, t ∗ (p)) · h ya que hay np, t ∗ (p) trabajos asignados a máquinas bajas. Por lo tanto, debemos tener m · t <np, t ∗ (p) · l + (n - np, t ∗ (p)) · h. pero argumentaremos que m · t ≥ np, t ∗ (p) · ·L+(N - NP, T ∗ (P)) · H, que produce una contradicción. Si t = t ∗ (p), esto se deduce de la definición de t ∗ (p). Si t = opt (p), entonces dejar que NOPT (P) denota el número de trabajos asignados a máquinas bajas en un horario óptimo, tenemos NP, T ∗ (P) ≥ NOPT (P). Entonces np, t ∗ (p) · l+(n - np, t ∗ (p)) · h ≤ nopt (p) · l+(n - nopt (p)) · h. Esta es exactamente la carga total en un horario óptimo, que es como máximo M · Opt (P).5.2.2 Prueba de ciclo Monotonicidad Lemma 5.8 Considere dos casos P = (PI, P - I) y P = (PI, P - I) donde Pi ≥ Pi, es decir, PIJ ≥ PIJ ∀J. Si t es un umbral tal que np, t> np, t, entonces cada flujo máximo x para (p, t) debe asignar todos los trabajos j tal que pij = l. prueba. Deje que GP denote el gráfico residual para (P, T) y el flujo x. Supongamos por contradicción que existe un trabajo j ∗ con pij ∗ = l que no se asigna por x. Dado que Pi ≥ Pi, todos los bordes (J, I) que están presentes en la red para (P, T) también están presentes en la red para (P, T). Por lo tanto, X es un flujo válido para (P, T). Pero no es un flujo máximo, ya que np, t> np, t. Entonces existe una ruta de aumento P en el gráfico residual para (P, T) y el flujo x. Observe que el nodo I debe incluirse en P, de lo contrario, P también sería una ruta de aumento en el GP de gráfico residual que contradice el hecho de que X es un máximo de flujo. En particular, esto implica que hay una ruta P ⊂ P desde i hasta el fregadero t.Sea p = (i, j1, i1, ..., jk, ik, t). Todos los bordes de P también están presentes como bordes en GP, todos los bordes inversos (i, j +1) están presentes ya que tal borde implica que xi j +1 = 1;Todos los bordes delanteros (j, i) están presentes ya que i = i so pi j = pi j = l, y xi j +1 = 0. Pero luego hay una ruta de aumento (J ∗, I, J1, I1, ..., Jk, Ik, T) en GP que contradice la máxima máxima de x. Deje que L denote el vector de tiempo de procesamiento total. Defina TL I (P - I) = T ∗ (L, P - I). Dado que nos estamos centrando en la máquina I, y P - I se fija en todo momento, abreviamos TL I (P - I) a TL. Además, deje pl = (L, P - I). Tenga en cuenta que t ∗ (p) ≥ tl para cada instancia p = (pi, p - i). Corolario 5.9 Sea P = (PI, P-I) cualquier instancia y sea X cualquier flujo de prefijo máximo para (P, T ∗ (P)). Luego, la carga baja en la máquina I es como máximo TL. Prueba. Sea t ∗ = t ∗ (p). Si t ∗ = tl, entonces esto es claramente cierto. De lo contrario, considere la asignación x truncada en TL. Dado que X es prefijo-máxima, sabemos que esto constituye un flujo máximo para (P, TL). Además, np, t l <npl, t l porque t ∗> tl. Entonces, por Lemma 5.8, este flujo truncado debe asignar todos los trabajos bajos de i. Por lo tanto, no puede haber un trabajo j con pij = l que se asigne a I después del umbral TL desde entonces, J no sería asignado por este flujo truncado. Por lo tanto, la carga baja de I es como máximo TL. Usando estas propiedades, demostraremos la siguiente desigualdad clave: para cualquier p1 = (p - i, p1 i) y p2 = (p - i, p2 i), np1, t l ≥ np2, t l - n2,1 h + n2, 1 L (7) donde N2,1 H y N2,1 L están como se definen en (4) y (5), respectivamente. Observe que esto implica inmediatamente la monotonicidad del ciclo, ya que si tomamos p1 = pk y p2 = pk+1, entonces (7) implica que npk, t l ≥ npk+1, t l - nk+1, k h+nk+1, kL;sumando esto sobre todo k = 1 ,..., K da (6). Lema 5.10 Si t ∗ (p1)> tl, entonces (7) sostiene. Prueba. Deje t1 = t ∗ (p1) y t2 = t ∗ (p2). Tome el flujo de prefijo-maximal x2 para (p2, t2), truncarlo en TL y eliminar todos los trabajos de esta tarea que se cuentan en N2,1 h, es decir, todos los trabajos j tal que x2 ij = 1, p2ij = l, p1 ij = H. denota este flujo por x. Observe que X es un flujo válido para (P1, TL), y el tamaño de este flujo es exactamente NP2, T 2 | T L −N2,1 H = NP2, T L −n2,1 H. También ninguno de los trabajos que se cuentan en N2,1 L son asignados por X ya que cada uno de esos trabajos J es alto en I en P2. Desde t1> tl, debemos tener np1, t l <npl, t l. Entonces, si aumentamos X a un flujo máximo para (P1, TL), entonces por Lemma 5.8 (con P = PL y P = P1), todos los trabajos correspondientes a N2,1 L deben asignarse en este flujo máximo. Por lo tanto, el tamaño de este flujo máximo es al menos (tamaño de x) + n2,1 L, es decir, np1, t l ≥ np2, t l-n2,1 h + n2,1 L, como se afirma. Lema 5.11 Suponga t ∗ (p1) = tl. Entonces (7) sostiene. Prueba. Nuevamente, deje t1 = t ∗ (p1) = tl y t2 = t ∗ (p2). Sea X1, X2 la asignación completa, es decir, la asignación después de los pasos 2 y 3, calculado por nuestro algoritmo para P1, P2 respectivamente. Sea s = {j: x2 ij = 1 y p2 ij = l} y s = {j: x2 ij = 1 y p1 ij = l}. Por lo tanto, | S |= | S |- N2,1 H + N2,1 L y | S |= ni p2, t 2 = ni p2, t 2 | t l (por corolario 5.9). Sea t = | s |· L. Consideramos dos casos. Supongamos primero que t ≤ tl. Considere el siguiente flujo para (P1, TL): asigne a todas las máquinas que no sean la baja asignación de x2 truncada en TL y asigne los trabajos en S a la máquina i. Este es un flujo válido para (P1, TL) ya que la carga en I es T ≤ TL. Su tamaño es igual a p i = i ni p2, t 2 | t l +| s |= np2, t 2 | t l −n2,1 h +n2,1 l = np2, t l −n2,1 h +n2,1 l. El tamaño del flujo máximo para (P1, TL) no es más pequeño y el reclamo sigue.259 ahora supongamos t> tl. Desde | S |· L ≤ TL (por Corolario 5.9), se deduce que N2,1 L> N2,1 H ≥ 0. Sea ˆt = t - l ≥ tl ya que t, tl son múltiplos de L. Sea M = Np2, T 2 - N2,1 H + N2,1 L = | S |+ P i = i ni p2, t 2. Primero mostramos que M · ˆT <M · L + (N - M) · H. (8) Sea n el número de trabajos asignados a la máquina I en x2. La carga en la máquina I es | S | · L+(N - | S |) · H ≥ | S | · L - N2,1 L · L+(N− | S |) · H, que es al menos | S | ·L> ˆt desde n2,1 l ≤ n− | s |. Así obtenemos la desigualdad | S | · L+(N - | S |) · H> ˆT. Ahora considere el punto en la ejecución del algoritmo en la instancia P2 justo antes de que se asigne el último trabajo alto a I en el Paso 3 (debe haber tal trabajo desde N2,1 L> 0). La carga en I en este punto es | S |· L + (n - | s | - 1) · h que es menos | s |· L - L = ˆT por un argumento similar al de arriba. Por la propiedad codiciosa, cada i = i también tiene al menos esta carga en este punto, por lo que P j p2 i jx2 i j ≥ ˆt. Agregar estas desigualdades para todas las i = i, y la desigualdad anterior para i, obtenemos eso | S |· L + (n - | s |) · h + p i = i p j p2 i jx2 i j> m ˆt. Pero el lado izquierdo es exactamente m · l + (n-m) · h. por otro lado, ya que t1 = tl, tenemos m · ˆt ≥ m · tl ≥ np1, t l · l + (n −NP1, T L) · H. (9) Combinando (8) y (9), obtenemos que NP1, T L> M = NP2, T 2 - N2,1 H + N2,1 L ≥ NP2, T L - N2,1H + N2,1 l. LEMMA 5.12 Algoritmo 2 satisface la monotonicidad del ciclo. Prueba. Tomando p1 = pk y p2 = pk+1 en (7), obtenemos que npk, t l ≥ npk+1, t l −nk+1, k h+nk+1, k l. Sumando esto sobre todo k = 1 ,..., K (donde k + 1 ≡ 1) produce (6).5.3 Cálculo de los precios Lemmas 5.7 y 5.12 muestran que nuestro algoritmo es un algoritmo de 2 apropiación que satisface la monotonicidad del ciclo. Por lo tanto, mediante la discusión en la Sección 3, existen precios que producen un mecanismo veraz. Para obtener un mecanismo de tiempo polinómico, también debemos mostrar cómo calcular estos precios (o pagos) en tiempo polinómico. No está claro, si el procedimiento descrito en la Sección 3 basado en la calculación de rutas más cortas en el gráfico de asignación produce un algoritmo de tiempo polinomial, ya que el gráfico de asignación tiene un número exponencial de nodos (uno para cada asignación de salida). En lugar de analizar el gráfico de asignación, aprovecharemos nuestra prueba de monotonicidad del ciclo, en particular, desigualdad (7), y simplemente explicaremos los pagos. Recuerde que la utilidad de un jugador es ui = pi - li, donde Pi es el pago realizado al jugador i. Por conveniencia, primero especificaremos pagos negativos (es decir, el PIS en realidad se cobrará los precios a los jugadores) y luego mostraremos que estos pueden modificarse para que los jugadores tengan servicios públicos no negativos (si actúan con sinceridad). Permitir que denote el número de trabajos asignados a la máquina I en el paso 3. Por Corollary 5.6, sabemos que todos estos trabajos están asignados a máquinas altas (según los PI declarados). Deje h - i = p i = i hi y n - i p, t = p i = i ni p, t. El pago PI al jugador I se define como: Pi (P) = −l · N - I P, T ∗ (P) - H · H - I (P) - (H - L) `NP, T ∗ (P)- NP, T L I (P - I) ´ (10) Podemos interpretar que nuestros pagos equivalen al costo de los jugadores a una modificación cuidadosa de la carga total (en el espíritu de los precios de VCG). El primer y el segundo términos en (10), cuando se sutre de la carga, Li Equate es un costo para la carga total. El término np, t ∗ (p) - np, t l i (p - i) es de hecho igual a n - i p, t ∗ (p) - n - i p, t ∗ (p) | t l i (p - i (p - i) Dado que la carga baja en I es como máximo TL I (P-I) (por reclamo 5.9). Por lo tanto, el último término en la ecuación (10) implica que tratamos los trabajos bajos que se asignaron más allá del umbral de TL I (P - I) (a máquinas distintas a i) efectivamente como trabajos altos para el cálculo total de la utilidad desde el punto de vista es. No está claro cómo uno podría haber conjurado estos pagos a priori para demostrar la veracidad de nuestro algoritmo. Sin embargo, al confiar en la monotonicidad del ciclo, no solo pudimos argumentar la existencia de pagos, sino que también nuestra prueba allanó el camino para inferir estos pagos. El siguiente lema verifica explícitamente que los pagos definidos anteriormente realmente dan un mecanismo veraz. LEMMA 5.13 FIJA un jugador I y los otros jugadores declaraciones P - I. Deja que sea verdadero ser p1 i. Luego, bajo los pagos definidos en (10), está la utilidad cuando declara su verdadero tipo P1 I es al menos su utilidad cuando declara cualquier otro tipo P2 i. Prueba. Sea C1 I, C2 i denote es el costo total, definido como el negativo de su utilidad, cuando ella declara P1 y P2, respectivamente (y los demás declaran P - I). Como P - I es fijo, omitimos P - I de las expresiones a continuación para una claridad de notación. La verdadera carga de I cuando declara su verdadero tipo P1 I es L · Ni P1, T ∗ (P1) + H · Hi (P1) y, por lo tanto, C1 i = L · NP1, T ∗ (P1) + H · ((n - np1, t ∗ (p1)) + (h - l) `np1, t ∗ (p1) - np1, t l i ´ = n · h - (h - l) np1, t l i (11) en el otroMano, es una verdadera carga cuando declara P2 I es L · (Ni P2, T ∗ (P2) - N2,1 H + N2,1 L) + H · (Hi + N2,1 H - N2,1 L) (Dado que el vector de tiempo de procesamiento verdadero es p1 i) y, por lo tanto, c2 i = n · h - (h - l) np2, t l i + (h - l) n2,1 h - (h - l) n2,1 l. Por lo tanto, (7) implica que C1 I ≤ C2 i. Las especificaciones de precios son comúnmente necesarias para satisfacer, además de la veracidad, la racionalidad individual, es decir, la utilidad de los jugadores no debe ser negativa si revela su verdadero valor. Los pagos dados por (10) no son individualmente racionales, ya que realmente cobran a un jugador una cierta cantidad. Sin embargo, es bien sabido que este problema se puede resolver fácilmente agregando una constante lo suficiente a la definición de precios. En nuestro caso, por ejemplo, permitiendo que h denote el vector de todas las HS, podemos agregar el término n · h - (h −l) n (h, p - i), t l i (p - i) a (10). Tenga en cuenta que esto es una constante para el jugador i. Por lo tanto, los nuevos pagos son Pi (P) = N · H - L · N - I P, T ∗ (P) - H · H - I (P) - (H −l) `NP, T ∗ (P) - -np, t l i (p - i) +n (h, p - i), t l i (p - i) ´. Como se muestra por (11), esto dará como resultado una utilidad no negativa para i (ya que n (h, p-i), t l i (p-i) ≤ n (pi, p-i), t l i (P - i) Para cualquier tipo de Pi del jugador i). Esta modificación también garantiza la propiedad de normalización deseada adicionalmente deseada de que si un jugador no recibe trabajos, entonces recibe un pago cero: si el jugador recibe el conjunto vacío para algún tipo pi, también recibirá el conjunto vacío para el tipo H (esto es fácil deVerifique para nuestro algoritmo específico), y para el tipo H, su utilidad es igual a cero;Por lo tanto, con veracidad, esta también debe ser la utilidad de cualquier otra declaración que resulte en que reciba el conjunto vacío. Esto completa la prueba del teorema 5.3.260 5.4 imposibilidad de implementación exacta ahora mostramos que, independientemente de las consideraciones computacionales, no existe un algoritmo de ciclo monótono para el caso L-H con una relación de aproximación mejor que 1.14. Deje h = α · L para unos 2 <α <2.5 que elegiremos más adelante. Hay dos máquinas I, II y siete trabajos. Considere los siguientes dos escenarios: Escenario 1. Cada trabajo tiene el mismo tiempo de procesamiento en ambas máquinas: los trabajos 1-5, son L, y los trabajos 6, 7 son H. Cualquier horario óptimo asigna trabajos de 1 a 5 a una máquina y trabajos 6, 7 a la otra, y ha hecho que HacePanOpt1 = 5l. El segundo calendario ha hecho al menos segundo1 = 2H + L. Escenario 2. Si el algoritmo elige un cronograma óptimo para el escenario 1, suponga sin pérdida de generalidad que los trabajos 6, 7 se asignan a la máquina II. En el escenario 2, la máquina I tiene el mismo vector de tiempo de procesamiento. La máquina II reduce los trabajos 6, 7 a L y aumenta 1-5 a H. Un horario óptimo tiene 2L + H, donde la máquina II obtiene trabajos 6, 7 y uno de los trabajos 1-5. El segundo mejor calendario para este escenario ha hecho al menos segundo2 = 5L. Teorema 5.14 Ningún mecanismo verdadero determinista para el problema de programación de dos valores puede obtener una relación de aproximación mejor que 1.14. Prueba. Primero argumentamos que un algoritmo monótono de ciclo no puede elegir el horario óptimo en ambos escenarios. Esto sigue porque de lo contrario se viola la monotonicidad del ciclo para la máquina II. Tomando P1 II, P2 II para ser vectores de tiempo de procesamiento de la máquina para los escenarios 1, 2 respectivamente, obtenemos P J (P1 II, J - P2 II, J) (X2 II, J −x1 II, J) = (L - H) (1-0) <0. Por lo tanto, cualquier mecanismo veraz debe devolver un haz de hacer un escenario subóptimo en al menos un escenario y, por lo tanto, su relación de aproximación es al menos min ˘second1 opt1, segundo2 opt2 ¯ ≥ 1.14 para α = 2.364. Observamos que para el {lj, hj} -case donde hay una relación común r = hj lj para todos los trabajos (esto generaliza la configuración de máquinas restringidas) uno puede obtener un mecanismo veraz fraccional (con precios eficientemente computables)Programa de MakePan a lo sumo OPT (P) por cada p.Uno puede ver cada trabajo j como constante de sub-Jobs de tamaño 1 en una máquina I si pij = lj, y tamaño r si pij = hj. Para esta nueva instancia ˜p, tenga en cuenta que ˜pij ∈ {1, r} para cada i, j. Observe también que cualquier asignación ˜x para la instancia ˜p se traduce en una asignación fraccional x para p, donde pijxiJ = p j: sub-Job de j ˜pij ˜xij. Por lo tanto, si usamos el algoritmo 2 para obtener un cronograma para la instancia ˜p, la ecuación (6) se traduce con precisión a (3) para la asignación x;Además, los precios de ˜P se traducen en precios para la instancia p.El número de subjobs asignados a las máquinas bajas en la fase de flujo es simplemente el trabajo total asignado a las máquinas bajas. Por lo tanto, podemos implementar la reducción anterior configurando un problema de flujo máximo que parece maximizar el trabajo total asignado a máquinas bajas. Además, dado que tenemos un dominio fraccional, podemos usar una regla codiciosa más eficiente para empacar las porciones no asignadas de trabajos y argumentar que la tarea fraccional tiene una marca a lo sumo (p). Sin embargo, la asignación x no necesita satisfacer la condición de que Xij> 0 implique PIJ ≤ OPT (P) para la R arbitraria, por lo tanto, el procedimiento de redondeo de Lemma 4.2 no produce un mecanismo de 2 de aportación de 2 de aptitud. Pero si R> opt (P) (como en la configuración de máquinas restringidas), esta condición se mantiene, por lo que obtenemos un mecanismo veraz de 2 de la acroximación. Agradecimientos Agradecemos a Elias Koutsoupias por su ayuda para refinar el análisis del límite inferior en la Sección 5.4, y a los revisores por sus útiles comentarios.6. Referencias [1] N. Andelman, Y. Azar y M. Sorani. Mecanismos de aproximación veraz para programar máquinas relacionadas egoístas. En Proc.22º STACS, 69-82, 2005. [2] A. Archer. Mecanismos para la optimización discreta con agentes racionales. Tesis doctoral, Universidad de Cornell, 2004. [3] A. Archer y ´e. Tardos. Mecanismos veraces para los agentes de un parámetro. En Proc.42nd FOCS, páginas 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna y G. Persiano. Mecanismos deterministas de aproximación veraz para programar máquinas relacionadas. En Proc.21st Stacs, páginas 608-619, 2004. [5] I. Bez´akov´a y V. Dani. Asignación de bienes indivisibles. En ACM Sigecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan y A. Sen. La monotonicidad débil caracteriza la implementación determinista de estrategia dominante. Econometrica, 74: 1109-1132, 2006. [7] P. Briest, P. Krysta y B. Vocking. Técnicas de aproximación para el diseño de mecanismo utilitario. En Proc.37th STOC, páginas 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias y A. Vidali. Un límite inferior para los mecanismos de programación. En Proc.18th Soda, páginas 1163-1170, 2007. [9] E. Clarke. Precio multiparte de bienes públicos. Public Choice, 8: 17-33, 1971. [10] T. Groves. Incentivos en equipos. Econometrica, 41: 617-631, 1973. [11] H. Gui, R. Muller y R. V. Vohra. Caracterización de mecanismos de estrategia dominantes con tipos multidimensionales, 2004. Hoja de trabajo.[12] L. A. Sala. Algoritmos de aproximación para la programación. En D. Hochbaum, editor, algoritmos de aproximación para problemas np-cuidados. PWS Publishing, MA, 1996. [13] A. Kov´acs. Algoritmo de acroximación de 3 monótonos rápidos para máquinas relacionadas con la programación. En Proc.13ª ESA, páginas 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy y A. Srinivasan. Algoritmos de aproximación para la programación en múltiples máquinas. En Proc.46º FOCS, páginas 254-263, 2005. [15] R. Lavi, A. Mualem y N. Nisan. Hacia una caracterización de subastas combinatorias veraz. En Proc.44th Focs, páginas 574-583, 2003. [16] R. Lavi y C. Swamy. Diseño de mecanismo veraces y casi óptimos a través de la programación lineal. En Proc.46º FOCS, páginas 595-604, 2005. [17] D. Lehmann, L. Ocallaghan e Y. Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Journal of the ACM, 49: 577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys y ´e. Tardos. Algoritmos de aproximación para programar máquinas paralelas no relacionadas. Matemáticas. Prog., 46: 259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel y A. Saberi. En asignaciones aproximadamente justas de bienes indivisibles. En Proc.5ª CE, páginas 125-131, 2004. [20] A. Mualem y M. Schapira. Establecer límites inferiores sobre la veracidad. En Proc.18th Soda, 1143-1152, 2007. [21] R. Myerson. Diseño de subasta óptimo. Matemáticas de Operations Research, 6: 58-73, 1981. [22] N. Nisan y A. Ronen. Diseño de mecanismo algorítmico. Juegos y Econ. Comportamiento, 35: 166-196, 2001. [23] J. C. Rochet. Una condición necesaria y suficiente para la racionalización en un contexto cuasilíneo. Journal of Mathematical Economics, 16: 191-200, 1987. [24] M. Saks y L. Yu. La monotonicidad débil es suficiente para la veracidad en los dominios convexos. En Proc.6th CE, páginas 286-293, 2005. [25] D. B. Shmoys y ´e. Tardos. Un algoritmo de aproximación para el problema de asignación generalizada. Programación Matemática, 62: 461-474, 1993. [26] W. Vickrey. Contrapeculaciones, subastas y licitaciones selladas competitivas. J. Finanzas, 16: 8-37, 1961. 261