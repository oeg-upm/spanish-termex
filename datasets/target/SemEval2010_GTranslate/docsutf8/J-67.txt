Diseño del mecanismo para la programación en tiempo real en línea Ryan Porter ∗ Departamento de informática de la Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu Resumen Para el problema de la programación de trabajos en línea en tiempo real en un solo procesador, el trabajo anterior presenta límites superiores e inferiores.en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados solo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivado por áreas emergentes como la computación de la red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado y interestado. El agente puede retrasar la liberación del trabajo al algoritmo, inflar su longitud y declarar un valor arbitrario y una fecha límite para el trabajo, mientras que el centro determina no solo el cronograma, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, mientras que solo aumenta la relación competitiva en uno. Luego mostramos un límite inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: Sistemas distribuidos de inteligencia artificial-matiagente;J.4 [Ciencias sociales y conductuales]: Economía;F.1.2 [Computación por dispositivos abstractos]: Modos de cálculo de cálculo en la línea de cálculo Algoritmos de términos generales, economía, diseño, teoría 1. Introducción Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de lanzamiento, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa en su fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados por sus respectivos plazos. El desafío clave en este entorno en línea es que el horario debe construirse en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar los algoritmos en línea comparándolos con el algoritmo optim ﬄ ﬄ ﬄ ine, que tiene pleno conocimiento de la entrada al comienzo de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo optim ﬄ ine óptimo al valor de los completados por el algoritmo en línea. Dos documentos pintan una imagen completa en términos de análisis competitivo para este entorno, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por el tiempo de procesamiento) de dos trabajos. Para K = 1, [4] presenta un algoritmo de 4 competitivo y demuestra que este es un límite más bajo en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el límite inferior a (1 + √ k) 2 para cualquier k ≥ 1, y [15] luego presenta un algoritmo competitivo de coincidencia (1 + √ k) 2. La configuración abordada por estos documentos es completamente no constrechosa, y se supone que el algoritmo siempre conoce las características verdaderas de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación de la cuadrícula (ver, por ejemplo, [7, 8]) esta suposición no es válida, porque los compradores del tiempo del procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un problema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión de la configuración en la que cada trabajo es propiedad de un agente separado e interestimonado. En lugar de ser liberado al algoritmo, cada trabajo ahora se libera solo a su agente de propiedad. Cada agente ahora tiene cuatro formas diferentes en que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo de liberación real, puede inflar artificialmente la duración del trabajo y puede declarar un valor arbitrario y una fecha límitepara el trabajo. Debido a que los agentes son interesados en sí mismos, elegirán manipular el algoritmo si lo hace hará que se complete su trabajo;y, de hecho, uno puede encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados en sí mismo mueve el problema del área del diseño de algoritmo al diseño del mecanismo [17], la ciencia de los protocolos de elaboración de los agentes egoístas. Los últimos años han visto mucha actividad en la interfaz de la informática y el diseño del mecanismo (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente y devolverá un cronograma para los trabajos, y cada agente realiza un pago al centro. Un concepto básico de solución del diseño del mecanismo es la compatibilidad de incentivos, que, en nuestro entorno, requiere que siempre sea de cada agente el mejor interés enviar inmediatamente su trabajo al liberar y declarar sinceramente su valor, longitud y fecha límite. Para evaluar un mecanismo utilizando un análisis competitivo, el modelo adversario debe actualizarse. En el nuevo modelo, el adversario aún determina la secuencia de trabajos, pero son los agentes egoístas quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de C, un mecanismo en línea debe ser compatible con incentivos, y siempre lograr al menos 1 c del valor que el mecanismo óptimo o ﬄ ine logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos y revisamos formalmente los resultados de la configuración original no estratégica. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos la configuración de diseño del mecanismo en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + √ k) 2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que K = 1 y cada agente no pueden alterar la longitud de su trabajo. Al devolver el entorno general, mostramos en la Sección 5 que esta relación competitiva es un límite más bajo para los mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos el trabajo relacionado que no sea el directamente relevante [4] y [15], antes de concluir con la Sección 7. 2. Configuración no estratégica En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores.2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutar, y n trabajos, aunque este número no se conoce de antemano. Cada trabajo I se caracteriza por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio θi de posibles tuplas es el mismo para cada trabajo y consiste en todos los θi de modo que Ri, Di, Li, Vi ∈ + (por lo tanto, el modelo del tiempo es continuo). Cada trabajo se libera en el momento RI, momento en el cual se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme (o, difícil), lo que significa que no se obtiene ningún valor para un trabajo que se completa después de su fecha límite. Se permite la prevención de trabajos, y no lleva tiempo cambiar entre trabajos. Por lo tanto, el trabajo I se completa si y solo si el tiempo total se ejecuta en el procesador antes de DI es al menos Li. Sea θ = (θ1, ..., θn) denota el vector de tuplas para todos los trabajos, y vamos θ - i = (θ1, ..., θi - 1, θi+1, ..., Θn) denota elEl mismo vector sin la tupla para el trabajo i. Por lo tanto, (θi, θ - i) denota un vector completo de tuplas. Defina la densidad de valor ρi = vi li del trabajo I para ser la relación de su valor hasta su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La relación de importancia se define como ρmax ρmin, la relación máxima de densidades de valor entre dos trabajos. Se supone que el algoritmo siempre conoce una K superior en la relación de importancia. Para simplificar, normalizamos el rango de posibles densidades de valor para que ρmin = 1. Un algoritmo en línea es una función F: θ1 ×...× θn → O que mapea el vector de tuplas (para cualquier número n) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S: + → {0, 1 ,..., N}, que mapea cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo transcurrido total que ha gastado un trabajo en el procesador en el momento t, usaremos la función ei (t) = t 0 µ (s (s (x) = i) dx, donde µ (·) es una función indicadoraEso devuelve 1 si el argumento es verdadero, y cero de lo contrario. Se define una laxitud de empleos en el momento t para ser di - t - li + ei (t), la cantidad de tiempo que puede permanecer inactiva y aún completar su fecha límite. Un trabajo se abandona si no se puede completar en su fecha límite (formalmente, si di −t+ei (t) <li). Además, sobrecarga S (·) y Ei (·) para que también puedan tomar un vector θ como argumento. Por ejemplo, S (θ, t) es la taquigrafía para el s (t) del resultado F (θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no se puede ejecutar antes de su tiempo de liberación, el espacio de posibles resultados está restringido en el que s (θ, t) = I implica ri ≤ t.Además, debido a que el algoritmo en línea debe producir el cronograma a lo largo del tiempo, sin el conocimiento de las entradas futuras, debe tomar la misma decisión en el tiempo t para las entradas que son indistinguibles en este momento. Formalmente, deje θ (t) denota el subconjunto de las tuplas en θ que satisfacen ri ≤ t.La restricción es entonces que θ (t) = θ (t) implica s (θ, t) = s (θ, t). La función objetivo es la suma de los valores de los trabajos que se completan por sus respectivos plazos: W (O, θ) = I vi · µ (Ei (θ, DI) ≥ Li). Deje w ∗ (θ) = maxo∈O w (o, θ) denota el valor total máximo posible para el perfil θ. En el análisis competitivo, se evalúa un algoritmo en línea comparándolo con un algoritmo ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ ﬄ. Debido a que el algoritmo O ﬄ ine conoce la entrada completa θ en el momento 0 (pero aún no puede iniciar cada trabajo I hasta el tiempo RI), siempre logra w ∗ (θ). Un algoritmo en línea f (·) es (estrictamente) C competitivo si no existe una entrada θ tal que c · w (f (θ), θ) <w ∗ (θ). También se dice que un algoritmo que es competitivo en C alcanza una relación competitiva de c.Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [TS, TF] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y fecha límite caen dentro del período de tiempo excede la duración del intervalo (formalmente, si TF −ts ≤ i | (TS≤ri, di≤tf) li). Sin tal suposición, no es posible lograr una relación competitiva finita [15].2.2 Resultados anteriores en la configuración no estratégica, [4] presenta un algoritmo de 4 competitivo llamado TD1 (Versión 2) para el caso de K = 1, mientras que [15] presenta un algoritmo competitivo de 2 (1+ √ k) llamadoDover para el caso general de K ≥ 1. Los límites inferiores coincidentes para los algoritmos deterministas para ambos casos se mostraron 62 en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (Versión 2) divide el cronograma en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a esta TB de tiempo) y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud;Sin embargo, para el resto del intervalo, la preferencia del trabajo activo solo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos enumerados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prevención durante este intervalo, porque el Job 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en TB = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda finalizar, la preferencia se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si evitar el trabajo activo, TD1 (versión 2) usa dos variables más: pérdida de TE y P. El primero registra la última fecha límite de un trabajo que se abandonará si el trabajo activo se ejecuta para su finalización (o, si no existe dicho trabajo, el momento en que el trabajo activo terminará si no está previsto). En este caso, TE = 17.0. El valor TE −TB representa el límite superior en la cantidad de tiempo de ejecución posible perdido al algoritmo ﬄ ﬄ ﬄ ﬄ ine debido a la finalización del trabajo activo. La otra variable, P pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo O ﬄ ine puede completarlo fuera del rango [TB, TE] .1 Si el algoritmo completa el trabajo activo y esta duración de los trabajos es al menos TE -TB +P Pérdida 4 4Luego, se garantiza que el algoritmo es 4 competitivo para este intervalo (tenga en cuenta que K = 1 implica que todos los trabajos tienen la misma densidad de valor y, por lo tanto, esas longitudes pueden usarse para calcular la relación competitiva). Debido a que este no es el caso en el momento 4.8 (ya que TE −tb +P pérdida 4 = 17.0−0.9 +4.0 4> 4.0 = L2), el algoritmo se adelanta al trabajo 2 para el trabajo 3, que luego se ejecuta para su finalización. Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6?6?6? Tabla 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan RI y DI, respectivamente, mientras que la longitud de la caja es igual a Li.3. Configuración de diseño del mecanismo Sin embargo, la información falsa sobre el trabajo 2 causaría que TD1 (versión 2) complete este trabajo. Por ejemplo, si el plazo del trabajo 2S se declarara como ˆd2 = 4.7, entonces tendría cero laxitud en el momento 0.7. En este momento, el algoritmo evitaría el trabajo 1 para el trabajo 2, porque la pérdida de TE -TB +P 4 = 4.7−0.0 +1.0 4> 0.9 = L1. El trabajo 2 se completaría antes de la llegada del trabajo 3.2 1, mientras que sería fácil alterar el algoritmo reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida de P.2 Si bien no describiremos lo significativamente más complejo para abordar problemas de incentivos como este, necesitamos formalizar la configuración como un problema de diseño de mecanismo. En esta sección primero presentamos la formulación de diseño del mecanismo y luego definimos nuestros objetivos para el mecanismo.3.1 Formulación Existe un centro, que controla el procesador y los agentes de N, donde el centro es desconocido por el centro de antemano. Cada trabajo I es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes θi ∈ θi. En el momento RI, el agente I observa en privado su tipo θi y no tiene información sobre el trabajo I antes de RI. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela solo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo γ = (θ1, ..., θn, g (·)), en el que cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g: Θ1 ×... × θn → o mapas los tipos declarados a un resultado o ∈ O. Un resultado O = (S (·), P1, ..., PN) consiste en un horario y un pago de cada agente al mecanismo. En una configuración de diseño de mecanismo estándar, el resultado se aplica al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, elegimos modelar devolver el trabajo si se completa y recolectar un pago de cada agente que ocurre en ˆDi, que, según la declaración de los agentes, es el últimopunto de tiempo relevante para ese agente. Es decir, incluso si el trabajo I se completa antes de ˆDI, el centro no devuelve el trabajo al agente I hasta ese momento. En cambio, esta decisión de modelado podría verse como una decisión por el diseñador de mecanismos de un espacio más grande de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completo es crucial para nuestro mecanismo. Cada utilidad de agentes, ui (g (ˆθ), θi) = vi · µ (ei (ˆθ, di) ≥ li) · µ (ˆdi ≤ di)-pi (ˆθ), es una función cuasi-lineal de su valor paraSu trabajo (si está completado y devuelto por su verdadero plazo) y el pago que realiza al centro. Suponemos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en que un agente no puede declarar una longitud más corta que la longitud verdadera, ya que el centro podría detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general permitiremos que los agentes declaren longitudes más largas, ya que en algunos entornos puede ser posible agregar trabajo innecesario a un trabajo. Sin embargo, también consideraremos una formulación restringida en la que no es posible este tipo de mentira. El tiempo de liberación declarado ˆri es el momento en que el agente elige enviar el trabajo I al centro, y no puede preceder al tiempo RI en el que el trabajo se revela al agente. El agente puede declarar una fecha límite o valor arbitraria. Para resumir, el agente I puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico, fue suficiente que el algoritmo conocer la K de límite superior en la relación ρmax ρmin, en la configuración de diseño del mecanismo fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de posibles densidades de valor) .3 Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior mostraremos en la Sección 5 implica que la información falsa también puede beneficiar un trabajo en Dover.3 Tenga en cuenta que luego podríamos forzar las declaraciones de agentes para satisfacer ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63, mientras que creemos que es poco probable que un centro conozca a K sin conocer este rango, luego presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que s (ˆθ, t) = I implica ˆri ≤ t, para capturar el hecho de que un trabajo no puede programarse en el procesador antes de que se declare al mecanismo. Como antes, se permite la prevención de trabajos, y el cambio de trabajo no lleva tiempo. Las restricciones debidas a los mecanismos en línea falta de conocimiento del futuro son que ˆθ (t) = ˆθ (t) implica s (ˆθ, t) = s (ˆθ, t), y ˆθ (ˆdi) = ˆθ (ˆdi) implicaPi (ˆθ) = Pi (ˆθ) para cada agente i. La configuración se puede resumir de la siguiente manera.1 Overview de la configuración: para todo T, el centro instancia s (ˆθ, t) ← i, para algunos i s.t.ˆRi ≤ t if ∃i, (ri = t) entonces θi se revela al agente I si ∃i, (t ≥ ri) y el agente I no ha declarado un trabajo, entonces el agente puedo declarar cualquier trabajo ˆθi, s.t.ˆRi = t y ˆli ≥ li if ∃i, (ˆdi = t) ∧ (ei (ˆθ, t) ≥ li) luego el trabajo completado I se devuelve al agente I si ∃i, (ˆdi = t) luego se establece el centro y recogePago PI (ˆθ) del Agente I 3.2 Objetivos del mecanismo Nuestro objetivo como diseñador de mecanismo es maximizar el valor de los trabajos completos, sujeto a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente I, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puedo aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo γ satisface la compatibilidad de incentivos (ic) si ∀i, θi, θi, ˆθ - i: ui (g (θi, ˆθ - i), θi) ≥ ui (g (θi, ˆθ−i), θi) deUna perspectiva del agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la cual se extraen otros tipos de agentes. Desde una perspectiva del diseñador de mecanismo, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará según él. Por estas razones, en este documento requerimos estrategias dominantes, en oposición a un concepto de equilibrio más débil, como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 Disminución del límite inferior en la relación competitiva.4 Un posible argumento contra la necesidad de compatibilidad con incentivos es que una mentira de los agentes en realidad puede mejorar el horario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa ˆd2 = 4.7. Sin embargo, si un agente se encuentra debido a creencias incorrectas sobre los aportes futuros, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se liberara, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes y, por lo tanto, no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Si bien restringirnos a los mecanismos directos compatibles con incentivos puede parecer limitante al principio, el principio de revelación para las estrategias dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad de generalidad. El segundo objetivo para nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo γ satisface la racionalidad individual (ir) si ∀i, θi, ˆθ - i, ui (g (θi, ˆθ - i), θi) ≥ 0. Finalmente, la función de bienestar social que nuestro objetivo es maximizar es la misma que la función objetivo de la configuración no estratégica: W (O, θ) = I VI · µ (EI (θ, DI) ≥ Li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando un análisis competitivo para compararlo con un mecanismo óptimo ﬄ ﬄ ine (que denotaremos con γoffline). Un mecanismo o ﬄ ine conoce todos los tipos en el tiempo 0 y, por lo tanto, siempre puede lograr w ∗ (θ) .5 Definición 3. Un mecanismo en línea γ es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de tipos de agentes θ tal que c · w (g (θ), θ) <w ∗ (θ).4. Resultados En esta sección, primero presentamos nuestro resultado positivo principal: A (1+ √ K) 2 +1 -Competitivo Mecanismo (γ1). Después de proporcionar cierta intuición de por qué γ1 satisface la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la relación competitiva. Luego consideramos un caso especial en el que K = 1 y los agentes no pueden mentir sobre la longitud de su trabajo, lo que nos permite alterar este mecanismo para que ya no requiere conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la más alta prioridad: (ˆvi + √ k · ei (ˆθ, t) · ρmin). A cada agente cuyo trabajo se completa se le cobra el valor más bajo que podría haber declarado de tal manera que su trabajo aún se habría completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, γ1 satisface tanto el IC con respecto a los valores como al IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación anterior, una longitud más corta o una fecha límite posterior) podría disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que el tercero causaría que el trabajo, si se completa, se devuelve al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completo en su fecha límite declarada, en lugar de en el punto en el que se completa.5 Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el momento 0, y obligar a γoffline a ser compatible con incentivos para que los agentes declaren sinceramente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que la ejecución de un mecanismo VCG (ver, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social.64 Mecanismo 1 γ1 Ejecutar s (ˆθ, ·) según el algoritmo 1 para todo lo que hago si ei (ˆθ, ˆdi) ≥ ˆli {agente es el trabajo que se completa} entonces pi (ˆθ) ← arg minvi≥0 (ei (((((((((((((((((((ei (ei ((ei ((ei ((ei (((ei ((ei ((ei ((ei (((eiˆRi, ˆdi, ˆli, vi), ˆθ -i), ˆdi) ≥ ˆli) else Pi (ˆθ) ← 0 Algoritmo 1 Para todos los to HACE ← {i | (t ≥ ˆri) ∧ (ei (ˆθ, t)<ˆLi) ∧ (ei (ˆθ, t)+ ˆdi-t ≥ ˆli)} {conjunto de todos los trabajos liberados, no completados, no abandonados} si disponibles = ∅ entonces s (ˆθ, t) ← arg maxi∈Atail(ˆVi + √ k · ei (ˆθ, t) · ρmin) {rompa lazos a favor de ˆri} más s (ˆθ, t) ← 0 Sigue a argumentar por qué un agente no tiene incentivos para empeorar su trabajo. Los únicos efectos posibles de una longitud inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente están causando que se abandonen y que se devuelva antes (lo que no tiene efecto sobrela utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considere un mecanismo γ1 que difiere de γ1 en el sentido de que no se adelanta al trabajo activo I a menos que exista otro trabajo j tal que (ˆVi + √ k · li (ˆθ, t) · ρmin) <ˆvj. Tenga en cuenta que a medida que un trabajo activo se acerca a la finalización en γ1, su condición para la preferencia se acerca a la de γ1. Sin embargo, los tipos en la Tabla 2 para el caso de K = 1 muestran por qué un agente puede tener un incentivo para retrasar la llegada de su trabajo bajo γ1. El trabajo 1 se activa en el momento 0, y el trabajo 2 se abandona en su liberación en el momento 6, porque 10 + 10 = V1 + L1> V2 = 13. Luego, en el momento 8, el trabajo 1 se prevenga por el trabajo 3, porque 10 + 10 = v1 + l1 <v3 = 22. El trabajo 3 luego se ejecuta hasta la finalización, lo que obliga a Job 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el tiempo 8, desde 13 + 13 = v2 + l2> v3 = 22. Por lo tanto, si el Agente 1 hubiera declarado falsamente ˆR1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 se habría completado durante el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6?6?6? Tabla 2: Los trabajos utilizados para mostrar por qué una versión ligeramente alterada de γ1 no sería compatible con incentivos con respecto a los tiempos de lanzamiento. Intuitivamente, γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se activa, debe tener una prioridad mayor que todos los demás trabajos disponibles. En segundo lugar, debido a que una prioridad de empleos solo puede aumentar a través del aumento de su tiempo transcurrido, EI (ˆθ, t), la tasa de aumento de una prioridad de empleos es independiente de sus características. Estas dos propiedades juntas implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador.4.1 Prueba de racionalidad individual y compatibilidad de incentivos Después de presentar la prueba (trivial) de IR, dividimos la prueba de IC en Lemmas. Teorema 1. El mecanismo γ1 satisface la racionalidad individual. Prueba. Para arbitrary i, θi, ˆθ - i, si el trabajo I no se completa, entonces el agente i no paga nada y, por lo tanto, tiene una utilidad de cero;es decir, pi (θi, ˆθ - i) = 0 y ui (g (θi, ˆθ - i), θi) = 0. Por otro lado, si se completa el trabajo I, entonces su valor debe exceder el agente es el pago. Formalmente, ui (g (θi, ˆθ - i), θi) = vi - arg minvi≥0 (ei (((ri, di, li, vi), ˆθ -i), di) ≥ li) ≥ 0 debe sostener, ya que vi = vi satisface la condición. Para demostrar, debemos mostrar que para un agente arbitrario I, y un perfil arbitrario ˆθ - i de declaraciones de los otros agentes, agente que nunca puedo obtener haciendo una declaración falsa ˆθi = θi, sujeto a las restricciones que ˆri ≥Ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆVI, si las declaraciones veraces de RI, DI y LI no hacen que se complete el trabajo I, entonces peores declaraciones de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ y li yˆDi ≤ Di) nunca puede hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo γ1, la siguiente condición es válida para todos los i, θi, ˆθ - i: ∀ ˆVi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ - i),ˆDi ≥ ˆli = ⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ - i), ˆdi ≥ ˆli prueba. Suponga por contradicción que esta condición no se mantiene, es decir, el trabajo I no se completa cuando RI se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ RI. Primero analizamos el caso en el que el tiempo de lanzamiento se declara sinceramente, y luego mostramos ese trabajo que no puedo completar cuando el agente me retraso que lo envía al centro. Caso I: el agente I declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, defina los siguientes tres puntos en la ejecución del trabajo i.• Sea ts = arg mint s ((ˆθi, ˆθ - i), t) = ser el tiempo en que el trabajo i inicia la ejecución.• Sea tp = arg mint> ts s ((ˆθi, ˆθ - i), t) = ser el tiempo en que el trabajo I se preempete primero.• Sea ta = arg mint ei ((ˆθi, ˆθ - i), t) + ˆdi - t <ˆli sea el momento en que el trabajo I está abandonado.65 Si TS y TP están indefinidos porque el trabajo I nunca se activa, entonces Ts = tp = Ta. Además, divide los trabajos declarados por otros agentes antes de TA en los siguientes tres sets.• x = {j | (ˆrj <tp) ∧ (j = i)} consiste en los trabajos (que no sean) que llegan antes del trabajo I primero se adelantan.• y = {j | (tp ≤ ˆrj ≤ ta) ∧ (ˆVJ> ˆVi + √ k · ei ((ˆθi, ˆθ -i), ˆrj)} consiste en los trabajos que llegan a la gama [TP, TA] yque cuando llegan tienen una prioridad más alta que el trabajo I (tenga en cuenta que estamos utilizando la normalización). • Z = {J | (tp ≤ ˆrj ≤ ta) ∧ (ˆVJ ≤ ˆVi + √ k · ei ((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan al rango [TP, TA] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (TP, TA] deben ser I o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se mantenga trivialmente), debe ser el caso de que el trabajo I tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el momento TP, ya que en ese momento solo el trabajo de TP era disponible y el trabajo estaba disponible y el trabajoEstaba activo. Formalmente, ˆvx + √ k · ex ((ˆθi, ˆθθ - i), tp) <ˆVi + √ k · ei ((ˆθi, ˆθ -i), tp) debe sostener.6 podemos mostrar que, sobre el rango[TP, TA], no hay trabajo x ∈ X se ejecuta en el procesador. Suponga por contradicción que esto no es cierto. Sea tf ∈ [tp, ta] el primer momento en este rango de que algún trabajo x ∈ X está activo, lo que implica que ex ((ˆθi, ˆθ - i), tf) = ex ((ˆθi, ˆθ - i),tp). Luego podemos mostrar que el trabajo I tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k · ex ((ˆθi, ˆθ - i), tf) = ˆvx+ √ k · ex ((ˆθi, ˆθ−i), tp)<ˆVi + √ k · ei ((ˆθi, ˆθ - i), tp) ≤ ˆVi + √ k · ei ((ˆθi, ˆθ - i), tf), contradiciendo el hecho de que el trabajo X está activo en el tiempo TF. Un argumento similar se aplica a un trabajo arbitrario Z ∈ Z, comenzando en el tiempo de liberación de TI ˆrz> TP, ya que por definición del trabajo I tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (TP, TA] son yo y los del conjunto Y. Caso II: el agente I declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri> ri. Ahora mostramos ese trabajo que no puedo completar en este caso, dado que no se completó en el caso de I. Primero, podemos restringir el rango de ˆri que debemos considerar de la siguiente manera. Declarar ˆri ∈ (RI, TS] no afectaría el horario, ya que TS seguiría siendo la primera vez que ejecuta el trabajo I. Además, declarar ˆri> ta no podría hacer que el trabajo se complete, ya que di - ta <ˆli se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts, ta]. Para que declare ˆθi para que se complete el trabajo I, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (TP, TA], ya que los únicos trabajos distintos de yo que están activos durante ese rangoestán en y. Sea tc = arg mint∈ (tp, ta] [∃yc ∈ Y, (s ((ˆθi, ˆθ - i), t) = yc) ∧ (s ((ˆθi, ˆθ - i), t) = yc)] ser la primera vez que ocurre tal cambio. Ahora mostraremos que para cualquier ˆri ∈ (ts, ta], no puede existir un trabajo con mayor prioridad que yc en el tiempo tc, contradiciendo (s ((ˆθi, ˆθ - i), t) = yc). Primero tenga en cuenta que el trabajo no puedo tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) de modo que ∃y ∈ 6 por simplicidad, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otraJob Y, asumiremos que la prioridad del trabajo XS es estrictamente mayor que el trabajo, porque, en el caso de un empate que favorece X, los lazos futuros también se romperían a favor del Job X.Y, (s ((ˆθi, ˆθ - i), t) = y) ∧ (s ((ˆθi, ˆθ - i), t) = i), contradiciendo la definición de TC. Ahora considere un arbitrario y ∈ Y tal que y = yc. En el caso de que yo, sabemos que Job Y tiene menor prioridad que YC en el momento TC;es decir, ˆvy + √ k · ey ((ˆθi, ˆθ - i), tc) <ˆvyc + √ k · eyc ((ˆθi, ˆθ - i), tc). Por lo tanto, pasar al Caso II, el trabajo Y debe reemplazar algún otro trabajo antes de TC. Dado que ˆry ≥ tp, la condición es que debe existir algunos t ∈ (tp, tc) tal que ∃w ∈ Y ∪ {i}, (s ((ˆθi, ˆθ - i), t) = w) ∧ (s((ˆΘi, ˆθ - i), t) = y). Dado que w ∈ Y contradeciría la definición de TC, sabemos que w = i. Es decir, el trabajo que reemplaza Y debe ser i. Por definición del conjunto y, sabemos que ˆvy> ˆvi + √ k · ei ((ˆθi, ˆθ - i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo no podría haber ejecutado en lugar de y en el caso I. Por otro lado, si ˆry> t, entonces el trabajo y obviamente no podía ejecutar en el momento t, contradiciendo la existencia de tal tiempo t.Ahora considere un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo I tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex ((ˆθi, ˆθ - i), ts) <ˆvi + √ k · ei (((ˆΘi, ˆθ - i), ts). También sabemos que ˆVi + √ k · ei ((ˆθi, ˆθ - i), tc) <ˆvyc + √ k · eyc ((ˆθi, ˆθ - i), tc). Dado que la demora en la llegada no afectará la ejecución hasta el tiempo, y dado que el trabajo X no puede ejecutar en lugar de un trabajo y en cualquier momento t ∈ (tp, tc] por definición de tc, la única forma de prioridad de trabajo xsAumente antes de TC a medida que avanzamos del caso I al II es reemplazar el trabajo I por el rango (TS, TC]. Por lo tanto, un límite superior en el trabajo XS prioridad cuando el agente I declara ˆθi es: ˆvx+ √ k · ex ((ˆθi, ˆθ -i), ts)+ ei ((ˆθi, ˆθ - i), tc) −ei ((ˆθi,, ˆΘ - i), ts) <ˆVi + √ k · ei ((ˆθi, ˆθ - i), ts) + ei ((ˆθi, ˆθ - i), tc) −Ei ((ˆθi, ˆθ - i),ts) = ˆVi + √ k · ei ((ˆθi, ˆθ - i), tc) <ˆvyc + √ k · eyc ((ˆθi, ˆθ - i), tc). Por lo tanto, incluso en este límite superior, Job YC ejecutaría en lugar del trabajo X en el momento TC. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en el tiempo de liberación ˆrz. Dado que los conjuntos {I}, X, Y, Z dividen el conjunto de trabajos publicados antes de TA, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de TC y completando la prueba. Lema 3. En el mecanismo γ1, la siguiente condición es válida para todos los i, θi, ˆθ - i: ∀ ˆVi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆVi), ˆθ - i), ˆdi ≥ ˆli = =⇒ ei ((ri, di, li, ˆvi), ˆθ - i), ˆdi ≥ li prueba. Suponga que por contradicción existe cierta instanciación de las variables anteriores, de modo que el trabajo I no se completa cuando Li y Di se declaran sinceramente, pero se completa para algunos par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Tenga en cuenta que el único efecto que ˆDi y ˆli tienen en la ejecución del algoritmo está en si está disponible o no. Específicamente, afectan las dos condiciones: (ei (ˆθ, t) <ˆli) y (ei (ˆθ, t) + ˆdi - t ≥ ˆli). Debido a que el trabajo I se completa cuando se declaran ˆli y ˆDi, la condición anterior (para completar) debe volverse falsa antes de la segunda. Dado que declarar con sinceramente Li ≤ ˆli y Di ≥ ˆdi solo hará que la condición anterior se vuelva falsa antes y la última condición se vuelva falsa más adelante, la ejecución del algoritmo no se verá afectada cuando se mude a declaraciones veraces, y el trabajo I será completado, uncontradicción. Ahora usamos estos dos lemas para demostrar que el pago de un trabajo completado solo puede aumentar al declarar falsamente peor ˆli, ˆdi y ˆri.66 Lema 4. En el mecanismo γ1, la siguiente condición es válida para todos los i, θi, ˆθ - i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ-i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ - i), di ≥ li prueba. Suponga por contradicción que esta condición no se mantiene. Esto implica que existe algún valor vi de tal manera que la condición (ei (((ˆri, ˆdi, ˆli, vi), ˆθ - i), ˆdi) ≥ ˆli) se mantenga, pero (ei ((((ri, di, li,vi), ˆθ - i), di) ≥ li) no lo hace. Aplicando lemas 2 y 3: (ei (((ˆri, ˆdi, ˆli, vi), ˆθ - i), ˆdi) ≥ ˆli) = ⇒ (ei (((ri, ˆdi, ˆli, vi), ˆθ - i), ˆDi) ≥ ˆli) = ⇒ (ei (((ri, di, li, vi), ˆθ - i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótono en su valor declarado. Lema 5. En el mecanismo γ1, la siguiente condición es válida para todos los i, ˆθi, ˆθ - i: ∀ ˆVi ≥ ˆVi, ei ((ˆri, ˆdi, ˆli, ˆVi), ˆθ - i), ˆdi ≥ ˆli = ⇒ ei ((ˆri,,ˆDi, ˆli, ˆvi), ˆθ - i), ˆdi ≥ ˆli la prueba, por contradicción, de esta lema se omite porque es esencialmente idéntica a la de Lemma 2 para ˆri. En el caso I, el agente I declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos luego procede como antes: la ejecución no cambiará hasta el tiempo TS porque la prioridad inicial del trabajo I disminuye a medida que avanzamos del caso I al II;y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea yo en el rango (TP, TA]. Ahora podemos combinar los lemas para mostrar que no es posible una desviación rentable. Teorema 6. El mecanismo γ1 satisface la compatibilidad de incentivos. Prueba. Para un agente arbitrario I, sabemos que ˆri ≥ ri y ˆli ≥ li se mantienen por suposición. También sabemos que el agente I no tiene ningún incentivo para declarar ˆDi> di, porque Job I nunca sería devuelto antes de su verdadera fecha límite. Luego, debido a que la función de pago no es negativa, el agente es la utilidad no podría exceder el cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisface ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente usando IR, podemos restringir aún más la consideración a ˆθi que hace que el trabajo I se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo I se complete, entonces por Lemma 4, dicha declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que se complete el trabajo I, entonces declarar que tal ˆθi hará que el agente I tenga una utilidad negativa, ya que vi <arg minvi≥0 ei (((ri, di, li, vi), ˆΘ - i), ˆdi) ≥ li ≤ arg minvi≥0 ei (((ˆri, ˆdi, ˆli, vi), ˆθ - i), ˆdi) ≥ ˆli se mantiene por Lemmas 5 y 4, respectivamente.4.2 Prueba de relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo mostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos mostrado IR, para demostrar la relación competitiva, sigue siendo limitar la pérdida de bienestar social contra γoffline. Denota por (1, 2, ..., f) la secuencia de trabajos completados por γ1. Divida el tiempo en intervalos de = (abierto F, cierre F], uno para cada trabajo F en esta secuencia. Establezca TClose F como el tiempo en el que se completa el trabajo F, y configure Topen F = TClose F - 1 para F ≥ 2, y Topen 1 = 0 para F = 1. Además, deje que Tbegin F sea la primera vez que el procesador no está inactivo en el intervalo si. Lema 7. Para cualquier intervalo si, la siguiente desigualdad se mantiene: tclose f - tbegin f ≤ (1 + 1√ k) · Vf prueba. Intervalo si comienza con un período de tiempo (posiblemente cero) en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2, ..., c), donde cada trabajo I en esta secuencia es previsto por el trabajo I + 1, excepto el trabajo C, que se completa (por lo tanto, el trabajo C enEsta secuencia es la misma que el trabajo F es la secuencia global de trabajos completos). Deja que sea el momento en que el trabajo comience a la ejecución. Tenga en cuenta que TS 1 = tbegin f. En el rango [tbegin f, tclose f], la prioridad (vi+ √ k · ei (θ, t)) del trabajo activo aumenta monotónicamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo y solo puede aumentarEn un momento en que ocurre la preferencia. Por lo tanto, cada trabajo i> 1 en esta secuencia comienza la ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activa. Ahora mostramos que el valor del trabajo C completado excede el producto de √ k y el tiempo que pasa en el intervalo en los trabajos 1 a C - 1, o, más formalmente, que la siguiente condición se mantiene: VC ≥ √ K C - 1 H= 1 (eh (θ, ts h+1) - eh (θ, ts h)). Para mostrar esto, demostraremos por inducción que la condición más fuerte VI ≥ √ k i - 1 h = 1 eh (θ, ts h+1) se mantiene para todos los trabajos i en la secuencia. Caso base: para i = 1, v1 ≥ √ k 0 h = 1 eh (θ, ts h+1) = 0, ya que la suma supera cero elementos. Paso inductivo: para un arbitrario 1 ≤ i <c, suponemos que vi ≥ √ k i - 1 h = 1 eh (θ, ts h+1) se mantiene. En el tiempo TS i+1, sabemos que vi+1 ≥ Vi+√ k · ei (θ, ts i+1) se mantiene, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h = 1 eh (θ, ts h+1), completando el paso inductivo. También sabemos que TClose f - ts c ≤ lc ≤ vc debe mantener, al simplificar la normalización de ρmin = 1 y el hecho de que el tiempo de ejecución de CS de trabajo no puede exceder su longitud. Podemos unir el tiempo de ejecución total de IF por: tclose f - tbegin f = (tclose f −ts c)+ c - 1 h = 1 (eh (θ, ts h+ 1) −eh (θ, ts h)) ≤ (1+ 1√ k) Vf. Ahora consideramos la posible ejecución de trabajos incompletos por γoffline. Asociar cada trabajo I que no se completa con γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos ahora están asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo puedo ser abandonado después del cierre del último intervalo en TClose f. Debido a que el procesador está inactivo después de TClose F, cualquier trabajo de este tipo que yo volviera activo en algún momento T ≥ tclose F, lo que conduciría a la finalización de algún trabajo, crea un nuevo intervalo y contradice el hecho de que si es el último.67 El siguiente lema es equivalente al lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo si y cualquier trabajo que abandonara en IF, la siguiente desigualdad es válida: vi ≤ (1 + √ k) vf. Prueba. Suponga por contradicción que existe un trabajo en el que abandoné si tal que vi> (1 + √ k) vf. En TClose F, la prioridad del trabajo F es vf + √ k · lf <(1 + √ k) vf. Debido a que la prioridad del trabajo activo aumenta monotónicamente en el rango [tbegin f, tclose f], el trabajo I tendría una prioridad más alta que el trabajo activo (y, por lo tanto, comenzaría la ejecución) en algún momento t ∈ [tbegin f, tclose f]. Una vez más, aplicando monotonicidad, esto implicaría que la prioridad del trabajo activo en TClose F excede (1 + √ k) VF, contradiciendo el hecho de que es (1 + √ k) VF. Como en [15], para cada intervalo IF, le damos a γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al VF adversario, ya que el adversario puede completar este trabajo en algún momento futuro, debido al hecho de que γ1 ignora los plazos. El siguiente lema es Lema 5.10 en [15], y su prueba ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante si no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el regalo de K · (tclose f −tbegin f) (intuitivamente, esto es equivalente a ejecutar trabajos con la densidad de valor máxima posible a lo largo del tiempoque γ1 está activo), y luego comience la ejecución de un trabajo abandonado por γ1 justo antes de TClose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo γ1 es (1+ √ k) 2+ 1 -competitivo. Prueba. Utilizando el hecho de que la forma en que los trabajos están asociados con los intervalos particionan todo el conjunto de trabajos, podemos mostrar la relación competitiva al mostrar que γ1 es (1+ √ k) 2 +1 -competitivo para cada intervalo en la secuencia (1, ..., f). En un intervalo arbitrario si, el algoritmo O ﬄ ine puede lograr como máximo (tclos f −tbegin f) · k+vf+(1+ √ k) vf, de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando el lema 7, esta cantidad se limita desde arriba por (1+ 1√ k) · vf · k+ vf+ (1+ √ k) vf = ((1+ √ k) 2 +1) · vf. Dado que γ1 logra VF, la relación competitiva es válida.4.3 Caso especial: longitud inalterable y k = 1, mientras que hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, no es posible mentir sobre la longitud del trabajo en algunos entornos. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alargue el trabajo y permita que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos son las densidades de valor uniformes (k = 1), que fue el caso considerado por [4]. Si la configuración satisface estas dos condiciones, entonces, al usar el mecanismo γ2, podemos lograr una relación competitiva de 5 (que es la misma relación competitiva que γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos que sean más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en el que los usuarios aún se interestan en sí mismas.7 Mecanismo 2 γ2 Ejecutar S (ˆθ, ·) según el algoritmo 2 para todosyo hago pi (ˆθ) ← 0 algoritmo 2 para todos t hove ← {i | (t ≥ ˆri) ∧ (ei (ˆθ, t) <li) ∧ (ei (ˆθ, t)+ ˆdi - t ≥ li)} si disponible = ∅ entonces s (ˆθ, t) ← arg maxi∈Avil (li + ei (ˆθ, t)) {rompa lazos a favor de ˆri} más s (ˆθ, t) ← 0 teorema 11. Cuando K = 1, y cada agente no puedo declarar falsamente Li, el mecanismo γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente no puedo declarar falsamente Li, el mecanismo γ2 es 5 competitivo. Dado que este mecanismo es esencialmente una simplificación de γ1, omitimos pruebas de estos teoremas. Básicamente, el hecho de que K = 1 y ˆli = Li sostienen permiten que γ2 sustituya la prioridad (li +ei (ˆθ, t)) para la prioridad utilizada en γ1;Y, dado que se ignora ˆVi, los pagos ya no son necesarios para garantizar la compatibilidad de incentivos.5. Un límite inferior competitivo ahora mostramos que la relación competitiva de (1 + √ k) 2 + 1 lograda por γ1 es un límite más bajo para los mecanismos en línea deterministas. Para hacerlo, atraeremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), lo que requiere que el centro nunca paga a un agente (formalmente, ∀i, ˆθ, pi (ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño del mecanismo. Sin embargo, observamos que tanto γ1 como γ2 lo satisfacen trivialmente, y que, en la siguiente prueba, cero solo sirve como una utilidad de referencia para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ-I. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k) 2 en el entorno no estratégico, con la novedad principal en la perturbación de la secuencia de trabajoy los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li + 1 = λ · li - k · i h = 1 lh y l1 = 1, donde (1 + √ k) 2 - 1 <λ <(1 + √ k) 2, existe un número entero m ≥ 1 tal que lm+k · m - 1 h = 1 lh lm> λ.7 Si bien no se requieren pagos en este entorno, γ2 se puede cambiar para cobrar un pago sin afectar la compatibilidad de incentivos cargando una fracción fija de Li por cada trabajo I que se complete.68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga NNP y que logra una relación competitiva menor que (1 + √ k) 2 + 1. Prueba. Suponga por contradicción que existe un mecanismo en línea determinista γ que satisface NNP y que logra una relación competitiva de c = (1 + √ k) 2 + 1 - para algunos> 0 (y, por implicación, satisface IC e IR también). Dado que una relación competitiva de C implica una relación competitiva de C + X, para cualquier x> 0, suponemos sin pérdida de generalidad que <1. Primero, construiremos un perfil de los tipos de agentes θ usando un argumento adversario. Después de posiblemente perturbando ligeramente θ para asegurar que se cumpla una propiedad de estricto, usaremos una perturbación más significativa de θ para alcanzar una contradicción. Ahora construimos el perfil original θ. Elija un α tal que 0 <α <, y defina δ = α CK+3K. El adversario utiliza dos secuencias de empleos: menor y mayor. Los trabajos menores I se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se lanza en el momento 0, y ri = di - 1 para todos i> 1. La secuencia se detiene cada vez que γ completa cualquier trabajo. Los trabajos principales también tienen la laxitud cero, pero tienen la relación de valor más pequeña posible (es decir, vi = li). Las longitudes de los principales trabajos que se pueden liberar, comenzando con i = 1, se determinan por la siguiente relación de recurrencia.li + 1 = (c - 1 + α) · li - k · i h = 1 lh l1 = 1 Los límites en α implican que (1 + √ k) 2 - 1 <c - 1 + α <(1+ √ k) 2, que nos permite aplicar el lema 13. Sea M el número positivo más pequeño de tal manera que LM+K · M - 1 H = 1 LH LM> C - 1+α. El primer trabajo importante tiene un tiempo de liberación de 0, y cada trabajo principal I> 1 tiene un tiempo de liberación de RI = Di - 1 - δ, justo antes de la fecha límite del trabajo anterior. El adversario libera el principal trabajo I ≤ m si y solo si cada trabajo principal J <I fue ejecutado continuamente sobre el rango [RI, RI+1]. No se publica un trabajo importante después del trabajo m.Para lograr la relación competitiva deseada, γ debe completar algún trabajo F importante, porque γoffline siempre puede al menos completar el trabajo principal 1 (por un valor de 1), y γ puede completar como máximo un trabajo menor (para un valor de αC+3 <1 c). Además, para que este trabajo F se publique, el tiempo del procesador anterior a RF solo se puede dedicar a ejecutar trabajos importantes que luego se abandonan. Si f <m, entonces se lanzará el trabajo principal F + 1 y será el trabajo final final. Γ no puede completar el trabajo F +1, porque rf +lf = df> rf +1. Por lo tanto, θ consiste en trabajos principales 1 a F + 1 (o, F, si F = M), más trabajos menores desde el tiempo 0 hasta el tiempo DF. Ahora posiblemente perturbamos θ ligeramente. Por IR, sabemos que VF ≥ PF (θ). Dado que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df están incrementados por δ sobre sus valores respectivos en θf. Por IC, el trabajo F aún debe completarse mediante γ para el perfil (θf, θ - F). Si no, entonces por IR y NNP sabemos que PF (θf, θ - f) = 0, y por lo tanto que UF (g (θf, θ - f), θf) = 0. Sin embargo, el agente F podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: Uf (g (θf, θ - f), θf) = vf - pf (θ) = Δ> 0, violando ic ic. Además, el agente F debe cargarse la misma cantidad (es decir, pf (θf, θ - f) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la prueba, suponga que vf> pf (θ). Ahora usamos una perturbación más sustancial de θ para completar la prueba. Si f <m, entonces define θf para que sea idéntico a θf, excepto que df = df + 1 + lf, lo que permite que el trabajo F se ejecute completamente después de que se complete el trabajo F + 1. Si f = m, entonces, establece df = df +lf. IC requiere que para el perfil (θf, θ - f), γ todavía ejecuta el trabajo f continuamente sobre el rango [RF, RF +LF], evitando que el trabajo F +1 se complete. Suponga por contradicción que esto no era cierto. Luego, en la fecha límite original de DF, el trabajo F no se completa. Considere el perfil posible (θf, θ - f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene cero laxitud, rx = df y vx = lx = max (df - df, (c (c+ 1) · (LF + LF + 1)). Debido a que este nuevo perfil es indistinguible de (θf, θ - f) a γ antes del tiempo DF, debe programar trabajos de la misma manera hasta DF. Luego, para lograr la relación competitiva deseada, debe ejecutar Job X continuamente hasta su fecha límite, que es mediante construcción al menos tan tarde como la nueva fecha límite DF del trabajo f.Por lo tanto, el trabajo F no se completará y, por IR y NNP, debe ser el caso de que pf (θf, θ - f, θx) = 0 y UF (g (θf, θ - f, θx), θf)= 0. Usando el hecho de que θ es indistinguible de (θf, θ - f, θx) hasta el tiempo df, si el agente f declaró falsamente su tipo como el original θf, entonces su trabajo sería completado por DF y se le cobraría PF (θ). Su utilidad aumentaría a UF (g (θf, θ - f, θx), θf) = vf - pf (θ)> 0, contradiciendo IC. Mientras que la ejecución de γS debe ser idéntica para ambos (θf, θ - F) y (θf, θ - F), γoffline puede aprovechar el cambio. Si f <m, entonces γ logra un valor de a lo la mayoría de LF+δ (el valor del trabajo F si se perturbó), mientras que γOffline logra un valor de al menos k · (f h = 1 lh −2Δ)+lf+1+LF ejecutando trabajos menores hasta RF+1, seguido del trabajo F +1 y luego el trabajo F (restamos dos ΔS en lugar de uno porque el último trabajo menor antes de RF+1 puede tener que ser abandonado). Sustituyendo en LF+1, la relación competitiva es al menos al menos: k · (f h = 1 lh - 2Δ)+lf+1+lf lf+δ = k · (f h = 1 lh) −2k · Δ+(c−1 +α) · · lf −k −k · (f h = 1 lh) +lf lf +Δ = c · lf +(α · lf −2k · Δ) lf +δ ≥ c · lf +((ck +3k) δ−2k · δ) lf +δ> c.Si, en cambio, F = M, entonces γ logra un valor de como máximo LM + δ, mientras que γoffline logra un valor de al menos k · (m h = 1 lh - 2δ) + lm completando trabajos menores hasta dm = rm + lm, yluego completando el trabajo m.La relación competitiva es al menos: k · (m h = 1 lh - 2Δ)+lm lm+δ = k · (m - 1 h = 1 lh) −2k · Δ+klm+lm lm+δ> (c− (c−1+α) · LM - 2K · δ+KLM LM+δ = (C+K - 1) · LM+(αLM - 2K · δ) LM+δ> C.6. Trabajo relacionado en esta sección Describimos trabajos relacionados que no sean los dos documentos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo O ﬄ ine (ver, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el Centro posee los trabajos en un entorno de ine, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este documento también lanzó el área del diseño del mecanismo algorítmico, en el que el mecanismo debe SAT69 requisitos computacionales ISFY además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño del mecanismo de intercambio de costos de multidifusión (ver, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multidifusión, si el agente recibe la transmisión y el preciodebe pagar. Para una encuesta de este y otros temas en el diseño de mecanismo algorítmico distribuido, ver [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de compensación del mercado en línea, en el que el subastador coincide con las compras y vende ofertas (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que sea compatible con incentivos con respecto a los valores. La declaración de valores también se considera en [3] y [16], que consideran subastas en línea de múltiples unidades. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que tiene un suministro ilimitado. Se señala en [16] que sus resultados continúan sujetando cuando la configuración se extiende para que los postores puedan retrasar su llegada. El único otro artículo que somos conscientes de que aborda el problema de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna el ancho de banda a los agentes que declaran tanto su valor como su tiempo de llegada. Se presenta una estrategia dominante mecanismo IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras.7. Conclusión En este documento, consideramos un dominio de programación en línea para el cual se encontraron algoritmos con la mejor relación competitiva posible, pero para las cuales se requerían nuevas soluciones cuando la configuración se extiende para incluir agentes interestonados. Presentamos un mecanismo que es un incentivo compatible con respecto al tiempo de liberación, fecha límite, longitud y valor, y que solo aumenta la relación competitiva por uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la longitud de su trabajo. Luego mostramos un límite inferior coincidente en la relación competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en esta configuración. Una es determinar si el límite inferior puede fortalecerse eliminando la restricción de pagos no negativos. Además, aunque creemos que es razonable fortalecer la suposición de conocer la relación máxima posible de las densidades de valor (k) para conocer el rango real de posibles densidades de valor, sería interesante determinar si existe un ((1 + √k) 2 + 1) -Cepetitivo Mecanismo bajo la suposición original. Finalmente, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro.8. Referencias [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en costos compartidos de multidifusión, juegos y comportamiento económico (para aparecer).[2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de los mecanismos en línea que contienen verdad a la optimización en línea, Actas sobre el 35º Simposio sobre la teoría de la computación, 2003. [3] Z. Bar-Yossef, K.Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio ACM-SIAM anual sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra,A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en línea en línea, Journal of Real Time Systems 4 (1992), no.2, 125-144.[5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13º Simposio ACM-SIAM anual sobre algoritmos discretos, 2002. [6] A. Borodin y R. El-Yaniv,Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para la gestión y programación de recursos en computación en la red, The Journal of Concurrence and Computation:Práctica y experiencia 14 (2002), 1507-1542.)Shenker, Diseño de mecanismo algorítmico distribuido: resultados recientes y direcciones futuras, Actas del sexto taller internacional sobre algoritmos y métodos discretos para la computación y comunicaciones móviles, 2002, pp. 1-13.[10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: The State of the Art, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios de WiFi en Starbucksissues en el diseño del mecanismo en línea, EC03,2003. [12] R. L. Graham, límites para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581.[13] B. Kalyanasundaram y K. Pruhs, la velocidad es tan poderosa como Clairvoyance, Journal of the ACM 47 (2000), 617-643.[14] C. Koo, T. Lam, T. Ngan y K. a la programación en línea con plazos ajustados, Teórica Computer Science 295 (2003), 251-261.[15] G. Koren y D. Shasha, D-Over: un algoritmo de programación en línea óptimo para sistemas sobrecargados en tiempo real, Siam Journal of Computing 24 (1995), no.2, 318-339.[16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Green, Microeconomic Theory, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismo algorítmico, Juegos y Comportamiento Económico 35 (2001), 166-196.[19] C. Papadimitriou, Algoritmos, Juegos e Internet, Stoc, 2001, pp. 749-753.70