Indexación de borde en una cuadrícula para entornos virtuales altamente dinámicos ∗ Beomjoo SEO bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 Resumen Sistemas de aplicaciones recientemente emergentes como el segundo como el segundo como el segundo como el segundoLife1 proporciona entornos virtuales 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que los usuarios aumentan continuamente. Para que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se basan en una división de subespacio de cuadrícula basada en el cliente-servidor donde los mundos virtuales se dividen en sub-mundo manejables. En cada sub-mundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados remotamente y los hace de acuerdo con su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan el rendimiento del servidor y la escalabilidad. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y los menos millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial y, por lo tanto, asignamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar como un objeto espacial y un objeto espacial y un objeto espacialconsulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de entornos nuevos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimice el estallido inesperado de objetos y admite una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos nuestro enfoque para sentar las bases para los marcos virtuales de próxima generación que pueden fusionarse con los servicios basados en la web existentes en el futuro cercano. Categorías y descriptores de sujetos: C.2.4 [computadora - redes de comunicación]: sistemas distribuidos - cliente/servidor, aplicaciones distribuidas, bases de datos distribuidas;I.3.7 [gráficos por computadora]: gráficos tridimensionales y realismo - Términos generales de realidad virtual: algoritmos, diseño, rendimiento 1. Introducción Recientemente, los juegos en línea multijugador masivo (MMOGS) se han estudiado como un marco para entornos virtuales de próxima generación. Sin embargo, muchas aplicaciones de MMOG aún se limitan a un enfoque de diseño tradicional donde su complejidad de la escena 3D se controla cuidadosamente por adelantado para cumplir con las limitaciones de representación en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea perfecto, interminable e ilimitado, Marshall et al.[1] identificó cuatro nuevos requisitos2: Extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución);escalabilidad (aunque aumenta el número de usuarios concurrentes, el sistema continúa funcionando de manera efectiva);interactibilidad;e interoperabilidad. En este artículo, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite que los usuarios de juegos regulares implementen su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad de la escena existente, causando problemas de rendimiento en todo el sistema. El apoyo total para la extensibilidad dinámica, por lo tanto, continuará siendo uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, generalmente no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples sub-mundo o replicar mundos en ubicaciones geográficamente dispersas, se puede admitir un número masivo de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo administrado por un solo servidor o un clúster de servidor se limita a varios miles, suponiendo un mundo bastante estacario [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, divide el espacio de manera similar a la red y originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales.402 Avatar Objeto Poppingautónomos Entidades (a) en el tiempo t (b) en el tiempo t+δ Figura 1: El estallido del objeto ocurrió a medida que un usuario avanza (capturas de pantalla desde la segunda vida) donde δ = 2 segundos.Emplea un modelo de transmisión de objetos 3D basado en el cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y proporciona a los usuarios libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque de determinación de visibilidad tradicional tiene un problema de explotación de objetos. Por ejemplo, una casa fuera de un rango visible de los usuarios no se dibuja en el tiempo t, ilustrada en la Figura 1 (a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + δ) como se muestra en la Figura 1 (b). Si δ es pequeño, o la casa es lo suficientemente grande como para colisionar con el usuario, interrumpirá la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud más pequeño que para mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La Sección 2 presenta trabajo relacionado. La Sección 3 describe nuestro nuevo método de vista. En la Sección 4, presentamos suposiciones en nuestra aplicación objetivo e presentamos un nuevo método de indexación espacial diseñado para admitir los cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. La determinación de la visibilidad del trabajo relacionada se ha explorado ampliamente en el campo de los gráficos 3D. Se han propuesto varios algoritmos de representación locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de representación. El sacrificio de visión-frustum, el sacrificio de la cara posterior y el sacrificio de oclusión son algunas de las técnicas de sacrificio de visibilidad bien conocidas [6]. Sin embargo, estos algoritmos suponen que todos los objetos visibles candidatos se han almacenado localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para representar desde las bases de datos del servidor. Teller et al.describió un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadro con el tiempo en tutoriales remotos de escenas 3D complejas de una ruta de navegación de usuarios [5]. Funkhouser et al.demostró que la representación multisolutiva, como los niveles de detalle (LOD), puede usarse para mejorar las velocidades de cuadro de representación y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente llenos de gente. Por otro lado, nuestro modelo de cálculo de visibilidad, un representante de esta categoría, se basa en diferentes supuestos en la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo para admitir cálculos de visibilidad en tiempo real para un número masivo de objetos y usuarios en movimiento. Aquí reconocemos que tales problemas relacionados con los gráficos tienen una similitud muy cercana con los problemas de la base de datos espacial. Recientemente, varias publicaciones han abordado el problema de escalabilidad sobre cómo apoyar un número masivo de objetos y consultas en entornos altamente dinámicos. Para admitir actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en el árbol R y (2) indexación espacial basada en la cuadrícula. El árbol R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por rectángulos mínimos delimitadores (MBR). El modelo de partición basado en la cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir, ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol R y sus variantes (R+ Tree, R ∗ -tree) sufren de una degradación inaceptable del rendimiento en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización ascendente propuesta para R-árboles [9] optimiza las operaciones de actualización del índice mientras se mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para las solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizarse a través de una tabla hash de objeto. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en la cuadrícula para entornos de objetos móviles emergentes. A diferencia de los métodos de indexación espacial tradicionales que construyen un índice en los objetos móviles, construye un índice en las consultas de rango continuo, suponiendo que las consultas se muevan con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasistacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un quadtree y los objetos cuasi-estacionarios se almacenan en un tree r ∗. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta las actualizaciones de objetos recién descubiertos (positivos) o no relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al.[12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto reside en esta región, se garantiza que todos los resultados de la consulta son válidos en el sistema. Si los objetos se mudan de su región, las solicitudes de actualización de ubicación deben entregarse al servidor de la base de datos y las consultas afectadas se reevalúan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La principal diferencia es que nos estamos concentrando más en la determinación de visibilidad en tiempo real, mientras que otros asumen limitaciones de tiempo suelto.3. Modelo de vista iniciado por objetos En esta sección, ilustramos cómo el problema de estallido de objetos puede asociarse con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas en este documento. Las entidades en un espacio virtual se pueden clasificar en tres tipos 403 en función de su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil ordinario o estacionario que puede ser visible para otras entidades. La entidad del espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación de punto. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona similar al control de una cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos la entidad del objeto término para referirnos a una entidad autónoma o un avatar mientras usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro del cual cualquier otra entidad puede reconocer su existencia. Se basa en las suposiciones de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento y cada usuario posee la misma visibilidad. Por lo tanto, el usuario y el objeto, solo cuando su distancia actual es más pequeña o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un área circular de interés (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios direccionales rápidos sin ninguna interrupción de visualización en la periferia del área visible. Sin embargo, empleamos un AOI squarado a expensas de la precisión porque la extensión espacial de forma cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en la cuadrícula. El modelo de vista tradicional, que llamamos modelo de vista iniciado por el usuario, supone que una entidad de usuario tiene una AOI, mientras que una entidad de objeto no. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su sobrecarga de baja indexación, muchos servicios basados en la ubicación (LBSS) y las aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un problema grave de estallido de objetos durante la navegación. Recuerde, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t.De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el momento t.Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema de estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objetos. Todas las entidades de objetos tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades de espectadores no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIS cubren su ubicación de punto. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema de estallido de objetos siempre que el sistema subyacente pueda administrar el rango óptimo visible de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de variascambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño;Un objeto tiene un rango visible más amplio durante el día que por la noche;Incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado;Si se encuentra un objeto dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctico, en comparación con la vista iniciada por el usuario. Estamos de acuerdo con el cliente E2 E1 A S Client Un Sub-World Server Figura 2: Sistema de destino en una partición de cuadrícula 4 × 4.que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con una gran cantidad de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de decisión de visibilidad, como el sacrificio de visibilidad [6], sino para filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativamente, como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación.4. Diseño de indexación de borde en la Sección 4.1 Introducimos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación celular se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de borde siguen en la Sección 4.5.4.1 Aplicación de destino Nuestra aplicación de destino asume tanto la transmisión de objetos 3D como el alojamiento del sub-mundo. El alojamiento del sub-mundo es un entorno virtual colaborativo donde cada servidor aloja un sub-mundo, construyendo así un solo mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en sub-mundo de tamaño igual. La muestra del sub-mundo separado con líneas con negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2);una entidad espectadora;y un avatar A. Como se menciona en la Sección 3, todas las entidades de objetos (E1, E2, A) tienen su propio AOI en forma cuadrada. Dos entidades de usuario (s, a) están asociadas con máquinas clientes individuales (Cliente S y Cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada sub-mundo es administrado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, ofrece cualquier evento nuevo (es decir, un nuevo usuario entra en el sub-mundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de las entidades móviles, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades de objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y DE3 Un mejor método de indexación para un espacio 3D es el trabajo en progreso.404 tokens: it (e1) it (e2) it (a) it (s) tokens: at (e1) dt (e1) at (e2) dt (e2) at (a) dt (a) it (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s)A) Indexación de nodos (b) indexación de borde (c) indexación de borde con evaluación de celda de hilera Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos e indexación de borde para el espacio de muestra en la Figura 2. Hay tres entidades de objetos, {e1, e2, a} y dos entidades de usuario, {s, a} en el mundo.Librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se denomina evaluación de usuario (o consulta). Nuestra aplicación solo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por sub -mundo están indexadas y qué tan rápido se reconocen y recuperan las actualizaciones de índice. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento.4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: el token de inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El token de apariencia (AT) denota que su entidad es una TI para la célula dada, pero no para la célula previamente adyacente. El token de desaparición (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación de TI con la célula dada, lo hace con la célula previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena su de una celda. Por lo tanto, el nodo para la celda I se define como un conjunto de entidades de TI y se expresa formalmente como ni = {o | o.r∩i.r = ∅}, donde r es una región AOI o una celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus AT o DT. Si el borde solo almacena las entidades AT, se denomina un borde de apariencia (AE);De lo contrario, si almacena DTS, se denomina un borde de desaparición (DE). El AE para dos células adyacentes I y J se define como un conjunto de ATS y se expresa como E+(I, J) = NJ - (Ni ∩ NJ) (1) donde Ni y Nj son las estructuras de nodo para las celdas I y J. El DE para dos células adyacentes I, J se define como un conjunto de DTS, satisfactorios: e− (i, j) = ni - (ni ∩ nj) (2) en un mapa 2D, dependiendo de la relación adyacencia entre dos vecinosLas celdas, los bordes se clasifican adicionalmente como cualquiera de las filas, si dos vecinos son adyacentes horizontalmente (ER), o en columna, si son adyacentes verticalmente (EC). En consecuencia, los bordes son de cuatro tipos diferentes, de acuerdo con su tipo de token y adyacencia: ER +(I, J), ER - (I, J), EC +(I, J) y EC - (I, J).4.3 La partición de la cuadrícula de indexación de nodos es un método de subdivisión espacial popular que recientemente ha ganado popularidad para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia en nuestro método recientemente propuesto, calificamos todas las indexación de nodos de métodos de indexación basados en divididos de cuadrícula existentes. La indexación de nodos divide el espacio en subespacios de tamaño Equi (celdas de cuadrícula), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodo por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodo de las células cuya región se cruza con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para entidades, esto permite actualizaciones de índice livianos. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costos de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 células de cuadrícula requiere 100 deleciones de tokens e 100 inserciones de tokens, en el peor de los casos. Se ha informado que uno de los métodos populares de indexación de nodos, la indexación de consultas, tiene dicha degradación del rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio de muestra que se muestra en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3 (a). Cada celda almacena entidades que se cruzan con su región. El procesamiento de la consulta para el Spectator S significa buscar en la estructura del nodo cuya región celular se cruza con S. En la Figura 3 (a), E2 se indexa en la misma celda, lo que se entrega al cliente S después de la evaluación de la consulta.4.4 Indexación de borde Nuestro nuevo método de indexación, la indexación de borde, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización de entidad periódica y evaluación celular.4.4.1 Estructura del borde de la idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de usar estructuras de nodo. Con este enfoque, se elimina la redundante entre dos células adyacentes (Ni ∩nj). En un mapa de cuadrícula 2d m × m, cada celda I está rodeada por cuatro células vecinas (i− 1), (i+ 1), (i− m), (i+ m) (excepto las 405 células más exteriores) y ocho diferentesEstructuras de borde. Si las dos primeras células vecinas están adyacentes horizontalmente a I y las dos últimas células (I - M), (i +m) están verticalmente cerca, las estructuras de ocho borde son EC +(i - M, I), EC - (I (I−m, i), er +(i - 1, i), er - (i - 1, i), er +(i, i +1), er - (i, i +1), ec +(i,i + m), y ec - (i, i + m). La Figura 3 (b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de borde deriva estructuras de nodos de las estructuras de borde. Si alguna estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo según lo definido por Lemma 1. La prueba del lema 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lema 1. NJ, un conjunto de su de una célula J se puede derivar de un conjunto de su Cell I, Ni y sus bordes E+(i, J) - E− (i, J): NJ = Ni+E+(i, j)-e− (i, j) Las estructuras de borde de la columna y las columnas, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na¨ıve almacena más tokens que la indexación de nodos: el número total de tokens de borde que se muestran en la Figura 3 (b) es 35 (17 ATS + 17 dts + 1 it);Para la indexación de nodos en la Figura 3 (a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo posterior de dos pasos a la indexación de borde original. Actualización periódica de la entidad y evaluación celular Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. En general, esto se realiza a través de un algoritmo de TWOSTEP [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de nodo de cada celda (el paso de evaluación de la celda). Después de una evaluación de una celda, se recuperan las entidades de usuario indexadas y la estructura de nodo calculada se entrega para cada cliente asociado con un usuario. Después de que se evalúan todas las células, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de borde actualizando las estructuras de borde de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lemma 1 durante las evaluaciones celulares. Además de esta adaptabilidad, el lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de fila o los bordes de la columna son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes en cuanto a hileras. Se supone que las estructuras de nodo más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la mano derecha desde la estructura del nodo más a la izquierda y los bordes en términos de hilera. Repetimos este cálculo hasta llegar a la célula más derecha. Por lo tanto, sin ningún bordes de columna podemos obtener todas las estructuras de nodo con éxito. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3 (c) ilustra el concepto de nuestro método de indexación de borde de hilera. El número total de tokens se reduce a 17 (8 ATS + 8 DTS + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2 Otro ejemplo, la Figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos células adyacentes 3 y 4 en cuanto a hileras tienen dos transiciones de borde en cuanto a hilera entre ellas, E+(3, 4), E− (3, 4);Entidades de dos puntos P1, P2;y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3, 4) se obtiene de la ecuación 1: n4 - (n3 ∩ n4) = {p1}. Del mismo modo, e− (3, 4) = n3 - celda 3 celda 4 e+(3, 4) = {p1} e_ (3, 4) = {p2, r1} p2 p1 r2 r1 Figura 4: Ejemplo de indexación de borde deEntidades de dos puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en cuanto a filas.(N3 ∩ n4) = {p2, r1}. Si sabemos N3, E+(3, 4) y E− (3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4) - E− (3, 4) = {{P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3, mientras que P1, R2 se superpone con la célula 4. Al transmitir de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece recientemente, mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de borde es ineficiente para indexar una geometría puntual. La indexación de nodos tiene una entidad de TI por punto y requiere una eliminación de tokens y una inserción en cualquier movimiento de ubicación. La indexación de borde, sin embargo, requiere una entidad DT por punto y dos eliminaciones de tokens y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos de acuerdo con la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3 (c), nuestro método de indexación de borde utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras usa estructuras de nodos para la (s) entidad puntual.4.5 Problemas de optimización En esta sección, describimos varias técnicas de optimización para la indexación de borde, lo que reduce significativamente la complejidad del algoritmo.4.5.1 Enfoque de la tabla única: Actualizar típicamente, existen dos políticas prácticas para una actualización de la región: la actualización completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar tokens recientemente actualizados en áreas recién posicionadas. La actualización incremental solo elimina los tokens cuya relación espacial con las celdas cambió en una actualización y las inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales.4.5.2 Enfoque de dos tablas: separar entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de borde con una tabla hash. Insertar un token se implementa insertándolo en la cabeza del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación del hash puede sufrir una penalización significativa en el sistema cuando se usa con una gran cantidad de entidades pobladas. La indexación de bordes de dos tablas está diseñada para que la eliminación de token sea constante. Primero, dividimos una estructura de borde único que indexa entidades estacionarias y en movimiento en dos borde separado 406 Tabla 1: Resumen de anotaciones para entidades virtuales y sus propiedades. Símbolo Significado U Conjunto de entidades de objetos poblados o conjunto de entidades de objetos en movimiento, o ⊆ u uq conjunto de entidades de usuario pobladas q conjunto de entidades de usuario en movimiento, q ⊆ uq un conjunto de avatares, a = {a | a ∈ U ∩ uq}I.P ubicación de la entidad I donde i ∈ (u ∪ uq) i.r aoi de entidad i donde i ∈ (u ∪ uq) mi longitud lateral de la entidad i donde i ∈ (u ∪ uq). Está representado por el número de unidades celulares.M Longitud del lado promedio de la varianza AOI de Entidades V AR (MI) de la distancia de la variable aleatoria MI V Máxima distancia accesible. Está representado por el número de unidades celulares.estructuras. Si una entidad no se mueve, sus tokens se colocarán en una estructura de borde estacionaria. De lo contrario, se colocará con un borde en movimiento. En segundo lugar, todas las estructuras de borde en movimiento se reconstruyen periódicamente. Después de la reconstrucción, todas las células de la cuadrícula se evalúan para calcular sus conjuntos visibles. Una vez que se evalúan todas las células, los bordes móviles se destruyen y el paso de reconstrucción sigue. Como resultado, las operaciones de búsqueda en las estructuras del borde en movimiento ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y la velocidad de movimiento de las entidades. Se utiliza una implementación de la lista vinculada individualmente para la estructura del borde móvil.5. Análisis Analizamos tres esquemas de indexación cuantitativamente (indexación de nodos, indexación de bordes e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas hash. Para las manipulaciones de tabla hash, asumimos tres funciones de acceso de memoria: inserción del token, eliminación de tokens y escaneo de tokens. Sus costos de procesamiento son denotados por TA, TD y TS, respectivamente. Una operación de escaneo de tokens lee los tokens en un cubo hash secuencialmente. Se usa ampliamente durante las evaluaciones celulares. TS y TD son una función del número de tokens en el cubo, mientras que TA es constante. A los fines del análisis, definimos dos variables aleatorias. Una variable, denotada por Mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor promedio de Mo se denota por m.La segunda variable aleatoria V denota la distancia máxima diireccional o ydireccional de una entidad móvil durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, V]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado.5.1 Los requisitos de memoria permiten que el tamaño del token se denote por s.La indexación de nodos usa S · | UQ |Unidades de memoria para entidades de usuario y S · èo∈U (Mo + 1) 2 ≈ S (M2 + 2M + 1 + V AR (Mo)) | U |Unidades para entidades de objetos. La indexación de borde de una sola mesa consume S · | UQ |Unidades de almacenamiento para las entidades de usuario y S · èo∈U 2 (Mo + 1) ≈ 2s (m + 1) | U |para las entidades objeto. La indexación de borde de dos tablas ocupa S · | UQ |Unidades para los usuarios y S {èi∈O 2 (Mi+1)+èj∈ (U - O) 2 (MJ +1)} ≈ 2s (m+1) | U |Unidades para los objetos. La Tabla 2 resume estos resultados. En nuestro objetivo, APTIBLE 2: Requisitos de memoria de diferentes métodos de indexación.Método de indexación Entidades de usuario Entidades de objeto Indexación del nodo S · | UQ |s ((m + 1) 2 + v ar (mo)) | u |borde de una mesa única s · | uq |2s (m + 1) | u |Edge de dos tablas S · | UQ |2s (m + 1) | u |PLICACIÓN, nuestros métodos de indexación de borde consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula de 2 m × 2m. El requisito de memoria para las entidades de usuario no cambia porque depende solo del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s (m + 1) | U |En el caso de la cuadrícula M × M y 2s (2m + 1) | U |para la cuadrícula (2m) × (2m). Por lo tanto, un tamaño de celda cuatro veces mayor conducirá a un número de tokens aproximadamente dos veces menor.5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones celulares. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad del tiempo de ejecución de los objetos en movimiento y los usuarios de mudanza.5.2.1 Costo de actualización Suponemos que un conjunto de objetos móviles o y un conjunto de usuarios móviles Q son conocidos de antemano. Similar a la indexación de borde, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en el índice Q [13] y Sina [10], elimina todos los tokens antiguos de las estructuras de nodo celular antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, presentamos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad móvil, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre (± V, ±v) espacio de celda de cuadrícula como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral del AOI de los objetos en el sistema;es decir, v <mo donde o ∈ O. Como se ve en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) (Mo + 1) - IJ Insercios y eliminaciones, donde 1 ≤ I, J ≤ v. De lo contrario, habrá k (Mo + 1) Tokeninserciones y eliminaciones, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimiento diferentes t nodo por actualización (o) = 4 · (a) + 4 · (b (b) (2v + 1) 2 · (ta + td) = v (v + 1) {v (4mo + 3 - v) + 2 (mo + 1)} (2v + 1) 2 · (ta + td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante el nodo t por actualización = èo∈O, v <mo t nodo por actualización (o) | o |= V (V + 1) {V (4M + 3 - V) + 2M + 1)} (2V + 1) 2 · (Ta + Td) (4).407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización único donde V <MQ, MO y Q ∈ Q. Consultas del método de indexación × (Ta + Td) (segundos) Objetos × (Ta + Td) (segundos) Indeportación con actualización incremental| P || O |· V (V+1) {V (4M+3-V) +2 (M+1)} (2V+1) 2 Independiente de borde de una sola mesa con actualización completa | Q || O |· 2 (m + 1) indexación de borde de una sola mesa con actualización incremental | Q || O |· V (4m (1+2v)+9v+5) (2v+1) 2 indexación de borde de dos table | Q |· Ta ta+td | o |· 2 (M + 1) Ta Ta + Td Distancia máxima alcanzable (V) (0,0) I J (I, J) A A AA B B B B Figura 5: Ilustración de la siguiente ubicación de celda, celda (i, j), de un movimiento en movimientoentidad cuya ubicación inicial estaba en la celda (0, 0). El tiempo esperado de cualquier actualización de la entidad para la indexación de borde con actualización completa es: t EdgeFull por actualización = èo∈O t EdgeFull por actualización (o) | o |= 2 (m + 1) (ta + td) (5) El análisis del tiempo esperado de cualquier actualización de entidad para la indexación de borde con actualización incremental se vuelve complicado porque el costo de tiempo depende tanto de la longitud lateral de la entidad AOI como enla velocidad de movimiento. En términos generales, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es más pequeño que Mo: tedingincremental por actualización = èo∈O, v <mo tedgeincincremental por actualización (o) | o |= v (4m (1 + 2v) + 9v + 5) (2v + 1) 2 · (ta + td) = v (4m (1 + 2v) + 9v + 5) (2v + 1) 2 · 2 (m+ 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que, si bien el costo de actualización de la indexación de borde en peor de los casos (indexación de borde de la tabla única con política de actualización completa) depende solo de M, el de la mejor indexación de nodo (indexación de nodos con política de actualización incremental) todavía es proporcional a dos variables, V y M.Para un valor más pequeño de V (V = 1), el costo de actualización de la indexación de nodos supera ligeramente el de la indexación de borde (es decir, 12m + 8 9 vs. 2 (m + 1)). Sin embargo, a medida que V aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 versus 2 (m + 1), donde v = 2). Otro resultado interesante es que la indexación de bordes de dos table depende solo del costo de inserción del token, TA. Por lo general, TD es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima accesible (v) (%) #fagedTokens Indexación de dos tiendas indexación incremental indexación de borde completo indexación de nodo incremental Figura 6: Resultados de simulación deActualizar complejidad de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones de tokens e inserciones por actualización del objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral promedio del objeto AOIS es el 10% de la longitud lateral de un mapa 2-D dado.mayor que TA porque TD requiere al menos una operación de búsqueda de tokens. Después de la búsqueda, TD ejecuta la operación inversa de TA. Por lo tanto, TD puede expresarse como (ta + tlookup) y puede simplificarse como (ta + | e | 2 · b · ts) donde | e |es el tamaño de la estructura del borde y B es el número de sus cubos hash. A partir de esta observación, podemos inferir esa actualización completa de la indexación de borde de una sola mesa lleva al menos el doble de tiempo que la actualización de la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de borde cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil tarda constantemente en actualizar las estructuras de borde correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura, suponemos que la longitud del lado promedio del AOI es 0.1 (o 10 %). Sin embargo, el método de indexación de nodos depende no solo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de borde. Como se esperaba, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen la cantidad de inserciones y eliminaciones de token notablemente, mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante.5.2.2 Evaluación de celdas Costo de inicio de la indexación de nodo Todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo celular. Por lo tanto, tomaría | Q | × TS escanear todas las entidades de usuario. Si cada nodo almacena (m2+2m+1+v ar (mo)) | o |Entidades de objeto M2 En promedio, el tiempo de finalización esperado de una evaluación de una celda será èo∈O (m2+2m+1+v ar (mo)) | o |M2 · ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de células será | Q |· (M2+2m+1+v ar (mo)) | o |M2 · ts. La complejidad en tiempo de ejecución de la evaluación de células de una sola mesa puede 408 Tabla 4: Resumen del costo de evaluación celular.Método de indexación esperado Indeporación de tiempo de tiempo transcurrido TS · | Q |· (M2+2m+1+v ar (mo)) | o |M2 Borde de una mesa única TS · (| Q | + | O | · 2 (M + 1)) Bordamiento de dos table (TS + TD) · (| Q | + | O | · 2 (M + 1)) Be Besimplificado como TS · | o | · 2 (M +1). En este análisis, no consideramos ninguna sobrecarga de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una sola mesa necesitamos escanear todos los tokens para evaluaciones celulares. La indexación de borde de dos tablas se ejecuta en TD para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación TD, la operación TD es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados calculados previamente se reutilizan durante la próxima ronda de evaluación, el tiempo transcurrido esperado de la indexación de nodos estará unido por el número total de evaluaciones de células (es decir, TS (M2 + 2M + 1 + V AR (Mo)) |O |). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexación de borde.5.2.3 Ponerlo: costo de monitoreo periódico Como vimos en la Sección 5.2.1, los métodos de indexación de borde superan la indexación del nodo en términos de actualizaciones y evaluaciones de celdas. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una sola mesa y la indexación de borde de dos table. El tiempo total transcurrido de la indexación de borde de la mesa única basada en actualización completa para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de las actualizaciones y las evaluaciones celulares: (Ta + Td + Ts) · {| Q |+ | O | 2 (m + 1)} (7) De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (ta + td + ts) · {| q |+ | O | 2 (m + 1)} (8) De la ecuación 7 y 8 concluimos que la indexación de borde de dos table, a pesar de que representa una optimización menor de la indexación de borde de una mesa única al reemplazar TD impredecible con TD predecible, lograuna mejora significativa del rendimiento. En primer lugar, TD es muy predecible y un procedimiento más liviano que TD. Todos los gastos generales de manipulación de la estructura de datos, como TA, TS y TD, se pueden perfilar fácilmente y todos se vuelven constantes. Además, se garantiza que la indexación dituable superará la indexación de borde de actualización completa de la mesa única. Otra novedad del enfoque de dos tablas es que es muy resistente a la distribución de datos subyacente, independientemente de si es muy sesgado o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, ta, ts, td, | q |, | o | y m.Mientras que TA, TS y TD son parámetros específicos del sistema, | O |, | Q | y M son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real d. Por lo tanto, el rendimiento del sistema, cuántos objetos y usuarios móviles son compatibles con el sistema dado, se obtiene de la Ecuación 9. Rendimiento máximo del sistema = | Q |+ | O | 2 (m + 1) = t ts + ta + td (9) Por ejemplo, si un sub-mundo dado solo se llena con avatares móviles, a = q = o, cuya longitud del lado promedio es el 10% deLa longitud del lado del mapa, luego TS + TD toma 0.42 microsegundos por evaluación de tokens, y TA toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar en el sub-mundo libremente y el mismo número de clientes conectados remotamente recibe los últimos eventos de actualización continuamente.6. Evaluación Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La Sección 6.1 examina si nuestro nuevo enfoque de vista es superior a los modelos de vista existentes, a pesar de su mayor complejidad de indexación. La Sección 6.2 analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista.6.1 Justificación Iniciada con View Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, precisión (P) y recuerdo (R), que estiman el grado de precisión y comprensión de AConjunto de resultados dado [15]. P es la relación de artículos relevantes y recuperados para todos los artículos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene una gran cantidad de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta de lo requerido. R es la relación de elementos relevantes y recuperados a todos los artículos relevantes. Un valor R más bajo significa que se ignoran más objetos que deben reconocerse. A partir de la medida R, podemos estimar cuantitativamente la aparición de estallidos de objetos. Además de las métricas P y R, utilizamos una métrica de evaluación de consultas de valor único estandarizado que combina P y R, llamado emasure [15]. La medida E se define como: E = 1-(β2 + 1) PR β2p + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es inferior a 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida. Un valor de medición electrónica más bajo implica que el modelo de vista probado tiene una calidad de mayor calidad. El mejor valor de medida electrónica es cero, donde los mejores valores para P y R son ambos.6.1.2 Configuración de simulación Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario-RQ-OP: consulta de región-Punto de objeto • Computación de visibilidad orientada a objetos-PQ -OR: Consulta de puntos - Región de objeto - RQ -OR: Consulta de región - Región de objeto - ACQ -OR: Consulta de celda aproximada - Región de objeto RQ -OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de un AOI definido por el usuario. PQ-o recoge un conjunto de objetos cuyo AOI se cruza con un punto de usuario dado, formalmente {o | q.p ∈ O.r}. RQ-o, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se cruza con la de un usuario, {o | o.r ∩ q.r = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición espacial basada en la cuadrícula, que es nuestra elección de la metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas de mosaico y un punto de usuario pertenece a una de las celdas, el ACQ o busca los objetos cuyos AOI 409 Tabla 5: P y R cálculos de diferentes esquemas de determinación de visibilidad. Esquema P r rq-op | {o | o.p ∈Q.r∧q.p ∈O.r)} || {o | o.p ∈Q.r} || {o | o.p ∈Q.r∧q.p ∈O.r)} || {o | q.p ∈O.r} |Pq-or | {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 | {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 rq-or | {o | q.p ∈O.r} || {o | q.r∩o.r = ∅} || {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 acq-or | {o | q.p ∈O.r} || {o | c.r∩o.r = ∅, q.p ∈C.R} || {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 se cruzaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares que RQ-OR, mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-o. Identifica cualquier objeto o satisfacer la condición c.r ∩ o.r = ∅ donde la celda c satisface q.p ∈ C.r también. Nuestro programa de simulación pobló 100k entidades de objetos y 10k entidades de usuario en un espacio de unidades 2D, [0, 1) × [0, 1). Las entidades pobladas están ubicadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa del 5% al 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos exhaustivamente y calcula los valores P, R y de medición electrónica (que se muestran en la Tabla 5).6.1.3 Distribución de resultados experimentales de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar una gama AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero una mayor amplitud. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos 5%. Por lo tanto, cada objeto recuperado por RQ-OP se garantiza que todo se representa en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, lo que sufre de demasiados objetos faltantes que deben representarse. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser representado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, lo que puede incurrir en una degradación significativa del sistema. Distribución de la medición electrónica: la Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-Or (100 × 100 Grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a la medida de RQ-o muestra la semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, lo que transmite que ACQ o hereda las propiedades de RQ-OR. Efecto del tamaño de la cuadrícula diferente: la Figura 9 muestra la diferencia estadística de los valores de medición electrónica de siete esquemas de partición de cuadrícula diferentes (usando ACQ-OR) y un modelo RQ-OP. Utilizamos una trama de caja y bigotes para mostrar tanto los valores medios como las variaciones de las distribuciones de medidas electrónicas y los valores atípicos de cada esquema. También dibujamos el valor medio de las medidas electrónicas RQ-OP (línea verde) para fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medición electrónica se concentran en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida electrónico más pequeño. El esquema RQ-OP mostró una varianza más amplia de su calidad que otros esquemas, que es en gran medida atribuible a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-o se mejora más evidentemente que la de RQOP. De la Figura 9, el esquema de la cuadrícula 20 × 20 tenía una mejor medida electrónica Tabla 6: tiempo transcurrido medido (segundos) de 100k objetos en movimiento y 10k usuarios en movimiento en un entorno de movimiento lento (V = 1).Indexación de tiempo de actualización Tiempo de evaluación Total Tabla de una sola Tabla ULL 3.48 0.82 4.30 Single-TableIncr 2.08 0.80 2.88 Two-Table 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100k objetos móviles y 10k usuarios en un entorno altamente dinámico (V = V =15).Indexación Tiempo de evaluación Tiempo Total Total de una sola mesa ULL 3.65 0.77 4.42 Tabla de una sola mesa 3.49 0.74 4.23 Two-Table 1.75 0.93 2.68 Valor en un entorno priorizado que en un entorno de igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula 20 × 20 recupera una mayor calidad de conjuntos visibles que el RQ-OP.6.2 Evaluación de la indexación de borde En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de borde. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualizar todas las entidades móviles y calcular conjuntos visibles para cada celda. También experimentamos con diferentes políticas de división de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas.6.2.1 Configuración de simulación Implementamos algoritmos de indexación de borde en C y ejecutó los experimentos en un procesador de itanio de 900MHz de 64 bits con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizado para almacenar estructuras de nodos y borde.6.2.2 Resultados experimentales Costo de monitoreo periódico: las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de borde variando v. La velocidad de mudanza de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6),El método de indexación de borde incremental supera la indexación de borde de actualización completa, debido a las actualizaciones de índice reducidos;El enfoque de dos tablas supera el rendimiento de los esquemas de una sola mesa, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de mesa única debido a su eliminación de token secuencial. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índice y las evaluaciones celulares en un entorno altamente dinámico donde los objetos que se mueven lentamente y se mueven dinámicamente coexisten. En comparación con los resultados que se muestran en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos móviles subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la del entorno en movimiento lento. Efecto de un tamaño de cuadrícula diferente: cuántas actualizaciones de objetos y evaluaciones de células pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de cálculo de visibilidad diferentes: dos métodos de búsqueda exhaustivos impulsados por el cálculo;y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula.410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.7 0.8 0.9 1 Recuerdos (R) Precisión (P) 5% Consulta Rango 6% Consulta de rango 7% Rango de rango 8% Rango de rango 9% RangoConsulta 10% Rango de rango Consulta 11% Consulta de rango 12% Consulta de rango 13% Consulta Rango 14% Rango de rango Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) e−Medida de optimización RQ - OP RQ - OR ACQ - OR (Celillas de cuadrícula 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1KX1K RQ -OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1 1 Medema E -Medición Media Media de RQ - OP Figura 7 Figura 7: Distribución de P y R medido por RQ-OP. Figura 8: Valor de medición electrónica en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición electrónica en función del esquema de partición de la cuadrícula ACQ-QR cuando β = 2. 10k 50k 100k 10 −1 10 0 10 10 1 10 2 # de actualizaciones de objetos (consultas de 10k) TotalelapsedTime (segundos) Tamaño de la población = 100K, rango visible = 5-15%, movilidad = 1% de búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Dos tesas indexación de borde 100x100 dos - indexación de borde de dos tiends 50x50 indexación de borde de dos tiendles Figura 10: Tiempo total transparentede diferentes esquemas de indexación. Los métodos de búsqueda exhaustivos no mantienen resultados intermedios. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar el comportamiento impredecible del movimiento del objeto. A pesar de su diseño y extensibilidad simples, sufren largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral promedio del objeto AOI. Debido a que la longitud lateral está representada por las unidades celulares, un aumento en el número de células aumenta las longitudes laterales proporcionalmente. La Figura 10 ilustra que los resultados de simulación medidos coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis.7. Conclusión y trabajo futuro para apoyar la extensibilidad dinámica y la escalabilidad en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objetos y su método de indexación eficiente, indexación de borde. En comparación con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de estallido de objetos que pueda observarse fácilmente en entornos virtuales existentes a expensas de una mayor complejidad de indexación. Sin embargo, nuestro modelo de indexación de bordes puede superar dicha complejidad de indexación dicha al indexar extensiones espaciales a nivel de borde, no a nivel de nodo en un sub-mundo dividido en la cuadrícula y se validó a través de análisis y simulaciones cuantitativas. Sin embargo, por ahora nuestra indexación de borde aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de borde para que la complejidad de indexación constante. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de borde pueda contribuir a la implementación exitosa de entornos de juego de próxima generación.8. Referencias [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Challeges in Modern Distributed Interactive Application Design, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Coronel Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis de tráfico de juegos: Una perspectiva MMORPG, en NossDav05.2005, pp. 19-24, ACM Press.[3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Traffic Charateristics de un juego de rol en línea multijugador masivo y sus implicaciones, en NetGames 05, octubre de 2005. [4] Philip Rosedale y Cory Ondrejka, lo que permite permitirMundos en línea creados por jugadores con computación y transmisión de cuadrícula, revista Gamastutra, http://www.gamasutra.com/Resource Guide/20030916/Rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, transmisión de complejo 3DEscenas para tutoriales remotos., Comput. Grafico. Foro, vol.20, no.3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, una arquitectura de red para la representación remota, en el segundo taller internacional sobre simulación interactiva distribuida y aplicaciones en tiempo real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Adaptive Adaptive.Algoritmo de visualización para velocidades de cuadros interactivas durante la visualización de entornos virtuales complejos, en Siggraph 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press.[8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press.[9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, que respalda actualizaciones frecuentes en R-Trees: un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003.[10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM Sigmod 04. 2004, págs. 623-634, ACM Press.[11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación principal de la memoria de consultas de monitoreo sobre objetos en movimiento, distribución. Bases de datos paralelas, vol.15, no.2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia Sigmod, 2005. [13] S. Prabhakar,Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación restringida de velocidad: técnicas escalables para consultas continuas en objetos en movimiento, transacciones IEEE en computadoras, vol.51, no.10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+Rtree: indexación eficiente para bases de datos de objetos en movimiento, en Dasfaa 03, Washington, DC, EE. UU., 2003, p.175, IEEE Computer Society.[15] C. J. Van Rijsbergen, Recuperación de información, 2ª edición, Departamento de Ciencias de la Computación, Universidad de Glasgow, 1979. 411