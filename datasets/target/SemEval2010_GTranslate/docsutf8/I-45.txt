Implementación de interacciones basadas en el compromiso ∗ Michael Winikoff School of Computer Science y la universidad de TI Melbourne, Australia Michael.winikoff@rmit.edu.au Resumen Aunque la interacción de los agentes juega un papel vital en MAS, y los enfoques mensajeros para la interacción de los agentes tienen sus inconvenientes, presente presenteLos lenguajes de programación orientados al agente no brindan soporte para implementar la interacción del agente que sea flexible y robusto. En su lugar, los mensajes se proporcionan como un bloque de construcción primitiva. En este artículo consideramos un enfoque para las interacciones de modelado de agentes: el marco de máquinas de compromiso. Este marco apoya las interacciones de modelado en un nivel superior (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo se pueden implementar interacciones basadas en compromiso en los lenguajes de programación orientados a agentes convencionales. Las contribuciones de este documento son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI;extensiones a la semántica de los lenguajes de programación BDI;y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de giro y condiciones de carrera) y soluciones a estos problemas. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: sistemas artificiales de inteligencia artificiales distribuidos;I.2.5 [Inteligencia artificial]: lenguajes de programación y software Términos generales Diseño 1. Los agentes de introducción son sociales, y la interacción de agentes juega un papel vital en los sistemas multiagentes. En consecuencia, el diseño y la implementación de la interacción del agente es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agente es MessageCentric: las interacciones se definen mediante protocolos de interacción que proporcionan las secuencias permitidas de mensajes, especificadas utilizando anotaciones como máquinas de estado finitas, redes de Petri o agente UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es una buena coincidencia para los agentes inteligentes. Los agentes inteligentes deben exhibir la capacidad de persistir en lograr sus objetivos frente al fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitada: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de interacciones se limita a aquellas opciones que proporcionó el diseñador de protocolos, y en la práctica, un diseño centrado en el mensajeLos procesos no tienden a conducir a protocolos que son flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones de agentes, se han propuesto varios enfoques en los últimos años que se alejan de los protocolos de interacción centrados en el mensaje y, en su lugar, consideran diseñar interacciones de agentes utilizando conceptos de nivel superior como los compromisos sociales [8,10, 18] o objetivos de interacción [2]. También ha habido trabajo en formas de interacción más ricas en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo para diseñar interacciones de agentes flexibles y robustos, prácticamente no ha habido trabajo para proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados al agente actual (AOPLS) no brindan soporte para implementar interacciones de agente flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los AOPL modernos [1], prácticamente sin excepciones, proporcionan solo el envío simple de mensajes como base para implementar la interacción del agente. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que admite la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer idioma de este tipo, se propuso un elemento básico, hace unos años [9], pero no se describe en detalle, y podría decirse que no es práctico para el uso de los no especialistas, debido a su base lógica y una gran dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender las AOPL similares a BDI para admitir la implementación directa de las interacciones de los agentes que están diseñadas con el marco de la máquina de compromiso Yolum & Singhs (CM) [19]. En el resto de este documento, revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de BDI aopls que se encuentra en el subconjunto común de idiomas como Jason, 3APL y Can. Luego presentamos un esquema para traducir máquinas de compromiso a este idioma e indicamos cómo el idioma debe extenderse para respaldar esto. Luego ampliamos nuestro esquema para abordar una variedad de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera.2. Antecedentes 2.1 Máquinas de compromiso El objetivo del marco de la máquina de compromiso es permitir la definición de interacciones que son más flexibles que los enfoques tradicionales centrados en los mensajes. Una máquina de compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de interacción. Este estado de interactuar consiste en fluentes (predica que cambian el valor con el tiempo), pero también los compromisos sociales, tanto a nivel de base como condicional. Un compromiso social a nivel base es una empresa por parte del deudor A al acreedor B para lograr la condición P, denotó C (A, B, P). Esto a veces se abrevia a C (P), donde no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del Cliente C con el comerciante M para hacer que el pago con fluidez sea verdadero se escribiría como C (C, M, pagado). Un compromiso social condicional es una empresa por parte del deudor A al acreedor B que debería condicionar Q se hace realidad, y luego se comprometerá a lograr la condición p.Esto se denota por CC (A, B, Q, P), y, donde la identidad de las entidades involucradas no es importante (u obvio), se abrevia a CC (Q P) donde la flecha es un recordatorio del vínculo causal entre Qconvertirse en verdad y la creación de un compromiso para hacer que P sea verdad. Por ejemplo, un compromiso de hacer que el pago sea verdadero con fluidez una vez que se hayan recibido bienes se escribieran CC (bienes pagados). La semántica de los compromisos (tanto a nivel de base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C (P) (o CC (Q P)) se descarga cuando P se vuelve verdadero;y el compromiso CC (Q P) es reemplazado por C (P) cuando Q se hace realidad. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformalizada por [14]. En resumen, estas semánticas se ocupan de una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se mantienen: si P se mantiene cuando CC (P Q) está destinado a ser creado, entonces se crea C (Q) en lugar de CC (p q). Se define una interacción especificando las entidades involucradas, el posible contenido del estado de interacción (tanto fluidos como compromisos) y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y los efectos de cada acción, especificadas como ADD yEliminar listas. Una máquina de compromiso (CM) define un rango de posibles interacciones que cada uno comienza en algún estado1 y realiza acciones hasta alcanzar un estado final. Un estado final es uno que no tiene compromisos de nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estado finito correspondiente al CM. Por ejemplo, la Figura 1 proporciona el FSM2 correspondiente a la máquina de compromiso de NetBill [18]: un CM simple donde un cliente (c) y comerciante (M) intentan comerciar utilizando las siguientes acciones3: 1 A diferencia de los protocolos de interacción estándar o las máquinas de estado finitas, no hay un estado inicial designado para la interacción.2 La máquina de estado finito está generada por software: los nodos y las conexiones se calcularon mediante una implementación de los axiomas (disponibles en http://www.winikoff.net/cm) y luego fueron presentados por GraphViz (http: // www.GraphViz.org/).3 Usamos la notación A (x): p ⇒ e para indicar que la acción A es realizada por Entity X, tiene condición previa p (con: P omitida si está vacía) y efecto E. • SendRequest (c) ⇒ Solicitud • SendQuote (M) ⇒ Oferta donde oferta ≡ prometygoods ∧ promisereceipt y promesagoods ≡ cc (m, c, acepta, bienes) y promisereceipt ≡ cc (m, c, pay, recibo) • Sendacept (c) ⇒ Aceptar donde acepte ≡ Cc (C, M, bienes, pagos) • SendGoods (M) ⇒ Promisereceipt ∧ Bienes donde Promisereceipt ≡ CC (M, C, Pay, Recibo) • SendEpo (C): Bienes ⇒ PAGO • SendReceipt (M): Pague ⇒ Recibo. El compromiso de aceptar es que los clientes prometen pagar una vez que se han enviado los bienes, prometen los comerciantes que prometen enviar los bienes una vez que el cliente acepta, y Promisereceipt es la promesa de los comerciantes de enviar un recibo una vez que se ha realizado el pago. Como se ve en la Figura 1, las máquinas de compromiso pueden soportar una gama de secuencias de interacción.2.2 Un agente abstracto Programing Language Agent Langua de programación en la tradición BDI (por ejemplo, DMARS, JAM, PRS, UM-PRS, Jack, AgentsPeak (L), Jason, 3APL, Can, Jadex) definen el comportamiento del agente en términos de planes activados por eventos,Cuando cada plan especifica por qué se desencadena, bajo qué situaciones se puede considerar aplicable (definida utilizando una llamada condición de contexto) y un cuerpo del plan: una secuencia de pasos que puede incluir eventos de publicación que a su vez desencadena aún másplanes. Dada una colección de planes y un evento E que se ha publicado, el agente primero recopila todos los tipos de planes que se desencadenan por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de estos es elegido y se ejecuta. Ahora definimos brevemente la sintaxis formal y la semántica de un lenguaje de programación de agente resumen simple (BDI) (SAAPL). Este idioma está destinado a ser una abstracción que se encuentra en el subconjunto común de idiomas como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y Can [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete a un mecanismo particular para tratar con la falla del plan, ya que diferentes AOPL utilizan diferentes mecanismos. Un programa de agente (denotado por π) consiste en una colección de cláusulas de plan de la Forma E: C ← P donde E es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan está construido a partir de las siguientes construcciones. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente n (↑ n m) y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). C :: = b |C ∧ C |C ∨ C |¬C |∃x.c p :: = |+B |−B |E |↑ n m |PAG;P Se da semántica formal para este idioma en la Figura 2. Esta semántica se basa en la semántica para AgentsPeak dada por [12], que a su vez se basa en la semántica para la lata [16]. La semántica está al estilo de la semántica operacional estructural de Plotkins, y supone que existen operaciones que verifican si una condición 4 usamos ↓ n m como mano corta para el evento correspondiente a recibir el mensaje M del agente N. 874 el sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) Figura 1: Máquina de estado finito para NetBill (sombreado = estados finales) se deduce de un conjunto de creencias, que agrega una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias son un conjunto de átomos terrestres, estas operaciones son respectivamente verificación de consecuencia (b | = c), y establecer adición (b ∪ {b}) y deleción (b \ {b}). Se pueden usar métodos de gestión de creencias más sofisticados, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia 5 donde los mensajes se agregan en un extremo y se eliminan del otro extremo), n es el nombre del agente, B es las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde, en lugar de un solo plan de plan, hay un conjunto de instancias de plan, γ. Finalmente, un MAS completo es un par Q, a partir de una cola de mensajes global y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de trillizos del remitente de formulario: destinatario: mensaje. Una transición S0 - → S1 especifica que la ejecución de S0 un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración MAS. La relación de transición se define utilizando reglas de la forma S - → S o de la forma S - → Sr S - → Sr;Estos últimos son condicionales con la parte superior (numerador) que es la premisa y la parte inferior (denominador) es la conclusión. Tenga en cuenta que no hay determinismo en SAAPL, p.La elección del plan para ejecutar desde un conjunto de planes aplicables. Esto se resuelve mediante el uso de funciones de selección: por lo que selecciona una de las instancias del plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias del plan que se puede ejecutar deben ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación..3. Implementación de interacciones basadas en compromiso en esta sección Presentamos una asignación de una máquina de compromiso a una colección de programas SAAPL (una para cada rol). Comenzamos considerando el caso simple de dos agentes que interactúan, y 5 el operador + se usa para denotar la concatenación de secuencia.Suponga que los agentes se turnan para actuar. En la Sección 4 relajamos estos supuestos. Cada acción a (x): p ⇒ e se asigna a varios planes: hay un plan (para el agente x) con la condición de contexto P que realiza la acción (es decir, aplica los efectos e a las creencias de los agentes) y envía un mensajeal otro agente y un plan (para el otro agente) que actualiza su estado cuando se recibe un mensaje de X. Por ejemplo, dada la acción sendacept (c) ⇒ Aceptar, tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Tenga en cuenta que cuando la identificación del remitente (respectivamente destinatario) es obvia, es decir, el otro agente, abreviamos ↑ n m a ↑ m (resp. ↓ n m a ↓ m). La toma de turnos se captura a través del evento ı (abreviatura de Interact): el agente que está activo tiene un evento que se está manejando. Manejar el evento implica enviar un mensaje al otro agente, y luego no hacer nada hasta que se reciba una respuesta. C: ı: verdadero ← +Aceptar;↑ sendaccept. M: ↓ Sendaccept: verdadero ← +Aceptar;i. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el destinatario: uno para realizar la acción (si es posible), y otro para informar un error si la condición previa de las acciones no se mantiene (volvemos a esto en la Sección 4). Por ejemplo, la acción sendReceipt (m): paga ⇒ recibo genera los siguientes planes: m: ı: paga ← +recibo;↑ sendReceipt. C: ↓ SendReceipt: PAGO ← +recibo;i. C: ↓ SendReceipt: ¬Pay ←...Error de informe.... Además de estos planes, también necesitamos planes para comenzar y terminar la interacción. Se puede completar una interacción siempre que no haya compromisos de nivel base, por lo que ambos agentes tienen los siguientes planes: ı: ¬∃p.c (p) ← ↑ Hecho.↓ Hecho: ¬∃p.c (P) ←.↓ Hecho: ∃p.c (P) ←...Error de informe.... Se inicia una interacción estableciendo creencias iniciales de los agentes y luego hacer que comience a interactuar. Exactamente cómo hacer esto depende de la plataforma de agente: p.La plataforma de agente en cuestión puede ofrecer una forma simple de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes init, cada uno del sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 875 Q, N, B, +B Basic-→ Q, N, B ∪ {B}, Q, N, B, −B Básico-→ Q, N, B\ {b}, Δ = {piθ | (ti: ci ← pi) ∈ π ∧ tiθ = e ∧ b | = ciθ} q, n, b, e básico - → q, n, b, so (Δ) q, N, B, P1 Básico - → Q, N, B, P Q, N, B, P1;P2 Básico - → Q, N, B, P;P2 Q, N, B ,;P BASIC - → Q, N, B, P Q, N, B, ↑ NB M BASIC - → Q + N: NB: M, N, B, Q = Na: N: M + Q Q, N, B, γ Agente- → q, n, b, γ ∪ {↓ na m} p = si (γ) q, n, b, p básico - → q, n, b, p q, n, b, agente γ - → q, n, B, (γ \ {p}) ∪ {p} p = si (γ) p = q, n, b, γ agente - → q, n, b, (γ \ {p}) n, b, γ= Sa (as) q, n, b, agente γ - → q, n, b, γ q, como mas - → q, (como ∪ {n, b, γ}) \ {n, b, γ} figura2: Semántica operativa para SAAPL que contiene una creencia a agregar;y luego envíe a uno de los agentes un mensaje de inicio que comienza la interacción. Por lo tanto, ambos agentes tienen los siguientes dos planes: ↓ Init (b): Verdadero ← +b.↓ Inicio: Verdadero ← ı. La Figura 3 ofrece los programas SAAPL tanto para comerciante como para el cliente que implementan el protocolo NetBill. Para la concisión se omiten los planes de informes de errores. Ahora recurrimos a refinar las condiciones de contexto. Hay tres refinamientos que consideramos. En primer lugar, necesitamos evitar realizar acciones que no tengan ningún efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben realizarse a menos que se mantengan condiciones adicionales. Por ejemplo, es posible que el cliente no desee aceptar la oferta de los comerciantes a menos que los bienes tengan un cierto precio o propiedad. En tercer lugar, las condiciones de contexto de los planes que terminan la interacción deben refinarse para evitar terminar la interacción prematuramente. Para cada plan de la forma ı: P ← +E;↑ m Reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P es cualquier condición adicional que el agente desea imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (suponiendo que no hay condiciones adicionales, es decir, no P): ı: bienes ∧ ¬ PAY ← +PAGO;↑ sendepo. Para cada plan de la forma ↓ M: P ← +E;Podríamos agregar ¬E a la condición previa, pero esto es redundante, ya que el artista de la acción ya lo verifica, y si la acción no tiene efecto, entonces los clientes planes: ı: verdadero ← +solicitud;↑ sendRequest.ı: Verdadero ← +Aceptar;↑ sendaccept.ı: bienes ← +pago;↑ sendepo.↓ SendQuote: Verdadero ← +PromiseGoods;+Promisereceipt;i.↓ SendGoods: True ← +Promisereceipt;+bienes;i.↓ SendReceipt: Pay ← +recibo;i. Planes de comerciantes: ı: Verdadero ← +promesagoods;+Promisereceipt;↑ sendQuote.ı: Verdadero ← +Promisereceipt;+bienes;↑ sendgoods.ı: Pague ← +recibo;↑ sendReceipt.↓ sendRequest: verdadero ← +solicitud;i.↓ Sendaccept: verdadero ← +Aceptar;i.↓ SendEpo: bienes ← +PAGO;i. Planes compartidos (es decir, planes de ambos agentes): ı: ¬∃p.c (p) ← ↑ Hecho.↓ Hecho: ¬∃p.c (P) ←.↓ Init (B): Verdadero ← +b.↓ Inicio: Verdadero ← ı. Donde acepte ≡ CC (Page de bienes) PromiseGoods ≡ CC (Aceptar bienes) Promisereceipt ≡ CC (Recibo de pago) Oferta ≡ PromiseDgoods ∧ Promisereceipt Figura 3: Implementación de SAAPL de NetBill El remitente no lo realizará y enviará el mensaje (ver también la discusión en la sección4). Al especificar las condiciones adicionales (P), se debe tener cuidado para evitar situaciones en las que no se pueden realizar el progreso porque las únicas acciones posibles se evitan por condiciones adicionales. Una forma de indicar la preferencia entre las acciones (en muchas plataformas de agentes) es reordenar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se evitan, solo se consideran en un orden diferente. El tercer refinamiento de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la máquina de compromiso, cualquier estado que no tenga ningún compromiso de nivel base es final, ya que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Que los estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es uno en el que los bienes han sido enviados y pagados, y un recibo emitido (es decir, bienes ∧ ∧ ∧ recibo). Para evitar que un agente termine la interacción demasiado temprano, agregamos esto como una condición previa al plan de terminación: ı: bienes ∧ paga ∧ recibo ∧ ¬∃p.c (p) ← ↑ ↑ Hecho. La Figura 4 muestra los planes que se cambian de la Figura 3. Para apoyar la realización de CMS, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se analizan a continuación, se pueden aplicar a los idiomas BDI existentes para que la máquina de compromiso sea de apoyo. Presentamos los tres cambios, explicamos en qué implican y para cada cambio explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado al agente 3APL. Los tres cambios son: 1. Extender las creencias del agente para que puedan contener compromisos;876 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) Planes de clientes: ı: ¬ Request ← +solicitud;↑ sendRequest.ı: ¬acept ← +aceptar;↑ sendaccept.ı: bienes ∧ ¬Pay ← +PAGO;↑ sendepo. Planes de comerciantes: ı: ¬offer ← +PromiseGoods;+Promisereceipt;↑ sendQuote.ı: ¬ (Promisereceipt ∧ bienes) ← +Promisereceipt;+bienes;↑ sendgoods.ı: paga ∧ ¬Receipt ← +recibo;↑ sendReceipt. Donde acepte ≡ CC (Page de bienes) PromiseGoods ≡ CC (Aceptar bienes) Promisereceipt ≡ CC (Recibo de pago) Oferta ≡ PromiseDgoods ∧ Promisereceipt Figura 4: Implementación de SAAPL de Netbill con condiciones de contexto refinadas (solo planes modificados) 2. Cambiar la definición de |= abarcar compromisos implícitos;y 3. Cada vez que se agrega una creencia, actualizando los compromisos existentes, de acuerdo con las reglas de dinámica de compromiso. Extender la noción de creencias para abarcar compromisos de hecho no requiere cambios en las plataformas de agentes que sean como un prólogo y de apoyo a los términos como creencias (p. Jason, 3APL, Can). Sin embargo, otras plataformas de agentes requieren una extensión. Por ejemplo, Jack, que es una extensión de Java, requeriría cambios para apoyar los compromisos que pueden anidarse. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cada vez que una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita por las creencias de los agentes (b | = c) debe tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar un compromiso para seguir un conjunto de creencias B si el compromiso está en el conjunto de creencias (c ∈ B), pero también en otras condiciones. Por ejemplo, se puede considerar que un compromiso de pagar C (pago) está implícito en un conjunto de creencias que contiene el pago porque el compromiso puede haber mantenido y dado de alta cuando el pago se hizo cierto. Reglas similares se aplican para los compromisos condicionales. Estas reglas, que se introdujeron en [15], se reformalizaron posteriormente en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la Figura 5. El cambio que debe hacerse a SAAPL para admitir implementaciones de la máquina de compromiso es extender la definición de | = para incluir estas cuatro reglas. Para 3APL, esto se realizó al hacer que cada agente incluya las siguientes cláusulas de Prolog: Holds (x):- cláusula (x, verdadero).Holds (C (P)):- Holds (P).Holds (c (p)):- cláusula (cc (q, p), verdadero), Holds (Q).Holds (CC (_, Q)):- Holds (Q).Holds (CC (_, Q)):- Holds (C (Q)). La primera cláusula simplemente dice que cualquier cosa se mantiene si es en las creencias de los agentes (cláusula (x, verdadera) es verdadero si x es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para usar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, CC (M, C, Pay, Recibo) escribamos Holds (CC (M, C, Pay, Recibo)). B = norma (b ∪ {b}) q, n, b, +b - → q, n, b, norma de función (b) b ← b para cada b ∈ B do si b = c (p) ∧ b |= p entonces b ← b \ {b} elseif b = cc (p q) entonces si b | = q entonces b ← b \ {b} elseif b | = p entonces b ← (b \ {b}) ∪ ∪ {c (q)} elseif b | = c (q) entonces b ← b \ {b} endif endif endfor return b Función final b | = P b | = c (p) c1 cc (q p) ∈ B b | = q b | = p c2B | = CC (P Q) B | = Q CC1 B | = C (Q) B | = CC (P Q) CC2 Figura 5: Nuevo semántico operativo El cambio final es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias para que aplique un algoritmo para actualizar los compromisos. La regla y el algoritmo modificados (que refleja la definición de norma en [14]) se puede encontrar en la parte superior de la Figura 5. Para 3APL, este cambio final se logró insertando manualmente la actualización () después de actualizar las creencias y definiendo las siguientes reglas para actualizar (): update () <- c (p) y posee (p) |{Deletec (p);update ()}, update () <- cc (p, q) y retiene (q) |{Deletecc (p, q);update ()}, update () <- cc (p, q) y retiene (p) |{Deletecc (p, q);AddC (q);update ()}, update () <- cc (p, q) y retiene (c (q)) |{Deletecc (p, q);update ()}, update () <- true |Omita donde Deletec y DeletecC eliminen respectivamente un compromiso de nivel base y condicional, y ADDC agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan las acciones directamente: pueden desencadenar acciones indirectamente, pero en general su efecto es evitar la finalización de una interacción mientras hay compromisos sobresalientes (nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso de NetBill6. Para ilustrar las diferentes interacciones posibles, el código se modificó para que cada agente seleccionado al azar de las acciones que podía realizar, y se realizaron varias ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostrados, 6 código fuente están disponibles en http://www.winikoff.net/cm el sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 877 Figura 6: La muestra se ejecuta desde la implementación de 3APL (giros alternos), incluida la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego realizado. Una diferencia menor entre la implementación 3APL y SAAPL se refiere a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPL), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que se recibió el mensaje [6]. Por lo tanto, en la implementación de 3APL tenemos reglas PG desencadenadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que debemos asegurarnos de que la creencia en cuestión se elimine una vez que se maneja, o que modificamos condiciones previas de planes para evitar manejarla más de una vez. En nuestra implementación, eliminamos estas creencias recibidas cuando se manejan, para evitar el manejo duplicado de los mensajes.4. Más allá de dos participantes que se generalizaran a más de dos participantes de interacción requieren revisar cómo se realiza la gestión de turnos, ya que ya no es posible asumir giros alternos [7]. De hecho, quizás sorprendentemente, incluso en el entorno de dos participantes, ¡una configuración de turno alterna es una suposición irrazonable! Por ejemplo, considere la ruta (en la Figura 1) del estado 1 al 15 (SendGoods) y luego al estado 12 (Sendaccept). El resultado, en una configuración de turno alterna, es un extremo muerto: solo hay una acción posible en el estado 12, a saber, SendEpo, pero esta acción lo realiza el cliente, ¡y es el recurro de los comerciantes para actuar! La Figura 7 muestra el FSM para NetBill con iniciativa alterna. Una solución a este problema que funciona en este ejemplo, pero no se generaliza7, es debilitar el régimen alterno de giro al permitir que un agente actúe dos veces seguidos si su segunda acción es impulsada por un compromiso. Una solución general es rastrear cuyo turno es actuar. Esto se puede hacer calculando qué agentes tienen acciones que se pueden realizar en el estado actual. Si solo hay un agente activo, entonces es claramente que los agentes recurren a actuar. Sin embargo, si más de un agente está activo, entonces de alguna manera los agentes necesitan determinar quién debe actuar a continuación. Trabajar esto por negociación no es una solución particularmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción donde más de un agente está activo (en el billete, esto se aplica a siete de cada dieciséis estados), por lo que es muy deseable tener un mecanismo de peso ligero para hacereste. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (usted va primero, no, primero,. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúa con preferencia al comerciante, o que cada agente tiene una prioridad numérica (tal vez determinada por el orden en que se unió a la interacción?) que determina quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no tratar de administrar la toma de giro.7 Considere las acciones A1 (c) ⇒ P, A2 (C) ⇒ Q y A3 (M): P ∧ Q ⇒ R.Figura 7: Netbill con iniciativa alterna en lugar de rastrear y controlar cuyo turno es, simplemente permitimos que los agentes actúen libremente y confíen en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que haremos precisa,y probar, en el resto de esta sección. El problema de que los agentes múltiples estén activos simultáneamente es que en lugar de que todos los agentes acuerden el estado de interacción actual, los agentes pueden estar en diferentes estados. Esto se puede visualizar como cada agente que tiene su propia copia del FSM que navega a través de donde es posible que los agentes sigan diferentes caminos a través del FSM. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales?2. ¿Puede un agente estar en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones viajan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (nuevamente, bajo ciertos supuestos). Por acciones viajan queremos decir que el estado resultante de realizar una secuencia de acciones A1... An es lo mismo, independientemente del orden en el que se realicen las acciones. Esto significa que incluso si los agentes toman diferentes caminos a través del FSM, todavía terminan en el mismo estado resultante, porque una vez que todos los mensajes se hayan procesado, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el tema de terminar en diferentes estados finales. Volvemos a la posibilidad de que ocurran errores en breve. Definición 1 (monotonicidad) Una acción es monotónica si no elimina 8 fluidos o compromisos. Una máquina de compromiso es 8 que se elimina directamente, está bien descargar compromisos agregando fluentes/compromisos.878 El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) monotónicos si todas sus acciones son monotónicas.(Adaptado de [14, definición 6]) Teorema 1 Si A1 y A2 son acciones monotónicas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1.(Adaptado de [14, Teorema 2]). Esto supone que ambas acciones se pueden realizar. Sin embargo, es posible que el rendimiento de A1 desactive A2. Por ejemplo, si A1 tiene el efecto +P, y A2 tiene condición previa ¬P, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no se pueden realizar en ninguno de los orden. Podemos evitar esto asegurando que las condiciones previas de las acciones no contengan negación (o implicación), ya que una acción monotónica no puede dar lugar a una condición previa que esté libre de negaciones. Tenga en cuenta que esta restricción solo se aplica a la condición previa de acción original, P, no a ninguna condición previa adicional impuesta por el agente (P). Esto se debe a que solo P se usa para determinar si otro agente puede realizar la acción. Por lo tanto, los CM monotónicos con condiciones previas que no contienen negaciones tienen acciones que viajan. Sin embargo, de hecho, la restricción a los CM monotónicos es innecesariamente fuerte: todo lo que se necesita es que cada vez que haya una opción de agente que pueda actuar, entonces las posibles acciones son monotónicas. Si solo hay un agente que puede actuar, entonces no se necesita restricción sobre las acciones: pueden o no ser monotónicos. Definición 2 (localmente monotónica) Una máquina de compromiso es localmente monotónica si para algún estado s (a) solo un agente solo tiene acciones que se pueden realizar;o (b) todas las acciones que se pueden realizar en S son monotónicas. Teorema 2 En un CM localmente monotónico, una vez que se hayan procesado todos los mensajes, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que se hayan procesado todos los mensajes, tenemos que todos los agentes habrán realizado el mismo conjunto de acciones, tal vez en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no tengan aún convergidos al mismo estado, todas las acciones deben ser monotónicas y, por lo tanto, que estas acciones conmutan, y no pueden deshabilitar ninguna otra acción. Considere el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo que otro agente (llamar XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitado, por lo que, dado que el CM es localmente monotónico, las acciones relevantes deben ser monotónicas. Por lo tanto, después de hacer A, la acción B aún debe estar habilitada, por lo que el mensaje para hacer B puede procesarse actualizando las creencias de los agentes receptores con los efectos de B. Además, debido a que las acciones monotónicas viajan, el resultado de hacer A antes de B es el mismo que hacer B antes de A: S A −−−−− → SA??YB B??y SB −−−− → A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Debido a que B está habilitado, y C no es realizado por el Agente XB (ver más abajo), debemos tener que C también sea monotónico y, por lo tanto, (a) el resultado de hacer A y B y C es el mismo independientemente del orden en queLas tres acciones se realizan;y (b) C no deshabilita B, por lo que B todavía se puede hacer después de C. S A −−−−− → Sa C −−−−−− → SAC??YB B??y b??y SB −−−−− → A SAB −−−−− → C SABC La razón por la cual C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada9. Desde la perspectiva de XB, la acción B se realizó antes de C y, por lo tanto, desde cualquier otra perspectiva de agentes, el mensaje que dice que B se realizó debe ser recibido (y procesado) antes de un mensaje que dice que C está hecho. Este argumento se puede extender para mostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en que convergen en un solo estado deben ser monotónicos y, por lo tanto, siempre es posible converger (porque las acciones no están deshabilitadas), por lo queLa interacción está libre de errores;y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monotónicas viajan). Este teorema ofrece una fuerte garantía teórica de que no hacer la gestión de turnos no conducirá al desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no conduciría a ningún accidente, y solo es posible porque los axiomas CM refinados son simétricos. Basado en este teorema, la transformación genérica de CM a código debería permitir que los agentes actúen libremente, lo que se logra simplemente cambiando ı: P ∧ P ∧ ¬E ← +E;↑ a a ı: P ∧ P ∧ ¬E ← +E;↑ a;ı Por ejemplo, en lugar de ı: ¬ Request ← +solicitud;↑ sendRequest tenemos ı: ¬ request ← +solicitud;↑ sendRequest;i. Una consecuencia del teorema es que no es necesario garantizar que los agentes procesen mensajes antes de continuar interactuando. Sin embargo, para evitar el paralelismo innecesario, lo que puede dificultar la depuración, aún puede ser deseable procesar mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones desde la implementación 3APL que se ha modificado para permitir la interacción libre, no alternativa.5. Discusión Hemos presentado un esquema para mapear las máquinas de compromiso en las plataformas BDI (usando SAAPL como un ejemplo), identificó tres cambios que debían realizarse a SAAPL para admitir la interacción basada en CM, y demostró que la gestión de turnos se puede evitar en la interacción CMBased,siempre que el CM sea localmente monotónico. Los tres cambios en SAAPL y el esquema de traducción de la máquina de compromiso a los planes BDI son aplicables a cualquier idioma BDI. Como hemos mencionado en la Sección 1, ha habido algo de trabajo para diseñar una interacción de agentes flexible y robusta, pero prácticamente no hay trabajo para implementar interacciones flexibles y robustas. Ya hemos discutido el grapas [9, 10]. Otro trabajo que es relevante es el trabajo de Cheong y Winikoff en su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmático, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar código de esqueleto que luego debe completarse. Además, no abordan el giro que está en problemas: cómo decidir qué agente actúa cuando más de un agente puede actuar.9 También suponemos que el medio de comunicación no entrega mensajes fuera de orden, que es el caso para (por ejemplo) TCP. El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 879 Figura 8: La muestra se ejecuta desde la implementación de 3APL (giros no alternativos) el trabajo de Kremer y Flores (por ejemplo [8]) también utiliza compromisos y se ocupa de la implementación. Sin embargo, proporcionan soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busca implementar agentes. Aunque hemos implementado la interacción NetBill usando 3APL, los cambios en la semántica se realizaron modificando nuestro programa NetBill 3APL, en lugar de modificar la implementación 3APL en sí. Claramente, sería deseable modificar la semántica de 3APL (o de otro idioma) directamente, cambiando la implementación. Además, aunque no lo hemos hecho, debe estar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para trabajos adicionales es observar cómo los supuestos necesarios para garantizar que las acciones viajen sean relajadas. Finalmente, es necesario realizar una evaluación empírica. Ya ha habido algo de trabajo para comparar Hermes con un enfoque convencional centrado en el mensaje para diseñar la interacción, y esto ha demostrado que el uso de Hermes da como resultado diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17].6. Referencias [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación de múltiples agentes: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseño de interacciones de agentes orientadas a objetivos. En Actas del 6to Taller Internacional sobre Ingeniería de Software Orientada a los Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementación de interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas de Multi-Agentes (PRoRAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nous, 25 (4): 487-512, 1991. [6] M. Dastani, J. van der Ham y F. dignum. Comunicación para los agentes dirigidos a objetivos. En Actas del Taller de lenguajes de comunicación y políticas de conversación de agentes, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un testbito para diálogos multipartidistas. En avances en la comunicación de agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una red de subsunción performativa para apoyar las conversaciones basadas en el compromiso. En F. dignum, V. dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, agentes autónomos y sistemas de múltiples agentes (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. Paple: un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Conjunta Internacional sobre Agentes Autónomos y Sistemas Multiagentes (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representar y ejecutar protocolos como acciones conjuntas. En Actas de la primera conferencia conjunta internacional sobre agentes autónomos y sistemas de múltiples agentes, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press.[11] M. Tambe y W. Zhang. Hacia el trabajo en equipo flexible en equipos persistentes: informe extendido. Revista de Agentes Autónomos y Sistemas de Multi-Agentes, 2000. Número especial en Best of ICMAS 98. [12] M. Winikoff. Un metabloqueo de AgentsPeak y sus aplicaciones. En el tercer taller internacional sobre programación de sistemas de agentes múltiples (PROMAS), páginas 123-138. Springer, LNCS 3862 (posterior al proceso, 2006), 2005. [13] M. Winikoff. Diseño de interacciones de agente basadas en compromiso. En Actas de la Conferencia Internacional IEEE/WIC/ACM de 2006 sobre tecnología de agentes inteligentes (IAT-06), 2006. [14] M. Winikoff. Implementación de interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuido. Multiagente y sistemas de cuadrícula, 2 (4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejora de las máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Lenguas y Tecnologías de Agentes Declarativos II, Número 3476 en Notas de conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y de procedimiento en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de representación y razonamiento del conocimiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo del protocolo. En F. dignum, V. dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, agentes autónomos y sistemas de múltiples agentes (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución de protocolo flexible: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la primera conferencia conjunta sobre agentes autónomos y sistemas multiagentes (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre los compromisos en el cálculo del evento: un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07)