Recopilación de métricas de tiempo de ejecución para el middleware Adaptación de aplicaciones móviles Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne,Australia caspar@cs.rmit.edu.au Pablo Rossi Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au Resumen Este documento propone, implementa y evalúa el peor de los casos de rendimiento, una estrategia de recolección de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móvil y admitir middleware. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico que incluye gerentes de host, tiempos de ejecución y objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y la propagación de métricas a través del sistema. La plataforma MobJex se utilizó como base para la implementación y las pruebas con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, la eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de la recolección. Categorías y descriptores de sujetos c.2.4 Sistemas distribuidos;D.2.8 Métricas Medición de términos generales, rendimiento.1. Introducción Las diferentes capacidades de los dispositivos móviles, más la velocidad variable, la tasa de error y las características de desconexión de las redes móviles [1], dificultan predecir de antemano el entorno de ejecución exacta de las aplicaciones móviles. Una solución que recibe una atención cada vez mayor en la comunidad de investigación es la adaptación de la aplicación [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como la red, el procesador o el uso de la memoria. La adaptación efectiva requiere información detallada y actualizada sobre el sistema y el software en sí. Las métricas relacionadas con la información del sistema (por ejemplo, procesador, memoria y carga de red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas requeridas para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifican en respuesta a los cambios en el entorno de tiempo de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de los objetos [6], también requiere métricas de software detalladas [9] ya que la colocación de objetos depende de las características de ejecución de los objetos móviles. Con la excepción de Mobjex [6], los sistemas de objetos móviles existentes como Voyager [10], Fargo [11, 12] y Javaparty [13] no proporcionan una adaptación automatizada y, por lo tanto, carecen del proceso de recolección de métricas requerido para respaldar este proceso. En el caso de MobJex, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas sintéticas pre-escritas ya que hay poco trabajo previo en la colección dinámica de métricas de software en marcos de objetos móviles, y no hay medios existentes derecolectándolos automáticamente. En consecuencia, la principal contribución de este documento es una solución para la colección de métricas dinámicas para admitir la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicaciones y middleware, y por lo tanto, la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados propagados de manera eficiente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recolectar cada métrica no se fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión en función de la eficiencia de la solución elegida (ver Sección 3). El resto de este documento se organiza de la siguiente manera: la Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recolección, propagación y entrega de métricas como se describe en la Sección 3. La Sección 4 describe algunas pruebas y resultados iniciales y la Sección 5 se cierra con un resumen, conclusiones y discusión del trabajo futuro.2. Antecedentes en general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos se etiqueten como objetos móviles, proporcionando soporte de middleware para que dichos objetos se muevan en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso de contenedor para la administración de objetos móviles. Por ejemplo, en Fargo [15] este componente se conoce como un núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso con MobJex, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizandohilos. Las aplicaciones en sí comprenden objetos móviles, que interactúan entre sí a través de proxies [14]. Se requieren proxies, que tienen la misma interfaz de método que el objeto en sí mismo pero agregan la comunicación remota y la funcionalidad de seguimiento de objetos, para cada objeto objetivo con el que se comunica un objeto fuente. Tras la migración, los objetos proxy se mueven con el objeto de origen. El sistema MobJex basado en Java, que se utiliza como plataforma de implementación para la solución de recolección de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un gerente de host (conocido como servicio en Mobjex) proporciona un punto de comunicación central al ejecutar en un puerto conocido por host por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución o objetos móviles. En segundo lugar, MobJex tiene un contenedor de objetos móviles por aplicación llamado Administrador de transporte (TM). Como tal, los gerentes de host y de transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJex puede tener un controlador de sistema centralizado que incorpore un motor de adaptación global para realizar una optimización del sistema.3. Colección de métricas Esta sección analiza el diseño y la derivación de una solución para recopilar métricas para apoyar la adaptación de las aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJex, se discute en su mayor parte en términos genéricos, excepto que explícitamente es específico de MobJex.3.1 Selección de métricas Las métricas de Ryan y Rossi [9] se han elegido como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles, además de haber sido derivadas de una serie de modelos matemáticos y validados empíricamente validados. Además, se demostró empíricamente las métricas para mejorar el rendimiento de la aplicación en un escenario de adaptación real después de un cambio en el entorno de ejecución. Sin embargo, estaría más allá del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9] y, por lo tanto, para proporcionar un subconjunto útil no aleatorio, elegimos implementar el conjunto mínimo de métricas necesarias para implementarAdaptación local y global [9] y, por lo tanto, satisface una variedad de escenarios de adaptación reales. Como tal, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a respaldar la implementación de las métricas restantes, así como otras métricas no especificadas, como las relacionadas con la calidad y la utilización de recursos. Este subconjunto se enumera a continuación y se clasifica de acuerdo con el tipo métrico. Tenga en cuenta que algunas métricas adicionales se utilizaron para fines de implementación para obtener métricas centrales o ayudar a la evaluación, y como tal se definen en contexto cuando corresponda.1. Métricas de software: número de invocaciones (NI), la frecuencia de las invocaciones en métodos de una clase.2. Métricas de rendimiento: tiempo de ejecución del método (ET), el tiempo necesario para ejecutar un cuerpo de método (MS).- Tiempo de invocación del método (IT), el tiempo necesario para invocar un método, excluyendo el tiempo de ejecución del método (MS).3. Métricas de utilización de recursos: uso de memoria (MU), el uso de la memoria de un proceso (en bytes).- Uso del procesador (PU), el porcentaje de la carga de la CPU de un host.- Uso de la red (NU), el ancho de banda de la red entre dos hosts (en bytes/seg). Los siguientes son breves ejemplos de varias de estas métricas para demostrar su uso en un escenario de adaptación. A medida que aumenta el uso del procesador (PU) en cierto host, el tiempo de ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], lo que facilita la decisión de mover un objeto con alto ET a otro host con bajoPU. El tiempo de invocación (IT) muestra la sobrecarga de invocar un determinado método, con la sobrecarga de invocación de los parámetros de ensarching y la transmisión de datos remotos para una llamada remota que sean órdenes de magnitud más altas que el costo de presionar y hacer estallar datos de la pila de llamadas de método. En otras palabras, la invocación del método remoto es costosa y, por lo tanto, debe evitarse a menos que las ganancias obtengan un objeto a un host con más potencia de procesamiento (reduciendo así ET) superan a la mayor cantidad de la llamada remota. Finalmente, el número de invocaciones (NI) se usa principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación predice el valor con el tiempo de una decisión de adaptación particular.3.2 Medición de métricas Esta subsección analiza cómo cada una de las métricas en el subconjunto bajo investigación se puede obtener en términos de medición directa o derivación, y en el lugar en el marco de objetos móviles se deben medir tales métricas. De las métricas de recursos ambientales, el uso del procesador (PU) y el uso de la red (NU) se relacionan con una máquina individual y, por lo tanto, se pueden medir directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJex. Sin embargo, el uso de la memoria (MU), que representa el estado de memoria de un proceso de ejecución en lugar del uso de memoria de un host, debe recolectarse dentro de un tiempo de ejecución individual. La medición del número de métricas de invocaciones (NI) y tiempo de ejecución (ET) también se puede realizar mediante medición directa, sin embargo, en este caso dentro de la implementación de objetos móviles (Mobject). Ni implica simplemente incrementar un valor de contador al comienzo o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al comienzo del método y deteniéndolo al finaldel método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recopilación de tiempo de invocación (IT) no es tan sencillo porque el tiempo necesario para invocar un método solo se puede medir después de que el método termina su ejecución y regresa a la persona que llama. Para recolectar métricas, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrica (RT), como el tiempo total tomado para una llamada de método a la finalización, que es la suma de IT y ET. El tiempo de respuesta se puede medir directamente utilizando la misma técnica basada en el temporizador utilizada para medir ET, aunque al comienzo y al final de la llamada proxy en lugar de la implementación del método. Una vez que se conoce el tiempo de respuesta (RT), puede derivarse restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores RT y ET de los cuales se derivan se miden por la necesidad utilizando el código de temporizador en diferentes ubicaciones, es decir, RT medido en el proxy, ET medido en el cuerpo del método de la implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de Mobjex, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente para un objeto móvil (mobject) tener referencias hacia atrás a todos los muchos proxies que referenIT (uno por objeto de origen). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la Sección 3.5 en el que la métrica RT se empuja al mobjeto para que pueda derivarse del valor ET almacenado allí. El valor derivado del mismo se almacena y se propaga aún más según sea necesario de acuerdo con los criterios de la Sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de medición El enfoque de encuesta se identificó como el método más apropiado para recolectar métricas de utilización de recursos, como el uso del procesador (PU), el uso de la red (NU) y el uso de la memoria (MU), ya que no son parte del flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos encuesta el sistema operativo para la CPU actual o la carga de red respectivamente. En el caso del uso de la memoria (MU), la máquina virtual Java (JVM) [16] está encuestada para la carga de memoria actual. Tenga en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de encuesta debe hacerse de manera asincrónica en un hilo separado. Las métricas que son adecuadas para la recopilación iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el número de invocaciones (NI), el tiempo de ejecución (ET) y el tiempo de invocación (IT), que son explícitamenterelacionado con la invocación normal de un método y, por lo tanto, se puede medir directamente en este momento.3.4 Agregación de métricas En la solución presentada en este documento, todas las métricas recopiladas en la misma ubicación se agregan en un metro de metroiner con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que les permite propagarse fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan entregarse al motor de adaptación, como se discute en la siguiente subsección. Tenga en cuenta que esta contención captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considere el caso de medir el consumo de memoria. En un nivel grueso de granularidad, esto podría medirse para una aplicación completa o incluso un sistema, pero también podría medirse a nivel de un objeto individual;o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en la movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representan tanto la duración de una ejecución del método como la sobrecarga de una invocación de método. El uso de contenedores de métricas facilita la recolección de métricas a niveles de granularidad que van desde una sola máquina hasta el nivel de método individual. Tenga en cuenta que algunos contenedores de métricas no contienen ningún objeto métrico, ya que como se describió anteriormente, la implementación de la muestra usa solo un subconjunto de las métricas de adaptación de [9]. Sin embargo, en aras de la consistencia y para promover la flexibilidad en términos de agregar nuevas métricas en el futuro, estos contenedores todavía se consideran en el diseño actual para la integridad y el trabajo futuro.3.5 Propagación y entrega de métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas del administrador/servicio del host (o tiempo de ejecución si el administrador del host no está presente) al motor de adaptación. Con respecto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, objeto móvil), la métrica se presiona (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, tiempo de ejecucióno Manager de transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de mobjetos cambiados) se empujará al siguiente componente de nivel (es decir, el administrador del host o la adaptaciónmotor). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local es realizada por un motor que se ejecuta en el host local (por ejemplo, en Mobjex, esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada local entre procesos. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas es a través de una llamada remota, y en el caso de que existan múltiples tiempos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de latencia de comunicación de red, es importante que el gerente del host pase tantas métricas como sea posible al motor de adaptación en una sola invocación, lo que implica la necesidad de reunir estas métricas en el gerente del host, a través de alguna forma de empuje.o propagación, antes de enviarlos al motor de adaptación. En consecuencia, se debe mantener una representación abstracta o modelo [17] del sistema. Tal modelo contendría entidades modelo, correspondientes a cada uno de los componentes del sistema principal, conectados en un árbol como la jerarquía, que refleja con precisión la estructura y la jerarquía de contención del sistema real. Adjuntar los contenedores de métricas a las entidades modeladas permite que una entidad modelo que represente a un administrador de host se entregue al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo puede reutilizarse para la propagación, sino que también proporciona un medio efectivo para entregar información de métricas del administrador del huésped al motor de adaptación. La relación entre las entidades modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de propagación y entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), para queReduzca la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterio que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe tomarse o no. Este enfoque fue diseñado de tal manera que cada vez que no se satisface un solo criterio, los criterios posteriores no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio métrico de medición: este criterio está unido a los objetos métricos individuales para decidir si un nuevo valor métrico debe medirse o no. Esto es más útil en el caso en que es costoso medir una métrica particular. Además, este criterio puede usarse como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga la historia métrica. Ejemplos simples se basarían en el tiempo o la frecuencia, mientras que los criterios más complejos podrían ser específicos de dominio para una métrica particular o basada en la información almacenada en el historial de métricas. Notifique el criterio del contenedor de métricas: este criterio también se adjunta a objetos métricos individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto métrico debe notificar a su MetricScontainer. Esto se basa en la suposición de que puede haber casos en los que es deseable medir y almacenar una métrica en la historia para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativo como para notificar al MetricScontainer para su posterior procesamiento. Un ejemplo simple de este criterio sería un umbral basado en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de algún interés para el MetricScontainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para garantizar un procesamiento adicional y una posible entrega de métricas. Notifique el criterio de la entidad del modelo: a diferencia de los dos criterios anteriores, este criterio está asociado con un metrográfico. Dado que un MetricScontainer puede tener múltiples objetos métricos, de los cuales tiene conocimiento de dominio explícito, es capaz de determinar si, cuándo y cuántas de estas métricas deben propagarse a la modelos de entorno y, por lo tanto, convertirse en candidatos para ser parte del modelo de modelos jerárquicos.Proceso como se describe a continuación. Esta toma de decisiones se ve facilitada por las notificaciones recibidas de objetos métricos individuales como se describió anteriormente. Una implementación simple estaría esperando un cierto número de actualizaciones antes de enviar una notificación a la entidad modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un posible criterio sería verificar si dos o más de las métricas han cambiado. Se puede hacer una implementación un poco más avanzada dando a cada métrica un peso para indicar cuán significativo es en el proceso de toma de decisiones de adaptación. Criterio de empuje: el criterio push se aplica a todos los modelentitos que son contenedores, es decir, el transporte de la ganagermodeleNidad, RuntimeModelEntity y ServiceModelEntity, así como el caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el transporte de ManagermodelEntidad esto sirve como un criterio para determinar la notificación ya que como con los criterios descritos anteriormente, se trata de una referencia local. Para las otras entidades modelo, esto tiene como una oportunidad para determinar cuándo y qué métricas deben llevarse al contenedor principal en el que el caso de la empresa de servicio, el padre es el motor de adaptación en sí o en el caso del proxymetricscontainer el objetivo del empuje del empuje.es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio métrico, pero lo más importante es que sirve para realizar un seguimiento de las notificaciones de sus modelos de hijos para determinar cuándo y qué información de métricas se debe impulsar a su padre o objetivo. En el caso especializado del criterio push para el proxy, la toma de decisiones se basa tanto en el proxymetricscontainer en sí, como en la información acumulada de los proxymetodmetricscontainers individuales. Tenga en cuenta que no se requiere un criterio push para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que este ya es modelo de servicio, entidad de servicio, se notifica al contenedor de la entidad del modelo de entidad del criterio de ejecución de tiempo de ejecución de tiempo de ejecución de tiempo de ejecución de la entidad del contenedor del contenedor de criterio del modelo de entidad del modelo de transporte de transporte de entidad del modeloManager Metrics Contenedor Notificar el criterio de entidad modelo Criterio Mobject Model Entity Mobject Método Métricos Notificar Criterio de entidad Modelo Criterio Push Criterion a Adaptation Engine Mobject METRICRT Metric Nodify Metrics Criterion Criterio Proxymetrics Contenedor Criterio Medida Mética Criterio Métrico 2 Medición de Criterio Métrico Métrico 1 1..N No implementado actualmente Notificar Criterio de contenedores Métricos 1 Métricos Medición Medida Criterio MétoNotificar el criterio del contenedor de métricas et métrico IT Métrico Ni Medición Métrica Criterio Medida Criterio Medición Medida Criterio Métrico Notificar Criterio del contenedor Nu Métrica Métrica Métrica Criterio Medición Medida Criterio 1..n Figura 1. Descripción general estructural de las relaciones de notificación jerárquica y criterada entre métricas, contenedores de métricas y entidades modelo manejadas por el MobjectMetricsContainer y su MobjectMethodMetricsContainers individual. Aunque siempre es importante reducir el número de empujes, esto es especialmente de un servicio a un motor de adaptación global centralizado, o de un proxy a un mobjeto. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y el ensarjamiento de datos y la desaceleración de la sobrecarga, y por lo tanto es más eficiente enviar una cantidad dada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Se puede hacer una implementación simple para reducir el número de empujes utilizando el concepto de un período de proceso [19] en cuyo caso la entidad modelo acumula los empujes de sus entidades infantiles hasta que el período de proceso expira en cuyo momento empuja las métricas acumuladas a su padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de mobjetos en una aplicación particular (es decir, TransportManager) han sufrido cambios sustanciales. Para reducir el tamaño de los datos empujados, se consideraron dos tipos de empujes: empuje poco profundo y empuje profundo. Con un empuje superficial, se presiona una lista de contenedores de métricas que contienen métricas actualizadas. En un impulso profundo, la entidad modelo en sí misma se empuja, junto con su contenedor de métricas y sus entidades infantiles, que también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el proxymetricscontainer y todos los proxymetodmetricscontainers, mientras que un impulso poco profundo significa solo los proxymetodmetricscontainers que cumplen con un cierto criterio.4. Evaluación Las pruebas preliminares presentadas en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todas las pruebas se ejecutaron con dos Pentium 4 PC de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas se conectaron a un enrutador con una tercera computadora que actuaba como un servidor de archivos y alojaba el motor de adaptación externo implementado dentro del controlador del sistema MobJex, simulando así un escenario de adaptación global. Dado que solo se podría ejecutar un número limitado de pruebas, esta evaluación eligió medir el peor de los casos en el que se inició toda la recolección de métricas en Mobjects, en el que el costo de propagación es más alto que para cualquier otra métrica recolectada en el sistema. Además, dado que las pruebas exhaustivas de los criterios están más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. Se eligió el criterio de métricas de medida, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio push también se implementó en el servicio, para proporcionar una evaluación del control de la frecuencia de la entrega de métricas al motor de adaptación. Todos los demás criterios (actualizados y empuje) se establecieron siempre, lo que significa que siempre evaluaron como verdadero y, por lo tanto, se publicó una notificación. La Figura 2 muestra la sobrecarga de la colección métrica en el Mobject (MMCO), para diferentes números de mobjetos y métodos cuando todos los criterios siempre deben proporcionar la medición máxima y la propagación de métricas y, por lo tanto, un escenario de rendimiento absoluto en el peor de los casos. Se puede ver que los factores independientes de aumentar el número de mobjetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que está aproximadamente a N cuadrado, los resultados iniciales no son desalentadores ya que entregan todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (que constituye una aplicación bastante grande dada que los mobjetos generalmente representan grano grueso.Los grupos de objetos) son de aproximadamente 400 ms, lo que razonablemente se puede esperar que se compensa con las ganancias de adaptación. Tenga en cuenta que, en contraste, la sobrecarga de la colección de métricas proxy (PMCO) era relativamente pequeña y constante en <5 ms, ya que en ausencia de un criterio de empuje proxy (esto solo se implementó en el servicio) los datos del tiempo de respuesta (RT) para un soloEl método se empuja durante cada invocación.50 150 250 350 450 550 1 5 10 15 20 25 Número de mobjetos/métodos MobjectMetricsCollectionCoverHeadmmco (MS) Métodos Mobjects ambos Figura 2. Las características de rendimiento del peor de los casos, el siguiente paso, fue determinar la sobrecarga de la recopilación de métricas porcentuales en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de los objetos que serían adecuados para la adaptación utilizando este enfoque de recolección métrica. Claramente, no es práctico medir las métricas y realizar la adaptación en objetos con breves tiempos de ejecución que no pueden beneficiarse de la ejecución remota en hosts con mayor potencia de procesamiento, lo que lo compensa con la sobrecarga de la ejecución remota en comparación con la ejecución local, así como el costo de la migración de objetos yEl proceso de recolección de métricas en sí. Además, para demostrar el efecto del uso de criterios basados en frecuencia simples, los resultados de MMCO como porcentaje del tiempo de ejecución del método se trazaron como un gráfico tridimensional en la Figura 3 con el eje z que representa la frecuencia utilizada en ambos criterios de metrics de mediday el criterio de empuje del motor de adaptación al motor de adaptación. Esto significa que para un valor de frecuencia de 5 (n = 5), las métricas solo se miden en cada quinta llamada de método, lo que resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n = 5 también se aplicó al criterio de empuje del servicio, de modo que las métricas solo fueron empujadas al motor de adaptación después de cinco de dichas notificaciones, eso es, por ejemplo, cinco mobjetos diferentes habían actualizado sus métricas. Estos resultados son alentadores ya que incluso para el peor de los casos de n = 1, la sobrecarga de la colección métrica es un 20% aceptable para un método de duración de 1500 ms (que es relativamente corto para un componente o objeto de nivel de servicio en una aplicación de clase empresarial distribuida) conTrabajo previo sobre adaptación que muestra que tal sobrecarga podría recuperarse fácilmente por las ganancias de eficiencia realizadas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados sincrónicamente a través de una llamada remota al motor de adaptación en un host diferente, lo que normalmente se haría de manera asincrónica, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso el uso de criterios modestos para reducir la medición de las métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET.0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. Resumen y conclusiones Dados los desafíos de desarrollar aplicaciones móviles que se ejecutan en entornos dinámicos/heterogéneos, y el posterior interés en la adaptación de la aplicación, este documento ha propuesto e implementado una estrategia de recolección de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y admitir el middleware. Se realizaron estudios de laboratorio controlados para determinar el rendimiento del peor de los casos, así como mostrar la reducción en la sobrecarga de la recolección al aplicar criterios de recolección simples. Además, las pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basados en el tiempo de ejecución del método) que serían buenos candidatos para la adaptación utilizando la implementación del peor de los casos de la estrategia de recolección de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de la recolección. Si bien la potencialmente eficacia de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente la sobrecarga de la recolección mediante el uso de criterios más sofisticados. Uno de estos enfoques podría basarse en mantener el historial de métricas para determinar el comportamiento temporal de las métricas y, por lo tanto, tomar decisiones más inteligentes y conservadoras con respecto a si es probable que un cambio en una métrica particular sea de interés para el motor de adaptación y, por lo tanto, debería servir comoUna base para la notificación de inclusión en el siguiente impulso de métricas. Además, dicha historia temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en gran medida constante no es necesario medir con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de Mobjex a la cantidad de las ganancias que se pueden hacer a través de la adaptación a través de la movilidad de los objetos y, por lo tanto, se demuestran en la práctica, la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recolección de métricas descritos en este documento a un sistema de gestión del contexto más general y reutilizable [20].6. Referencias 1. Katz, R.H., Adaptación y movilidad en sistemas de información inalámbrica. IEEE Personal Communications, 1994. 1: p.6-17.2. Hirschfeld, R. y Kawamura, K. Adaptación del servicio dinámico.En talleres ICDCS04.2004. 3. Lemlouma, T. y Layaida, N. Adaptación consciente del contexto para dispositivos móviles.En Actas de la Conferencia Internacional IEEE sobre Gestión de datos móviles 2004. 2004. 4. Noble, B.D., et al. Adaptación ágil consciente de la aplicación para la movilidad.en Proc.del 16º Simposio ACM sobre sistemas operativos y principios Sosp.1997. Santo-Malo, Francia.5. Rossi, P. y Ryan, C. Una evaluación empírica de la adaptación local dinámica para aplicaciones móviles distribuidas.en Proc.del Simposio Internacional de 2005 sobre objetos y aplicaciones distribuidas (DOA 2005).2005. Larnaca, Chipre: Springerverlag.6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparentes y portátiles en Java.en Simposio internacional sobre objetos y aplicaciones distribuidas (DOA 2004).2004. Larnaca, Chipre: Springerverlag.7. Da Silva E Silva, F.J., Endler, M. y Kon, F. Desarrollo de aplicaciones distribuidas adaptativas: una descripción general del marco y resultados experimentales.En el movimiento hacia los sistemas de Internet significativos 2003: Coopis, DOA y Odbase (LNCS 2888).2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas.en el noveno Simposio Internacional de Métricos de Software.2003. Sydney: IEEE.9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes de contexto.En Actas del Simposio de Métricos de Software Internacional IEEE Métricos 2005. 2005. Como, Italia.10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm.2005. 11. Titular, O., Ben-Shaul, I., y Gazit, H., soporte del sistema para el diseño dinámico de aplicaciones distribuidas.1998, Instituto de Tecnología Techinonisrael.pag.163 - 173. 12. Titular, O., Ben-Shaul, I. y Gazit, H. Diseño dinámico de aplicaciones distribuidas en Fargo.en 21st intl conf. Ingeniería de software (ICSE99).1999: ACM Press.13. Philippsen, M. y Zenger, M., Javaparty - Objetos remotos transparentes en Java. Concurrencia: Práctica y experiencia, 1997. 9 (11): p.1225-1242.14. Shapiro, M. Estructura y encapsulación en sistemas distribuidos: el principio de proxy.En Proc.6th intl. Conferencia sobre sistemas informáticos distribuidos.1986. Cambridge, Massachusetts (EE. UU.): IEEE.15. Gazit, H., Ben-Shaul, I. y Holder, O. La reubicación dinámica de componentes basada en el monitoreo de los componentes en Fargo.En Actas del Segundo Simposio Internacional sobre Sistemas y Aplicaciones de Agentes y el Cuarto Simposio Internacional sobre Agentes Móviles.2000. 16. Lindholm, T. y Yellin, F., La especificación de la máquina virtual Java 2ª edición.1999: Addison-Wesley.17. Randell, L.G., Holst, L.G. y Bolmsjö, G.S. Desarrollo del sistema incremental de grandes modelos de simulación de eventos discretos.En Actas de la 31ª Conferencia sobre Simulación de Invierno.1999. Phoenix, Arizona.18. Waldo, J., Llamadas de procedimiento remoto e invocación de método remoto de Java. IEEE concurrencia, 1998. 6 (3): p.5-7.19. Rolia, J. y Lin, B. Problemas de consistencia en las métricas de rendimiento de la aplicación distribuida.En Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa.1994. Toronto Canada.20. Henricksen, K. e Indulska, J. Un marco de ingeniería de software para la informática generalizada con el contexto.En Actas de la 2da Conferencia IEEE sobre Computación y Comunicaciones Permanentes (PERCOM).2004. Orlando.