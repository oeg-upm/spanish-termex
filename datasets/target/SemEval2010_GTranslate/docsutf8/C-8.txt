Operación contexto y transformación operativa basada en el contexto División de informática David Sun, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Nanyang Universidad Tecnológica Singapur czsun@ntu.edu.sg Abstract Operational Transformación (OT) es una técnica para el mantenimiento de consistencia y la deshacer del grupo, y se aplica a un número creciente de aplicaciones de colaboración. La base teórica para OT es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es inadecuado capturar los requisitos de corrección esenciales. Investigaciones anteriores habían inventado varios parches para resolver este problema, lo que resultó en algoritmos OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos OT, reflexionamos sobre lo que se había aprendido y nos propusimos desarrollar un nuevo marco teórico para una mejor comprensión y resolución de problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en el contexto). El algoritmo COT es capaz de admitir tanto DO y deshacer cualquier operación en cualquier momento, sin requerir funciones de transformación para preservar la propiedad de reversibilidad, Convergencia Propiedad 2, Propiedades inversas 2 y 3. El algoritmo COT no solo es más simple y más eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo usamos para soportar una gama de aplicaciones de colaboración novedosas. Categorías y descriptores de sujetos c.2.4 [Redes de comunicación por computadora]: aplicaciones distribuidas de sistemas distribuidos;H.5.3 [Interfaces de información y presentación]: Interfaces de grupo y organización Computación colaborativa;Algoritmos de términos generales de interacción sincrónica, diseño, teoría 1. Introducción La transformación operativa (OT) se inventó originalmente para el mantenimiento de consistencia en editores de grupos de texto simple [4]. En más de 15 años, OT ha evolucionado para respaldar un número creciente de aplicaciones, incluida la deshacer de grupos [15, 19, 18, 21], la conciencia de grupo [28], la notificación de operación y la compresión [20], la hoja de cálculo y las aplicaciones centradas en la mesa[14, 27], html/xml y edición de documentos estructurados en árbol [3, 7], procesamiento de textos y creación de diapositivas [29, 25, 24], intercambio de aplicaciones transparentes y heterogéneos [1, 10, 24] y móviles y móvilesSistemas de computación y base de datos replicados [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos continuar mejorando la capacidad y la calidad de OT para resolver problemas antiguos y nuevos. La solidez de la base teórica para OT es crucial en este proceso. Una base teórica de todos los algoritmos OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal;Las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es inadecuada para capturar condiciones de OT esenciales para la transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el comienzo de OT. El algoritmo DOPT fue el primer algoritmo OT y se basó únicamente en las relaciones de concurrencia entre las operaciones [4]: un par de operaciones son transformables siempre que sean concurrentes. Sin embargo, la investigación posterior descubrió que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben definirse en el mismo estado de documento. De hecho, el fracaso para cumplir con la segunda condición fue la raíz del Dopt-Puzzle [22]. Este rompecabezas se resolvió de varias maneras, pero la teoría de la causalidad y su limitación fueron heredadas por todos los algoritmos de seguimiento. La limitación de la teoría de la causalidad se volvió aún más prominente cuando se aplicó OT para resolver el problema de deshacer en los editores grupales. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer de nivel meta) y otras operaciones de edición normales. De hecho, la relación de causalidad no se define para las operaciones inversas (ver Sección 2). Se inventaron varios parches para resolver este problema, lo que resultó en algoritmos OT más intrincados complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos OT de mayor complejidad, reflexionamos sobre lo que se había aprendido y nos propusimos desarrollar un marco teórico uniformado para comprender y resolver problemas de OT, reducir su complejidad y 279 que respaldan suevolución continua. En este artículo, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en el contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos dependencia causal/independencia y describimos brevemente sus limitaciones en la Sección 2. Luego, presentamos los elementos clave de la teoría del contexto de la operación, incluida la definición del contexto de la operación, las relaciones de dependencia de contexto/independencia, las condiciones basadas en el contexto y los vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para soportar el mantenimiento de consistencia (DO) y el grupo deshacer bajo el supuesto de que las funciones de transformación subyacentes pueden preservar algunas propiedades de transformación importantes. Luego, estas propiedades de transformación y sus pre-condiciones se discuten en la Sección 5. Las soluciones COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo OT previo, los problemas de corrección y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8. 2. Limitaciones de la causalidad La teoría de la causalidad es fundamental para la computación distribuida y el diseño de todos los algoritmos OT existentes. Después de Lamport [9], las relaciones causales de dependencia/independencia entre las operaciones de edición se pueden definir en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones OA y OB, generadas en los Sitios I y J, OB depende causal de OA, denotado por OA → OB, IFF: (1) I = J y la generación de OA ocurrió antes de la generaciónde ob;o (2) i = j y la ejecución de OA en el sitio j ocurrió antes de la generación de OB;o (3) existe una operación de buey, de modo que OA → Ox y Ox → Ob.2 Definición 2. Relación de independencia causal dadas dos operaciones OA y OB, OA y OB son causalinables u concurrentes, denotadas por OA OB, si no ni OA → OB, ni OB → OA.2 Así como los relojes lógicos vectoriales se utilizan para capturar la casualidad en los sistemas distribuidos [17], los vectores estatales se han utilizado para capturar relaciones causales entre las operaciones y representar los estados de documentos en los sistemas OT [4, 19, 23]. Para ilustrar las relaciones causales entre las operaciones, considere una sesión de edición grupal en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (el comando deshacer deshacer (O2) y su relación con otras operaciones se explicará más adelante): O1 generado en el Sitio 0, y O2 y O3 generados en el Sitio 1. De acuerdo con las definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes de la generación de O3;O1 O2 y O1 O3 Debido a que para cada par, ninguna de las operaciones ocurrió antes de la generación de otras operaciones. En la siguiente discusión, utilizaremos el término ittransform para significar el uso de la función de TI (transformación de inclusión): IT (OA, OB), que transforma la operación OA contra la operación OB de tal manera que el impacto de OB se incluye efectivamenteen OA [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición grupal en tiempo real. El escenario en la Figura 1 (sin el comando deshacer) a menudo se ha utilizado para ilustrar el dopt-huzzle. Bajo el algoritmo DOPT [4], cuando O2 llega al Sitio 0, se informará contra O1 desde O2 O1;Esto es correcto porque O2 y O1 se definen en el mismo estado de documento (inicial). Cuando O3 llega al Sitio 0, también se transformará contra O1 desde O3 O1;Pero esto es incorrecto porque O3 se define en el estado del documento que contiene el efecto de O2, mientras que O1 se define en el estado de documento inicial. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, pueden no ser transformados correctamente. La solución a este rompecabezas es la primera en la transformación de TI O1 contra O2 para producir O1, que se define en el estado del documento, incluido el efecto de O2 (el mismo estado en el que se define O3), y luego a la transformación de IT O3 contra O1[22]. De las definiciones 1 y 2, está claro que la relación causalDependencia solo se define para las operaciones originales (p. Ej. O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (p. O1). Además, la relación de concurrencia no captura la condición esencial para la transformación correcta de TI: las dos operaciones de entrada deben definirse en el mismo estado de documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar las condiciones de OT para las operaciones inversas. El comando deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto de deshacer correcto para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe tratarse como una operación definida en el estado del documento, incluido el efecto de O2 pero no O1 y O3, de modo que O2 se pueda transformar contra O1 y O3 antes de su ejecución. Sin embargo, de acuerdo con la relación de lamports antes de la relación [9], deshacer (O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de deshacer (O2), entonces se trataría efectivamente como una operación definida en el estado del documento con los efectos de las tres operaciones O1, O2 y O3, lo que prohibiría que O2 se transforme contraCualquier operación, por lo que no logró el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado correctamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales.3. Contexto de operación 3.1 Concepto básico Conceptualmente, cada operación O se asocia con un contexto, denotado por C (O), que corresponde al estado del documento 280 en el que se define la operación. La importancia del contexto de operación es doble: (1) una operación se puede ejecutar correctamente solo si su contexto y el estado del documento actual son los mismos;y (2) una operación se puede hacer correctamente en otra operación solo si los contextos de estas dos operaciones son los mismos. En la Figura 1, tanto O1 como O2 se definen en el mismo documento inicial, por lo que están asociados con el mismo contexto;O3 se define en el estado del documento que incluye el efecto de O2, por lo que C (O3) es diferente de C (O1) o C (O2). Cuando O2 llega al Sitio 0, no se puede ejecutar como está ya que C (O2) no coincide con el estado de documento actual en el Sitio 0, que incluye el efecto de O1. O2 puede transformarse correctamente contra O1 ya que sus contextos corresponden al mismo estado de documento inicial. Cuando el O3 llega al Sitio 0, no se puede ejecutar como es, ya que C (O3) no coincide con el estado del documento actual en el Sitio 0, lo que incluye los efectos de O1 y O2. O3 no se puede transformar correctamente contra O1 ya que sus contextos son diferentes, que es la raíz del dopt-ruzzle. Como se discutió en la Sección 2, el deshacer (O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de O2 solamente.3.2 Representación del establecimiento del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para la ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, hay dos tipos diferentes de operaciones: operaciones originales generadas por usuarios y operaciones transformadas que son los resultados de algunas transformaciones. Las operaciones originales se pueden dividir en dos clases: operaciones normales que se generan para hacer algo y las operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inverso se denota por O. Dado que cada operación transformada debe provenir de una operación original, utilizamos la orgia de notación (O) para denotar la operación original de O. Si o es una operación original, entonces org (o) = O. Dado que el contexto de una operación corresponde al estado del documento en el que se define la operación, el problema de la representación del contexto puede reducirse al problema de la representación del estado del documento. En un editor de grupos basado en OT, cada estado de documento puede representarse de manera única por el conjunto de operaciones originales ejecutadas hasta ahora en el documento. Estas operaciones originales pueden ejecutarse en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado de documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar un estado de documento. Definición 3. Representación del estado del documento Un estado de documento puede estar representado por DS de la siguiente manera: 1. El estado del documento inicial está representado por ds = {}.2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org (O)}.2 Esta presentación no especifica qué forma de ejecución se deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documento son iguales y para derivar sus diferencias en términos de origen original.operaciones. Según la representación del estado del documento, el contexto de una operación normal original debe ser el mismo que la representación del estado del documento a partir del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento ds = c (o) ∪ {o}, que es el estado después de ejecutar la operación original O en el estado c (o). De acuerdo con la definición de la función IT [23], una operación transformada o, donde o = it (o, ox), debe definirse en el estado del documento ds = c (o) ∪ {org (ox)}, que esEl estado se puede lograr ejecutando buey en el estado c (o). Más precisamente, el contexto de una operación se define un golpe. Definición 4. El contexto de una operación 1. Para una operación normal original O, C (O) = DS, donde DS es la representación del estado del documento desde el cual se generó O.2. Para una operación inversa original O, C (O) = C (O) ∪ {O}, donde O es la operación que se deshará.3. Para una operación transformada O, C (O) = C (O) ∪ {org (ox)}, donde o = it (o, ox).2 Según la definición anterior, el contexto de cualquier tipo de operación puede representarse como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos c (o1) = {}, x (o2) = {} y co3) = {o2} según la definición 4-ítem 1. De acuerdo con la definición 4-ítem 2, tenemos C (O2) = {O2}. De o2 = it (o2, o1), tenemos c (o2) = {o1} de acuerdo con la definición 4-ítem 3. 3.3 dependencia de contexto/independencia definimos la relación de-dependencia/independencia de contexto entre operaciones en términos deSi se incluye una operación original en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto C → Dada una operación original OA y una operación OB de cualquier tipo, OB depende del contexto en OA, denotado por OA C → OB, IFF: (1) OA ∈ C (OB);o (2) existe una operación original de buey, de modo que oa ∈ C (ox) y ox ∈ C (OB).2 Cabe señalar que la relación de dependencia de contexto se define solo entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden incluirse en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales OA y OB, OA y OB son independientes del contexto, denotadas por OA C OB, si no se otorgan o OB, ni Ob C → OA.2 Se puede demostrar que si tanto OA como OB son operaciones normales originales, entonces OA C → OB es equivalente a OA → OB;y OA C OB es equivalente a OA OB. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación contexto-dependencia/independencia.3.4 Condiciones basadas en el contexto Las siguientes condiciones basadas en el contexto (CC) capturan requisitos esenciales para la ejecución y transformación de la operación en sistemas OT: 281 CC1: C (O) ⊆ DS es una condición necesaria para que una operación original O se transforme en el documentoEstado DS para la ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C (O). En otras palabras, para cualquier operación original Ox, si Ox C → O, entonces OX debe ejecutarse antes de O. Cuando O es una operación normal original, todas las operaciones que son causalmente antes de O deben incluirse en C (O) (de acuerdo con la Definición 1 y la Definición 5), por lo que CC1 conserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C (O) debe incluir la operación que se deshacerá por O (ver definición 4-ítem 2), por lo que CC1 conserva el orden de do-into entre las operaciones normales e inversas [21]. CC2: DS - C (O) 1 es el conjunto de operaciones con las que O debe transformarse antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforme en todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier buey en ds - c (o), debe ser que buey c o. Cuando O es una operación normal original, DS - C (O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe transformarse contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe transformarse en todas las operaciones que se ejecutan después de que O [21] deba deshacer la operación. CC3: C (O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. Se requiere CC3 para ejecutar correctamente las operaciones. CC4: C (OA) ⊆ C (OB) es una condición necesaria para que OA sea transformable al nuevo contexto dado por C (OB). Se requiere cc4 porque si c (oa) ⊆ c (ob), entonces debe haber una operación ox ∈ C (OA) pero ox ∈ C (OB), lo que significa que OA no puede transformarse al nuevo contexto C (OB) Dado que la transformación de IT no puede eliminar este buey de C (OA) (ver definición 4-item3). CC5: C (OB)-C (OA) es el conjunto de operaciones en las que OA debe transformarse antes de que se transformara contra OB. CC5 asegura que la OA se transforme en contra de las operaciones independientes de contextación en C (OB) antes de transformarse contra OB. Se puede demostrar que, para cualquier buey en C (OB)-C (OA), debe ser que Ox C Oa, CC6: C (OA) = C (OB) sea una condición necesaria para que OA se transforme encontra OB. Se requiere CC6 para aplicar correctamente las funciones. En resumen, se requieren CC1 y CC4 para garantizar el orden correcto de la ejecución/transformación de la operación;CC2 y CC5 son necesarios para seleccionar las operaciones de destino de transformación correctas;y se requieren CC3 y CC6 para garantizar la ejecución/transformación de operación correcta. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS-C (O) es la diferencia establecida entre DS y C (O).3.5 Vector de contexto Un elemento importante de la teoría del contexto de la operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para una comodidad de notación, suponemos que una sesión de edición colaborativa consiste en n sitios de colaboración, identificados por 0, 1 ,..., N - 1. 3.5.1 que representan operaciones normales originales de operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (SID, NS), donde Sid es el identificador del sitio y NSes el número de secuencia local de esta operación. Deje que Oij sea una operación normal original generada en el Sitio I con un número de secuencia j. Si OIJ se incluye en un contexto C (O), entonces Oi1, Oi2 ,..., Oij - 1 también debe incluirse en C (O) de acuerdo con la definición 3 y la definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden caracterizarse suficientemente por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos de acuerdo con sus sitios de generación, por lo que se necesitan N enteros para representar operaciones normales originales en un contexto.3.5.2 Representación de operaciones inversas originales Se puede generar una operación inversa original para deshacer una operación normal original, o para rehacer una operación sin hacer. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede generarse para deshacer, y se puede generar para deshacer O. Tanto O como O corresponden a la misma operación normal O. Según esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso para cada operación normal original deshecho. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más mediante un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene la secuencia número 1, y O tiene la secuencia número 2. En general, un inverso puede identificarse mediante un triple (SID, NS, IS), donde SID y NS son el identificador del sitio y el número de secuencia del funcionamiento normal correspondiente, y IS es el número de secuencia inversa dentro del grupo. Dado que los inversos se ejecutan secuencialmente, el número de secuencia más grande en el grupo se puede usar para representar todos los inversos en el grupo. Los grupos inversos pueden dividirse adicionalmente en n grupos inversos de acuerdo con los identificadores del sitio de sus operaciones normales correspondientes. El grupo inverso en el sitio I - icicano se expresará de la siguiente manera: ICI = [(NS0, IS0), (NS1, IS1) ,..., (NSK - 1, ISK - 1)], donde cada par (NSJ, ISJ), 0 ≤ J <k, representa un grupo inverso con operaciones inversas ISJ correspondientes a la operación normal original con el número de secuencia NSJ en el sitio i. Si no se ha deshecho el funcionamiento normal en el sitio I, ICI está vacío.3.5.3 Representando las operaciones normales e inversas para representar un contexto de operación con operaciones normales e inversas originales, un vector de contexto N-dimensional se define a continuación.282 Definición 7. Vector de contexto Dada una operación O, su contexto C (O) puede representarse mediante el siguiente vector de contexto CV (O): CV (O) = [(NS0, IC0), (NS1, IC1) ,..., (NSN - 1, ICN - 1)], donde, para 0 ≤ i ≤ n - 1, 1. NSI representa todas las operaciones normales originales generadas en el Sitio I, y 2. ICI = [(NS0, IS0), (NS1, IS1) ,..., (NSK - 1, ISK - 1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el Sitio I, donde (NSJ, ISJ), 0 ≤ J <k, representa un grupo inverso con inversos ISJ relacionados con la operación normal conNúmero de secuencia NSJ.2 En ausencia de operaciones inversas en el contexto de operación, todo ICI, 0 ≤ I ≤ n - 1, estaría vacío y un vector de contexto se reduciría a un vector de estado [4]. La representación vectorial del contexto de operación también se puede utilizar como la representación vectorial del estado del documento. Como ejemplo, considere el estado del documento después de interpretar el comando deshacer deshacer (O2) en la Figura 1. Dado que UNDO (O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (transformado) O2 será ds = {o1, o2, o3, o2}. Este estado de documento no puede ser representado por un vector de estado, pero puede representarse como un vector de contexto de la siguiente manera: CV (DS) = [(1, []), (2, [(1, 1)]]. Según la definición 7, es sencillo derivar el esquema para mantener la representación vectorial para el estado del documento después de ejecutar cada operación (según la definición 3). Además, la representación vectorial del contexto de operación también se puede utilizar para detectar eficientemente las relaciones de dependencia/independencia. Debido a la limitación del espacio, estos detalles técnicos se omiten en este documento.4. El algoritmo COT básico en el algoritmo COT básico, suponemos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas SO-FAR. Esto es diferente del log o los esquemas de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos deliberadamente la estructura de datos internos de DS no especificados para mantener el algoritmo COT independiente de la estrategia de almacenamiento de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C (O), en lugar de la representación del vector de contexto CV (O). Sin embargo, cuando una operación O se propaga del sitio local a sitios remotos, es el vector de contexto, no el conjunto de contexto, el que en realidad está respaldado en O para la propagación. El conjunto de operaciones en C (O) se puede determinar fácilmente a partir de DS en función de la información en CV (O). El algoritmo COT tiene dos partes: la parte COT-DO para soportar el mantenimiento de consistencia (DO) y la parte Cotondo para soportar deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT.4.1 COT -DO COT -DO toma dos parámetros: o - una operación original que se ejecutará, y ds - la representación actual del estado del documento. COT-DO se invoca solo si C (O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya se hayan ejecutado en DS. Algoritmo 1. Cot-do (o, ds) 1. transformación (o, ds-c (o));2. Ejecutar o;Ds: = ds ∪ {org (o)}. Procedimiento 1. Transformar (O, CD) Repita hasta CD = {}: 1. Retire el buey de Cd, donde c (ox) ⊆ c (o);2. transformar (ox, c (o) - c (ox));3. O: = it (o, ox);C (o): = c (o) ∪ {org (ox)}. COT-DO Invoca primero la transformación del procedimiento () para transformar O contra operaciones en DS-C (O) (CC2). Esto es para actualizar el contexto de O a DS. En el paso 2, debe ser que C (O) = DS (CC3), por lo que O se ejecuta como está, y el original de O se agrega a DS (de acuerdo con la definición 3-ítem 2). El corazón de Cot-Do es la transformación (O, CD), cuya tarea es transformar O contra las operaciones en CD, lo que representa la diferencia de contexto entre C (O) y un nuevo contexto en el que se debe definir O. Este procedimiento repite los siguientes tres pasos hasta que el CD se vacíe: 1. Retire una operación de buey de CD, donde C (Ox) ⊆ C (O) (CC4). Se puede determinar una operación de buey que cumple con esta condición si todas las operaciones en CD se clasifican en el orden de su ejecución y se recuperan secuencialmente.2. La transformación del procedimiento () se invoca recursivamente para transformar OX contra operaciones en C (O) −C (OX) (CC5). Esto es para actualizar el buey al contexto de O, para que puedan usarse para la transformación de TI en el siguiente paso.3. Después de la llamada recursiva para transformar (), debe ser que c (o) = c (ox) (cc6), también se transforma contra buey, y el contexto de o se actualiza agregando el original de buey (segúna la definición 4-ítem 3). Para mostrar cómo funciona Cot-Do, examinamos cómo resuelve el dopt-Puzzle en la Figura 1. Considere las ejecuciones de operación en el Sitio 0, con el estado del documento inicial DS0 = {}.1. Después de la generación de O1, desde C (O1) = DS0, O1 se ejecuta como-IS y DS0 se actualiza a DS1 = {O1}.2. Cuando O2 llega con C (O2) = {}, se llama transformar (O2, ds1− c (o2)), donde ds1 - c (o2) = {o1}. Inside Transform (O2, {O1}), ya que c (o1) = c (o2), tenemos o2: = it (o2, o1) y c (o2) = {o1}. Volviendo de la transformación (O2, {O1}), tenemos c (o2) = ds1, por lo que O2 se ejecuta, y ds1 se actualiza a ds2 = {o1, o2}, donde o2 = org (o2).3. Cuando O3 llega con C (O3) = {O2}, se llama transformar (O3, ds2− c (o3)), donde ds2 - c (o3) = {o1}. La transformación interna (O3, {O1}), Transform (O1, C (O3) −c (O1)) se llama recursivamente, con C (O3) - C (O1) = {O2}, que es el paso clave para detectarEl dopt-huzzle. En la transformación recursiva (O1, {O2}), ya que c (o2) = c (o1), tenemos o1: = it (o1, o2) y c (o1) = {o2}. Volviendo de la recursión, tenemos c (o1) = c (o3), entonces c (o3): = it (o3, o1) (el dopt-sumorz resuelto aquí) y c (o3) = {o1, o2}, donde o1 = org (O1). Después de regresar de Transform (O3, {O1}), C (O3) = DS2;Entonces se ejecuta O3, y DS2 se actualiza a ds3 = {o1, o2, o3}, donde o3 = org (o3).283 4.2 COT-UNDO para deshacer una operación O, un usuario debe emitir un comando de deshielo de meta-nivel (o). Cómo generar el comando deshacer para seleccionar cualquier operación para deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, deshacer (O) se interpreta como una O inversa, que depende del contexto en las operaciones en C (O) y O en sí. COT-UNDO toma dos parámetros de entrada: o es la operación seleccionada para deshacerse, que puede ser cualquier operación realizada SOFAR, y DS es la representación actual del estado del documento. Algoritmo 2. Cot-UNDO (O, DS) 1. O: = makeinverse (o);C (o): = c (o) ∪ {o};2. Cot-do (O, DS). Cot-UNDO funciona primero creando una O inversa invocando makeinverse (o) 2, con su contexto c (o): = c (o) ∪ {o} (de acuerdo con la definición 4-item 2), y luego invocando cotdo amanejar O. Por ejemplo, para interpretar deshacer (O2) en la Figura 1, Cotundo se invoca con parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C (O2) = {O2}. Luego, Cot-Do se invoca con parámetros O2 y DS. Se invocará COT-DO, transformar (O2, Ds-C (O2)), y O2 se transformará correctamente contra O1 y O3 ya que CD = DS-C (O2) = {O1, O3}. Este ejemplo muestra que Cot-Do puede manejar una operación inversa de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables a las operaciones normales e inversas. El algoritmo BASIC COT es simple pero poderoso, capaz de hacer y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de Goto y AnyUndo (denominado Goto-Anyundo) tiene capacidades similares [22, 21].5. Propiedades de transformación COT es un algoritmo de control de alto nivel responsable de determinar qué operación debe transformarse contra otras operaciones y en qué orden de acuerdo con las condiciones basadas en el contexto. Otro componente importante de un sistema OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones de acuerdo con sus tipos y parámetros. Investigaciones anteriores han identificado una gama de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema OT. Los diferentes sistemas OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-AYUNDO, el algoritmo COT básico no usa funciones ET (transformación de exclusión) [21], evitando así el requisito de la propiedad de reversibilidad (RP) entre las funciones de TI y ET [21]. Similar a GOTO-ALYUNDO, el algoritmo COT básico supone que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 El lector se remite [25] para definiciones precisas de tres operaciones primitivasInserte, elimine y actualice y sus inversos correspondientes. El procedimiento MakeInverse (O) sigue directamente estas definiciones.1. Propiedad de convergencia 1 (CP1) 3. Dado un estado de documento ds, y operaciones OA, OB, si OA = it (OA, OB) y OB = it (OB, OA), entonces debe ser: DS ◦ [OA, OB] = DS ◦ [Ob,OA], lo que significa que [OA, OB] y [OB, OA] son equivalentes con respecto al efecto en el estado del documento DS.2. Propiedad de convergencia 2 (CP2). Dadas tres operaciones o, oa y ob, si oa = it (oa, ob) y ob = it (ob, oa), entonces debe ser: it (it (o, oa), ob) = it (o, Ob), oa), lo que significa que [OA, Ob] y [Ob, OA] son equivalentes con respecto al efecto en la transformación.3. Propiedad inversa 2 (IP2) 4. Dado cualquier operación de buey y un par de operaciones [O, O], debe ser: it (it (ox, o), o) = it (ox, i) = ox, lo que significa que [o, o] y yoson equivalentes con respecto al efecto en la transformación.4. Propiedad inversa 3 (IP3). Dadas dos operaciones oa y ob, si oa: = it (oa, ob), ob: = it (ob, oa), y oa: = it (oa, ob), entonces debe ser: oa = oa, lo que significaLa operación inversa transformada OA es igual al inverso de la operación transformada OA. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son necesarias incondicionalmente. Sin embargo, las pre-condiciones para requerirlos nunca se declararon explícitamente en sus especificaciones, lo que desafortunadamente ha causado cierta conceptos erróneos en la literatura OT. Para explorar soluciones alternativas a estas propiedades, establecemos explícitamente las condiciones previas (PC) para CP1, CP2, IP2 y IP3 de la siguiente manera: 1. PC-CP1: CP1 solo se requiere si el sistema OT permite ejecutar el mismo grupo de operaciones independientes de contexto en diferentes órdenes.2. PC-CP2: CP2 solo se requiere si el sistema OT permite que una operación se transforme en el mismo grupo de operaciones independientes del contexto en diferentes órdenes.3. PC-IP2: se requiere IP2 solo si el sistema OT permite que una operación OX se transforme contra un par de operaciones DO y deshacer (O y O) uno por uno.4. PC-IP3: IP3 solo se requiere si el sistema OT permite que una operación inversa OA se transforme en otra operación OB que sea independiente del contexto de OA.3 Propiedad de convergencia 1 y 2 en este documento (y en [21]) son las mismas que la propiedad de transformación 1 y 2 en [19].4 Hay otra propiedad inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionado con las funciones de TI.284 Generalmente hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades;El otro es diseñar algoritmos de control capaces de romper las condiciones previas para requerir estas propiedades. Investigaciones anteriores han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial para diseñar y probar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Las contraexemples que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas temprano se pueden encontrar en [23, 21, 8, 11]. Las funciones capaces de preservar IP2 e IP3 se han ideado en el contexto de AnyUndo [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son intrincadas e ineficientes rápidas (se puede encontrar más análisis en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel de algoritmo de control tiene el beneficio de simplificar el diseño de funciones de transformación y el sistema OT en su conjunto. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel de algoritmo de control.6. Las soluciones de COT a CP2, IP2 e IP3, una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transformación (O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el contexto en el contexto-Difrado parámetro CD (calculado mediante las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, podemos organizar correctamente estas operaciones para romper las condiciones previas para CP2, IP2 e IP3.6.1 Procedimiento de transformación extendida () Extendemos la transformación del procedimiento central (O, CD) para aprovechar el conocimiento global de las operaciones en el CD del parámetro ContextDiFference para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida (), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el paso 1 (asegurar tpSafety ()) y en el paso 2- (c) (la parte if-then). Procedimiento 2. Transformar (O, CD) 1. Si cd = {}, asegúrese de tpSafety (o, cd);2. Repita hasta que cd = {}: (a) Retire la primera operación OX de CD;(b) transformación (ox, c (o) - c (ox));(c) Si el ox es un par de do-into, entonces c (o): = c (o) ∪ {org (ox), org (ox)};más o: = it (o, ox);C (o): = c (o) ∪ {org (ox)}. Procedimiento 3. Asegúrese de TPSafety (O, CD) 1. Asegúrese de que la seguridad CP2: clasifique las operaciones en CD en un orden total que respeta su orden de dependencia de contexto.2. Asegúrese de que la seguridad IP2: para cualquier ox ∈ Cd, si ox ∈ Cd, entonces marque el buey como un par de do-into, elimine el buey de la CD.3. Asegúrese de que la seguridad IP3: si O está inversa, el Invoke hace que IP3Safe inverse (O, CD). Procedimiento 4. Realice IP3Safe Inverse (O, CD) 1. O: = makeinverse (o);C (o): = c (o) - {o};2. NCD: = {ox |Ox ∈ Cd y ox c o};3. Transformar (O, NCD);4. O: = makeinverse (o);C (o): = c (o) ∪ {o};5. CD: = CD - NCD.6.2 Romper la condición previa para CP2 La solución COT a CP2 es ordenar todas las operaciones en CD en un orden total que respeta su orden de dependencia de contexto (en el paso 1 de garantizar tpSafety ()). Si una operación O se transforma en el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar (O, CD), este grupo de operaciones debe incluirse en CD y ordenarse en el mismo orden total. Por lo tanto, O nunca se puede transformar en el mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe señalar que el CD se convierte en un conjunto ordenado después de la clasificación. El primer buey en CD debe cumplir con la condición c (ox) ⊆ c (o) en el paso 2 (a) de transformación (o, cd) (procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el procedimiento 2. Un orden total correcto para romper PCCP2 se puede determinar convenientemente utilizando las relaciones contextables de dependencia entre todas las operaciones más los identificadores del sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema Got (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en la secuencia global) [26], El sistema agradable (por un notificador central basado en la transformación) [20], y el sistema Tibot (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT a CP2 es única y evita el uso de cualquier secuestro/secuenciación global/sincronización global.6.3 Romper la condición previa para IP2 La idea básica de la solución COT a IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de OD y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) Paso 2 de garantizar las operaciones de parejas de TPSafety (CD) con sus inversos correspondientes si todos están incluidos en el CD de diferencia de contexto y eliminar estos inversos de CD;(2) En el paso 2- (c) de transformación (), si se encuentra que el buey es un par de do-intodo, se omite la transformación IT de O contra el buey (tratando efectivamente este par como una operación de identidad) y laEl contexto de O se actualiza agregando dos operaciones: {org (ox), org (ox)}.6.4 Romper la condición previa para IP3 La solución COT a IP3 está encapsulada en el procedimiento, hace que IP3Safe inverse (O, CD), lo que hace que O sea un inverso seguro IP3 con respecto a la diferencia de contexto de CD. Una O inversa es Safe IP3 con respecto al CD si está hecha de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de la COT, la O inversa segura de IP3 nunca se transformará contra operaciones que son independientes del contexto de O, rompiendo así la PC-IP3. El procedimiento inverso de fabricación de IP3S funciona de la siguiente manera: (1) Crear operación O (la inversa de O) y C (O) = C (O) - 285 {O};(2) Seleccione todas las operaciones de CD que son contextores independientes de O y creen una nueva diferencia de contexto NCD;(3) transformar O contra operaciones en NCD (invocando recursivamente transform ());(4) crear un nuevo inverso a partir de la O transformada;y (5) crear un nuevo CD restando NCD del CD anterior (el nuevo CD debe mantener el orden total según sea necesario para resolver CP2). Esta nueva O inversa O debe ser Safe IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. La O inverse segura de IP3 nunca se transformará en las operaciones en NCD ya que estas operaciones se han eliminado del nuevo CD en el paso (5).7. Discusiones 7.1 La teoría del contexto de operación La noción de contexto de operación se propuso por primera vez en el algoritmo Got [23] y se usó junto con la teoría de la causalidad en los algoritmos de seguimiento y cualquier sindodo [22, 21]. En el trabajo previo, el contexto de una operación O se definió como una secuencia de operaciones transformadas que se pueden ejecutar para llevar el documento de su estado inicial al estado en el que se define O. Esta definición está directamente acoplada a la estrategia de almacenamiento de historial secuencial, que guarda operaciones ejecutadas en sus formularios y órdenes de ejecución. No hubo representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición del amortiguador de la historia entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado de documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Según la representación establecida del contexto de operación, las condiciones de OT esenciales (CC1 - CC6) se han capturado de precisión y concisión. Además, se ha diseñado el vector de contexto para representar eficientemente las operaciones normales e inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas informáticos distribuidos también. Según la teoría de la causalidad, los algoritmos OT anteriores han utilizado vectores estatales para capturar relaciones de dependencia causal entre las operaciones normales originales y representar estados de documentos en términos de operaciones normales originales. Sin embargo, las relaciones de dependencia causal no se definen para operaciones inversas o transformadas, y los vectores estatales no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar condiciones de OT esenciales (CC1 - CC6) para todo tipo de operación: operaciones originales y transformadas, normales e inversas.7.2 COT versus Goto-AYUNDO Tanto Cot como Goto-Anyundo son capaces de hacer y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin usar funciones ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir funciones para preservar CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de funciones de transformación y el sistema OT en su conjunto. COT es más simple que GOTO-ALYUNDO (y algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una sola teoría del contexto de operación para capturar todasoperación y la concisión de estas condiciones basadas en el contexto. El sistema basado en COT es más eficiente que el sistema basado en Gotoanyundo para resolver IP2 e IP3. En GoToanyUndo, el Do-Part (una operación normal) y el Undepart (una operación inversa) deben acoplarse con el fin de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento ansiosa: una operación inversa se combina con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historia. Sin embargo, cuando se debe ejecutar una operación normal, es posible que deba transformarse solo contra la parte de deshacer de una pareja de do-intodo. Para hacer frente a este problema, se debe usar un esquema adicional de decouple-goto-recouple para desacoplar un par de do-indoto antes de invocar a GOTO y luego recuperarlos después [21]. Sin embargo, la implementación de este esquema de recepción decouple reveló que era bastante complejo y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-Udo están integrados sin problemas. Las operaciones inversas se representan explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de do-into se produce inmediatamente después de ejecutar cada inverso, sino solo cuando tanto el DO-Part como el deshacer aparecen enEl mismo proceso de transformación en alguna etapa tardía. Estas estrategias ayudan a evitar transformaciones generales causadas por el esquema de acoplamiento ansioso y el esquema de recepción decouple. En el sistema basado en GOTO-ALYUNDO, la solución a IP3 se encapsula en una función de preservación de IT de IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, lo que puede invocar el costoso algoritmo GOTO para garantizar RP con la función IT correspondiente. Por el contrario, la solución COT a IP3 se encapsula en el procedimiento de alto nivel, hace que IP3SAFE inverse (O, CD), que es más eficiente ya que (1) evita la conversión de O a O de ida y vuelta varias veces para cada ox ∈ NCD ((si se usaron IP3P-IT (O, OX) en su lugar);y (2) el procedimiento Transform () es mucho más barato que GOTO.7.3 Estrategias de amortiguación OT Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento de operaciones subyacente. Esto no solo ha resultado en una estructura lógica más limpia y simple para el algoritmo en sí, sino que también permitió una gama de optimizaciones de rendimiento en el nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en búfer en la que no solo se pueden guardar operaciones originales, sino también versiones transformadas;y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original en el nivel de algoritmo COT, se busca al grupo de versiones correspondiente una versión que coincida con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, guardando así la sobrecarga para transformar la operación original en esta versión. Bajo esta estructura de amortiguación, se pueden usar varias heurísticas para guardar selectivamente versiones transformadas para maximizar su reutilización y minimizar su uso de espacio. Mediante la experimentación, hemos identificado algunas heurísticas útiles que son 286 efectivas para ahorrar transformaciones para una serie de patrones comunes de secuencia de operación. COT no es el primer algoritmo OT que amortigua y usa operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluidos CCU [2], adoptados [19] y Gotoanyundo [21], también han amortiguado las operaciones originales. COT es único en su forma de amortiguar y usar operaciones originales y transformadas.7.4 OT Corrección La corrección es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado resolución de detección de rompecabezas, se ha utilizado comúnmente para explorar y refinar las soluciones OT. Los rompecabezas son escenarios sutiles pero representativos en los que se pueden violar ciertas propiedades/condiciones de OT y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los rompecabezas conocidos es una condición necesaria y un indicador importante de la solidez de un sistema OT. En la literatura de investigación, los escenarios simples de rompecabezas a menudo se usan para ilustrar las razones clave por las cuales un sistema OT funciona o falla. Sin embargo, en el diseño del sistema OT real, una implementación real y casos de prueba integrales basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección se han entendido bien y los criterios de verificación y las condiciones de contorno han sido bien definidas. En este sentido, los métodos experimentales como la resolución de la detección de rompecabezas pueden desempeñar un papel importante en la obtención de los conocimientos necesarios sobre los problemas de corrección real y establecer criterios y condiciones adecuados para la verificación formal. Se necesita un enfoque sistemático para realizar investigaciones OT experimentales y teóricas. Muchos componentes y problemas de OT están íntimamente relacionados, y es poco probable que una solución a un problema, si se examina de forma aislada, sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de consistencia (DO) puede fallar cuando se consideran los problemas de DO y Deshacer;y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución al mantenimiento de consistencia [21]. Una solución OT completa para los problemas de hacer y deshacer es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente OT puede resolverse fácilmente o evitarse por completo, si este problema se aborda desde un componente OT diferente. Por ejemplo, se sabe que diseñar y probar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades se pueden evitar diseñando algoritmos de control (como cot) capaces de romper las condiciones previas para requerir estas propiedades;También es más fácil demostrar que un algoritmo de control es capaz de romper las condiciones previas para estas propiedades, que probar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 eran necesarios y suficientes para que los sistemas basados en adopción converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas OT. De hecho, CP1 y CP2 no son suficientes ni necesarios para muchos sistemas OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades/condiciones adicionales, como IP2, IP3 y las resumidas en [21]. Son innecesarios si se han roto las pre-condiciones para requerirlas. Por ejemplo, ni CP1 ni CP2 se requieren en el sistema Redido en función del algoritmo Got para garantizar la convergencia [23]. CP2 tampoco es requerido por los sistemas OT basados en COT o algunos algoritmos OT anteriores [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de la violación de CP2, es el problema de los falsos corbatas: cuando dos (o más) las operaciones con la misma posición se transforman entre sí, el empate de posición puede serFalso si no era original pero causado por transformaciones anteriores. Un sistema OT puede no producir resultados correctos si la regla de ruptura de unión normal (por ejemplo, basada en los identificadores del sitio) se usa para romper los falsos. Este problema se descubrió durante mucho tiempo en el trabajo temprano de OT y se ilustra un escenario concreto relacionado con este problema en la Fig. 6 de [23]. Está más allá del alcance de este documento discutir las soluciones a este problema, pero vale la pena señalar que el problema de los falsos tintes es diferente del problema de violación de CP2: puede ocurrir una falsificación sin violar CP2. En nuestra opinión, el problema de la falsa empanada es un problema en el nivel de función de transformación y su solución podría y también debería localizarse a este nivel. Para puntos de vista y enfoques alternativos de este problema, se hace referencia al lector [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un conjunto de pruebas integral que cubre todos los escenarios de rompecabezas OT conocidos. En este artículo, se han utilizado análisis informales y escenarios simples de rompecabezas para mostrar la corrección de la cuna con respecto a diversas propiedades/condiciones de transformación. La verificación formal de la corrección de la cuna con respecto a estas propiedades/condiciones, y el análisis cuantitativo del tiempo y la complejidad del espacio de la COT, se informará en una versión de revista de este documento.8. Conclusiones Hemos contribuido con la teoría del contexto de operación y el algoritmo COT (OT basado en el contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todos los tipos de operación en un sistema OT;Proporciona una nueva base para una mejor comprensión y resolución de problemas de OT. El algoritmo COT proporciona soluciones uniformadas tanto para el mantenimiento de consistencia como para los problemas de deshacer;Es más simple y más eficiente que los algoritmos de control OT anteriores con capacidades similares;y simplifica significativamente el diseño de funciones de transformación. El algoritmo COT se ha implementado en un motor de colaboración genérico y utilizado para soportar una gama de aplicaciones de colaboración nuevas [24]. Las aplicaciones del mundo real brindan oportunidades y desafíos emocionantes para futuras investigaciones de OT. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y revisores anónimos por sus valiosos comentarios y sugerencias que han ayudado a mejorar la presentación del documento.287 9. Referencias [1] J. Begole, M. Rosson y C. Shaffer. Transparencia de colaboración flexible: respaldo de la independencia del trabajador en sistemas replicados de intercambio de aplicaciones. ACM Trans.En la interacción humana de la computadora, 6 (2): 95-132, 1999. [2] G. Cormack. Un cálculo para la actualización concurrente. En Informe de investigación CS-95-06, Departamento de Informática, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizar la transformación operativa al lenguaje de marcado general estándar. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de grupos. En Proc.de la ACM conf.sobre gestión de datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q.Zhang. Mantenimiento de consistencia basado en la técnica de Mark & Ratrice en los sistemas de grupos. En Proc.de acm conf.sobre el trabajo grupal de apoyo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre principios de informática móvil, páginas 51-57, Nueva York, Octo 2002. Acm[7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que depende del algoritmo Treeopt. En Proc.del conf. Europeo.de trabajo cooperativo respaldado por computadora, páginas 315-324, septiembre de 2003. [8] A. IMine, P. Molli, G. Oster y M. Rusinowitch. Probar corrección de las funciones de transformación en el grupo de grupos en tiempo real. En Proc.del conf. Europeo.en el trabajo cooperativo respaldado por computadora, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el pedido de eventos en un sistema distribuido. Comunicación de ACM, 21 (7): 558-565, 1978. [10] D. Li y R. Li. Compartir e interoperación transparentes de aplicaciones heterogéneas de un solo usuario. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservar la relación de efectos de operación en editores grupales. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en un intervalo de tiempo para aplicaciones interactivas de Groupware. En Proc.de la conferencia internacional sobre sistemas paralelos y distribuidos, páginas 429-436, julio.2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adoptado. Cartas de procesamiento de información, (86): 303-310, 2003. [14] C. Palmer y G. Cormack. La operación se transforma para una hoja de cálculo compartida distribuida. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas de colaboración. ACM Trans.En Interaction-Human Interaction, 4 (1): 295-330, diciembre de 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatizar la reconciliación basada en la semántica para bases de datos móviles. En Actas de la 3ta Conferencia Francaise Sur Les Systems Dexploitation, Octo 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: captura de causalidad en sistemas distribuidos. IEEE Computer Magazine, 29 (2): 49-56, febrero de 1996. [18] M. Ressel y R. Gunzenh¨auser. Reducción de los problemas de deshacer grupo. En Proc.de la ACM conf.en el trabajo grupal de apoyo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenh¨auser. Un enfoque integrador orientado a la transformación para el control de la concurrencia y deshacer en los editores de grupos. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inverso concurrente en editores grupales. ACM Trans.En Interaction-Human Interaction, 9 (4): 309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operativa en editores de grupos en tiempo real: problemas, algoritmos y logros. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Lograr la convergencia, la preservación de la causalidad y la preservación de la intención en los sistemas de edición cooperativa en tiempo real. ACM Trans.En Interaction-Human Interaction, 5 (1): 63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans.En Interaction-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun y D. Chen. Transformación operativa para el procesamiento de textos colaborativos. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferri´e y M. Suleiman. Copias Convergencia en un entorno colaborativo distribuido en tiempo real. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 171-180, diciembre de 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición de tabla colaborativa basada en la adaptación transparente. En Proc.de la Conf. Internacional.en Cooperative Information Systems, LNCS vol.3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. TelePointer asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc.del IEEE conf.Sobre la computación colaborativa: redes, aplicaciones y trabajadores, diciembre de 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración de usuarios múltiples: el enfoque Coword. En Proc.de la ACM conf.En el trabajo cooperativo respaldado por computadora, páginas 162-171, noviembre de 2004. 288