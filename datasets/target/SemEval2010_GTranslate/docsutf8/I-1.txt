Aborto de tareas en los agentes de BDI John Thangarajah, James Harland RMIT University Melbourne, Australia {Johthan, jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Centro de Inteligencia Artificial, Sri International Menlo Park, CA 94025 U.S.A. {Morley,,nysmith}@ai.sri.com Resumen Los agentes inteligentes que están destinados a trabajar en entornos dinámicos deben poder manejar con gracia tareas y planes sin éxito. Además, tales agentes deberían poder tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir abortar una tarea o plan, ya sea como resultado de las propias deliberaciones de los agentes, o potencialmente a pedido de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales es apropiado abortar una tarea o plan, y cómo determinar las consecuencias de dicha decisión. Aumentamos cada plan con un método de aborto opcional, análogo al método de falla que se encuentra en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agente particular (como Jack, Jadex, Jason,o chispa). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralela y de sub-tareas, que requieren que el agente garantice que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: Agentes de inteligencia artificiales distribuidos-Inteligentes Términos generales Diseño, confiabilidad, teoría 1. Introducción Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que no se puede garantizar el éxito de ninguna acción o plan en particular [13]. En consecuencia, tratar con el fracaso es fundamental para la programación de agentes, y es un elemento importante de las características del agente, como la robustez, la flexibilidad y la persistencia [21]. En las arquitecturas de los agentes inspiradas en el modelo de creencia-intención-intención (BDI) [16], estas propiedades a menudo se caracterizan por las interacciones entre creencias, objetivos y planes [2] .1 En general, un agente que desea lograr un particularEl conjunto de tareas buscará varios planes simultáneamente. Cuando ocurran fallas, se revisará la elección de los planes. Esto puede implicar buscar planes alternativos para una tarea en particular, volver a programar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas o alguna otra decisión que aumente la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por varias razones, y a menudo no es posible predecirlas por adelantado, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación de fallas se integra comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan en particular. Esta decisión puede deberse a una deliberación interna (como el agente que cree que la tarea ya no se puede lograr, o que una tarea conflictiva ahora tiene una prioridad más alta) o debido a un factor externo (como otro agente que altere un compromiso o un compromiso oun cambio en el entorno). Abortar una tarea o plan es distinto de su falla. La falla refleja una incapacidad para realizar y no niega la necesidad de funcionar; por ejemplo, una respuesta razonable a la falla puede ser intentarlo nuevamente. En contraste, abortar no dice nada sobre la capacidad de actuar;Simplemente elimina la necesidad. La falla se propaga de abajo hacia arriba, mientras que abortarse se propaga de arriba hacia abajo. El potencial para ejecutar simultáneamente los subplans introduce diferentes complejidades para abortar y fallar. Para abortar, significa que los subplans concurrentes múltiples pueden necesitar ser abortados a medida que el aborto se propaga hacia abajo. Para el fracaso, significa que los planes de hermanas paralelo pueden necesitar ser abortados a medida que se propaga la falla. Ha habido una cantidad considerable de trabajo en fallas del plan (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallas. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de abortes más allá de la simple caída de planes y tareas actualmente previstos, que no se ocupan de la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de una construcción paralela 1 se puede considerar ambas tareas que se realizarán y los objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea que se ha realizado, y un objetivo puede considerarse una tarea de lograr ese estado del mundo. Adoptamos la última vista y usamos la tarea para referirnos también a los objetivos.8 978-81-904262-7-5 (RPS) c 2007 Ifaamas falla (los enfoques comunes incluyen dejar que la otra rama funcione hasta la finalización sin obstáculos o deja caerlo por completo). En este artículo discutimos en detalle la incorporación de los métodos de limpieza de abortes en el ciclo de ejecución del agente, proporcionando un enfoque unificado para la falla y el aborto. Una característica clave de nuestro enfoque basado en el procedimiento es que permitimos que cada plan ejecute algún código particular en una falla y en un aborto. Esto permite que un plan intente garantizar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar antes de salir. En consecuencia, un desafío técnico central es administrar la ejecución ordenada del código de limpieza apropiado. Mostramos cómo los abortos pueden introducirse sin problemas en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto. Esto nos permite especificar un nivel de detalle apropiado para el modelo de ejecución, sin centrarnos en las construcciones específicas de cualquier sistema de agente como Jack [2], Jadex [14], Jason [6] o Spark [9]. Nuestro enfoque está en un solo agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas individuales y multiagentes (por ejemplo, [22, 5, 6]). Este artículo está organizado de la siguiente forma: En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deben ocurrir los abortos, y los procedimientos de representación e invocación apropiados. En la Sección 4 mostramos cómo podemos usar Can para especificar formalmente el comportamiento de un plan abortado. La Sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro.2. Ejemplo motivador Alice es una trabajadora de conocimiento asistida por un agente de asistencia personal, como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente de CALO adopta la tarea de presentación de la reunión de apoyo (SMS) para ayudarla. El plan CALOS para una tarea de SMS en el caso de una presentación de la conferencia consiste en las siguientes subasinas: 1. Asignar un número de papel (APN) para ser utilizado para fines administrativos en la Compañía.2. Track Writing Resumen (TWA): Realice un seguimiento del progreso de Alices en la preparación de un resumen.3. Solicite la autorización (AFC) para su publicación de Alices Manager en base a los detalles del resumen y la conferencia.4. Papel de escritura de pistas (TWP): Realice un seguimiento del progreso de Alices al escribir el documento.5. Manejar la presentación en papel (HPS): siga los procedimientos internos de la compañía para enviar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. Del mismo modo, CALO puede realizar la tarea aplicada para la autorización (AFC) mediante un plan que consiste en: 1. Envíe la solicitud de despacho (SCR) al gerente de Alices.2. Espere la respuesta (WFR) del gerente.3. Confirme que la respuesta fue positiva y falló de lo contrario. Ahora suponga que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras escribe el periódico. Alice ya no podrá asistir a IJCAI. Por lo tanto, le indica a su agente de CALO que aborte la tarea de SMS. Abortar la tarea implica abortar tanto el plan SMS como el subplan de la AFC. El aborto del primer plan requiere que CALO notifique al registro del número de papel que el número de papel asignado es obsoleto, lo que puede lograr con la tarea de número de papel de cancelación (CPN ).2 El aborto del segundo plan requiere que CALO notifique a Alices que Alice ya no requiereLa autorización para la publicación, que CALO puede lograr invocando la tarea de solicitud de autorización de cancelación (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede provenir de las deliberaciones internas del agente (como el razonamiento sobre las prioridades en un conflicto sobre los recursos), o de fuentes externas (como otro agente que cancela un compromiso), como en estoejemplo. En este artículo solo tocamos el problema de determinar si una tarea o un plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se toma esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. En segundo lugar, una vez que se toma la decisión de abortar el intento de enviar un documento, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente una cuestión de eliminar la tarea y los planes activos asociados: hay algunas acciones de limpieza que deben hacerse. Esto es similar al caso de falla, ya que también puede haber acciones que tomar cuando falla una tarea o plan. En ambos casos, tenga en cuenta que no se trata simplemente de que el agente deshace sus acciones hasta la fecha;De hecho, esto no es posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado mundial) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica una compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes ejecutados para realizar la tarea deben ser abortados;En el último caso, puede ser que haya mejores alternativas al plan actual y se debe intentar una de ellas. Por lo tanto, el plan de aborto o falla no necesariamente conduce al aborto o al fracaso de la tarea. Cuarto, dado que las tareas pueden contener subtareas, que pueden contener más subcartas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que se aborta una tarea o plan principal.3. Abortar tareas y planes a la que hemos aludido, el fracaso y el aborto son conceptos relacionados. Ambos causan la ejecución de los planes existentes para cesar y, en consecuencia, el agente refleja sobre sus tareas e intenciones actuales. La falla y el aborto, sin embargo, difieren en la forma en que surgen. En el caso de la falla, el desencadenante de cesar la ejecución de una tarea o plan viene de abajo, es decir, la falla de las subasinas o los planes de nivel inferior. En el caso de abortar, el desencadenante proviene de arriba, es decir, las tareas y los planes matriz que iniciaron un plan. En los sistemas de estilo BDI como Jack y Spark, un conocimiento de dominio de agentes incluye una biblioteca de planes de plan de planes predefinidos. Cada cláusula del plan tiene un cuerpo del plan, que es un programa (es decir, una combinación de acciones primitivas, sub-tareas, etc.) que se puede ejecutar en respuesta a una tarea u otro evento en caso de que se cumpla la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas del plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en el caso de que uno falle, se puede intentar otro aplicable. Los planes pueden tener subasinas que deben tener éxito 2 necesidades de CALO solo deja caer las tareas TWA y TWP para abortarlas: en aras de la simplicidad, suponemos que no es necesaria una limpieza explícita de su estado interno. El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 9 para que el plan tenga éxito. En tales sistemas, se produce una falla del plan si una de las acciones o subasinas dentro del plan falla. La acción de los agentes al falla del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si un plan ha sido juzgado y resultó en una falla, o puede volver a intentar los planes alternativos y declarar (de hecho, debe declarar) falla de la tareaSolo si todos los planes alternativos posibles para realizar la tarea se han probado y han resultado en una falla. Observe que, si bien la falla de la tarea puede seguir de la falla del plan o una secuencia de fallas del plan, la falla del plan no es necesario que la falla de la tarea siempre que el agente pueda completar con éxito un plan alternativo. Además, la falla de la tarea también puede surgir por separado de la falla del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas de acuerdo con cómo el agente intenta realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que pueden realizarse dinámicamente de la manera habitual de BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto debe invocarse y de qué manera. Dada la complejidad de los espacios de acción del agente, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos abortados dinámicamente de acuerdo con el estado de ejecución y sus propios eventos internos. Una alternativa a unir un método de aborto a cada plan es adjuntar tales métodos a cada acción atómica. Elegimos el primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una sobrecarga mayor, (2) los planes están destinados a ser diseñados como unidades cohesivas únicas y son la unidad de deliberación en los sistemas BDI, y (3) la limpiezaLos métodos de falla en los sistemas actuales se adjuntan a los planos. Para comprender cómo los agentes abortan el procesamiento, consideramos tres situaciones en las que es sensato que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, suponga que la política de la compañía cambia para que los empleados de Alices de antigüedad tengan automáticamente la autorización para publicar documentos. Como Alice ahora tiene autorización para publicar su artículo, Calo puede abortar el plan de solicitar autorización. Al hacerlo, debe invocar el método de aborto, en este caso, realizando así una solicitud de autorización de cancelación.3 2. Cuando se ejecutan dos o más subprogramas en paralelo, si uno falla, los otros deben ser abortados, dado que la falla de una rama conduce a la falla de la tarea general. Por ejemplo, supongamos que a la mitad de la escritura del documento, Alice se da cuenta de que hay un defecto fatal en sus resultados, y por lo tanto, notifica a Calo que no podrá completar el documento antes de la fecha límite. La falla de la tarea de papel de escritura de seguimiento debe hacer que la solicitud de autorización se ejecute en paralelo sea abortada.3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar sobre si los planes existentes deben continuar. Por ejemplo, suponga que Alice asigna a Calo con una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice carece de fondos suficientes para comprar la computadora portátil y asistir a IJCAI. El razonamiento sobre los requisitos de recursos [20, 10] hará que el agente se realice 3 si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente versus cómo abortar uno que ahora se sabe que es imposible, el mébalio de abortes puede detectarlas circunstancias y manejar la situación según corresponda.que no puede completar con éxito ambas tareas. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar al menos suspender, la tarea existente de enviar un documento e intenciones derivadas de él [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones anteriores. La tercera situación implica deliberar sobre la importancia de una tarea, que depende de varios factores, como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Tenga en cuenta que las situaciones anteriores se aplican a los objetivos de logro, para lo cual se completa la tarea cuando se produce un estado particular del mundo (por ejemplo, asegúrese de que tengamos autorización). Las diferentes formas de razonamiento se aplican a otros tipos de objetivos [4], como los objetivos de mantenimiento [1], donde el objetivo se cumple mediante el mantenimiento de un estado del mundo durante algún período de tiempo (por ejemplo, mantener $ 100 en efectivo). La representación del método de aborto La intención de abortar una tarea o plan es que la tarea o el plan y todos sus hijos dejen de ejecutar, y que los métodos de limpieza apropiados se realizan según sea necesario. A diferencia de los sistemas de planificación fuera de línea, los agentes de BDI están situados: realizan la deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no se pueden deshacer simplemente. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación a plazo que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación del plan común en sistemas de estilo BDI como Jack y Spark incluye un método de falla, que es el método de limpieza designado invocado cuando el plan falla. A esto, agregamos el método de aborto, que se invoca si el plan debe ser abortado. En nuestro ejemplo, el método de aborto para la presentación de la reunión del plan para el plan de apoyo consiste en invocar el número de papel de cancelación de la sub-tarea. El método de aborto no necesita abortar explícitamente la solicitud de autorización, porque el agente invocará el método de aborto para la subtarea adecuadamente, ya que describimos a continuación. La suposición aquí es que, como el método de falla, el programador del sistema de agentes tiene la oportunidad de especificar un método de aborto sensato que tiene en cuenta el punto en el plan en el que se ejecutará el aborte. Para cualquier plan, el método de aborto es opcional: si no se especifica el método de aborto, el agente no toma medidas específicas para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes aún se aplican, por ejemplo, si volver a intentar un plan alternativo para la tarea principal. Tenga en cuenta que no se requiere una representación explícita de los métodos de limpieza para tareas, ya que las tareas se realizan ejecutando algunos planes o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se ejecuta para realizar esa tarea, como lo describimos a continuación. Invocación del método de aborto Ahora presentamos informalmente la acción de los agentes al abortar planes y tareas. Cuando se aborta un plan P: 1. Abortar cada subtara que es un niño activo de P. Un niño activo es desencadenado por P y actualmente está en ejecución.2. Cuando no hay más niños activos, invoque el método de aborto del Plan P. 3. Indique una falla del plan para TP, la tarea principal de P. Notamos aquí que si la tarea principal no debe ser abortada, el agente puede elegir otro plan aplicable para satisfacer TP.10 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) cuando se aborta una tarea (o subtarea) t: 1. Abortar el plan activo actual para satisfacer t (si lo hay).2. Cuando no hay más procesos infantiles activos, elimine la tarea. El agente ya no persigue T. 3. Tenga en cuenta aquí que cuando se aborta el plan activo actual para realizar T, no se debe probar otros planes aplicables para realizar T, ya que es la tarea la que se abortará. Para evitar esfuerzos de limpieza infinitamente en cascada, suponemos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, sin un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos, por lo tanto, no es un reflejo de la completa complejidad de la realidad, sino una pragmática en términos del ciclo de ejecución del agente;El enfoque para el manejo de fallas de [21] hace la misma suposición. En sistemas como Spark, el programador puede especificar un comportamiento alternativo para una falla fallida o método de aborto mediante procedimientos de nivel de metro. También suponemos que los métodos de falla y abortes terminan en tiempo finito.4. Semántica operativa Proporcionamos la semántica para la tarea y la falla del plan y los procesos de aborto se describen anteriormente. Usamos el lenguaje CAN inicialmente definido en [23] y luego se extendió como CanPlan en [17] para incluir un componente de planificación y luego como CanPlan2 en [18] para mejorar los mecanismos de adopción y caída de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Después de una presentación de la semántica operativa de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos.4.1 El lenguaje de Can puede es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentsPeak [15] y Kinnys ψ [7], los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. Can proporciona una construcción de meta explícita que captura los aspectos declarativos y de procedimiento de un objetivo. Los objetivos son persistentes en la lata en la que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo de manejo de falla predeterminado que se encuentra típicamente en los sistemas BDI implementados como Jack [2]. En los sistemas prácticos, las tareas generalmente se traducen en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje de la lata, pero, para mantener la persistencia de los objetivos, se introduce una construcción de objetivos. Esto se denota por meta `φs, p, φf ´, donde φs es la condición de éxito que determina cuándo se considera el objetivo, φF es una condición de falla bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es ISUn programa para lograr el objetivo, que se abortará una vez que φs o φf se hagan verdaderos. Un comportamiento de los agentes es especificado por una biblioteca de plan, denotada por π, que consiste en una colección de cláusulas de plan de la forma E: C ← P, donde E es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentesEso debe ser cierto para que el plan sea aplicable) 4 y P son el cuerpo del plan. El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P :: = ACT |+B |−B |? φ |! E |P1;P2 |P1 P2 |Objetivo `φs, P1, φf ´ |P1 P2 |{ψ1: P1 ,..., ψn: pn} |Nil 4 Una C omitida es equivalente a verdadero. Δ = {ψiθ: Piθ |E: ψi ← Pi ∈ π ∧ θ = mgu (e, e)} b ,! e - → b, δ evento ψi: pi ∈ Δ b | = ψi b, δ - → b, pi Δ \ {ψi: pi: pi} Seleccione B, P1 - → B, (P1 P2) - → B, P2 Fail B, P1 - → B, P1 B, (P1; P2) - → B, (P2) secuencia B, P1 - → B, P B, (P1 P2) - → B, (P P2) Paralelo1 B, P2 - → B, P B, (P1 P2) - → B, (P P1) Paralelo2 Figura 1: Reglas operativas de CAN.donde p1 ,..., PN son programas en sí mismos, ACT es una acción primitiva que no se especifica más, y +B y −B son operaciones para agregar y eliminar creencias. La base de creencias contiene átomos de creencia de tierra en forma de relaciones de primer orden, pero podría extenderse ortogonalmente a otras lógicas. Se supone que se proporcionan operaciones bien definidas para verificar si una condición se deriva de un conjunto de creencias (b | = c), para agregar una creencia a un conjunto de creencias (b ∪ {b}) y para eliminar una creencia de unConjunto de creencias (b \ {b}).? φ es una prueba de condición φ, y! E5 es un evento 6 que se publica desde el programa. Las construcciones compuestas son la secuenciación (P1; P2), la ejecución paralela (P1 P2) y los objetivos (Objetivo `φs, P, φf ´). Lo anterior define el idioma de usuario. Además, un conjunto de formularios compuestos auxiliares se usa internamente al asignar semántica a construcciones.nulo es el programa básico (terminación). Cuando un evento coincide con un conjunto de cláusulas de plan, se recogen en un conjunto de alternativas guardadas (C1: P1, ..., CN: PN). La otra forma de compuesto auxiliar, es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló. Un resumen de la semántica operativa para Can en línea con [23] y seguir algunas de las simplificaciones de [17] es la siguiente. Una configuración básica S = B, G, γ consiste en la base de creencias actual B del agente, el conjunto actual de los objetivos G que se persigue (es decir, el conjunto de fórmulas) y el programa actual P (es decir, la intención actual). Una transición S0 - → S1 especifica que la ejecución de S0 para un solo paso produce la configuración de la configuración S1. S0 - → ∗ Sn es el cierre transitivo reflexivo habitual de - →: Sn es el resultado de una o más transiciones singlestep. Una regla de derivación S - → Sr S - → Sr consiste en un conjunto de premisas (posiblemente vacías), que son transiciones junto con algunas condiciones auxiliares (numerador), y una única conclusión de transición derivable de estas premisas (denominador). La Figura 1 da algunas de las reglas operativas. La regla del evento maneja los eventos de tareas recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula del plan E: ψi ← Pi, si hay un unifier más general, θ = mgu (e, e) de E y el evento en5 Donde es obvio que E es un evento, a veces excluye el signo de exclamación para la legibilidad.6 Típicamente un objetivo de logro. El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 11 b | = φs b, objetivo `φS, P, φF ´-→ B, verdadero GS B | = φf B, Objetivo` φS, P, φF ´-→ B, falla gf p = meta `φS, p, φf ´ p = p1 £ p2 b | = φS ∨ φf b, p - → b, objetivo` φs, p £ p, φf ´ gi p = p1 £ p2 b | =φs ∨ φf b, p1 - → b, p b, objetivo `φs, p, φf ´ - → b, objetivo` φs, p £ p2, φf ´ gs p = p1 £ p2 b | = φS ∨ φf p1 ∈ {verdadero, fallas} b, meta `φS, P, φf ´ - → B, meta` φs, p2 £ p2, φf ´ Gr Figura 2: reglas para objetivos en la lata.Pregunta, entonces la regla construye una alternativa protegida ψiθ: Piθ. La regla de selección luego selecciona un cuerpo del plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P δ establece que el programa P debe juzgarse primero, volviendo a las alternativas restantes, δ \ P, si es necesario. Esta regla y la regla de falla se utilizan para el manejo de fallas: si el programa actual PI de una cláusula de plan para una tarea falla, primero se aplica la regla Fail, y luego, si es posible, la Regla Seleccione elegirá otra alternativa aplicable para la tarea.existe. La secuencia de reglas maneja la secuencia de programas de la manera habitual. Las reglas paralelas1 y paralelas2 definen el posible intercambio al ejecutar dos programas en paralelo. La Figura 2 ofrece reglas simplificadas para lidiar con objetivos, en línea con los presentados en [17]. La primera regla establece que un objetivo tiene éxito cuando los φ se vuelven verdaderos;La segunda regla establece que un objetivo falla cuando φF se vuelve verdadero. La tercera regla GI inicializa la ejecución de un programa de goles actualizando la base de goles y estableciendo el programa en el objetivo de P £ P;La primera P se ejecutará y la segunda P se utiliza para realizar un seguimiento del programa original para el objetivo. La cuarta regla GS ejecuta un solo paso del programa de gol. La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) siempre que el programa actual esté terminado, pero el objetivo deseado y aún posible aún no se ha logrado.4.2 Interviones de aborto y falla de manejo A continuación, presentamos la capacidad de especificar programas de controladores, en forma de falla y métodos de aborto, que se ocupan de la limpieza requerida cuando un programa determinado respecta respectivamente o se aborta. No asociamos los métodos de falla y aborto con las cláusulas del plan o con las tareas (eventos), sino que presentamos una nueva construcción del programa que especifica los métodos de falla y aborto para un programa arbitrario. La construcción FAB (P, PF, PA) ejecuta el programa P. debe fallar, ejecuta el programa de manejo de falla PF;Si P necesita ser abortado, ejecuta el programa de manejo de abortes PA. Por lo tanto, para agregar fallas y abortos, métodos PF y PA a una cláusula de plan E: C ← P, escribimos E: C ← Fab (P, PF, PA). Con la introducción de la capacidad de abortar los programas, modificamos la construcción paralela para permitir la falla de una rama para abortar a la otra. Debemos tener en cuenta la posible existencia de métodos abortados en la rama abortada. Del mismo modo, con la construcción de objetivos, ya no podemos abandonar completamente el programa, el objetivo contiene tan pronto como se mantenga la condición de éxito o fracaso;Ahora debemos tener en cuenta la existencia de cualquier método de abortes aplicable al programa. Proporcionamos la semántica de un lenguaje de agente aumentado que contiene la construcción FAB al definir una transformación de origen, similar a la macroexpansión, que mapea una biblioteca de plan que contiene la construcción FAB (P, PF, PA) en (casi) estándar. La única extensión no estándar a la lata es una construcción de espera para esperar. Explicamos esta simple modificación de la construcción paralela a continuación cuando llegamos a la traducción de la construcción de objetivos. Primero describimos la naturaleza general de la transformación de la fuente, que demuestra ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAB, paralelas y de objetivos. Una cuestión clave es que las construcciones FAB pueden estar anidadas, ya sea directa o indirectamente. Llamemos a cada instancia de la construcción en el tiempo de ejecución un posible punto de aborto (PAP). Cuando estas construcciones están anidadas, es importante que antes de que se ejecute el método de falla o aborto de un PAP de los padres, los programas de falla de falla o abortes de los PAP de los niños se ejecutan primero, como se describe anteriormente en la Sección 3. La necesidad de coordinar la ejecución de los métodos de aborto de PAP anidados requiere que haya alguna forma de identificar a los padres y los hijos de un PAP en particular. Logramos esto como parte de la transformación de la fuente realizando explícitamente un seguimiento del contexto de la ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan.7 La transformación de la fuente reemplaza cada cláusula del plan de la forma E: C ← PCon una cláusula de plan E (v): c ← μV (p) donde V es una variable libre, no previamente presente en la cláusula del plan. Esta variable se utiliza para realizar un seguimiento del contexto de la ejecución. El valor de la variable de contexto es una lista de identificadores, donde cada PAP nuevo se representa al preparar un nuevo identificador para el contexto. Por ejemplo, si los identificadores son enteros, el contexto de un PAP puede estar representado por una lista [42, 1] y el contexto introducido por un nuevo PAP puede estar representado por [52, 42, 1]. Nos referiremos a PAP por el contexto en lugar de por el nuevo identificador agregado, por ejemplo, por [51, 42, 1] no 51. Esto nos permite equiparar la relación de antepasados entre PAP con la relación de sufijo de la lista en los contextos relevantes, es decir, V es un antepasado de V si y solo si V es un sufijo de V. Para la mayoría de las construcciones de Can, la variable de contexto no se usa o se pasa sin cambios: μV (ACT) = ACT μV ( +B) = +B μV (−B) = −B μV (nil) = nil μV (! E) =! E(v) μV (P1; P2) = μV (P1);μV (P2) μV (P1 P2) = μV (P1) μV (P2) μV (ψ1: P1, ..., ψn: Pn) = ψ1: μV (P1) ,..., ψn: μV (PN) sigue siendo especificar la transformación μV (·) en tres casos: construcciones FAB, paralelas y de meta. Estos son más complejos, ya que la fuente transformada necesita crear un nuevo identificador de PAP dinámicamente, para su uso como un nuevo contexto dentro de la construcción, y para realizar un seguimiento de cuándo el PAP está activo (es decir, actualmente en ejecución) agregando y eliminando las creenciassobre el contexto. Presentemos la acción primitiva prependid (v, v) que crea un nuevo identificador de PAP y lo prepara para la lista de la lista V de la lista v. También presentamos los siguientes predicados: • A (V): el PAP V está actualmente activo.• Abortar (v): el PAP V debe ser abortado (después de abortar a todos sus descendientes).7 Una alternativa sería usar predicados de nivel meta que reflejen el estado actual de la estructura de intención.12 El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) • F (v): el programa de PAP V ha fallado.• Ancestorof (V, V) ≡ V = V ∨ Ancestorof (V, cola (V)) El PAP V es un antepasado de PAP V.• NAC (V) ≡ ¬∃V.(A (V) ∧ Ancestorof (V, V) ∧ V = V) - V no tiene hijos activos.• Sa (V) ≡ ∃V .Abort (V) ∧ Ancestorof (V, V) - Deberíamos abortar V, es decir, el aborto es cierto de V o algún antepasado;Sin embargo, debemos esperar hasta que no hay hijos de V activos.• SAN (V) ≡ SA (V) ∧ NAC (V) - Deberíamos abortar V ahora si debemos abortar V y V no tienen hijos activos. Primero consideremos el caso de la construcción FAB. La idea es que, cada vez que ocurre un nuevo PAP, la acción prependid (V, V) se usa para crear una nueva lista de identificadores de PAP V de la lista existente v. Luego agregamos la creencia de que V es el contexto activo, es decir, +, +A (v), y comience a procesar el programa dentro del PAP usando V en lugar de V como contexto. Necesitamos asegurarnos de que retraemos la creencia de que V está activo al final, es decir, −a (v). Utilizamos la construcción de objetivos para permitirnos eliminar la ejecución de un programa dentro de un PAP V cuando es necesario abortar. Mientras ejecutamos el programa P, sabemos que necesitamos dejar caer P e invocar su método de aborto si se le ha dicho a algún antepasado de P que aborte. Esto está representado por el predicado SA (V) siendo cierto. Sin embargo, debemos asegurarnos de hacer esto solo después de que cada PAP de niños haya tenido la oportunidad de invocar su método de aborto y todos estos métodos de aborto se hayan completado: si dejamos caer el programa demasiado pronto, entonces la ejecución de los métodos de abortode los niños también se dejarán caer. Por lo tanto, la condición que realmente usamos en la construcción de objetivos para probar cuándo eliminar el programa es SAN (V). Esta condición se basa en el hecho de que a medida que se completan los PAP de los niños, eliminan los hechos A de A. Nuestro uso de la construcción de objetivos es por su capacidad para eliminar la ejecución de un programa cuando se cumplen las condiciones. Para dejar de lado la ejecución repetida hasta que se cumpla una condición, debemos asegurarnos de que la condición de éxito o falla de la construcción se cumpla una vez que la ejecución del programa tiene éxito o falla. Nos aseguramos de esto retrayendo el hecho de (v) sobre el éxito y afirmando el hecho de F (v) sobre el fracaso, y al tener las condiciones apropiadas de éxito y falla sobre el objetivo. Por lo tanto, si la construcción de objetivos falla, entonces el programa fue abortado o falló. Invocamos el método relevante de falla o aborto, retractamos el hecho A (v) y luego fallamos. Al reunir todo esto, definimos formalmente μV (FAB (P, PA, PF)) para que sea lo siguiente, donde V es una nueva variable distinta de cualquier otra Biblioteca del Plan de Agentes: PrependID (V, V);+a (v);Objetivo (¬A (V), (μV (P); −a (V) +F (V)), SAN (V) ∨ F (V)) (((? Sa (V); μV (PA))μV (pf)); −a (v) ;? falso) segundo, debemos transformar el operador paralelo para garantizar que la falla de una rama aborta de manera segura a la otra. Aquí construimos dos nuevos contextos, V y V, a partir del contexto existente v. Si una rama falla, debe abortar la otra rama. Al final, si alguna rama fue abortada, entonces debemos fallar. Deje que V y V sean nuevas variables distintas de cualquier otra en la biblioteca del Plan de Agentes. Definimos μV (P1 P2) para que sea: prependid (V, V);prependid (V, V);+a (v);+a (v);(Objetivo (¬A (V), (μV (P1); −a (V) +F (V)), San (V) ∨ F (V)) ( +Abort (V); −a (V))Objetivo (¬A (V), (μV (P2); −a (V) +F (V)), SAN (V) ∨ F (V)) ( +Abort (V); −a (V))));? ¬abort (v) ∧ ¬abort (v) Finalmente, necesitamos modificar las ocurrencias de la construcción de objetivos de dos maneras: Primero, para asegurarnos de que los métodos de manejo de abortes no se eviten cuando se satisfacen las condiciones de éxito o falla, yEn segundo lugar, para activar el aborto del programa contenido cuando se cumplen las condiciones de éxito o falla. Para transformar la construcción de objetivos, necesitamos extender el estándar CAN con una construcción de espera-acondicionamiento. La construcción φ: P no ejecuta P hasta que φ se vuelve verdadera. Aumentamos el lenguaje de lata con las siguientes reglas para el operador de guardia :: b | = φ b, g, (φ: p - → b, g, p: verdadero b | = φ b, g, (φ: p) − −→ B, G, (φ: P): Falso Para especificar μV (objetivo φs, P, φf ´), generamos un nuevo PAP y ejecutamos el programa dentro de la construcción de objetivos en este nuevo contexto. Debemos asegurarnos de que la creencia A (v) se elimine si el objetivo tiene éxito o falla. Cambiamos la condición de éxito y falla de la construcción de objetivos a una rama paralela utilizando la construcción de espera-hasta la condición, y modificamos el objetivo de usar la condición ahora de la condición de SAN (v) como la condición de éxito. La rama de espera activará el aborto del programa en caso de que se cumpla el éxito o la condición de falla. Para evitar cualquier problema para terminar la condición de espera, también terminamos la espera si el PAP ya no está activo. Sea v una nueva variable distinta de cualquier otra en la biblioteca del plan de agentes. Definimos μV (objetivo `φs, p, φf ´) para ser: prependid (V, V);+a (v);(Objetivo (San (V), μV (P), Falso); −a (V); "(v) se vuelve verdadero. Hay dos formas en que esto puede ocurrir. Primero, si la condición de éxito φs o la condición de falla φF se vuelve verdadera, entonces se ejecuta la segunda rama de la construcción paralela. Esto hace que el aborto (v) se vuelva verdadero y, después de que se ejecutan los abortos de los PAPS descendientes, San (V) se hace realidad. En este caso, P ahora se cae, se elimina el A (V) y la construcción completa tiene éxito o falla en función de φs. La segunda forma de que San (V) se vuelva verdadera es si V o uno de sus antepasados se aborta. En este caso, una vez que se ejecutan los métodos de aborto de los PAPS descendientes, San (v) se vuelve verdadero, P se cae, se elimina la creencia A (V) (lo que permite que la segunda rama paralela se ejecute, instruye a Vacuosamente a V para que aborte), yLa primera rama paralela falla (suponiendo que φS es falso).4.3 Ejemplo trabajado Veamos la traducción del ejemplo de envío de IJCAI de la Sección 2. Expresaremos tareas por eventos, por ejemplo, la tarea asigna un número de papel que expresamos como el APN del evento. Deje que la salida de la tarea de autorización se aplique o n, lo que indica la aprobación o no del gerente de Alices, respectivamente. Luego tenemos (al menos) las siguientes dos cláusulas del plan en Can, para la presentación de la reunión de soporte y solicitar tareas de autorización, respectivamente: SMS (M): ISconf (M) ← Fab (! APN;! TWA; (! AFC!Twp) ;! hps ,! cpn ,! cpn) afc: verdadero ← fab (! Scr ;! wfr (r);? R = y, nil ,! ccr) Tenga en cuenta que el envío de la reunión tiene una parámetro m, la reunión deInterés (IJCAI, en nuestro ejemplo), si bien la solicitud de autorización no tiene parámetros. El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 13 Veamos primero la traducción de la segunda cláusula del plan, para AFC, ya que es el más simple de los dos. Deje que V y V denoten nuevas variables. Luego tenemos como la cláusula del plan traducido: AFC (V): Verdadero ← Prependid (V, V);+a (v);Objetivo (¬A (V), (! Scr (V);! Wfr (R, V) ;? R = Y; −a (V) +F (V)), San (V) ∨ F (V)))una construcción de objetivos. Si el antiguo cuerpo del plan tiene éxito, la creencia A (v) se retrae, lo que hace que el objetivo tenga éxito. Si el cuerpo del plan antiguo falla, o si la tarea debe ser abortada, la construcción de objetivos falla. Esto es seguido por la ejecución de CCR (en el caso de un aborto), la retracción de un (v) y la falla. La traducción de la primera cláusula de plan, para SMS, es más compleja, debido a la construcción paralela que introduce PAP anidadas: SMS (M, V): ISconf (M) ← Prependid (V, V);+a (v);Objetivo (¬A (V), ((! APN (V);! Twa (V); Prependid (V, V); Prependid (V, V); +A (V); +A (V); (Objetivo(¬A (v), (! Afc (v); −a (v) +f (v)), san (v) ∨ f (v)) ( +abort (v); −a (v)) objetivo(¬A (V), (! Twp (V); −a (V) +F (V)), San (V) ∨ F (V)) ( +Abort (V); −a (V)))));? ¬abort (v) ∧ ¬abort (V) ;! HPS (V); −a (V)) +F (V)), SAN (V) ∨ F (V)) ((((V (V (V (V (V (V));! Cpn (v))! Cpn (v)); −a (v);? Falso) Aquí podemos ver que si la tarea! Twp (v) falla, entonces f (v) se afirmará, no se afirmará el objetivoConstruya que lo contiene, y lo que hace que aborta (v) se afirme. Si la tarea! Wfr (R, V) en la expansión de! Afc (V) todavía se está ejecutando y no tiene PAPS activos, entonces SA (V) y SA (V) serán verdaderos;Sin embargo, solo San (V) y no San (V) será cierto. Este conjunto de condiciones causará la construcción de objetivos en la primera cláusula del plan para fallar, eliminando la ejecución de! WFR (R, V). La tarea! CCR (v) se ejecutará. Una vez que se completa esta tarea, la creencia A (v) se retrae, lo que hace que San (V) se haga realidad, lo que lleva a la primera construcción de objetivos de la segunda cláusula del plan para fallar. Si bien las cláusulas del plan traducido parecen complicadas, observe que la traducción de las cláusulas del plan inicial está completamente automatizada, de acuerdo con las reglas establecidas en la Sección 4.2. Las cláusulas del plan traducido, con la semántica de Can aumentada por nuestra construcción de condición Waituntil, especifican así la operación del agente para manejar tanto la falla como el aborto para el ejemplo.5. La falla del plan de trabajo relacionado se maneja en la versión extendida de AgentsPeak que se encuentra en el sistema Jason [6]. Los planes de limpieza de fallas se activan de los eventos de eliminación de objetivos-! G. Dichos planes, similares a nuestros métodos de falla, están diseñados para que el agente efectúe los cambios estatales (ACT para deshacer sus acciones anteriores) antes de intentar otro plan para lograr el objetivo fallido g.Dado las construcciones de Jasons para dejar caer un objetivo con una indicación de si probar o no un plan alternativo para ello, H¨ubner et al.[6] Proporcione una descripción informal de cómo un agente Jason modifica su estructura de intención cuando ocurre un evento de falla de objetivo. En un plan de eliminación de objetivos, el programador puede especificar cualquier acción de deshacer y si intentar nuevamente el objetivo. Si no se proporciona un plan de eliminación de objetivos, el comportamiento predeterminado de Jasons es no volver a sumergir el objetivo. El manejo de fallas se aplica solo a los planes desencadenados por la adición de un objetivo de logro o prueba;En particular, los eventos de eliminación de objetivos no se publican para el fracaso de un plan de eliminación de objetivos. Además, la semántica informal de [6] no considera sub-goles paralelos (es decir, la construcción de la lata), ya que dicha ejecución no es parte del lenguaje Jasons. La implementación de H¨ubner et al.[6] Requiere acciones internas de Jasons. Un requisito para implementar nuestro enfoque es una capacidad reflexiva en la implementación del agente BDI. Las implementaciones adecuadas del formalismo BDI son Jack [2], Jadex [14] y Spark [9]. Los tres permiten métodos de meta -nivel que están indicados por meta eventos, como la adopción de objetivos o la falla del plan, y ofrecen capacidades introspectivas sobre los estados de objetivos e intención. Dichas instalaciones de meta nivel también son requeridas por el enfoque de Unruh et al.[21], quienes definen la compensación semántica basada en objetivos para un agente. Los objetivos de manejo de fallas se invocan de acuerdo con las reglas de la estrategia de control de la falla, por un componente de manejo de falla de agente dedicado (FHC) que rastrea la ejecución de la tarea. El programador de agentes especifica estos objetivos y se adjunta a tareas, al igual que nuestro fabuloso (P, PF, PA) construye la falla y aborta los métodos con un plan P. Nota, sin embargo, que en contraste con [6] y nuestra semántica[21] Adjunta el conocimiento de manejo de fallas a nivel, no plan, no plan. Sus objetivos de manejo de fallas pueden consistir en objetivos de estabilización que realizan una limpieza inmediata localizada para restaurar el estado de los agentes a un estado estable conocido y objetivos de compensación que realizan acciones de deshacer. Los objetivos de compensación se activan al abortar un objetivo, por lo que no necesariamente en la falla del objetivo (es decir, si el FHC dirige al agente que vuelva a intentar el objetivo fallido y el reintento sea exitoso). El enfoque FHC se define a nivel de objetivo para facilitar la especificación abstracta del conocimiento de manejo de falla;El FHC decide cuándo abordar una falla y qué hacer (es decir, qué objetivos de control de falla para invocar), separando este conocimiento de cómo implementar acciones correctivas (es decir, qué plan de ejecutar para cumplir con el objetivo de manejo de fallas adoptada). Esto contrasta con el manejo simplista de falla a nivel del plan en el que se entremezcla qué y cómo se entremezcla en el conocimiento de la tarea de dominio. Si bien nuestro enfoque se define a nivel del plan, nuestra semántica BDI extendida proporciona la separación de la ejecución y el manejo de fallas. Además, el FHC mantiene explícitamente estructuras de datos para rastrear la ejecución del agente. Aprovechamos las estructuras de ejecución existentes y la capacidad autorreflexiva de un agente BDI para lograr tanto el aborto como el manejo de fallas sin sobrecarga adicional. Las reglas de la estrategia de manejo de fallas de FHCS (por ejemplo, si volver a intentar un objetivo fallido) se reemplazan por instrucciones en nuestros planes PF y PA, junto con los controladores de falla por defecto de nivel meta de nivel de la naturaleza de los agentes (por ejemplo, cometidos ciegamente). El enfoque FHC es independiente de la arquitectura del agente en sí, en contraste con nuestro trabajo dedicado al formalismo BDI (aunque no está vinculado a ningún sistema de agente). Por lo tanto, no se desarrollan semántica formal en [21];La operación FHCS se administra como 14 el sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) un protocolo basado en el estado. Este enfoque, junto con el punto de control estatal, se utiliza para sistemas de agentes múltiples en [22]. La arquitectura resultante incorpora su enfoque de manejo de fallas dentro de una arquitectura de procesamiento de pares para la recuperación de accidentes de agentes. Otro trabajo sobre el manejo de excepciones de múltiples agentes incluye agentes de manejo de excepciones distribuidas AOEXS [5], y los centinelas similares de [8]. En ambos casos, la lógica y el conocimiento de manejo de fallas se desacoplan de los agentes;Por el contrario, al separar el manejo de excepciones del conocimiento específico del dominio, Unruh et al.s FHC y nuestro enfoque retienen la lógica de manejo de fallas dentro de un agente.6. Conclusión y trabajo futuro Las tareas y planes de un agente pueden no llegar a la finalización con éxito, ni por la elección del agente para abortarlos (tal vez a solicitud de otro agente para que lo hagan), o mediante factores no tristes que conducen al fracaso. En este artículo, hemos presentado un enfoque basado en el procedimiento que incorpora tareas y planes de aborto en el ciclo de deliberación de un agente de estilo BDI, proporcionando así un enfoque unificado para la falla y el aborto. Nuestra contribución principal es un análisis de los requisitos sobre la operación del agente para abortar tareas y planes, y una semántica operativa correspondiente para abortar en el lenguaje del agente abstracto puede. Estamos planeando implementar una instancia de nuestro enfoque en el sistema de agente Spark [9];En particular, el trabajo de este documento será la base del mecanismo de manejo de las chispas. También estamos desarrollando una herramienta de análisis para nuestra versión extendida de CAN como base para la experimentación. Un agente inteligente no solo manejará con gracia tareas y planes sin éxito, sino que también deliberará sobre sus actitudes cognitivas para decidir su próximo curso de acción. Hemos asumido el comportamiento predeterminado de un agente de estilo BDI, según su naturaleza: por ejemplo, volver a intentar las alternativas a un plan fallido hasta que uno tenga éxito o hasta que no queden planes alternativos (en cuyo caso fallar la tarea). El trabajo futuro es colocar nuestro enfoque en el servicio del razonamiento de agentes más dinámicos, como la introspección que un agente capaz de razonar sobre los efectos de interacción de tareas y los requisitos de recursos pueden lograr [19, 12]. Relacionado con esto está determinando el costo de abortar una tarea o plan, y usar esto como una entrada para el proceso de deliberación. En particular, esto influiría en el compromiso que el agente tiene con una tarea particular: cuanto mayor sea el costo, mayor será el compromiso. Nuestra suposición de que los métodos de aborto no fallan, como se discutió anteriormente, es pragmático. Sin embargo, este es un problema digno de una exploración adicional, ya sea para desarrollar suposiciones más débiles que también son prácticas o para analizar las condiciones bajo las cuales nuestra suposición es realista. Otro elemento de interés es extender nuestro enfoque de falla y abortar a los objetivos de mantenimiento [1]. Para tales objetivos, es necesaria una semántica operativa diferente para el aborto que para los objetivos de logro, para igualar la diferencia en la semántica de los objetivos en sí. Agradecimientos Agradecemos a Lin Padgham y a los revisores anónimos por sus comentarios. El primer autor reconoce el apoyo del Consejo de Investigación de Australia y el software orientado al agente bajo Grant LP0453486. El trabajo de los dos autores de SRI International fue apoyado por la Agencia de Proyectos de Investigación Avanzada de Defensa (DARPA) bajo el No. NBCHD030010. Cualquier opinión, hallazgos y conclusiones o recomendaciones expresadas en este material son las de los autores y no reflejan necesariamente la visión de DARPA o del Departamento del Centro de Negocios Interior-Nacionales.7. Referencias [1] L. Braubach, A. Pokahr, D. Moldt y W. Lamersdorf. Representación de objetivos para sistemas de agentes BDI. En Proc.de la segunda intl. Taller sobre programación de sistemas de múltiples agentes (Permas04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson y A. Lucas. Agentes inteligentes de Jack - Componentes para agentes inteligentes en Java. Agentlink News, Número 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira y P. Henderson. Extendiendo el concepto de compensación de transacciones. IBM Systems Journal, 41 (4), 2002. [4] M. Dastani, M. B. Van Riemsdijk y J.-J. C. Meyer. Tipos de objetivos en la programación de agentes. En Proc.de Aamas06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy y E. Kendall. AOEX: un marco de manejo de excepciones basado en agentes para construir sistemas de software confiables, distribuidos y abiertos. En Proc.de la séptima conf. Conf.Sobre la ingeniería de software basada en el conocimiento, 2006. [6] J. F. H¨ubner, R. H. Bordini y M. Wooldridge. Programación de objetivos declarativos utilizando patrones de plan. En Proc.de 4th intl. Taller sobre lenguas y tecnologías de agentes declarativos, 2006. [7] D. Kinny. El cálculo de PSI: un lenguaje de agente algebraico. En Proc.de Atal01, 2001. [8] M. Klein, J. A. Rodr´ıguez-Aguilar y C. Dellarocas. Uso de servicios de manejo de excepciones independientes del dominio para permitir sistemas robustos de múltiples agentes abiertos: el caso de la muerte del agente. Agentes autónomos y sistemas de múltiples agentes, 7 (1-2): 179-189, 2003. [9] D. Morley y K. Myers. El marco de agente Spark. En Proc.de Aamas04, 2004. [10] D. Morley, K. L. Myers y N. Yorke-Smith. Refinamiento continuo de estimaciones de recursos de agente. En Proc.de Aamas06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack y M. Tambe. Un asistente personal inteligente para la gestión de tareas y tiempo. AI Magazine, 28, 2007. A aparecer.[12] K. L. Myers y N. Yorke-Smith. Un marco cognitivo para la delegación a un agente de usuario de asistencia. En Proc.del Simposio de otoño de AAAAI 2005 sobre asistentes de resolución de problemas de inicio mixto, 2005. [13] L. Padgham y M. Winikoff. Desarrollo de sistemas de agentes inteligentes: una guía práctica. John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach y W. Lamersdorf. Jadex: un motor de razonamiento BDI. En R. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores, programación de múltiples agentes. Springer, 2005. [15] A. S. Rao. AgentsPeak (L): los agentes de BDI hablan en un lenguaje computable lógico. En Proc.del séptimo taller europeo sobre modelos de agentes autónomos en un mundo de múltiples agentes, 1996. [16] A. S. Rao y M. P. Georgeff. Una arquitectura abstracta para agentes racionales. En Proc.de KR92, 1992. [17] S. Sardi˜na, L. de Silva y L. Padgham. Planificación jerárquica en lenguajes de programación de agentes BDI: un enfoque formal. En Proc.de Aamas06, 2006. [18] S. Sardina y L. Padgham. Objetivos en el contexto de la falla y la planificación del plan BDI. En Proc.de Aamas07, 2007. [19] J. Thangarajah, L. Padgham y M. Winikoff. Detectar y explotar la interacción de objetivos positivos en agentes inteligentes. En Proc.de Aamas03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham y K. Fischer. Evitar conflictos de recursos en agentes inteligentes. En Proc.de ECAI-02, 2002. [21] A. Unruh, J. Bailey y K. Ramamohanarao. Un marco para la compensación semántica basada en objetivos en los sistemas de agentes. En Proc.de First Intl. Taller sobre seguridad en sistemas de múltiples agentes, 2004. [22] A. Unruh, H. Harjadi, J. Bailey y K. Ramamohanarao. Gestión de recuperación basada en compensación semántica en sistemas de agentes múltiples. En Proc.del segundo Simposio IEEE sobre seguridad y supervivencia de múltiples agentes (IEEE MAS y S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y de procedimiento en sistemas de agentes inteligentes. En Proc.de KR02, 2002. El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 15