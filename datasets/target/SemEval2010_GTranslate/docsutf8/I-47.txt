Semántica operativa de interacciones multiagentes Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, España Juanmanuel.Serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spina Sergio.Saugar@urjc.Resumen de ES La postura social defendida por los marcos institucionales y la mayoría de las metodologías del sistema de múltiples agentes han resultado en un amplio espectro de abstracciones organizacionales y comunicativas que han encontrado moneda en varios marcos de programación y plataformas de software. Aún así, estas herramientas y marcos están diseñados para admitir una gama limitada de capacidades de interacción que limitan a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este documento es que la variedad de mecanismos de interacción de múltiples agentes, tanto, organizacionales como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el documento propone un modelo basado en el conector de interacciones de múltiples agentes que intenta identificar la estructura esencial subyacente a las interacciones múltiples de agentes. Además, el documento también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto se pretende como la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores acomodar un conjunto abierto de mecanismos de interacción. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: Sistemas de inteligencia artificial distribuidos Sistemas de agente Términos generales Idiomas, Teoría, Diseño 1. Introducción La idoneidad de la computación basada en agentes para administrar los patrones complejos de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizacional o social defendida por los marcos institucionales [2] y la mayoría de las metodologías del sistema múltiple (MAS) [26, 10], proporciona una base excelente para lidiar con la complejidad y el dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha resultado en un amplio espectro de abstracciones organizacionales y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAS), etc., para modelar efectivamente el espacio de interacción de MAS. Esta riqueza de abstracciones computacionales ha encontrado moneda en varios marcos de programación y plataformas de software (Ameli [9], Madkit [13], Ingenias Toolkit [18], etc.), que aprovechan los artículos intermedios de múltiples agentes basados en ACL sin procesar.[14], y minimice la brecha entre los metamodelos organizacionales y los lenguajes de implementación de objetivos. Aún así, estas herramientas y marcos están diseñados para admitir una gama limitada de capacidades de interacción que limitan a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este documento es que la variedad de mecanismos de interacción de múltiples agentes, tanto, organizacionales como comunicativos, comparten un núcleo semántico común. Por lo tanto, este documento se centra en los bloques de construcción fundamentales de las interacciones múltiples de agentes: las que pueden ser compuestas, extendidas o refinadas para definir tipos de interacciones organizacionales o comunicativos más complejos. Su primer objetivo es llevar a cabo un análisis de principios de interacciones múltiples, que se apartan de las características generales comúnmente atribuidas a la informática basada en agentes: autonomía, situación y socialidad [26]. Para abordar este problema, aprovechamos la noción de conector, presentado dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en el conector de interacciones múltiples entre agentes entre componentes sociales autónomos y situados, es decir, agentes, que intentan identificar su estructura esencial. Además, el documento también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones múltiples de agentes (o sociales). La semántica operacional estructural (SOS) [21], una técnica común para especificar la semántica operativa de los lenguajes de programación, se utiliza para este propósito. El documento está estructurado de la siguiente manera: Primero, se introducen las principales entidades y relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. El último trabajo relevante en la literatura se discute 889 978-81-904262-7-5 (RPS) C 2007 Ifaamas con respecto a la propuesta, se abordan las limitaciones y se describe el trabajo actual y futuro.2. Estructura de interacción social Desde un punto de vista arquitectónico, las interacciones entre los componentes del software se incorporan en conectores de software: entidades de primera clase definidas sobre la base de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamadas y Callee de un conector RPC, o los roles de remitente y receptor en un conector de aprobación de mensajes. La operación de archivo adjunto une un componente al papel de un conector dado. El análisis de las interacciones sociales introducidas en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, el rol) en una interacción social, los llamados agentes. Básicamente, los agentes son aquellos componentes de software que se considerarán autónomos dentro del alcance de la interacción1.• Un segundo grupo de participantes, los llamados recursos ambientales, puede identificarse a partir de la característica de sitios. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de los recursos en una interacción no es obligatoria.• Por último, según la socialidad de los agentes, la especificación de los protocolos de conector social: el pegamento que vincula a los agentes entre ellos y con los recursos, dependerá de conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de los agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción;y eventos, que representan los cambios en la interacción resultante del desempeño de las acciones o la actividad de los recursos ambientales. A continuación, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T L1: T1 ,...LN: TN, posiblemente seguido de varios invariantes, definiciones y las acciones que afectan a su estado. Las instancias o valores V de un tipo de registro T se representarán como V = V1 ,..., VN: T. El tipo sett representa una colección de valores extraídos del tipo T. El tipo queuet representa una cola de valores v: t esperando ser procesados. El valor v en la expresión [v |]: La cola [t] representa la cabeza de la cola. El tipo enum {v1 ,..., vn} 1 Tenga en cuenta que pensamos en la función de autonomía en una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, p.en sus interacciones a través de interfaces de usuario humano. Esta conceptualización de la agencia se asemeja a la forma en que los objetos se entienden en Corba: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB.representa un tipo de enumeración cuyos valores son V1 ,..., vn. Dado algún valor V: T, el término VL se refiere al valor del campo L de un tipo de registro T. Dadas algunas etiquetas L1, L2 ,..., La expresión vl1, l2, ... es azúcar sintáctica para ((VL1) L2).... El término especial nulo se usará para representar la ausencia de valor adecuado para un campo opcional, de modo que vl = nil será cierto en esos casos y falsos de otra manera. El modelo formal se ilustrará con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de los cursos universitarios.2.1 Interacciones sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que representa un curso universitario (por ejemplo, en estructuras de datos). Por un lado, esta interacción es en realidad compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de asignación de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignación, a su vez, pueden contener una serie de envíos de asignación y interacciones de solicitudes de prueba. Una solicitud de prueba también puede considerarse como una interacción compleja, en última instancia, descompuesta en las interacciones atómicas o de nivel inferior representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, basura, ...). Por otro lado, los cursos se ejecutan dentro del alcance de un grado particular (por ejemplo, informática), una interacción de nivel superior. Atraviando hacia arriba de un título a sus antepasados, encontramos su facultad, la universidad y, finalmente, la comunidad o la sociedad de agentes de múltiples agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción múltiple de agente2. Los tipos de interacción organizacional y comunicativo identificados anteriormente difieren claramente de muchas maneras. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que manipulan los agentes, el protocolo que regula las actividades del agente y el espacio de la subinteracción. En consecuencia, podemos especificar el Tipo I de las interacciones sociales, variada por el meta-variable I, como sigue: I State: Si, Ini: A, MEM: SET A, Env: SET R, SUB: SET I, Prot:P, CH: CH def.: (1) icontext = i1 ⇔ i ∈ Isub 1 inv.: (2) iini = nil ⇔ icontext = nil act.: Configurar, unirse, crear, destruir dónde los campos de miembro y medio ambiente representan los agentes (a) y los recursos locales (R) que participan en la interacción;el campo de subteracción, su conjunto de interacciones internas;y el campo del protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su súper interacción (def. 1), de modo que el contexto de la interacción toplevel es nulo. El tipo SI enum {Open, Closing, Cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, pero la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 en el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad, ya que los agentes serían una elección correcta.890 El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07), por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (Inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes de agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen los recursos de su entorno local. Finalmente, la interacción puede llegar a su fin (de acuerdo con las reglas de los protocolos), o ser cerrado explícitamente por algún agente, deshabilitando así prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.2.2 Los componentes de los agentes se adhieren a sí mismos como agentes en las interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente cuando se una a una interacción se considerará como el objetivo institucional que pretende satisfacer dentro de ese contexto3. Los tipos de agentes que participan en una interacción dada se identifican principalmente a partir de sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso que pretenden obtener un certificado en el tema de los cursos. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El Tipo A de los agentes, variados por Meta-Variables A, se define de la siguiente manera: A Estado: SA, Jugador: A, Prop: F, ATT: Acto de cola, EV: Queue E, Obl: Set O def.: (3) acontext = i ⇔ a ∈ IMem (4) a1 ∈ Aroles ⇔ Aplayer 1 = A (5) I ∈ Aparte en ⇔ a1 ∈ IMem ∧ a1 ∈ Aroles Act.: Consulte dónde se representa el propósito como una fórmula booleana bien formada, de un tipo genérico F, que se evalúa a verdadero si el propósito se satisface y se falla de otra manera. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA enum {jugar, dejar, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente de jugadores se une a la interacción, o algún componente de software se adjunta como agente al sistema de múltiples agentes (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de Partin representan los roles desempeñados por el agente y los contextos en los que se juegan estos roles (def. 4, 5) 4. Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son interpretados por agentes estudiantiles pertenecientes al título (de pregrado), mientras que los profesores pueden ser jugados por los maestros de un departamento determinado y el papel de asistente puede ser interpretado por estudiantes de un título de doctorado (ambos, elEl departamento y los grados de doctorado se modelan como subinteracciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, para configurar subteracciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben ser conscientes del estado actual de la interacción, para que también puedan observar ciertos eventos de la interacción. Ambos, la visibilidad de la interacción 3, por lo tanto, puede corresponder o no a los objetivos o intenciones internos reales del componente.4 Variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universal/existencialmente.y los intentos de los miembros están sujetos a las reglas que rigen la interacción. Los intentos y los campos de eventos de la estructura del agente representan las colas de los intentos de ejecutar algunas acciones (ACT), y los eventos (e) recibidos por el agente que aún no se han observado. Un agente puede actualizar su cola de eventos al ver el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción terminará. Esto puede suceder cuando ciertas condiciones se cumplen (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de dejar la interacción. En cualquier caso, el estado final del agente tendrá éxito si su propósito fue satisfecho;sin éxito de lo contrario. El estado de salida transitoria se describirá en la siguiente sección.2.3 Recursos Los recursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para satisfacer los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por parte de los maestros incluyen compiladores e intérpretes. El tipo R de recursos, variados por R Meta-Variables, se puede especificar por el siguiente tipo de registro Tipo: R Cr: A, Propietarios: Establecer A, OP: Establecer OP DEF.: (6) rContext = i ⇔ r ∈ Ienv acto.: Tomar, compartir, dar, invocar esencialmente, los recursos pueden considerarse como objetos implementados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de características obligatorias representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera un dispositivo normativo dirigido a la simplificación de las reglas de los protocolos que rigen la interacción de los agentes y el medio ambiente. Los miembros pueden obtener la propiedad de algún recurso tomándolo y otorgar propiedad a otros agentes dando o compartiendo sus propias propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La última función de operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso constituye su interfaz.2.4 Protocolos El protocolo de cualquier interacción se compone de las reglas que rigen su estado general y dinámica. La presente especificación abstrae el formalismo particular utilizado para especificar estas reglas, y se centra en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, variado por Metathe Sixth Intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 891 Variable P, se define de la siguiente manera 5: P EMP: A × ACT → Boolean, Perm: A × ACT → Boolean, Obl: → Set (A × Set O × Set E), monitor: E → SET A, FINALO: → BOOLEAN, Over: A → Boolean def.: (7) pcontext = i ⇔ p = iProt inv.: (8) pfinish () ∧ s ∈ Pcontext, sub ⇒ sprot, final () (9) pfinish () ∧ a ∈ Pcontext, mem ⇒ pobre (a) (10) pobre (a) ∧ ai ∈ Aroles ⇒ acontext,Prot, sobre I (ai) (11) αadd ∪ {a} ⊆ pmonitor (a, α,) acto.: Cerrar, dejar a la demanda de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos incluirán reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el medio ambiente, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderados se considerarán las capacidades institucionales que posee algún agente para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de la función empoderada, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderimientos solo pueden ejercirse bajo ciertas circunstancias, que especifican los permisos. Las reglas de permiso permitirán determinar si el intento de un agente facultado para realizar alguna acción particular está satisfecho o no (cf. campo permitido). Por ejemplo, el protocolo de cursos especifica que los agentes facultaron para unirse a la interacción, ya que los estudiantes son aquellos estudiantes del título que han pagado la tarifa establecida para el tema de los cursos y poseen los certificados correspondientes a sus materias previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente 6. En segundo lugar, los protocolos permitirán determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de aplicación social, totalmente compatible con la autonomía de los agentes, utilizados para sesgar su comportamiento en una cierta dirección. Este tipo de reglas permitirá determinar si algún agente debe realizar una acción de un tipo determinado, así como si se cumplió, violara o debe revocar alguna obligación. Las obligaciones de función de la estructura del protocolo identifican así a los agentes cuyo conjunto de obligaciones debe actualizarse. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de cursos establece que los miembros de los departamentos deben unirse al curso como maestros cada vez que se asignan a la asignatura de cursos. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originan dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser despiertos de algún evento. Por ejemplo, esta función de la formalización supone que los protocolos funcionan implícitamente como entrada de la interacción que se está regulando.6 La relación Haspaidfee entre los estudiantes (de grado) y los recursos de la asignatura está representada por un campo adicional dependiente de la aplicación de la estructura del agente para este tipo de roles. Del mismo modo, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P se pueden extender.Los maestros explotan la información para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales se terminará automáticamente alguna interacción y si la participación de algún agente miembro terminará automáticamente. Por lo tanto, el final del campo de función devuelve verdadero si la interacción regulada debe finalizar su ejecución. Si sucede, un conjunto de protocolos bien definidos debe asegurarse de que sus subteracciones y miembros también estén terminados (Inv. 8,9). Del mismo modo, la función se devuelve sobre verdadero si la participación del miembro especificado debe haber terminado. Los protocolos bien formados deben garantizar la consistencia entre estas funciones a través de roles de juego (Inv. 10) 7. Por ejemplo, el protocolo de cursos establece que la participación de los estudiantes ha terminado cuando obtienen la propiedad del certificado de cursos o las posibilidades de que se agoten. También establece que el curso debe finalizarse cuando ha pasado la etapa de admisión y todos los estudiantes terminaron su participación.3. Dinámica de interacción social La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, para ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con los agentes (por ejemplo, observa los eventos de su cola de eventos, ingrese o salga de la comunidad) y se saltarán los recursos (por ejemplo, un recurso de temporizador puede indicar el paso de tiempo). El procesamiento de algún intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o la configuración de nuevas subteracciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (el objetivo incluido), a saber, en su estado de ejecución, así como en el estado de ejecución, las obligaciones y la visibilidad de sus miembros. Esta sección también describirá la forma en que se procesan estos eventos. La dinámica resultante descrita a Bellow permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución.3.1 Intento de procesamiento Se define un intento por la estructura en t perf: a, acto: acto, donde el artista representa al agente a cargo de ejecutar la acción especificada. Esta acción está destinada a alterar el estado de alguna interacción objetivo (posiblemente, el contexto de los artistas en sí), y notificar a una colección de los destinatarios de los cambios resultantes de una ejecución exitosa. En consecuencia, el acto de acciones de tipo, variado por α meta-variable, se especifica de la siguiente manera: Acto Estado: SACT, Target: I, Agregar: Establecer una def.: (12) αperf = a ⇔ α ∈ Aatt 7 Las acciones de cierre y deje actualizar los campos de finalización y sobre la función como se explica en la siguiente sección. Las acciones adicionales, como permiso, prohibir, empoderar, etc., para actualizar otros campos de protocolos aún no se han identificado en el trabajo futuro.892 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) donde: el artista se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo estatal representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, como se especifica por el tipo de enumeración sact enum {emp, perman, ejecutivo}: verificación de empoderamiento, verificación de permiso y ejecución de acción, descrita en la secuela.3.1.1 Comprobación de empoderamiento La condición posterior de un intento consiste en insertar la acción en la cola de intentos del artista especificado. Como la Regla 1 especifica8, esto solo será posible si el artista está facultado para ejecutar esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si no se cumple esta condición, el intento simplemente será ignorado. Además, el agente del intérprete debe estar en el estado de juego (esta pre-condición también es necesaria para cualquier regla relativa al procesamiento de intentos). Si estas pre-condiciones están satisfechas, se dispara la regla y el procesamiento de la acción continúa en la etapa de verificación de permiso. Por ejemplo, cuando el componente de software adjunto como estudiante en un grado intenta unirse como estudiante, el curso en el que se enseña algunas asignaturas, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante (de grado) ha aprobado los cursos de requisitos previos, la acción de unión se insertará en su cola de intentos y se considerará para su ejecución.αTarget, Prot, Em (A, α) A = Playing ,,, Qact ,, A, α: At t - → Playing ,,, Qact ,, (1) W aquí: (α) estado = Perm (Qact) =Insertar (α, QACT) 3.1.2 Permisos que verifican el procesamiento de la acción se reanudan cuando las posibles acciones anteriores en la cola de intentos de los artistas se procesan completamente y se eliminan de la cola. Además, no debería haber eventos pendientes que se procesen en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará en breve en la próxima subsección). Si estas condiciones se cumplen, los permisos para ejecutar la acción dada (y notificar a los destinatarios especificados) se verifican (por ejemplo, se verificará si el estudiante pagó la tarifa por el tema de los cursos). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento pasa a la etapa de ejecución de la acción (Regla 2). De lo contrario, la acción se descarga y se elimina de la cola. A diferencia de los intentos no de poder, uno prohibido hará que se genere y transferirá un evento al canal del evento para su posterior procesamiento.αstate = Perm ∧ Acontext, CH, IN, EV = ∅ ∧ αTarget, Prot, Perm (A, α) A = Playing ,, [α |] ,, - → Playing ,, [α |],, (2) W aquí: (α) Estado = Exec 8 Las etiquetas de instancias registradas se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registro en donde las cláusulas solo afectan los campos especificados.3.1.3 Ejecución de acción Las transiciones disparadas en esta etapa se clasifican de acuerdo con los diferentes tipos de acciones que se ejecutarán. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otros requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas como la configuración y el unión. El segundo grupo de acciones incluye aquellos, como Close and Leave, cuyos efectos se logran indirectamente mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera 9: Actuación de configuración · NUEVO: I Inv.: (13) αNew, MEM = αNew, Res = αNew, sub = ∅ (14) αNew, estado = abierto donde el nuevo campo representa la nueva interacción que se inicia. Sus conjuntos de participantes (agentes y recursos) y las subteracciones deben estar vacías (Inv. 13) y su estado debe estar abierto (Inv. 14). La configuración de la nueva interacción puede afectar su protocolo y los posibles campos dependientes de la aplicación (por ejemplo, el tema de una interacción del curso). Según la Regla 3, el resultado de la ejecución es triple: en primer lugar, el intento de los artistas se actualiza para que se elimine la acción de ejecución;En segundo lugar, la nueva interacción se agrega al conjunto de subteracciones de objetivos (además, su campo de iniciador se establece en el agente del intérprete);Por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de objetivos.αState = Exec ∧ α: Configuración ∧ αNew = I a = Playing ,,, [α | Qact] ,, - → Jugar ,, Qact ,, αTarget = Open ,,,,, SI, C - → Abierto ,,,,,,,,,,,,,,,,,, Si ∪ I, C (3) W aquí: (i) ini = a (c) out, eV = insert (a, α, sub (αTarget, i), cout, eV) consideremos ahora el caso de un cierreacción. Esta acción representa un intento del artista de forzar alguna interacción para finalizar, evitando así sus reglas de protocolo actuales (aquellas sobre la función de finalización). La forma de lograr este efecto es causar una actualización en el protocolo para que la función de finalización devuelva verdadero10. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · UPD: (→ Bool) → (→ Bool) Inv.: (15) αTarget, estado = abierto (16) αTarget, context = nil (17) αUpd (αTarget, prot, termina) () donde el campo objetivo heredado representa la interacción que debe cerrarse (que debe estar abierta y diferente a laTopinteraction, según los invariantes 15 y 16) y el nuevo 9 el tipo resultante consiste en los campos del registro de ACT extendido con un nuevo campo adicional.10 Esta estrategia también se sigue en la definición de licencia y también puede usarse en la definición de otros tipos de acciones como incendio, permiso, prohibir, etc. El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 893 El campo de actualización representa una función de orden superior adecuada para actualizar el protocolo de objetivos (Inv. 17). La transición que modela la ejecución de esta acción, especificada por la Regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento realmente activará el proceso de cierre de la interacción como se describe en la siguiente subsección.αState = Exec ∧ α: Cerrar A = Playing ,,, [α | Qact] ,, - → Reproducción ,, Qact ,, αTarget = Open ,,,,,, P, C - → Open ,,, y P ,,,,,,,,,,,,,,,,,,,,,,,,,,,,c (4) w aquí: (p) acabado = αupd (pfinish) (c) out, eV = insertar (a, α, acabado (αTarget), cout, EV) 3.2 El procesamiento de eventos del procesamiento de eventos está encapsulado en caso decanales de interacciones. Los canales, variados por m meta-variables, se definen por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH OUT: OUTP, IN: INP Inv.: (18) ccontext ∈ Cout, disp (,, final (ccontext)) (19) ccontext ∈ Cout, disp (, over (a)) (20) ccontext, sub ⊆ cout, disp (cierre (cContext)) (21) apartsin ⊆ cout, disp (saliendo (a)) (22) ccontext ∈ Cout, disp (cerrado (i)) (23) {cContext, APlayer, context} ⊆ cout, disp (a) outp eV:Cola e, disp: e → set i, int: set i, ag: set a inp eV: cola e, etapa: enum {int, mem, obl}, ag: establecer las tiendas de puerto de salida y procesos los eventos originados dentroEl alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados de las funciones de acabado, sobre y obligación de ciertos protocolos, también se enviarán a los puertos de entrada de las interacciones identificadas a través de una función de envío, cuyos invariantes se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activan la reevaluación de los funciones anteriores cada vez que se recibe algún evento11. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: envío de eventos, actualización del estado de interacción, actualización del estado miembro y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en subprocesos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento.3.2.1 Evento El envío del evento El procesamiento de algún evento almacenado en el puerto de salida se activa cuando se han enviado todos sus eventos anteriores. Como primer paso, los campos Auxiliary Int y Ag se inicializan 11 alternativamente, es posible que hayamos asumido que las interacciones son plenamente conscientes de cualquier cambio en la comunidad de múltiples agentes. En este escenario, las interacciones se activarían sin requerir ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada.con los valores devueltos de las funciones de envío y monitoreo de protocolos, respectivamente (Regla 5). Luego, las reglas adicionales simplemente iteran sobre estas colecciones hasta que se hayan notificado todos los agentes e interacciones (es decir, ambos conjuntos están vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se vuelven a establecer a NIL. La función de envío identificará el conjunto de interacciones (posiblemente, vacía) que puede verse afectada por el evento (que puede incluir la interacción de los canales en sí) 12. Por ejemplo, de acuerdo con la regla de finalización de los cursos universitarios mencionados en la última sección, el evento que representa el final de la etapa de admisión, se originó en el alcance de la interacción escolar, se enviará a cada curso de los títulos de las escuelas. Con respecto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de un rendimiento de acción, los agentes a ser notificados incluirán a los artistas y destinatarios de esa acción. Por lo tanto, de acuerdo con la regla de monitoreo de los cursos universitarios, si un estudiante de algún título se une a un curso determinado y especifica a un colega como destinatario de esa acción, los maestros de cursos y mismos también serán notificados de la ejecución exitosa.ccontext, estado s = abierto ∧ ccontext, prot, monitor s = mon cs = [e |], d, nil, nil, - → [e |] ,, d (e), lun (e), (5) 3.2.2 La actividad del puerto de entrada del estado de la actualización de la interacción se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe estar finalizada. Por lo tanto, el envío del evento final resultante de una acción cercana (Inv. 18) sirve como un disparador del procedimiento de cierre. Si la interacción no debe estar finalizada, el campo de la etapa del puerto de entrada se establece en la etapa de actualización del estado miembro y el campo Auxiliar AG se inicializa a los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni subteracciones. En este caso, la interacción se puede cerrar de inmediato. Como muestra la Regla 6, la interacción se cierra, se elimina del conjunto de contextos de subteracciones y se inserta un evento cerrado en su canal de salida. Según Invariant 22, este evento se insertará más tarde en su canal de entrada para permitir un tratamiento adicional.Cin, EV 1 = ∅ ∧ Cin, Etapa 1 = int ∧ pfinish () ,,, {i} ∪ Si ,, C - → ,,,, SI ,, C i = ,, ∅ ,, ∅, P, C1-→ cerrado ,,,,,, (6) w aquí: (c) fuera, ev = insertar (cerrado (i), cout, ev) En el segundo escenario, la interacción tiene algún miembro o subteracción. En este caso, se requiere una limpieza antes de la eliminación de la interacción (por ejemplo, si el período de admisión finaliza y ningún estudiante ha matriculado para el curso, los maestros deben estar terminados antes de terminar el curso en sí). Como muestra la Regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el Invariant 20, el evento de cierre se enviará a cada subteracción para activar su procedimiento de cierre (garantizado por Invariant 8). Además, 12 Esto está esencialmente determinado por las reglas de protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de envío está fuera del alcance de este documento.894 El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07), la etapa y los campos de Ag se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9).Cin, EV = ∅ ∧ Cin, Stage = int ∧ pfinish () ∧ (sa = ∅ ∨ Si = ∅) i = abierto, Sa, SI, P, C - → Cierre, Sa, Si, P,c (7) w aquí: (c) out, eV = insertar (cierre (i), cout, ev) (c) en, etapa = mem (c) en, ag = sa eventualmente, cada miembro dejará la interacción yCada subteracción estará cerrada. Los eventos correspondientes serán recibidos por la interacción (según los invariantes 23 y 22) para que las condiciones del primer escenario se mantengan.3.2.3 Estado miembro Actualización Esta etapa simplemente itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido revisados, el campo de la etapa se establecerá en la siguiente etapa de actualización de la obligación y el campo Auxiliar AG se initalizará con los agentes identificados por la función de actualización de la obligación de protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, se abandonará de manera interna (con éxito o sin éxito, de acuerdo con la satisfacción de su propósito). El evento correspondiente se reenviará a su interacción y a la interacción de su agente de jugadores para tener en cuenta más cambios (Inv. 23). De lo contrario, el miembro ingresa al estado de salida transitoria, evitando así cualquier rendimiento de acción. Luego, espera la finalización de los procedimientos de salida de sus roles jugados, desencadenados por el envío adecuado del evento de salida (Inv. 21).3.2.4 Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesarias de los miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando se han actualizado todos los agentes identificados, el evento se elimina de la cola de entrada y el campo de la etapa se retrasa en la actualización del estado de interacción. Por ejemplo, cuando una interacción del curso recibe un evento que representa la asignación de algún miembro del departamento a su tema, se crea una obligación de unirse al curso como maestro para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento.4. Discusión Este documento ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre los componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones de múltiples agentes, desde el más grande (la sociedad de agentes en sí) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de nivel superior pueden representar el tipo de agente-WEB perseguido por iniciativas a gran escala, como Agentcity/OpenNet One [25]. Las interacciones a gran escala, que modelan agregados complejos de interacciones de agentes, como las representadas por instituciones electrónicas o organizaciones virtuales [2, 26], también son susceptibles para ser conceptualizados como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones de nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen el orador y posiblemente muchos oyentes. El propósito del orador coincide con el propósito ilocucionario de la CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente del software) procesó con éxito el significado de la CA. El análisis de las interacciones sociales presentadas en este documento se basa en las propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizacional de los sistemas de múltiples agentes [2, 26, 10, 7] y la perspectiva normativa sobre múltiplesProtocolos de agentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes, como relaciones de poder, contratos, confianza y mecanismos de reputación en entornos organizacionales, etc., podrían explotarse aún más para caracterizar con mayor precisión el carácter organizacional de algunas interacciones múltiples. Del mismo modo, la conceptualización de las acciones comunicativas como interacciones atómicas puede beneficiarse de manera similar de la semántica pública de acciones comunicativas como la introducida en [3]. Por último, el modelo abstracto de los protocolos puede refinarse teniendo en cuenta los modelos operativos de normas existentes [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar todas las características organizacionales o comunicativas de las interacciones múltiples, sino para revelar sus raíces en los mecanismos de interacción básicos. A su vez, esto permitiría la explotación de formalismos comunes, particularmente en relación con los protocolos. A diferencia del desarrollo de agentes individuales, que se ha beneficiado enormemente del diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas de múltiples agentes se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Argumentamos que el campo actual de la programación del sistema de múltiples agentes puede beneficiarse enormemente de los lenguajes de programación de múltiples agentes que permiten a los programadores acomodar un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentadas en este documento se pretende como la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas e lenguajes de agentes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agente). Además de la semántica de ejecución presentada, el trabajo actual y futuro apunta a la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis de superficie correspondientes (tanto textuales como visuales) y el diseño e implementación deUna máquina virtual sobre tecnologías de middleware existentes, como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares al modelo propuesto, particularmente con respecto al envío de eventos, semántica la sexta intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la programación del conjunto de respuestas para especificar las reglas de los protocolos, atendiendo el papel de que la incompletitud (las reglas solo pueden especificar condiciones necesarias o suficientes, por ejemplo), negación explícita (por ejemplo, prohibiciones) yLos valores predeterminados juegan en este dominio.5. Agradecimientos Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de Español (MEC), Proyecto TIN200615455-C03-03.6. Referencias [1] R. Allen y D. Garlan. Una base formal para la conexión arquitectónica. Transacciones ACM sobre Ingeniería y Metodología de Software, 6 (3): 213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodr´ıguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre aplicaciones de ingeniería de inteligencia artificial, 18 (2): 191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de las actitudes mentales y la semántica de compromisos sociales. En Aamas, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. Ohare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas de múltiples agentes. Informatica, 30: 33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner y R. Vieira. Jason y el vellón dorado de la programación orientada al agente. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, programación de múltiples agentes: lenguajes, plataformas y aplicaciones, Capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificar y analizar instituciones sociales basadas en agentes utilizando la programación del conjunto de respuestas. En Eumas, páginas 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda y F. dignum. OMNI: Introducción de estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de sistemas de múltiples agentes Second International Workshop Premas 2004, volumen 3346 de LNAi, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. Islander: editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la primera conferencia internacional conjunta sobre agentes autónomos y sistemas multiagentes (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodr´ıguez-Aguilar y J. L. Arcos. Ameli: un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Conjunta Internacional sobre Agentes Autónomos y Sistemas Multiagentes, Volumen 1, Páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. Desde agentes hasta organizaciones: una visión organizacional de los sistemas de múltiples agentes. En AOSE, páginas 214-230, 2003. [11] Fundación para agentes físicos inteligentes. Especificación de la biblioteca de protocolo de interacción FIPA.http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J. A. Rodr´ıguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a la norma de instituciones electrónicas. En Aamas, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agente Madkit. Notas de conferencia en informática, 1887: 48-55, 2001. [14] Jade. La página de inicio del proyecto Jade.http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología del agente: Computación como interacción: una hoja de ruta para la informática basada en agentes. Agentlink III, 2005. [16] P. McBurney y S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, Editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press.[17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pav´on y J. G´omez-Sanz. Ingeniería de software orientada al agente con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la tercera Conferencia Internacional de Europa Central y Oriental sobre Sistemas de Aguos de Multi-Agentes. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y lenguajes de programación. The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot y A. Artikis. Votación en sistemas de múltiples agentes. 27 de febrero de 2006. [21] G. Plotkin. Un enfoque estructural para la semántica operativa. Informe técnico Daimi FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de las posiciones normativas. Transacciones ACM en Logic Computacional, 2 (4): 581-622, octubre de 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P.Gleizes, y F. Zambonelli, editores, metodologías e ingeniería de software para sistemas de agentes, Capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y Al. Agentcities / OpenNet Testbed.http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings y M. Wooldridge. Desarrollo de sistemas multiagente: la metodología GAIA. Transacciones ACM en Ingeniería y Metodología de Software, 12 (3): 317-370, julio de 2003. 896 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07)