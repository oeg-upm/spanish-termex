Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems canser resuelto a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos de determinación del ganador existente para las subastas combinatorias están centralizados. La subasta de pausa es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible deshacerse del subastador). Es una subasta combinatoria de precios cada vez mayor que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tienen un incentivo para realizar el cálculo. Se puede usar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. Pausa establece las reglas que los postores deben obedecer. Sin embargo, no nos dice cómo los postores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de licitación para los postores en una subasta de pausa. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los licitantes. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en la cantidad de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este artículo presentamos nuestros algoritmos de licitación, discutimos sus virtudes y inconvenientes, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación del ganador. Categorías y descriptores de sujetos I.2.11 [Metodologías de computación]: agentes de inteligencia artificial-inteligencia distribuida, sistemas multiagentes. Algoritmos de términos generales, rendimiento.1. Introducción Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los licitadores pueden realizar ofertas en combinaciones de artículos, llamados paquetes o ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximicen los ingresos de los subastadores. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-HARD [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para los tamaños y estructuras de problemas que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: asignación del despegue del aeropuerto y espacios de tiempo de aterrizaje, adquisición de servicios de transporte de carga, adquisición de servicios de transporte público y adquisiciones industriales [2]. Debido a su amplia aplicabilidad, uno no puede esperar un algoritmo de determinación del ganador general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos de determinación del ganador existente para las subastas combinatorias están centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son Cass [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deben estudiarse, ya que ofrecen un mejor ajuste para algunas aplicaciones, ya que, por ejemplo, los agentes no quieren revelar sus valoraciones al subastador. La subasta de pausa (entorno de selección de usuario adaptativo progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. Pausa establece las reglas que los participantes tienen que adherirse para que el trabajo se distribuya entre ellas. Sin embargo, no se preocupa por cómo los postores determinan lo que deben ofertar. En este documento presentamos dos algoritmos, Pausebid y CachedPauseBid, que permiten a los agentes en una subasta de pausa para encontrar el bido que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de la utilidad miope y están garantizados para encontrar el beque que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado.PAUSEBID realiza una rama y una búsqueda vinculada completamente desde cero cada vez que se llama.CachedPauseBid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones.694 978-81-904262-7-5 (RPS) C 2007 Ifaamas 2. La subasta de pausa Una subasta de pausa para m ítems tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente y durante esta etapa los postores solo pueden colocar ofertas en artículos individuales. Al final de este estado, sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva K = 2, 3 ,..., M consiste en una subasta de precios ascendente donde los licitadores deben presentar ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser para k ítems o menos. Los postores pueden usar ofertas que otros agentes han colocado en rondas anteriores al construir sus bidsets, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo bidset debe tener una suma de precios de oferta que sea más grande que el del bestet actualmente ganador. Al final de cada etapa K, todos los agentes conocen la mejor oferta por cada subconjunto de tamaño K o menos. Además, en cualquier momento después de que la etapa 1 haya terminado, hay un bidto permanente cuyo valor aumenta monotónicamente a medida que se presentan los nuevos bidsets. Dado que en la ronda final, todos los agentes consideran todos los bidsets posibles, sabemos que el bidset ganador final será uno de los que ningún agente puede proponer un mejor bidto. Sin embargo, tenga en cuenta que no se garantiza que este banco sea el que maximice los ingresos, ya que estamos utilizando una subasta de precios ascendente, por lo que la oferta ganadora para cada conjunto será solo un poco más grande que la segunda oferta más alta para el conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los elementos a los postores que se encuentran en una subasta de pausa es la misma que la solución de maximización de ingresos. Los resultados de nuestra prueba proporcionan una respuesta a esta pregunta. La subasta de pausa hace que el trabajo del subastador sea muy fácil. Todo lo que tiene que hacer es asegurarse de que cada nuevo bidset tenga un ingreso más grande que el bidset ganador actual, así como para asegurarse de que cada oferta en un bidset de agentes que no sea suya corresponde a otros agentes anteriores. El problema computacional cambia de una de la determinación del ganador a una de la generación de ofertas. Cada agente debe buscar sobre el espacio de todos los bidsets que contienen al menos una de sus ofertas. La búsqueda se hace más fácil por el hecho de que el agente debe considerar solo las mejores ofertas actuales y solo quiere ofertas en los que su propia utilidad sea más alta que en el bidset ganador actual. Cada agente también tiene un incentivo claro para realizar este cálculo, a saber, su utilidad solo aumenta con cada bidset que propone (por supuesto, podría disminuir con los bidsets que otros proponen). Finalmente, se ha demostrado que la subasta de pausa es libre de envidia, ya que al concluir la subasta, ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar completamente eliminar el subastador y, en cambio, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de las mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar su cálculo, ya que aumentará su utilidad esperada. Además, cualquier mentira sobre otras ofertas de agentes se descubre fácilmente realizando un seguimiento de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). A saber, el único que puede aumentar el valor de oferta de un agente es el agente mismo. Cualquiera que reclame un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcula el bidset de maximización de utilidad para cada agente.3. Formulación del problema Una oferta B está compuesta por tres elementos bitems (el conjunto de artículos que la oferta ha terminado), bagent (el agente que colocó la oferta) y bvalue (el valor o el precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de elementos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un set W ⊆ B de las ofertas actualmente ganadoras. Este es el conjunto de ofertas que cubre todos los elementos y actualmente maximiza los ingresos, donde los ingresos de W están dados por R (W) = b∈W BValue.(1) El agente es la función de valor viene dada por vi (s) ∈ donde s es un conjunto de elementos. Dada una función de valor de los agentes y el bidset ganador actual w, podemos calcular la utilidad de los agentes a partir de w como ui (w) = b∈W |bagent = i vi (bitems) - bvalue.(2) Es decir, la utilidad de los agentes para un bidset w es el valor que recibe por los artículos que gana en w menos el precio que debe pagar por esos artículos. Si el agente no está ganando ningún elemento, entonces su utilidad es cero. El objetivo de los agentes de licitación en la subasta de pausa es maximizar su utilidad, sujeto a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos más grande que los ingresos actuales, donde está el incremento más pequeño permitido en la subasta. Formalmente, dado que W es el bateador ganador actual, agente, debo encontrar una g ∗ i tal que r (g ∗ i) ≥ r (w) + y g ∗ i = arg max g⊆2b ui (g), (3)donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈G (b ∈ B) o (bagent = i y bvalue> b (bitems) y tamaño (bitems) ≤ k), y donde b (elementos)El valor de la oferta en B para los elementos establecidos (si no hay oferta para esos elementos, devuelve cero). Es decir, cada oferta B en G debe satisfacer al menos una de las dos condiciones siguientes.1) B ya está en B, 2) B es una oferta de tamaño ≤ k en la que el agente I oferta más alto que el precio de los mismos artículos en B. 4. Algoritmos de licitación Según la subasta de pausa, durante la primera etapa solo tenemos varias subastas en inglés, y los postores presentan ofertas en artículos individuales. En este caso, una estrategia dominante de agentes es una oferta más alta que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas posteriores: K> 1. Cuando K> 1, los agentes tienen que encontrar G ∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un gran árbol de búsqueda. Nuestros algoritmos representan enfoques alternativos para superar esta costosa búsqueda.4.1 El algoritmo de pausa en el algoritmo de pausa (que se muestra en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores quieren maximizar su utilidad y que en cualquier punto dado es probable que solo hay unas pocas ofertas dentro de B que el sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 695 pausebid (i, k) 1 my-bids ← ∅ 2 sus-bids ← ∅ 3 para b ∈ B 4 do si bagent = i o vi (bitems)> bvalue 5luego my-bids ← my-bids +nueva oferta (bitems, i, vi (bitems)) 6 más sus-bids ← sus-bids +b 7 para s ∈ Subsets de k o menos elementos tal que vi (s)> 0y ¬∃b∈Bbitems = s 8 do my-bids ← my-bids + new bid (s, i, vi (s)) 9 ofertas ← my-bids + sus-bids 10 g ∗ ← ∅ £ Variable global 11 u∗ ← ui (w) £ variable global 12 pbsearch (ofertas, ∅) 13 excedente ← b∈G ∗ |bagent = i bvalue-b (bitems) 14 si excedente = 0 15 entonces regrese g ∗ 16 my-payment ← vi (g ∗)-u ∗ 17 para b ∈ G ∗ |bagent = i 18 do si mi pago ≤ 0 19 entonces bvalue ← b (bitems) 20 más bvalue ← b (bitems) + my-pago · bvalue −b (bitems) excedente 21 retorno g ∗ Figura 1: el algoritmo de pausa queImplementa una rama y una búsqueda unida.I es el agente y k es la etapa actual de la subasta, para k ≥ 2. El agente puede dominar, comenzamos por definir los my-bids para ser la lista de ofertas para las cuales la valoración de los agentes es más alta que la mejor oferta actual,como se da en B. Establecemos el valor de estas ofertas para ser la verdadera valoración de los agentes (pero no necesariamente estamos ofertando una valoración verdadera, como explicamos más adelante). Del mismo modo, establecemos que sus clientes sean el resto de las ofertas de B. Finalmente, la lista de búsqueda de los agentes es simplemente la concatenación de los my-bids y sus vajillas. Tenga en cuenta que las propias ofertas de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (PAUSEBIDE LINE 3 a 9). El agente ahora puede realizar una rama y una búsqueda vinculada en el árbol de ramas en las cervezas producidas por estas ofertas. PBSearch (Figura 2) implementa esta búsqueda de rama y límite. Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que usamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Inicialmente, U ∗ se establece en UI (W) (PAUSeBid Line 11) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si PBSearch alguna vez se encuentra con una solución parcial en la que la utilidad máxima que el agente puede esperar es menor que U ∗, entonces ese subárbol está podado (PBSearch Line 21). Tenga en cuenta que podemos determinar la utilidad máxima solo después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están primero en la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente es el ganador asíLa utilidad de los agentes ya no aumentará. Por ejemplo, pbsearch (ofertas, g) 1 si ofertas = ∅ ∅ ∅ ∅ ∅ ∅ ∅ ∅ ∅ ∅ luego returación 2 b ← primero (ofertas) 3 ofertas ← ofertas −b 4 g ← g + b 5 ¯ig ← elementos no en g 6 si g no contiene unoferta de i 7 y luego regrese 8 Si g incluye todos los elementos 9 y luego el pago min ← max (0, r (w) +-(r (g)-ri (g)), b∈G | bagent = i b (bitems)) 10 Máx-Utilidad ← VI (G)-Mínimo Pago 11 Si R (G)> R (W) y Máx-Utilidad ≥ U ∗ 12, entonces G ∗ ← G 13 U ∗ ← Máx-Utilidad 14 PBSEARK (BIDS, g-b) £ b está fuera 15 más max-ingresos ← r (g) + max (h (¯ig), hi (¯ig)) 16 Si max-venue ≤ r (w) 17 entonces pbsearch (ofertas,g-b) £ b está fuera 18 elseif bagent = i 19 entonces pagado minel(g)-Min-pago 21 Si max-utilidad> u ∗ 22 entonces pbsearch ({x ∈ Bids | xItems ∩ bitems = ∅}, g) £ b está en 23 pbsearch (ofertas, g-b) £ b está fuera24 más 25 pbsearch ({x ∈ Bids | xItems ∩ bitems = ∅}, g) £ b está en 26 pbsearch (ofertas, g - b) £ b está fuera 27 return figura 2: el procedimiento recursivo de pbsearch donde las ofertas son el conjunto del conjuntode las ofertas disponibles y G es la solución parcial actual.Si un agente solo tiene una oferta en My-Bids, entonces la utilidad máxima que puede esperar es igual a su valor para los elementos en esa oferta, menos el pago mínimo posible que podemos hacer para esos artículos y aún se les ocurre un conjunto de ofertas quetiene ingresos mayores que R (W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y la línea 9 para el caso en el que tenemos una solución completa en PBSearch. Tenga en cuenta que para calcular el pago min para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer para cada artículo. Este límite superior es proporcionado por h (s) = s∈S max b∈B |s∈Bitems tamaño de bvalue (bitems).(4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada elemento individual en s un valor igual al máximo de oferta en B dividido por el número de elementos en esa oferta. Para podar las ramas que no pueden conducir a una solución con ingresos mayores que el W actual, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones del 696 el Sexto INTL. Conf.en agentes autónomos y agentes de sistemas de múltiples agentes (AAMAS 07). Del mismo modo a (4) definimos hi (s, k) = s∈S max s |tamaño (s) ≤k y s∈S y vi (s)> 0 vi (s) tamaño (s) (5) que asigna a cada elemento individual s en s el valor máximo producido por la valoración de S dividida por el tamañode S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene S, y su tamaño es menor o igual que k.El algoritmo utiliza la heurística H y HI (líneas 15 y 19 de PBSearch), para podar las ramas recién mencionadas de la misma manera que un algoritmo A ∗ usa su heurística. Una técnica de poda final implementada por el algoritmo es ignorar las ramas donde el agente no tiene ofertas en la respuesta actual G y no hay más ofertas de los agentes en la lista (PBSearch Lines 6 y 7). El G ∗ resultante encontrado por PBSearch es, por lo tanto, el conjunto de ofertas que tienen ingresos mayores que R (W) y maximiza el agente es la utilidad. Sin embargo, el agente es ofertas en G ∗ todavía se establecen en su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausa son responsables de establecer los pagos de los agentes para que pueda lograr su utilidad máxima u ∗. Si el agente solo tiene una oferta en G ∗, entonces es simplemente una cuestión de reducir el pago de esa oferta por U ∗ desde el máximo actual de los agentes Valoración verdadera. Sin embargo, si el agente tiene más de una oferta, entonces enfrentamos el problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos elegido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de elementos.Pausebid supone que el conjunto de las mejores ofertas B y el mejor bidset ganador actual W permanece constante durante su ejecución, y devuelve los agentes miopes de utilidad miope que maximiza el bidset (si hay una) usando una rama y una búsqueda unida. Sin embargo, repite toda la búsqueda en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores.4.2 El algoritmo CachedPauseBid El algoritmo CachedPauseBid (que se muestra en la Figura 3) es nuestro segundo enfoque para resolver el problema de licitación en la subasta de pausa. Se basa en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar hacer una búsqueda completa cada vez. El problema es el mismo;El agente que tengo que encontrar G ∗ i. Observamos que G ∗ I es un bidset que contiene al menos una oferta del agente i. Sea s un conjunto de elementos para los cuales el agente I tiene una valoración de tal manera que vi (s) ≥ b (s)> 0, que gs sea un bidto sobre s tal que r (gs i) ≥ r (w) +y gs i = arg max g⊆2b ui (g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈G (b ∈ B) o (bagent = i y bvalue> b (bitems)) y (∃b∈Gbitems = sy bagent = i). Es decir, GS I es el mejor BIDSE para todos los elementos que incluyen una oferta de I por todos los artículos. En la subasta de pausa no podemos ofertar por conjuntos de artículos con un tamaño mayor que k.Entonces, si tenemos para cada conjunto de elementos s para los cuales vi (s)> 0 y tamaño (s) ≤ k su GS I I BS I entonces G ∗ I es el GS I que maximiza la utilidad de los agentes. Eso es g ∗ i = arg max {s |vi (s)> 0∧Size (s) ≤k} ui (gs i).(7) Cada agente I implementa una tabla de hash C-Table de tal manera que la tabla C [S] = GS para todos los S que VI (S) ≥ B (S)> 0. Podemos almacenar en caché (i, k, k-cambiado) 1 para cada s en la tabla C 2 si vi (s) <b (s) 3 y luego retire S de la table C 4 de lo contrario si K-cambiado y tamaño (s) = k 5 Entonces b ← b + nueva oferta (i, s, vi (s)) 6 g ∗ ← ∅ 7 u ∗ ← ui (w) 8 para cada s con tamaño (s) ≤ k en c-table 9do ¯s ← items-s 10 GS ← C-Table [S] £ Variable global 11 min- Pagment ← Max (R (W) +, B∈Gs B (Bitems)) 12 US ← R (GS)-Min-Pago £ Variable global 13 if (k-cambiado y tamaño (s) = k) o (∃b∈B bitems ⊆ ¯s y bagent = i) 14 entonces b ← {b ∈ B | bitems ⊆ ¯s} 15 ofertas ←B +{b ∈ B | bitems ⊆ ¯s y b /∈ B} 16 para b ∈ Bids 17 do si vi (bitems)> bvalue 18 entonces bagent ← i 19 bvalue ← vi (bitems) 20 si k cambió y tamaño(S) = k 21 Entonces n ← Tamaño (ofertas) 22 US ← 0 23 más n ← Tamaño (b) 24 g ← ∅ + nuevas ofertas (S, I, VI (s)) 25 CpbSearch (BIDS, G, N) 26 C-Table [S] ← GS 27 Si us> u ∗ y r (gs) ≥ r (w) + 28 entonces excedente ← b∈Gs |bagent = i bvalue-b (bitems) 29 Si excedente> 0 30 entonces my-payment ← vi (gs)-ui (gs) 31 para b ∈ Gs |bagent = i 32 do si mi pago ≤ 0 33 entonces bvalue ← b (bitems) 34 más bvalue ← b (bitems)+ my-pago · bvalue −b (bitems) excedente 35 u ∗ ← ui (gs) 36 g ∗← GS 37 más Si us ≤ 0 y VI (S) <b (s) 38, retire S de la Tabla C 39 return G ∗ Figura 3: El algoritmo de CacheDpauseBid que implementa una búsqueda basada en el almacenamiento en caché para encontrar un banqueto que maximice la utilidadpara el agente i.K es la etapa actual de la subasta (para K ≥ 2), y K-Changed es un booleano que es cierto justo después de que la subasta se movió a la siguiente etapa. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 697 cpbSearch (ofertas, g, n) 1 Si ofertas = ∅ ∅ o n ≤ 0, entonces returación 2 b ← primero (ofertas) 3 ofertas ← BIDS −B 4 G ← G +b 5 ¯ig ← Los elementos no en G 6 Si G incluye todos los elementos 7, entonces pagador minero ← Max (0, R (W) +-(R (G)-Ri (G)), B∈G | Bagent = IB (bitems)) 8 max-utilidad ← vi (g)-Mínimo pago 9 Si R (G)> R (W) y Máx-Utilidad ≥ US 10, entonces GS ← G 11 US ← Máx-Utilidad 12 CpbSearch (BIDS, g-b, n-1) £ b está fuera 13 más max-ingresos ← r (g) + max (h (¯ig), hi (¯ig)) 14 si max-venue ≤ r (w) 15 entoncescpBSearch (BIDS, G-B, N-1) £ B está fuera 16 Elseif Bagent = I 17 Entonces, pago mínimo ← (R (W) +)-(R (G)-Ri (G))-H (¯Ig) 18 max-utilidad ← vi (g)-Min-pago 19 Si max-utilidad> us 20 entonces cpBSearch ({x ∈ Bids | xitems ∩ bitems = ∅}, g, n + 1) £ b está en 21 cpbsearch(ofertas, g - b, n - 1) £ b está fuera 22 más 23 cpbSearch ({x ∈ Bids | XItems ∩ bitems = ∅}, g, n + 1) £ b está en 24 cpbsearch (ofertas, g - b, n - 1) £ b está disponible 25 retorno Figura 4: El procedimiento recursivo de CPBSearch donde las ofertas son el conjunto de ofertas disponibles, G es la solución parcial actual y N es un valor que indica cuán profundo en las ofertas de la lista tiene que hacer el algoritmobuscar.Luego encuentre G ∗ buscando el GS, almacenado en C-Table [S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos con tamaño (s) ≤ k.El problema sigue siendo el mantenimiento de la tabla C actualizada y evitando buscar cada GS cada vez.CachedPauseBid trata con este y otros detalles. Sea B el conjunto de ofertas que contengan las nuevas ofertas mejores, es decir, B contiene las ofertas agregadas recientemente a B y las ofertas que han cambiado el precio (siempre más alto), el postor o ambas y ya estaban en B. Sea ¯s = items - s el complemento de S (el conjunto de elementos no incluidos en S).CachedPauseBid toma tres parámetros: i el agente, k la etapa actual de la subasta y K cambió de un booleano que es cierto justo después de que la subasta se movió a la siguiente etapa. Inicialmente, C-Table tiene una fila o entrada para cada conjunto S para el que vi (S)> 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual VI (S) <B (S) de C-Table (línea 3). Luego, en el caso de que K-Changed sea verdadero, para cada conjunto S con tamaño (s) = k, agregamos a B una oferta para ese conjunto con un valor igual a VI (S) y agente de postor I (línea 5);Esta es una oferta que ahora se le permite considerar al agente. Luego buscamos G ∗ entre el GS almacenado en C-Table, para esto solo necesitamos considerar los conjuntos con tamaño (s) ≤ K (línea 8). Pero, ¿cómo sabemos que el GS en C-Table [S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros de eso y necesitamos hacer una búsqueda para actualizar C-Table [s]. Estos casos son: i) Cuando el cambio de K es verdadero y el tamaño (s) ≤ k, ya que no había GS almacenado en C-table para este S. ii) cuando existe al menos una oferta en B para el conjunto de elementos¯s o un subconjunto presentado por un agente diferente al I, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en C-Table [S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de CachedPauseBid. En ambos casos, dado que GS debe contener una oferta para S, necesitamos encontrar un bidset que cubra los elementos faltantes, es decir. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de elementos ¯s o para un subconjunto de ello. Creamos las ofertas de la lista que contienen solo esas ofertas. Sin embargo, colocamos las ofertas de B al comienzo de las ofertas (línea 14) ya que ellos son las que han cambiado. Luego, reemplazamos las ofertas en ofertas que tienen un precio más bajo que la valoración que el agente que tiene para esos mismos elementos con una oferta del agente I por esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo CPBSearch, llamado en la línea 25 de CachedPauseBid y que se muestra en la Figura 4, es el que encuentra el nuevo GS.CPBSearch es una versión ligeramente modificada de nuestra rama y búsqueda vinculada implementada en PBSearch. La primera modificación es que tiene un tercer parámetro n que indica cuán profundo en las ofertas de la lista queremos buscar, ya que deja de buscar cuando N menos o igual a cero y no solo cuando las ofertas de la lista están vacías (línea 1). Cada vez que hay una llamada recursiva de CPBSearch n se reduce en una cuando una oferta de ofertas se descarta o afuera (líneas 12, 15, 21 y 24) y N permanece igual (líneas 20 y 23). Establecemos el valor de N antes de llamar a CPBSearch, para que sea el tamaño de las ofertas de la lista (CachedPauseBid Line 21) en el caso I), ya que queremos que CPBSearch busque en todas las ofertas;Y establecemos que N es el número de ofertas de B incluidas en las ofertas (CachedPauseBid Line 23) en el caso II), ya que sabemos que solo esas primeras N BIDS en las ofertas cambiaron y pueden afectar nuestra GS actual. Otra diferencia con PBSearch es que el límite en CpBSearch es nosotros que establecemos como 0 (línea cachedpausida 22) cuando en el caso i) y r (gs)-min-pago (línea cachedpausebida 12) cuando en el caso ii). Llamamos a CPBSearch con G que ya contiene una oferta para S. Después de ejecutar CPBSearch, estamos seguros de que tenemos el GS correcto, por lo que la almacenamos en la Table C correspondiente [S] (CachedPauseBid Line 26). Cuando llegamos a la línea 27 en CachedPauseBid, estamos seguros de que tenemos el GS correcto. Sin embargo, el agente es las ofertas en GS todavía están establecidas en su propia valoración y no al precio más bajo posible. Si EE. UU. Es mayor que el U ∗ actual, las líneas 31 a 34 en CachedPauseBid son responsables de establecer los pagos de los agentes para que pueda lograr su utilidad máxima en los Estados Unidos. Como en pausa, hemos elegido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de elementos. En el caso de que nosotros menos o igual a cero y la valoración que el agente I tiene para el conjunto de elementos s es más bajo que el valor actual de la oferta en b para el mismo conjunto de elementos, eliminamos la mesa C correspondiente[S] Dado que sabemos que no vale la pena mantenerlo en la tabla de caché (CachedPauseBid Line 38). La función CachedPauseBid se llama cuando K> 1 y devuelve los agentes miopes de utilidad miope Bidset, si hay uno. Se supone que W y B permanecen constantes durante su ejecución.698 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) GenerateValues (i, elementos) 1 para x ∈ Items 2 Do VI (x) = exp (.01) 3 para n ← 1...(Números-Bids-ítems) 4 do S1, S2 ← Dos conjuntos aleatorios de elementos con valores.5 VI (S1 ∪ S2) = VI (S1) + VI (S2) + exp (.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorio.Expd (x) Devuelve un número aleatorio tomado de una distribución exponencial con media 1/x.0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (y-eje), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, como función del número de elementos en la subasta.5. Prueba y comparación Hemos implementado ambos algoritmos y realizamos una serie de experimentos para determinar cómo su solución se compara con la solución de maximización de ingresos y cómo sus tiempos se comparan entre sí. Para hacer nuestras pruebas, tuvimos que generar funciones de valor para los agentes1. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden reunir ciertos subconjuntos de tareas. Por ejemplo, imagine un conjunto de robots que deben recoger y entregar elementos a diferentes ubicaciones. Dado que cada robot está en una ubicación diferente y tiene diferentes habilidades, cada uno tendrá diferentes preferencias sobre cómo agrupar. Sus costos para los paquetes de artículos son subadititivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la 1 nota adecuada de que no podíamos usar gatos [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si le dijeran el conjunto de ofertas colocadas en una subasta combinatoria, pero no quién colocó cada oferta o incluso cuántas personas colocaron ofertas, y luego pidió que determine la función de valor de cada participante en la subasta.0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmosEn relación con los ingresos máximos (eje y) como función del número de elementos en la subasta.funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos como se encuentra por CASS cuando se les da un conjunto de ofertas que corresponden a la verdadera valoración de los agentes. Es decir, para cada agente I y cada conjunto de elementos s para los cuales vi (s)> 0 generamos una oferta. Este conjunto de ofertas se alimentó a CASS que implementa un algoritmo de determinación del ganador centralizado para encontrar la solución que maximiza los ingresos. Sin embargo, tenga en cuenta que los ingresos de la subasta de pausa en todas las subastas siempre son más pequeños que los ingresos de la solución que maximiza los ingresos cuando los agentes ofertan sus verdaderas valoraciones. Dado que Pause utiliza subastas en inglés, los precios finales (aproximadamente) representan la segunda valoración más alta, además, para ese conjunto de artículos. Arreglamos el número de agentes a ser de 5 años y experimentamos con un número diferente de elementos, a saber, de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución de maximización de ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de elementos que la solución de maximización de ingresos (como se muestra en la Figura 6). Los casos en que nuestros algoritmos no lograron llegar a la distribución de la solución de maximización de ingresos son aquellos donde había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución de maximización de ingresos contiene la oferta (o ofertas) utilizando esta mayor valoración, entonces es imposible que la subasta de pausa encuentre esta solución porque esa oferta (esas ofertas) nunca se coloca. Por ejemplo, si el agente I tiene VI (1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces solo necesito hacer una oferta de 11 para ganar ese artículo. Si la solución de maximización de ingresos requiere que se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se colocará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen a la solución maximizadora de ingresos disminuyen a medida que aumenta el número de elementos. Para 2 ítems es casi el 100%, pero disminuye un poco menos del 1 por ciento a medida que aumentan los elementos, por lo que este porcentaje promedio de convergencia es de alrededor del 90% para 10 ítems. En algunos casos, nuestros algoritmos encuentran diferentes soluciones, esto se debe a los diferentes INTL. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 PAUSEBID + + + + + + + + + + + + + + + + + ++ Figura 8: Número promedio de nodos expandidos (eje y) como función de los elementos en la subasta.ordenar de las ofertas en la lista de ofertas que los hacen buscar en diferentes orden. Sabemos que los ingresos generados por la subasta de pausa son generalmente más bajos que los ingresos de la solución de ingresos por ingreso, pero ¿cuánto más bajo? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos otorgados por nuestros algoritmos en relación con los ingresos dados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio del 2.7% a medida que aumenta el número de elementos, como se muestra en la Figura 7. Sin embargo, descubrimos que CachedPauseBid genera un ingreso más alto que Pausebid (4.3% más alto en promedio), excepto las subastas con 2 ítems donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 ítems, ambos algoritmos producen en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 ítems), CachedPauseBid produjo en promedio una proporción de ingresos del 91.5%, mientras que Pausebid produjo en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos se puede determinar contando el número de nodos expandidos en el árbol de búsqueda. Para esto, contamos la cantidad de veces que se invoca pbsearch por cada vez que se llama pausa y la cantidad de veces que se invoca fastpauseBidSearch por cada vez que caquedpausebido, respectivamente para cada uno de nuestros algoritmos. Como se esperaba, ya que este es un problema np-cudo, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que los resultados de los supuestos de CachedPauseBid pausbid, ya que se expande en promedio de menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos se expandió cuando 2 elementos es cero para CachedPauseBid, mientras que para Pausebid es 2;y en los otros extremos (10 ítems) CachedPauseBid se expande en promedio solo 633 nodos, mientras que Pausbido se expande en promedio de 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta como función del número de elementos, el número real de nodos es mucho más pequeño que el peor de los casos de nn, donde n es el número de elementos. Por ejemplo, para 10 ítems nos expandimos ligeramente más de 103 nodos para el caso de pausa y menos que para el caso de la cachepause 0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de elementos CacheDPauseBid 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 33 3 3 3 3 3 3 PAUSEBID + + + + + + + + + + Figura 9: Tiempo promedio en segundos que se necesitan para terminar una subasta (eje y) como función del número de elementos en la subasta.oferta que son números mucho más pequeños que 1010. Observe también que nuestro algoritmo de generación de valor (Figura 5) genera una serie de ofertas que son exponenciales en el número de elementos, como podría esperarse en muchas situaciones. Como tal, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan exponencialmente en función del número de ofertas, pero permanezca aproximadamente constante a medida que crece el número de elementos. Queríamos asegurarnos de que los nodos menos expandidos correspondan a una ejecución más rápida, especialmente porque nuestros algoritmos ejecutan operaciones diferentes. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, una PC portátil Intel Centrino 2.0 GHz con 1 GB de RAM y un disco duro de 7200 RMP 60 GB, y calculó el tiempo promedio que lleva finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, CachedPauseBid es más rápida que PAUSEBID, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos.6. Trabajo relacionado Se ha realizado una gran cantidad de investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena revisión. Sin embargo, el estudio de los algoritmos de determinación del ganador distribuido para las subastas combinatorias sigue siendo relativamente nuevo. Los algoritmos dan un enfoque para distribuir el problema de determinación del ganador en las subastas combinatorias presentadas en [7], pero estos algoritmos suponen que las entidades computacionales son los elementos que se venden y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación del ganador distribuido en la subasta combinatoria, pero supone que las ofertas en sí tienen el cálculo. Este algoritmo tampoco converge a una solución para la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos de VCG en un problema de diseño de mecanismo. Su mecanismo equivale aproximadamente a que cada agente calcule los pagos para otros dos agentes y los entreguen a un 700 el sexto INTL. Conf.En los agentes autónomos y el servidor central de los sistemas de múltiples agentes (AAMAS 07) que luego verifica para asegurarse de que los resultados de todos los pares estén de acuerdo, de lo contrario se ordena un re-calculación. Esta idea general, que llaman el principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se da en [8] cuando los agentes de licitación priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo de determinación del ganador centralizado debe considerar, lo que facilita ese problema. Finalmente, en la subasta de reloj de obtención de cálculo [1], los agentes reciben un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Como tal, supone que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores según lo asumido por la subasta de pausa.7. Conclusiones Creemos que las soluciones distribuidas al problema de determinación del ganador deben estudiarse, ya que ofrecen un mejor ajuste para algunas aplicaciones como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entrelos postores. La subasta de pausa es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en las subastas combinatorias. Con esta subasta, incluso podemos imaginar completamente eliminar completamente el subastador y, en cambio, hacer que cada agente realice la tarea del subastador. Sin embargo, aunque Pause establece las reglas que los postores deben obedecer, no nos dice cómo los postores deben calcular sus ofertas. Hemos presentado dos algoritmos, Pausebid y CachedPauseBid, que los agentes de los postor pueden usar para participar en una subasta de pausa. Ambos algoritmos implementan una estrategia de maximización de la utilidad miope que está garantizada para encontrar el bidto que maximiza la utilidad de los agentes dado el conjunto de las mejores ofertas pendientes en un momento dado, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayoría de las veces, la misma distribución de elementos que la solución de maximización de ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos donde había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Como es un problema difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa.PAUSEBID realiza una rama y una búsqueda vinculada completamente desde cero cada vez que se invoca.CachedPauseBid Caches soluciones parciales y realiza una rama y una búsqueda unida solo en las pocas porciones afectadas por los cambios en las ofertas entre tiempos consecutivos.CachedPauseBid tiene un mejor rendimiento, ya que explora menos nodos (menos de la mitad) y es más rápido. Como se esperaba, los ingresos generados por una subasta de pausa son más bajos que los ingresos de una solución de maximización de ingresos encontrada por un algoritmo de determinación de ganador centralizado, sin embargo, encontramos que CachedPauseBid genera en promedio 4.7% de ingresos más altos que PAUSeBid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan como función del número de elementos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas limitaciones de coordinación respaldadas por subastas combinatorias sin tener que recurrir a un algoritmo de determinación del ganador centralizado. Además, debido al diseño de la subasta de pausa, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de licitación pueden ser utilizados por cualquier sistema multiagente que use subastas combinatorias para la coordinación, pero prefiere no implementar un subastador centralizado.8. Adquisición descentralizada de cálculo y robustez computacional en un mercado inteligente. Economic Theory, 13 (1): 41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown e Y. Shoham. Domestica la complejidad computacional de las subastas combinatorias: enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Management Science, 46 (4): 586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. Pausa: una subasta combinatoria computacionalmente manejable. En Cramton et al.[2], Capítulo 6, páginas 139-157.[6] K. Leyton-Brown, M. Pearson e Y. Shoham. Hacia un suite de prueba universal para algoritmos de subasta combinatoria. En Actas de la 2da Conferencia ACM sobre Comercio Electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu.[7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación del ganador distribuido en subastas combinatorias. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas endógenamente determinadas. Informe técnico, Rutgets Center for Operations Research, enero de 2001. RRR 3-2001.[9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Conjunta Internacional sobre Agentes Autónomos y Sistemas Multiagentes, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinacionales manejables computacionalmente. Management Science, 44 (8): 1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Artificial Intelligence, 135 (1-2): 1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo rápido para la determinación del ganador en subastas combinatorias. Management Science, 51 (3): 374-391, 2005. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 701