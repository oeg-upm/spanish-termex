Zar: una arquitectura de almacenamiento de sensores de dos niveles utilizando gráficos de olor a intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, Shenoy@cs.umass.edu Abstract Archival El almacenamiento de datos del sensor es necesario para aplicaciones que consultan, extraen y analicen dichos datos para características y tendencias interesantes. Argumentamos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no explotan completamente la naturaleza de varios niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies atados, cada una administrando decenas a cientos de sensores sin ataduras. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de datos de metadatos al emplear el archivo local en los sensores e indexación distribuida en los proxies. En el nivel proxy, TSAR emplea una nueva estructura de índice distribuido ordenado por múltiples resolución, el gráfico de omisión del intervalo, para soportar eficientemente las consultas espacio-temporales y de valor. En el nivel del sensor, TSAR admite un resumen adaptativo consciente de la energía que puede intercambiar el costo de transmitir metadatos a los representantes contra la sobrecarga de golpes falsos resultantes de consultar un índice de grano grueso. Implementamos TSAR en una prueba de prueba de sensor de dos niveles que comprende proxies basados en StarGate y sensores basados en motas. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento de eficiencia energética en redes de sensores de varios niveles. Categorías y descriptores de sujetos: C.2.4 [Networks de comunicación - Comunicación]: Sistemas distribuidos Términos generales: algoritmos, rendimiento, experimentación.1. Introducción 1.1 Motivación Muchos tipos diferentes de aplicaciones de sensores centrados en datos en red han surgido en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben procesarse, filtrarse, interpretarse y archivarse para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso a datos de sensores en vivo y pasados. Mientras que el acceso a los datos en vivo es necesario en las aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la minería de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento de archivos de datos del sensor pasado requiere un sistema de almacenamiento, cuyos atributos clave son: donde se almacenan los datos, ya sea indexado y cómo la aplicación puede acceder a estos datos de manera eficiente en energía con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En el más simple, los sensores transmiten datos o eventos a un servidor para el almacenamiento de archivo a largo plazo [3], donde el servidor a menudo indexa los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar varios saltos de la estación base más cercana, se incurren en los costos de la red;Sin embargo, una vez que los datos están indexados y archivados, los accesos de datos posteriores se pueden manejar localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento está centralizado, las lecturas son eficientes y baratas, mientras que las escrituras son caras. Además, todos los datos se propagan al servidor, independientemente de si alguna vez lo usan la aplicación. Un enfoque alternativo es tener cada datos o eventos de almacenamiento de sensores localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no incurran en gastos de comunicación. Una solicitud de lectura, como si un sensor en particular detectó un evento, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas se manejan por inundaciones. Por ejemplo, determinar si se detectó un intruso en un intervalo de tiempo particular requiere que la solicitud se inunde a todos los sensores del sistema. Por lo tanto, en este enfoque, el almacenamiento se distribuye, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes gastos generales de la red. Las solicitudes que requieren inundaciones, debido a la falta de un índice, son costosas y pueden desperdiciar recursos de sensor preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Sin embargo, los esfuerzos de investigación, como la difusión dirigida [17], han intentado reducir estos costos de lectura mediante el enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran varios otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidas en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice de inicio para aumentar la naturaleza completamente distribuida del almacenamiento del sensor. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla de hash distribuida o geográfica para asignar las claves a los nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también activen actualizaciones a la tabla hash en la red. Una solicitud de lectura requiere una búsqueda en la tabla hash en la red para localizar el nodo que almacena el elemento de datos 39;Observe que la presencia de un índice elimina la necesidad de inundaciones en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo del sensor está limitado por la energía. En este documento, proponemos una nueva arquitectura de almacenamiento llamada TSAR1 que refleja y explota la naturaleza de varios niveles de las redes de sensores emergentes, donde la aplicación se compone de decenas de proxies de sensores atados (o más), cada una controladora o cientos de sensores sin ataduras. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo de Presto [8], que combina el almacenamiento de archivo con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de varios niveles de futuras redes de sensores. Específicamente, la arquitectura de almacenamiento necesita explotar la naturaleza rica en recursos de los proxies, al tiempo que respeta las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debe explotar cuidadosamente las tendencias tecnológicas actuales, lo que indica que las capacidades de los recuerdos de flash continúan aumentando según la ley de los Moores, mientras que sus costos continúan cayendo en picado. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento de flash por unas pocas decenas de dólares. Un argumento aún más convincente es el costo de energía del almacenamiento flash, que puede ser hasta dos órdenes de magnitud más bajos que el de la comunicación. Los recuerdos más nuevos de NAND Flash ofrecen costos de energía de escritura y borrado muy bajos: nuestra comparación de un almacenamiento Flash Samsung Nand de 1 GB [16] y el ChIPCON CC2420 802.15.4 Radio inalámbrico [4] en la Sección 6.2 indica una relación 1: 100 en por byteCosto de energía entre los dos dispositivos, incluso antes de contabilizar los gastos generales del protocolo de red. Estas tendencias, junto con la naturaleza limitada por la energía de los sensores sin ataduras, indican que el almacenamiento local ofrece una alternativa viable y eficiente en la energía a la comunicación en las redes de sensores. TSAR explota estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de eficiencia energética en cada sensor. Los sensores envían información de identificación concisa, que llamamos metadatos, a un proxy cercano;Dependiendo de la representación utilizada, estos metadatos pueden ser un orden de magnitud o más más pequeño que los datos en sí, lo que impuso costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos informados de todos los sensores y, por lo tanto, un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite que una aplicación consulte y lea los datos anteriores de manera eficiente: el índice se utiliza para identificar todos los datos que coinciden con una solicitud de lectura, seguido de mensajes para recuperar esos datos de los sensores correspondientes. Se eliminan las búsquedas de índice en la red, reduciendo los gastos generales de la red para las solicitudes de lectura. Esta separación de datos, que se almacena en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los gastos de energía en los sensores, aprovechando los recursos en los proxies atados.1.2 Contribuciones Este documento presenta TSAR, una nueva arquitectura de almacenamiento de dos niveles para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores que se adapta explícitamente para las redes de sensores múltiples emergentes. Nuestro diseño e implementación de TSAR ha resultado en cuatro contribuciones. En el núcleo de la arquitectura del zar hay una nueva estructura de índice distribuido basada en gráficos de omisión de intervalos que presentamos en este documento. Esta estructura de índice puede almacenar resúmenes gruesos de los datos del sensor y organizarlos de manera ordenada para buscar fácilmente el zar: arquitectura de almacenamiento escalonada para redes de sensores.capaz. Esta estructura de datos tiene O (log n) esperado de búsqueda y complejidad de actualización. Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel de sensor, cada sensor mantiene un archivo local que almacena datos en la memoria flash. Nuestra arquitectura de almacenamiento es totalmente estancada en cada sensor desde la perspectiva del índice de metadatos;Todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento explícitamente identificadas a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y recompensadas en recursos. Además, la tienda local está optimizada para el acceso de series de tiempo a los datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una nueva técnica de resumen adaptativa que adapta la granularidad de los datos informados en cada resumen a la relación de golpes falsos para consultas de aplicación. Se envían más resúmenes de grano fino cuando se observan más falsos positivos, equilibrando así el costo de energía de las actualizaciones de metadatos y los falsos positivos. En tercer lugar, hemos implementado un prototipo de TSAR en una prueba de prueba de varios niveles que comprende proxies basados en Stargate y sensores basados en mote. Nuestra implementación admite consultas espacio-temporales, de valor y a base de rango en los datos del sensor. Cuarto, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de Emstar/EMTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EMSTAR/EMTOS se centran en la escalabilidad del TSAR en entornos más grandes, nuestra evaluación de prototipos implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escala logarítmica del gráfico de salto disperso y la baja latencia de las consultas de extremo a extremo en una red múltiple de cicatrices múltiple. El resto de este trabajo se estructura de la siguiente manera. La Sección 2 presenta problemas de diseño clave que guían nuestro trabajo. Las Secciones 3 y 4 presentan el índice de nivel de proxy y el archivo local y el resumen en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipos, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. 2. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de varios niveles asumidas en nuestro trabajo. Luego presentamos una descripción de los modelos de uso esperados para este sistema, seguido de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento.2.1 Modelo del sistema imaginamos una red de sensores de varios niveles que comprende múltiples niveles: un nivel inferior de nodos de sensores remotos sin atar, un nivel medio de proxies de sensores atados y un nivel superior de aplicaciones y terminales de usuarios (ver Figura 1). Se supone que el nivel más bajo forma un despliegue denso de sensores de baja potencia. Un nodo del sensor canónico en este nivel está equipado con sensores de baja potencia, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1 GB). La restricción común para este nivel es la energía y la necesidad de una larga vida a pesar de una restricción de energía finita. El uso de radio, procesador, RAM y la memoria flash consumen energía, que debe ser limitada. En general, asumimos que la comunicación por radio es sustancialmente más costosa que los accesos a la memoria flash. El nivel medio consiste en proxies de sensores ricos en potencia que tienen recursos significativos de cálculo, memoria y almacenamiento y pueden usar 40 Tabla 1: Características del sistema de datos de sistemas de almacenamiento de sensores Lectura de escrituras Escrituras Preservador de la tienda centralizada Centralizado Centralizado Manejado en Store Enviar a Store Sí SÍTienda de sensores local completamente distribuido inundación de índice, difusión local sin ght/dcs [24] índice de índice en la red totalmente distribuido al nodo enviar al nodo hash no tsar/presto índice distribuido totalmente distribuido en proxies bearup + sensor consultas locales más índice actualización de índiceSí, el usuario unificado consultas lógicas de almacén (tiempo, espacio, valor) Respuesta de consulta Cache Consulta Reenvío Proxy Sensores remotos Archivo de datos locales En intervalo de memoria Flash Skip Graph Consulta Reenvío de la consulta Inicio Inicio Índice Índice Final Index Lineal Consulta Respuesta de consulta de caché Cache: Arquitectura de una red de sensores de varios niveles.estos recursos continuamente. En los entornos urbanos, el nivel proxy comprendería los nodos de clase de estación base atada (por ejemplo, ballesta de Stargate), cada uno con múltiples radios: una radio 802.11 que lo conecta a una red de malla inalámbrica y una radio de baja potencia (por ejemplo, 802.15.4) Eso lo conecta a los nodos del sensor. En aplicaciones de teledetección [10], este nivel podría comprender un nodo Stargate similar con una célula de energía solar. Se supone que cada proxy administra varias decenas a cientos de sensores de nivel inferior en su vecindad. Una implementación de red de sensores típica contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo del edificio, se puede colocar un proxy de sensor por piso o pasillo para monitorear los sensores de temperatura, calor y luz en sus vecindad. En el nivel más alto de nuestra infraestructura hay aplicaciones que consultan la red de sensores a través de una interfaz de consulta [20]. En este trabajo, nos centramos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en una tienda persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que explote la abundancia relativa de recursos en los proxies para enmascarar la escasez de recursos en los sensores.2.2 Modelos de uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se planteen. Se puede esperar que una gran fracción de consultas sobre los datos del sensor sea de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico;Dos atributos clave de esta información son cuando ocurrió un evento o actividad particular y donde ocurrió. Algunas instancias de tales consultas incluyen el tiempo y la ubicación de las detecciones objetivo o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos, como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales) o una simple recopilación de datosconsultas que solicitan datos de una hora o ubicación particular (por ejemplo, monitoreo del clima o medio ambiente). Las consultas esperadas de dichos datos incluyen aquellos que solicitan rangos de uno o más atributos;Por ejemplo, una consulta para todos los datos de imagen de cámaras dentro de un área geográfica especificada durante un cierto período de tiempo. Además, a menudo es deseable admitir un acceso eficiente a los datos de una manera que mantenga el pedido espacial y temporal. Hay varias formas de soportar consultas de rango, como los hashes que preservan la localidad, como los que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y uno que naturalmente proporciona un acceso ordenado eficiente, es mediante el uso de estructuras de datos que preservan el orden. Las estructuras de preservación de orden, como el conocido árbol B mantienen relaciones entre los valores indexados y, por lo tanto, permiten el acceso natural a los rangos, así como las operaciones predecesoras y sucesoras en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en el valor que implican determinar si se observó un valor V en cualquier sensor;La consulta devuelve una lista de sensores y los momentos en los que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (V1, V2) en lugar de un único valor v. Las consultas de valor se pueden manejar indexando los valores informados en los resúmenes. Específicamente, si un sensor informa un valor numérico, entonces el índice se construye en estos valores. Una búsqueda implica encontrar valores coincidentes que están contenidos en el rango de búsqueda (V1, V2) o coincidir con el valor de búsqueda V exactamente. El valor híbrido y las consultas espacio-temporales también son posibles. Dichas consultas especifican un intervalo de tiempo, un rango de valor y una región espacial y solicitan todos los registros que coincidan con estos atributos: encuentre todas las instancias en las que la temperatura excedió los 100o F en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en tiempo como en valor. En zar, nuestro enfoque está en consultas de rango en el valor o el tiempo, con extensiones planificadas para incluir el alcance espacial.2.3 Principios de diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes de varios niveles se basa en el siguiente conjunto de principios, que abordan los problemas que surgen del sistema y los modelos de uso anteriores.• Principio 1: Almacene localmente, Acceso a nivel mundial: la tecnología actual permite que el almacenamiento local sea significativamente más eficiente de energía que la comunicación de red, mientras que las tendencias tecnológicas no muestran signos de borrar esta brecha en el futuro cercano. Para la máxima vida de red, un sistema de almacenamiento de sensores debe aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por una transmisión de radio costosa. Pero sin mecanismos eficientes para la recuperación, las ganancias de energía del almacenamiento local pueden verse superadas por los costos de comunicación incurridos por la aplicación en la búsqueda de datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de un solo almacén lógico a las aplicaciones, como 41 hace TSAR, entonces tendrá flexibilidad adicional para optimizar los costos de comunicación y almacenamiento.• Principio 2: distinguir los datos de los metadatos: los datos deben identificarse para que la aplicación pueda recuperarlos sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y el sistema de almacenamiento puede consultar. Los ejemplos de estos metadatos son los atributos de datos, como la ubicación y el tiempo, o los valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores limitados por recursos. Los proxies comparten este índice de metadatos para proporcionar una visión lógica unificada de todos los datos en el sistema, lo que permite buscar búsquedas eficientes de baja latencia. Dicha separación específica de nivel de almacenamiento de datos de la indexación de metadatos permite que el sistema explote las idiosincrasias de las redes de varios niveles, al tiempo que mejora el rendimiento y la funcionalidad.• Principio 3: Proporcionar soporte de consulta centrada en datos: en una aplicación de sensor, es poco probable que la ubicación específica (es decir, compensación) de un registro en una secuencia sea de importancia, excepto si transmite información sobre la ubicación y/o tiempo en el que else generó información. Por lo tanto, esperamos que las aplicaciones sean mejor atendidas por una interfaz de consulta que les permite localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporciona búsquedas de bajo costo.2.4 Diseño del sistema TSAR encarna estos principios de diseño empleando almacenamiento local en sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: en TSAR, las escrituras ocurren en los nodos del sensor, y se supone que consisten en datos opacos y metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que la aplicación puede utilizar para ubicar e identificar registros de datos, y que puede ser buscado y comparado por TSAR en el curso de la ubicación de datos para la aplicación. En una aplicación de detección basada en la cámara, por ejemplo, estos metadatos pueden incluir coordenadas que describen el campo de visión, la luminancia promedio y los valores de movimiento, además de la información básica como el tiempo y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de la imagen o los datos acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos informados a un proxy cercano. El resumen contiene información como la ID del sensor, el intervalo (T1, T2) sobre el cual se generó el resumen, un mango que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociadoscon el récord. La representación de datos precisa utilizada en el resumen es específica de la aplicación;Por ejemplo, un sensor de temperatura puede optar por informar los valores de temperatura máximos y mínimos observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice;El índice es global en el sentido de que almacena información de todos los sensores del sistema y se distribuye en los diversos proxies del sistema. Por lo tanto, las aplicaciones consulte una vista unificada de datos distribuidos y pueden consultar el índice en cualquier proxy para obtener acceso a los datos almacenados en cualquier sensor. Específicamente, cada consulta desencadena las búsquedas en este índice distribuido y la lista de coincidencias se usa para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían usarse en este sistema;Sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso, en lugar de los datos reales, las búsquedas del índice producirán coincidencias aproximadas. El mecanismo de resumen del TSAR garantiza que las búsquedas de índice nunca producirán falsos negativos, es decir, nunca se perderá resúmenes que incluyan el valor que se busca. Sin embargo, las búsquedas de índice pueden producir falsos positivos, donde un resumen coincide con la consulta, pero cuando se consulta el sensor remoto no encuentra valor coincidente, desperdiciando los recursos de la red. Cuanto más grueso sea el resumen, menor será la sobrecarga de la actualización y mayor es la fracción de falsos positivos, mientras que los resúmenes más finos incurren en la sobrecarga de la actualización mientras reducen la sobrecarga de consultas debido a falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en golpes de búsqueda, y calcular la relación entre los dos;Basado en esta relación, TSAR emplea una nueva técnica adaptativa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos.3. Estructuras de datos en el nivel proxy, TSAR emplea una nueva estructura de índice llamado gráfico de omisión del intervalo, que es una estructura de datos distribuida ordenada para encontrar todos los intervalos que contienen un punto o rango particular de valores. Los gráficos de omisión de intervalos combinan árboles de intervalo [5], un árbol de búsqueda binario basado en intervalo, con gráficos de omisión [1], una estructura de datos distribuida ordenada para sistemas entre pares [13]. La estructura de datos resultante tiene dos propiedades que lo hacen ideal para redes de sensores. Primero, tiene la complejidad de búsqueda O (log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, la indexación de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o el valor. Dicha indexación basada en sumar es un ajuste más natural para los nodos sensores con energía, ya que la transmisión de resúmenes incurre en menos gastos generales de energía que transmitir todos los datos del sensor. Definiciones: Asumimos que hay proxies NP y sensores NS en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos de sensores, y no se asume sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalo de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo I se representa como [Lowi, Highi]. Estos intervalos pueden corresponder a rangos de tiempo o valor que se utilizan para indexar los datos del sensor. No se supone sobre el tamaño de un intervalo o la cantidad de superposición entre los intervalos. Los usuarios plantean consultas de rango en los intervalos a la red de proxies y sensores;Cada consulta Q necesita determinar todos los valores de índice que se superponen al intervalo [LowQ, Highq]. El objetivo del gráfico de omisión del intervalo es indexar todos los intervalos de manera que el conjunto que superponga un intervalo de consulta puede ubicarse de manera eficiente. En el resto de esta sección, describimos el gráfico de omitir el intervalo con mayor detalle.3.1 Skip Graph Descripción general Para informar la descripción del gráfico de omitir el intervalo, primero proporcionamos una breve descripción de la estructura de datos de gráficos de omisión;Para una descripción más extensa, se hace referencia al lector [1]. La Figura 2 muestra un gráfico de omisión que indexa 8 teclas;Las teclas se pueden ver a lo largo de la parte inferior, y por encima de cada tecla están los punteros asociados con esa tecla. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 Nivel 0 Nivel 1 Nivel 2 Elemento de gráfico de omisión simple (cada uno puede estar en un nodo diferente)encontrar (21) mensajes de nodo a nodo Figura 2: omita gráfico de 8 elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21, 30] [2,5] 5 14 14 16 23 23 27 30 [bajo, alto] Máx contiene (13) Match sin coincidencia Figura 3: Gráfico de omitir intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 Nivel 2 Nivel 1 Nivel 0 Figura 4: El gráfico de omitir el intervalo distribuido y los punteros identifican ambosun nodo remoto, así como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un gráfico de omisión: • Índice ordenado: las claves son miembros de un tipo de datos ordenados, por ejemplo, enteros. Las búsquedas hacen uso de comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice.• Indexación en el lugar: los elementos de datos permanecen en los nodos donde se insertaron, y los mensajes se envían entre nodos para establecer enlaces entre esos elementos y otros en el índice.• Altura log n: hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0 ... log2 n - 1], y junto con algunos otros punteros en ese nivel forma una cadena de elementos N/2L.• Balance probabilístico: en lugar de confiar en las operaciones de re-equilibrio que pueden activarse al insertar o eliminar, omitir gráficos implementan un mecanismo de equilibrio aleatorio simple que mantiene cerca de un equilibrio perfecto en promedio, con una probabilidad extremadamente baja de desequilibrio significativo.• Redundancia y resistencia: cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo en la red, eliminando los puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a la falla del nodo;No se pueden acceder a los datos en el nodo fallido, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un gráfico de omisión. Los punteros alcanzables de un solo elemento de datos forman un árbol binario: un puntero que atraviesa el nivel más alto se salta sobre los elementos N/2, N/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender el árbol del nivel más alto al nivel 0, en cada nivel, comparando la clave de destino con el siguiente elemento en ese nivel y decidir si atraviesa o no. En el caso perfectamente equilibrado que se muestra aquí hay niveles log2 N de punteros, y la búsqueda atravesará 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente y medimos el costo de búsqueda por los mensajes numéricos enviados (es decir, el número de punteros atravesados);Esto será claramente o (log n). La actualización de los árboles avanza desde el fondo, como en un árbol B, con la (s) raíz (s) promovida en el nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca hay necesidad de dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir cuál de las cadenas 2L insertar un elemento en cada nivel L e insertarlo en el lugar adecuado en cada cadena. Mantener un gráfico de omisión perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo;En cambio, se utiliza el método de equilibrio probabilístico introducido en las listas de Skip [23], que cierra una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenece a una cadena particular en el nivel L solo puede pertenecer a una de las dos cadenas en el nivel L+1. Para insertar un elemento, ascendemos los niveles a partir de 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, una parada cuando llegamos a una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria arbitrariamente larga. Cada cadena en el nivel L se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros bits de L, creando así 2l posibles cadenas en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, después del análisis en [23] podemos demostrar que la probabilidad de que esté significativamente fuera de equilibrio es extremadamente pequeña;Además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre.3.2 Gráfico de Skip Interval Un gráfico de omisión está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los gráficos de omisión para almacenar intervalos [Lowi, Highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor V, es decir, {I: Lowi ≤ V ≤ Highi}. Nuestra estructura de datos se puede extender a las búsquedas de rango de manera directa. El gráfico de salto de intervalo se construye aplicando el método de los árboles de búsqueda aumentados, según lo descrito por Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un árbol de intervalo. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede usarse para buscar en una tecla secundaria que no es de toma en la primera clave. Dado un conjunto de intervalos ordenados por un límite inferior - Lowi ≤ Lowi+1 - Definimos la clave secundaria como el máximo acumulativo, maxi = maxk = 0 ... i (highk). El conjunto de intervalos que se cruzan en un valor V se puede encontrar luego buscando el primer intervalo (y, por lo tanto, el intervalo con menos bajo) de tal manera que Maxi ≥ VCon Lowi> V, seleccionando aquellos intervalos que se cruzan v. Usando este enfoque aumentamos la estructura de datos de gráficos de omisión, como se muestra en la Figura 3, de modo que cada entrada almacena un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativodel límite superior). Para calcular eficientemente la clave secundaria MAXI para una entrada I, tomamos el más grande de Highi y los valores máximos reportados por cada uno de los vecinos de la izquierda. Para buscar aquellos intervalos que contienen el valor V, primero buscamos V en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (Mediante la definición de maxi, para este elemento de datos maxi = highi). Si lowi> V, entonces este intervalo no contiene V, y ningún otro intervalos tampoco lo hará. De lo contrario, atravesamos el índice en el orden creciente de Mini, devolviendo intervalos de coincidencia, hasta que llegamos a una entrada con Mini> V y terminamos. Las búsquedas de todos los intervalos que se superponen a un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: Busque el primer intervalo que coincida con un valor dado se realiza de manera muy similar a un árbol de intervalo. La complejidad de la búsqueda es o (log n). El número de intervalos que coinciden con una consulta de rango puede variar según la cantidad de superposición en los intervalos que se indexan, así como el rango especificado en la consulta. Insertar complejidad: en un árbol de intervalo o lista de omisión de intervalo, el valor máximo para una entrada solo necesita calcularse sobre el subárbol enraizado en esa entrada, ya que este valor se examinará solo cuando se busque dentro del subárbol enraizado en esa entrada. Sin embargo, para un gráfico de omisión de intervalo simple, este valor máximo para una entrada debe calcularse en todas las entradas que lo preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Se puede ver fácilmente que, en el peor de los casos, la inserción de un solo intervalo (uno que cubre todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, para el costo de inserción del peor de los casos de o (n).3.3 Intervalo de escasos gráfico de omisión Las extensiones finales que proponemos aprovechar la diferencia entre el número de elementos indexados en un gráfico de omisión y el número de sistemas en los que se distribuyen estos elementos. El costo en los mensajes de red de una operación puede reducirse organizando la estructura de datos para que la mayoría de los recorridos de la estructura ocurran localmente en un solo nodo y, por lo tanto, incurran en el costo de la red cero. Además, dado que tanto la congestión como la falla ocurren por nodo, podemos eliminar los enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución y/o la resistencia de la carga dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica de la actualización y la búsqueda. Como puede ser en la Sección 3.2, inserte y elimine el costo en un gráfico de omisión de intervalo tiene la peor complejidad de O (N), en comparación con O (log N) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de omisión tienen una estructura de búsqueda completa enraizada en cada elemento, para distribuir la carga y proporcionar resiliencia a las fallas del sistema en una configuración distribuida. Sin embargo, para proporcionar distribución de carga y resiliencia de falla, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si como en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto dará como resultado ahorros significativos. Implementación: para construir un gráfico de omisión de intervalo disperso, nos aseguramos de que haya un solo elemento distinguido en cada sistema, el elemento raíz para ese sistema;Todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas a niveles crecientes L hasta que el elemento esté en una lista sin otro, nos detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesiblede todos los elementos raíz. Se puede ver un ejemplo de aplicar esta optimización en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos en el inicio). Al usar la técnica de los vectores de membresía como en [1], esto se puede hacer transmitiendo los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel L cuando no comparte un prefijo L-bitcon cualquiera de los elementos de raíz NP. El número esperado de raíces que comparten un prefijo log2np-bit es 1, dando una altura esperada esperada para cada elemento de log2np +o (1). Se omite una implementación alternativa, que distribuye información sobre elementos raíz en el tiempo de establecimiento de puntero, se omite debido a limitaciones de espacio;Este método elimina la necesidad de mensajes adicionales. Rendimiento: en un gráfico de omisión disperso (no intervalado), ya que la altura esperada de un elemento insertado ahora es log2 np + o (1), la complejidad de inserción esperada es o (log np), en lugar de o (log n), dondeNP es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red.(En el caso degenerado de un solo sistema tenemos una lista de omisión; con probabilidad de división 0.5, la altura esperada de un elemento individual es 1.) Tenga en cuenta que dado que las búsquedas se inician en los elementos raíz de la altura esperada log2 n, la complejidad de búsqueda no se mejora. Para un gráfico de omisión escaso de intervalo, el rendimiento de la actualización se mejora considerablemente en comparación con el peor caso de O (n) para el caso de no pareja. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para nodos que se puede alcanzar desde ese elemento-e.g.el subárbol enraizado en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalo, la actualización solo se propaga hacia la raíz. En un gráfico de omita el intervalo escaso, las actualizaciones a un nodo solo se propagan hacia los elementos raíz NP, para un costo peor de NP log2 n.Búsqueda de atajos: al comenzar una búsqueda de un valor V, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a V (por ejemplo, usando un índice local secundario), y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 np, y la búsqueda ahora tomará en promedio los pasos log2 np + o (1). Para ilustrar esta optimización, en la Figura 4 dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] a partir del nodo 2 puede tomar 3 lúpulos de red, atravesando al nodo 1, luego volver al nodo 2 y finalmente al nodo 3donde se encuentra el destino, para un costo de 3 mensajes. Sin embargo, la búsqueda de acceso directo localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 para un costo de 1 mensaje. Rendimiento: esta técnica se puede aplicar a la búsqueda de clave principal, que es el primero de los dos pasos de inserción en un gráfico de omisión de intervalo. Al combinar la optimización atrevida con gráficos de omisión de intervalo escaso, el costo esperado de inserción ahora es O (log np), independiente del tamaño del índice o el grado de superposición de los intervalos insertados.3.4 Estructuras de datos alternativas Hasta ahora solo hemos comparado el gráfico de omisión del intervalo escaso con estructuras similares de las cuales se deriva. En la Tabla 2. 44 Tabla 2: Comparación de estructuras de índice distribuidos de consulta de consulta de consulta de consulta de consulta de consulta de consulta de soporte de intervalo para el intervalo de compensación de intervalo de compensación de intervalo de compensación de intervalo de resaliencia de Representación de Balancing de una comparación con varias otras estructuras de datos que cumplen con al menos algunos de los requisitos para el índice TSAR para el índice TSAR.no no no sí, buen buen índice local, consulta de inundación sí sí no sí bien prae p mal, rp* (árboles b distribuidos) Sí posible sí no buenas dimensas sí sí sí sí sí sí interval[6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Roots Nodo 1 Nodo 2 Figura 5: Intervalo dispersoSkip Graph Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad de realizar consultas de rango y, por lo tanto, no se adaptan bien a la indexación de datos espacio-temporales. La indexación localmente utilizando una estructura de singlenode apropiada y luego inundaciones de consultas a todos los proxies es una alternativa competitiva para pequeñas redes;Para las redes grandes, la dependencia lineal del número de proxies se convierte en un problema. Se examinaron dos árboles B distribuidos: árboles P [6] y RP* [19]. Cada uno de estos respalda consultas de rango, y en teoría podría modificarse para apoyar la indexación de intervalos;Sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resiliencia de las otras estructuras. Dims [18] proporciona la capacidad de realizar consultas de rango espacio-temporal y tiene la resistencia necesaria para las fallas;Sin embargo, no se puede utilizar intervalos de índice, que son utilizados por el algoritmo de resumen de datos de TSARS.4. Almacenamiento y resumen de datos Al haber descrito la estructura del índice de nivel proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivo local en cada nodo del sensor que está optimizado para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativa que permite a cada sensor adaptarse a los datos cambiantes y las características de consulta. El resto de esta sección describe estos mecanismos en detalle.4.1 Almacenamiento local en los gráficos de omisión del intervalo de sensores proporcionan un mecanismo eficiente para buscar nodos de sensores que contengan datos relevantes para una consulta. Estas consultas se enrutan a los sensores, que ubican los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar tales búsquedas, cada nodo del sensor en TSAR mantiene una tienda de archivo de datos del sensor. Si bien la implementación de tal tienda de archivo es directa en dispositivos ricos en recursos que pueden ejecutar una base de datos, los sensores a menudo son potencia y con recursos limitados. En consecuencia, el subsistema de archivo de sensores en TSAR está explícitamente diseñado para explotar las características de los datos del sensor en un entorno limitado por los recursos. Parámetros de calibración de la marca de tiempo Atributos Opaces Datadatos/Event Attributes Tamaño Figura 6: Los datos del sensor de registro de almacenamiento único tienen características muy distintas que informan nuestro diseño de la tienda del archivo TSAR. Los sensores producen flujos de datos de series de tiempo y, por lo tanto, el orden temporal de los datos es una forma natural y simple de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente a menudo es adecuada para muchas tareas de procesamiento de datos del sensor, ya que involucran el procesamiento de datos de la serie temporal. Los ejemplos incluyen operaciones de procesamiento de señales como FFT, transformaciones wavelet, agrupación, coincidencia de similitud y detección de objetivos. En consecuencia, la tienda local de archivos es una colección de registros, diseñada como un búfer circular solo de apropiación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, configuración del sensor, parámetros de calibración, etc. Los datos del sensor sin procesar se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no conoce ni se preocupa por interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para admitir una variedad de aplicaciones, TSAR admite campos de datos de longitud variable;Como resultado, los tamaños de registro pueden variar de un registro a otro. Nuestra tienda de archivo admite tres operaciones en registros: Crear, leer y eliminar. Debido a la naturaleza de solo appería de la tienda, la creación de registros es simple y eficiente. La operación Crear simplemente crea un nuevo registro y lo agrega a la cola de la tienda. Dado que los registros siempre se escriben en la cola, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación;Por lo tanto, el tamaño del registro se conoce a priori y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea.proxy proxy proxy registro 3 resumen de registro Archivo local en el inicio de resumen de datos de memoria flash, finalización de intervalo de intervalo de compensación final resumen enviado a proxy insertar resúmenes en intervalos gráfico de omisión Figura 7: Resumen del sensor 45 La operación de lectura permite recuperar registros almacenados para responder para responderconsultas. En un sistema de base de datos tradicional, las búsquedas eficientes se habilitan manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo de sensor pequeño con recursos limitados. En consecuencia, los sensores de TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, confían en los proxies para mantener este índice de metadatos que los sensores de índice envían periódicamente la información del proxy que resume los datos contenidos en una secuencia contigua de registros, así como un mango que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contiene el intervalo de tiempo correspondiente al resumen, así como al inicio y al final de la ubicación de la memoria flash donde se corresponde a los datos sin procesar.almacenado (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en granularidad de un resumen: el desplazamiento de inicio de cada parte de los registros representados por un resumen es conocido por el proxy. Dentro de esta colección, se accede a los registros secuencialmente. Cuando una consulta coincide con un resumen en el índice, el sensor usa estas compensaciones para acceder a los registros relevantes en su flash local leyendo secuencialmente datos desde la dirección de inicio hasta la dirección final. Cualquier operación de QuerySpecific se puede realizar en estos datos. Por lo tanto, no es necesario mantener ningún índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y se mantiene en el poder. Si bien anticipamos que la capacidad de almacenamiento local para ser grande, eventualmente puede haber una necesidad de sobrescribir datos más antiguos, especialmente en aplicaciones de alta velocidad de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de resolución múltiple [9], o simplemente simplemente sobrescribiendo datos más antiguos. Cuando se sobrescriben los datos más antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del gráfico de omisión del intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor.4.2 Resumen adaptativo Los resúmenes de datos sirven como pegamento entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen y las compensaciones de inicio y finalización para el archivo Flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valor informado en el resumen (o ambos). El primer índice habilita las búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el último índice habilita las búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe una compensación entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los golpes falsos durante las consultas. La información resumida más gruesa y menos frecuente, cuanto menos energía requerida, mientras que la consulta falsa llega a su vez la energía de desperdicio en las solicitudes de datos inexistentes. TSAR emplea una técnica de resumen adaptativa que equilibra el costo de enviar actualizaciones contra el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de golpes falsos y éxitos verdaderos para consultas que acceden a su archivo local. Si la mayoría de las consultas dan como resultado éxitos verdaderos, entonces el sensor determina que el resumen puede engranarse aún más para reducir los costos de actualización sin afectar negativamente la relación HIT. Si muchas consultas dan como resultado golpes falsos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la sobrecarga de golpes falsos. La resolución del resumen depende de dos parámetros el intervalo sobre el cual se construyen y transmiten resúmenes de los datos al proxy, así como al tamaño del resumen específico de aplicaciones. Nuestro enfoque en este documento está en el intervalo sobre el cual se construye el resumen. Cambiar el tamaño del resumen de datos se puede realizar de manera específica de aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está más allá del alcance de este documento. Actualmente, el zar emplea un esquema de resumen simple que calcula la relación de golpes y disminución (aumenta) falsas y verdaderas el intervalo entre resúmenes cada vez que esta relación aumenta (disminuye) más allá de un umbral.5. Implementación de TSAR Hemos implementado un prototipo de TSAR en un Bed de prueba de red de sensores de varios niveles. Nuestro prototipo emplea nodos de Stargate de ballesta para implementar el nivel proxy. Cada nodo Stargate emplea un procesador Intel XScale de 400MHz con 64 MB de RAM y ejecuta el Linux 2.4.19 Kernel y Emstar Release 2.1. Los nodos proxy están equipados con dos radios inalámbricos, una radio 802.11b con sede en Cisco Aironet 340 y un puente de hostmote a los nodos del sensor Mica2 utilizando el transceptor Emstar. La red inalámbrica 802.11b se utiliza para la comunicación interproxi dentro del nivel proxy, mientras que el puente inalámbrico permite la comunicación del sensor-proxima. El nivel del sensor consta de mica2 de ballesta y mica2-dots, cada uno que consiste en una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash a bordo de 4 MB y un procesador ATMEGA 128L. Los nodos sensores ejecutan Tinyos 1.1.8. Además del flash integrado, los nodos del sensor se pueden equipar con tarjetas Flash MMC/SD externas utilizando un conector personalizado. Los nodos proxy se pueden equipar con almacenamiento externo, como flash compacto de alta capacidad (hasta 4GB), micro-conductas de 6 GB o unidades de disco móvil de 1,8 pulgadas de hasta 60 GB. Dado que los nodos sensores pueden estar a varios saltos del proxy más cercano, el nivel de sensor emplea un enrutamiento de saltos múltiples para comunicarse con el nivel proxy. Además, para reducir el consumo de energía de la radio mientras aún hace que el nodo del sensor esté disponible para consultas, se habilita la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente para un intervalo corto para detectar el canal para las transmisiones y el paquete y el paqueteEl preámbulo se extiende para tener en cuenta la latencia hasta el siguiente intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento de multioplepsm con la capa BMAC configurada en el modo de baja potencia con un ciclo de trabajo del 11% (uno de los parámetros BMAC predeterminados [22]) nuestra implementación de TSAR en la mota implica una tarea de recopilación de datos que obtiene periódicamente el sensor de sensor de sensor.Lecturas y registra estas lecturas en la memoria flash. Se supone que la memoria flash es un almacén circular solo de apéndice y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada n lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección de la mota, (ii) un mango que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene datos mencionados por el resumen, (iii) un intervalo (T1, T2) sobreque se genera este informe, (iv) una tupla (baja, alta) que representa los valores mínimos y máximos observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un gráfico de omisión de intervalo disperso que se distribuye a través de proxies, a través de mensajes de red entre proxies a través de la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (T1, T2) o un rango de valor (V1, V2). Las restricciones espaciales se especifican utilizando ID del sensor. Dada una lista de intervalos coincidentes del gráfico Skip, TSAR admite dos tipos de mensajes para consultar el sensor: buscar y obtener. Un mensaje de búsqueda desencadena una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera los datos). Por el contrario, un mensaje de búsqueda no solo 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 Tamaño del índice del índice (entradas) Insertar (Skipgraph) Insertar (Skipgraph) Búsqueda inicial (a) James Reserve Datos 0 20 30 40 40 40 40 40 40 40 4050 60 70 80 512 1024 2048 4096 Número de messages Tamaño del índice (entradas) Insertar (SkipGraph) Insertar (SkipGraph Sparse) Búsqueda inicial (B) Datos sintéticos Figura 8: Skip Graph Insertar el rendimiento desencadena una búsqueda pero también devuelve todos los registros de datos coincidentes al proxy del proxy al proxy del proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros.6. Evaluación experimental En esta sección, evaluamos la eficacia del TSAR utilizando nuestro prototipo y simulaciones. El Testbed para nuestros experimentos consta de cuatro proxies de Stargate y doce sensores de mica2 y mica2dot;Se asignan tres sensores a cada proxy. Dado el tamaño limitado de nuestro Bed de prueba, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación emplea el emulador EMTOS [10], que nos permite ejecutar el mismo código en simulación y la plataforma de hardware. En lugar de usar datos en vivo de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, un rastro) que dicta los valores informados por ese nodo al proxy. Una sección de la memoria flash en cada nodo del sensor está programada con puntos de datos de la traza;Estas observaciones se reproducen durante un experimento, registran el archivo local (ubicado también en la memoria flash), y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de James Reserve [27] que incluye datos de once nodos del sensor de temperatura durante un período de 34 días. El segundo conjunto de datos se genera sintéticamente;La traza para cada sensor se genera utilizando una caminata aleatoria distribuida uniformemente a través del espacio de valor. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones EMTOS para evaluar la búsqueda, actualizar y eliminar la sobrecarga para los gráficos de omisión de intervalo escaso utilizando los conjuntos de datos reales y sintéticos. En segundo lugar, proporcionamos resultados resumidos de micro-benchos del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos de energía y la latencia de las lecturas y escrituras para el chip de memoria flash, así como la plataforma de mote entera, y las comparaciones con los números publicados para los números publicados para los números publicados paraOtras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base para nuestra evaluación a gran escala de TSAR en un lecho de prueba de cuatro proxies de Stargate y doce motas. Medimos la latencia de consulta de extremo a extremo en nuestro Bed de prueba de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel Mote. Finalmente, demostramos la capacidad de resumen adaptativa en cada nodo del sensor. El resto de esta sección presenta nuestros resultados experimentales.6.1 Intervalo de escasez de gráfico de omisión Esta sección evalúa el rendimiento de los gráficos de omisión del intervalo disperso cuantificando insertar, buscar y eliminar los gastos generales. Asumimos un nivel proxy con 32 proxies y construimos gráficos de omisión de intervalo disperso de varios tamaños utilizando nuestros conjuntos de datos. Para cada omisión 0 5 10 15 20 25 30 35 409620481024512 Número de messages Tamaño del índice (entradas) Traversal inicial (a) Datos de reserva de James 0 2 4 6 8 10 12 409620481024512 Número de messages Tamaño del índice (Entradas) Mireza inicial Traversal (B) Datos sintéticos de datos sintéticosFigura 9: Skip Graph Búsqueda Rendimiento 0 10 20 30 30 40 50 60 70 1 4 8 16 24 32 48 Número deMessages Número de proxies Skipgraph Insert Skipgraph Skipgraph Insertar Búsqueda inicial (a) Impacto del número de proxies 0 20 40 60 60 100 120 512 10242048 4096 Número de Messages Tamaño del índice (Entradas) Insertar (redundante) Insertar (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de resúmenes redundantes Figura 10: omitir los gastos generales de los gráficos, evaluamos el costo de insertar una unaNuevo valor en el índice. Cada entrada se eliminó después de su inserción, lo que nos permitió cuantificar la sobrecarga de eliminación también. La Figura 8 (a) y (b) cuantifican la sobrecarga de insertos para nuestros dos conjuntos de datos: cada inserto implica un recorrido inicial que incurre en mensajes log N, seguido de la actualización del puntero de vecinos a niveles crecientes, incurriendo en un costo de 4 mensajes log n. Nuestros resultados demuestran este comportamiento y también muestran que el rendimiento de Delete, que también implica un recorrido inicial, seguido de las actualizaciones de puntero en cada nivel, un costo similar. A continuación, evaluamos el rendimiento de la búsqueda de la estructura del índice. Nuevamente, construimos omitir gráficos de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura del índice. Las Figuras 9 (a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda, la búsqueda del primer intervalo que coincide con la consulta y, en el caso de los intervalos superpuestos, la transferencia lineal posterior para identificar todos los intervalos coincidentes. Se puede ver que la búsqueda inicial toma mensajes log n, como se esperaba. Sin embargo, los costos del recorrido lineal posterior dependen de los datos. Por ejemplo, los valores de temperatura para los datos de la reserva de James exhiben correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo transversal variable (ver Figura 9 (a)). Los datos sintéticos, sin embargo, tienen menos superposición y incurre en una sobrecarga transversal más baja como se muestra en la Figura 9 (b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del gráfico de omisión. Varimos el número de proxies de 10 a 48 y distribuimos un gráfico de omisión con 4096 entradas entre estos proxies. Construimos gráficos de omitir el intervalo regular, así como los gráficos de omisión de intervalo escaso usando estas entradas y medimos la sobrecarga de inserciones y búsqueda. Por lo tanto, el experimento también busca demostrar los beneficios de los gráficos de omisión dispersos sobre los gráficos de omisión regulares. La Figura 10 (a) representa nuestros resultados. En gráficos de omisión regulares, la complejidad de inserción es o (log2n) en el caso 47 esperado (y o (n) en el peor de los casos) donde n es el número de elementos. Esta complejidad no se ve afectada al cambiar el número de proxies, como lo indica la línea plana en la figura. Los gráficos de omisión escasos requieren menos actualizaciones de puntero;Sin embargo, su sobrecarga depende del número de proxies, y es O (log2np) en el caso esperado, independiente de n.Esto se puede ver que resulta en una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo que disminuye a medida que aumenta el número de proxies. El manejo de fallas es un problema importante en una arquitectura de sensores de varios niveles, ya que se basa en muchos componentes, los nodos de sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden desvanecerse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento;Sin embargo, consideramos el caso de la resiliencia de los gráficos de omitir a las fallas de poder. En este caso, Skip Graph Search (y las operaciones de reparación posteriores) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un gráfico de omisión escaso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudar una vez que la solicitud de búsqueda se ha enrutado alrededor de la falla. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el gráfico Skip se pueden accesibles con una alta probabilidad de las entradas en el proxy fallido y los datos correspondientes en los sensores se vuelven inaccesibles. Para garantizar que todos los datos en sensores sigan siendo accesibles, incluso en el caso de falla de un proxy que contiene entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes adicionales de grano grueso para proteger resúmenes regulares. Cada sensor envía datos de resumen periódicamente a su proxy local, pero con menos frecuencia envía un resumen de baja resolución a un proxy de respaldo: el resumen de copia de seguridad representa todos los datos representados por los resúmenes de grano más fino, pero de manera más general, lo que resulta en una lectura más alta.sobrecarga (debido a golpes falsos) si se usa el resumen de copia de seguridad. El costo de implementar esto en nuestro sistema es bajo: la Figura 10 (b) muestra la sobrecarga de dicho esquema de redundancia, donde se envía un solo resumen grueso a una copia de seguridad por cada dos resúmenes enviados al proxy primario. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes dan como resultado solo un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporciona una capacidad de recuperación completa a cualquier falla de representación única.6.2 Microbiadores de almacenamiento Dado que los sensores están limitados por los recursos, el consumo de energía y la latencia en este nivel son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local de TSAR, en función de las mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento locales, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas, medimos el uso de energía para el componente de almacenamiento en sí (es decir, la corriente dibujada por el chip de flash), así como para toda la mota de Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote de Mica2, que es un dispositivo de flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en los dispositivos de detección es NAND Flash, como el dispositivo Samsung K9K4G08U0M [16];Los números de potencia publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio CCCON [4] CC2420 (utilizada en Micaz y Telos Motes) se proporcionan para comparación, suponiendo que la energía de energía / byte Mote Flash lea 256 byte Page 58µJ* / 136µJ* Total 0.23µJ* Escribir 256 Byte 256 Byte 256 Byte 256 BytePágina 926 µJ* / 1042µJ* Total 3.6µj* Nand Flash Leer 512 BYTE Página 2.7µJ 1.8nj Escriba 512 Byte Page 7.8µJ 15nj Eroase 16k Byte Sector 60µJ 3.7NJ CC2420 Transmisión de radio 8 bits (-25dbm) 0.8µj 0.8 µJ Recibe 8 bits 8 bits 8 bits1.9 µJ 1.9 µJ MOTE AVR Procesador Búsqueda en memoria, 256 bytes 1.8 µJ 6.9NJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 LATENCIA (MS) Número de lúpulo (a)Rendimiento de consultas de múltiples saltos 0 100 200 300 400 500 1 5121024 2048 4096 LATENCIA (MS) Tamaño del índice (entradas) Comunicación del sensor Proxy Communication Sensor Búsqueda, Procesamiento (B) Rendimiento de la consulta Figura 11: Red de latencia cero de la consulta Network y Protocolo Overocolos. Comparando el costo total de energía para escribir flash (borrar + escribir) con el costo total de la comunicación (transmisión + recibir), encontramos que el flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso suponiendo protocolos de red perfectos.6.3 Evaluación del prototipo Esta sección informa que resulta de una evaluación de extremo a extremo del prototipo TSAR que involucra ambos niveles. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos se preconfiguó de tal manera que los nodos sensores se conectaron en una línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 RECUPERALACIÓN (MS) Datos archivados recuperados (bytes)(a) Consulta de datos y tiempo de obtención 0 2 4 6 8 10 12 4 8 16 32 LATENCIA (MS) Número de registros de 34 bytes buscados (b) Retraso de procesamiento de consultas del sensor Figura 12: Componentes de latencia de consulta 48 3. Debido a las limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología aseguró que el diámetro de la red fuera tan grande como para una red típica de tamaño significativamente mayor. Nuestra métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en zar primero incurre en la latencia de una búsqueda de gráfico de omisión escasa, seguido de enrutamiento a los nodos del sensor apropiados. El nodo del sensor lee las páginas requeridas de su archivo local, procesa la consulta en la página que se lee y transmite la respuesta al proxy, que luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál se consulte de los sensores, la latencia total aumenta casi linealmente de aproximadamente 400 ms a 1 segundo, a medida que aumenta el número de lúpulo de 1 a 3 (ver Figura 11 (a)). La Figura 11 (b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación sobre uno o más lúpulos. El tiempo típico para comunicarse en un salto es de aproximadamente 300 ms. Esta gran latencia se debe principalmente al uso de una capa MAC ciclada por deber;La latencia será mayor si el ciclo de trabajo se reduce (por ejemplo, la configuración del 2% en comparación con la configuración del 11.5% utilizada en este experimento), y por el contrario disminuirá si el ciclo de trabajo aumenta. La figura también muestra la latencia para diferentes tamaños de índice;Como se esperaba, la latencia de la comunicación interproxi y omitir las búsquedas de gráficos aumenta logarítmicamente con el tamaño del índice. No es sorprendente que la sobrecarga vista en el sensor sea independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta, cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12 (a). La función de paso se debe a la paquete en Tinyos;Tinyos envía un paquete siempre que la carga útil sea menor que 30 bytes y divide la respuesta en múltiples paquetes para cargas útiles más grandes. A medida que aumentan los datos recuperados por una consulta, la latencia aumenta en los pasos, donde cada paso denota la sobrecarga de un paquete adicional. Finalmente, la Figura 12 (b) muestra el impacto de la búsqueda y el procesamiento de las regiones de memoria flash de los tamaños crecientes en un sensor. Cada resumen representa una colección de registros en la memoria flash, y todos estos registros deben recuperarse y procesarse si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande es la región de memoria a la que debe acceder. Para los tamaños de búsqueda examinados, la amortización de la sobrecarga al buscar múltiples páginas de flash y registros de archivo, así como dentro del chip flash y su controlador asociado, da como resultado la aparición del aumento sublineal en la latencia con el tamaño de búsqueda. Además, se puede ver que la operación tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que requiere solo una operación de comparación con cada elemento almacenado. Las operaciones más complejas, sin embargo, incurrirán, por supuesto, una mayor latencia.6.4 Resumen adaptativo Cuando el sensor resume los datos antes de ser informado al proxy, se pierde la información. Con el método de resumen de intervalo que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo del sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo informado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que no lo hace, y reenviar mensajes de consulta al sensor para estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben equilibrarse con los ahorros logrados al reducir el número de informes. El objetivo del resumen adaptativo es variar dinámicamente el tamaño de suma para que estos dos costos estén equilibrados.0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 FractionOfTruehits Tamaño de resumen (número de registros) (a) Impacto del tamaño de resumen 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Resumen (num.Records) normalizadotiempo (unidades) tasa de consulta 0.2 tasa de consulta 0.03 tasa de consulta 0.1 (b) Adaptación a la tasa de consulta Figura 13: Impacto de la granularidad de resumen La Figura 13 (a) demuestra el impacto de la granularidad resumida en los golpes falsos. A medida que aumenta el número de registros incluidos en un resumen, la fracción de consultas reenviadas al sensor que coincide con los datos de ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13 (b) ejecutamos la simulación AMTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad resumida (definida como el número de registros por resumen) cuando el costo (actualizaciones) costo (falshits)> 1 + y la reduce si el costo (actualizaciones) costo (falshits)> 1 -, donde es una pequeña constante constante. Para demostrar la naturaleza adaptativa de nuestra técnica, trazamos una serie temporal de la granularidad de resumen. Comenzamos con una tasa de consulta de 1 consulta por 5 muestras, la disminuimos a 1 cada 30 muestras y luego la aumentamos nuevamente a 1 consulta cada 10 muestras. Como se muestra en la Figura 13 (b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la tasa de aciertos falsos más altos) y menos resúmenes de grano grueso a tasas de consulta más bajas.7. Trabajo relacionado En esta sección, revisamos el trabajo previo sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas conjuntamente, mucho trabajo previo los ha considerado de forma aislada. El problema del almacenamiento de archivo de datos del sensor ha recibido atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos Logestructurado para el almacenamiento local en la memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que está empaquetado con la distribución TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque está tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos estos archivos locales. El almacenamiento de resolución múltiple [9] está destinado al almacenamiento y búsqueda en la red en sistemas donde hay datos significativos en comparación con los recursos de almacenamiento. En contraste, TSAR aborda el problema del almacenamiento de archivo en sistemas de dos niveles donde se pueden colocar suficientes recursos en los sensores de borde. La plataforma Rise [21] se desarrolla como parte del proyecto de nodo en UCR aborda los problemas del soporte de la plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no la indexación y consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuidos, se debe construir un índice de los datos. El trabajo temprano en las redes de sensores, como la difusión dirigida [17], supone que un sistema donde todos los datos de sensor útiles se almacenan localmente en cada sensor, y las consultas de alcance espacial se enrutan utilizando coordenadas geográficas en ubicaciones donde se almacenan los datos. Las fuentes publican los eventos que detectan, y se hunden con interés en eventos específicos pueden suscribirse a estos eventos. Las consultas de las rutas de sustrato de difusión dirigida a ubicaciones específicas 49 Si la consulta tiene información geográfica integrada en ella (por ejemplo, encontrar temperatura en el cuadrante suroeste), y si no, la consulta se inunda en toda la red. Estos esquemas tenían el inconveniente de que para consultas que no están geográficamente alcanzan el costo de búsqueda (O (N) para una red de N nodos) pueden ser prohibitivos en grandes redes con consultas frecuentes. El almacenamiento local con enfoques de indexación en la red abordan este problema mediante la construcción de índices utilizando marcos como tablas de hash geográficas [24] y árboles cuádruples [9]. Investigaciones recientes han visto un creciente cuerpo de trabajo en esquemas de indexación de datos para redes de sensores [26] [11] [18]. Uno de esos esquemas es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El índice distribuido de características en sensorNets (DIFS [11]) y consultas de rango multidimensional en redes de sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías de índices distribuidas espacialmente a datos. Si bien estos enfoques abogan por la indexación en la red para las redes de sensores, creemos que la indexación es una tarea demasiado complicada para realizar en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, las operaciones complejas, como la indexación y la gestión de metadatos, se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo simple. Además de las técnicas de almacenamiento e indexación específicas de las redes de sensores, muchas estructuras de índice distribuidas, pares y espacio-temporales son relevantes para nuestro trabajo. Los DHT [25] se pueden usar para indexar eventos en función de su tipo, las variantes de cuádruple como RTrees [12] se pueden usar para optimizar las búsquedas espaciales, y los árboles K-D [2] se pueden usar para la búsqueda de atributos múltiples. Si bien este documento se enfoca en construir una estructura de índice ordenada para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre los datos del sensor.8. Conclusiones En este documento, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no explotan completamente la naturaleza de varios niveles de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de datos de metadatos al emplear almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel proxy, TSAR emplea una nueva estructura de índice distribuido ordenada por múltiples resolución, el gráfico de omisión del intervalo escaso, para soportar eficientemente las consultas espacio-temporales y de rango. En el nivel del sensor, TSAR admite un resumen adaptativo consciente de la energía que puede intercambiar el costo de energía de transmitir metadatos a los representantes contra la sobrecarga de golpes falsos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en una prueba de prueba de sensor de dos niveles que comprende proxies basados en StarGate y sensores basados en la mota. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia de bajo consumo de energía en redes de sensores de múltiples niveles.9. Referencias [1] James Aspnes y Gauri Shah. Omita gráficos. En el decimoterce simposio anual de ACM-SIAM sobre algoritmos discretos, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binarios multidimensionales utilizados para la búsqueda asociativa. Comun. ACM, 18 (9): 509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles., Enero de 2001. [4] Chipcon. CC2420 2.4 GHz IEEE 802.15.4 / Transceptor RF listo para Zigbee, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. The MIT Press y McGraw-Hill, segunda edición de edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultar redes entre pares con árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivo flash estructurado de registro eficiente para nodos de micro sensor. En Sensys 04: Actas de la 2da Conferencia Internacional sobre Sistemas de Sensores Networked Incrustados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press.[8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. Presto: una arquitectura de almacenamiento predictiva para redes de sensores. En el décimo taller sobre temas calientes en sistemas operativos (Hotos X)., Junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de resolución múltiple en redes de sensores. En Actas de la primera conferencia de ACM sobre sistemas de sensores en red integrados (Sensys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para simulación, emulación y implementación de redes de sensores heterogéneos. En Actas de la Segunda Conferencia de ACM sobre Sistemas de Sensores Networked Incrustados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: un índice distribuido para características en redes de sensores. Elsevier Journal of Ad-Hoc Networks, 2003. [12] Antonin Guttman. R-TRES: una estructura de índice dinámico para la búsqueda espacial. En Sigmod 84: Actas de la Conferencia Internacional ACM Sigmod de 1984 sobre gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press.[13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: una red superpuesta escalable con propiedades prácticas de localidad. En Actas del 4to Simposio de Usenix sobre tecnologías y sistemas de Internet (USIT 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Instrucciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Apoyo Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), Páginas 93-104, Cambridge, MA, EE. UU., Noviembre de 2000. Acm[15] Atmel Inc. 4 megabit 2.5 voltios o 2.7 voltios Dataflash AT45DB041b, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M X 8 BIT / 1G X 8 BIT NAND FLASH MEMORY, 2003. [17]Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press.[18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensional en redes de sensores. En Actas de la primera conferencia de ACM sobre sistemas de sensores en red integrados (Sensys)., 2003. Aparecer.[19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de orden que preserva estructuras de datos distribuidos escalables. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de datos muy grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. Etiqueta: un pequeño servicio de agregación para redes de sensores ad-hoc. En Osdi, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de bajo rendimiento y baja potencia con almacenamiento de escala de gigabyte. En Senmetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis de rendimiento de redes de sensores inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso versátil de medios de baja potencia para redes de sensores inalámbricos. En Actas de la segunda conferencia de ACM sobre sistemas de sensores en red integrados (Sensys), noviembre de 2004. [23] William Pugh. Listas de omisión: una alternativa probabilística a los árboles equilibrados. Comun. ACM, 33 (6): 668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker y F. Yu. Almacenamiento centrado en los datos en Sensornets. En ACM First Workshop sobre temas calientes en redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red de contenido de contenido escalable. En Actas de la Conferencia ACM Sigcomm 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: una tabla de hash geográfica para el almacenamiento centrado en los datos. En First ACM International Workshop sobre redes de sensores inalámbricos y sus aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin.http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la reserva de James.50