Adaptación de mensajería asíncrona de middleware al Departamento Ad-Hoc Networking Mirco Musolesi Dept. de informática, University College London Gower Street, Londres WC1E 6BT, Reino Unido M.Musolesi@cs.ucl.ac.uk Cecilia Mascolo Departamento de Informática, University College London Gower Street, Londres WC1E 6BT, Reino Unido C.Mascolo@cs.ucl.ac.uk Stephen Hailes Departamento de Informática, University College London Gower Street, Londres WC1E 6BT, Reino Unido s.hailes@cs.ucl.ac.uk Resumen Las características de los entornos móviles, con la posibilidad deLas desconexiones frecuentes y el ancho de banda fluctuante han forzado un replanteamiento del middleware tradicional. En particular, los paradigmas de comunicación sincrónica a menudo empleados en el middleware estándar no parecen ser particularmente adecuados para entornos ad-hoc, en los que ni siquiera se puede suponer la disponibilidad intermitente de una red troncal. En cambio, la comunicación asincrónica parece ser un paradigma generalmente más adecuado para tales entornos. El middleware orientado a mensajes para sistemas tradicionales se ha desarrollado y utilizado para proporcionar un paradigma asincrónico de comunicación para sistemas distribuidos y, recientemente, también para algunos sistemas informáticos móviles específicos. En este documento, presentamos nuestra experiencia en el diseño, implementación y evaluación de EMMA (mensajería epidémica de middleware para redes ad-hoc), una adaptación del Servicio de Mensajes Java (JMS) para entornos ad-hoc móviles. Discutimos en detalle los desafíos de diseño y algunas posibles soluciones, que muestran un ejemplo concreto de la viabilidad y la idoneidad de la aplicación del paradigma asíncrono en este entorno y describen una hoja de ruta de investigación para los próximos años. Categorías y descriptores de sujetos c.2.4 [Redes de comunicación por computadora]: aplicaciones distribuidas de sistemas distribuidos;C.2.1 [Arquitectura y diseño de red]: Diseño de términos generales de comunicación inalámbrica, algoritmos 1. Introducción Con la creciente popularidad de los dispositivos móviles y su adopción generalizada, existe una clara necesidad de permitir el desarrollo de un amplio espectro de aplicaciones que funcionan de manera efectiva en dicho entorno. Desafortunadamente, esto está lejos de ser simple: los dispositivos móviles son cada vez más heterogéneos en términos de capacidades de procesamiento, tamaño de memoria, capacidad de batería e interfaces de red. Cada una de estas configuraciones tiene características sustancialmente diferentes que son estáticamente diferentes, por ejemplo, hay una gran diferencia en la capacidad entre una mote de Berkeley y una computadora portátil equipada con 802.11g, y que varían dinámicamente, como en situaciones de ancho de banda fluctuante y conectividad intermitente. Los entornos ad hoc móviles tienen un elemento adicional de complejidad en el sentido de que están completamente descentralizados. Para elaborar aplicaciones para entornos tan complejos, una forma apropiada de middleware es esencial si se debe lograr un desarrollo rentable. En este documento, examinamos uno de los aspectos fundamentales del middleware para entornos ad-hoc móviles: el de las primitivas de comunicación. Tradicionalmente, las primitivas de middleware para la comunicación más utilizadas suponen la presencia simultánea de ambos puntos finales en una red, ya que la estabilidad y la omnipresencia de la infraestructura de redes no es una suposición irrazonable para la mayoría de los entornos con cable. En otras palabras, la mayoría de los paradigmas de comunicación son sincrónicos: el middleware orientado a objetos, como Corba y Java RMI, son ejemplos típicos de middleware basados en la comunicación sincrónica. En los últimos años, ha habido un creciente interés en las plataformas basadas en paradigmas de comunicación asincrónica, como Publish-Susscribe Systems [6]: estos se han explotado con mucho éxito donde hay asincronidad a nivel de aplicación. De un informe de mercado de Gartner [7]: Dada la popularidad, la escalabilidad, la flexibilidad y la afinidad de Messages Orientados (MOM), la escalabilidad, la flexibilidad y la afinidad con las arquitecturas móviles e inalámbricas, para 2004, MOM emergerá como la forma dominante de middleware de comunicación para vincular aplicaciones móviles y empresariales (0.7 probabilidad) .... Además, en los sistemas ad-hoc móviles, la probabilidad de fragmentación de la red significa que la comunicación sincrónica en cualquier caso puede ser impracticable, dando situaciones en las que demora el tráfico asincrónico tolerante es la única forma de tráfico que podría ser compatible.121 Middleware 2004 Companion Middleware para entornos ad-hoc móviles, por lo tanto, deben admitir primitivas de comunicación semi-sincronales o completamente asíncronas si se trata de evitar limitaciones sustanciales para su utilidad. Además del desafío intelectual para apoyar este modelo, este trabajo también es interesante porque hay una serie de dominios prácticos de aplicaciones para permitir la comunicación entre comunidades en áreas no desarrolladas del mundo. Así, por ejemplo, los proyectos que se han llevado a cabo para ayudar a las poblaciones que viven en lugares remotos del mundo, como Laponia [3] o en áreas pobres que carecen de infraestructura de conectividad fija [9]. Ha habido intentos de proporcionar al middleware móvil estas propiedades, incluidos Steam, Lime, Xmiddle, Bayou (ver [11] para una revisión más completa del middleware móvil). Estos modelos difieren considerablemente del middleware tradicional existente en términos de primitivas proporcionadas. Además, algunos de ellos fallan en proporcionar una solución para los verdaderos escenarios ad-hoc. Si el éxito proyectado de MOM se convierte en una realidad como una realidad, habrá muchos programadores con experiencia. La solución ideal para el problema del middleware para los sistemas ad-hoc es, entonces, permitir a los programadores utilizar los mismos paradigmas y modelos presentados por formas comunes de MOM y garantizar que estos paradigmas sean compatibles con el entorno móvil. Este enfoque tiene claras ventajas al permitir que las aplicaciones desarrolladas en plataformas de middleware estándar se implementen fácilmente en dispositivos móviles. De hecho, algunas investigaciones ya han llevado a la adaptación de las plataformas de middleware tradicionales a la configuración móvil, principalmente para proporcionar integración entre los dispositivos móviles y las redes fijas existentes en un entorno nómada (es decir, mixto) [4]. Con respecto al middleware orientado a mensajes, las implementaciones actuales, sin embargo, suponen la existencia de una red troncal a la que los hosts móviles se conectan de vez en cuando mientras deambulan [10], o supone que los nodos siempre son accesibles a través de una ruta [18] Se ha intentado ninguna adaptación a escenarios heterogéneos o completamente ad-hoc, con desconexión frecuente y nubes de huéspedes aisladas periódicamente. En el resto de este documento, describimos un intento inicial de adaptar el middleware orientado a mensajes para adaptarse a las redes móviles y, más específicamente, móviles ad-hoc. En nuestro caso, elegimos examinar JMS, como uno de los sistemas de mamá más conocidos. En la última parte de este documento, exploramos las limitaciones de nuestros resultados y describimos los planes que tenemos para llevar el trabajo más allá.2. Los sistemas de middleware orientados a mensajes orientados a mensajes y Java (JMS) Sistemas de middleware orientados a mensajes admiten la comunicación entre componentes distribuidos a través de pasos de mensajes: el remitente envía un mensaje a colas identificadas, que generalmente residen en un servidor. Un receptor recupera el mensaje de la cola en un momento diferente y puede reconocer la respuesta utilizando el mismo mecanismo asíncrono. El middleware orientado a mensajes admite la comunicación asincrónica de una manera muy natural, logrando el desacoplamiento de los remitentes y receptores. Un remitente puede continuar procesando tan pronto como el middleware haya aceptado el mensaje;Finalmente, el receptor enviará un mensaje de reconocimiento y el remitente podrá recopilarlo en un momento conveniente. Sin embargo, dada la forma en que se implementan, estos sistemas de middleware generalmente requieren dispositivos ricos en recursos, especialmente en términos de memoria y espacio en disco, donde se almacenan colas persistentes de mensajes que se han recibido pero aún no procesados. Sun Java Message Service [5], IBM WebSphere MQ [6], Microsoft MSMQ [12] son ejemplos de middleware orientado a mensajes muy exitoso para sistemas distribuidos tradicionales. El servicio de mensajería Java (JMS) es una colección de interfaces para la comunicación asincrónica entre componentes distribuidos. Proporciona una forma común para que los programas Java creen, envíen y reciban mensajes. Los usuarios de JMS generalmente se conocen como clientes. La especificación de JMS define además a los proveedores como los componentes a cargo de implementar el sistema de mensajería y proporcionar la funcionalidad administrativa y de control (es decir, persistencia y confiabilidad) requerida por el sistema. Los clientes pueden enviar y recibir mensajes, asincrónicamente, a través del proveedor de JMS, que está a cargo de la entrega y, posiblemente, de la persistencia de los mensajes. Hay dos tipos de comunicación compatibles: punto a punto y publicar modelos de suscripción. En el modelo de punto a punto, los hosts envían mensajes a colas. Los receptores se pueden registrar con algunas colas específicas, y pueden recuperar asincrónicamente los mensajes y luego reconocerlos. El modelo Publish-Subscribe se basa en el uso de temas a los que los clientes pueden suscribirse. Los mensajes son enviados a temas por otros clientes y luego son recibidos en modo asincrónico por todos los clientes suscritos. Los clientes aprenden sobre los temas y colas disponibles a través de la interfaz Java Naming and Directory (JNDI) [14]. Las colas y los temas son creados por un administrador en el proveedor y están registrados con la interfaz JNDI para la búsqueda. En la siguiente sección, presentamos los desafíos de las redes móviles y mostramos cómo JMS puede adaptarse para hacer frente a estos requisitos.3. JMS para la computación móvil redes móviles varía muy ampliamente en sus características, desde redes nómadas en las que los modos se reubican mientras están fuera de línea hasta redes ad-hoc en las que los modos se mueven libremente y en los que no hay infraestructura. Las redes ad-hoc móviles son más generalmente aplicables en situaciones en las que la supervivencia y la implementabilidad instantánea son clave: sobre todo en aplicaciones militares y alivio de desastres. Entre estos dos tipos de redes móviles, existen, sin embargo, una serie de posibles combinaciones heterogéneas, donde los paradigmas nómadas y ad-hoc se utilizan para interconectar áreas totalmente no deseadas con redes más estructuradas (como una LAN o Internet). Mientras que la especificación JMS se ha implementado ampliamente y se ha utilizado en sistemas distribuidos tradicionales, las adaptaciones para entornos móviles se han propuesto recientemente. Los desafíos de portar JMS a la configuración móvil son considerables;Sin embargo, en vista de su aceptación y uso generalizado, existen ventajas considerables al permitir la adaptación de aplicaciones existentes a entornos móviles y en permitir la interoperación de aplicaciones en las regiones cableadas e inalámbricas de una red. En [10], JMS se adaptó a una configuración móvil nómada, donde los hosts móviles pueden ser clientes de JMS y comunicarse a través del proveedor de JMS que, sin embargo, se encuentra en una red troncal, proporcionando confiabilidad y persistencia. El prototipo del cliente presentado en [10] es muy ligero, debido a la delegación de toda la funcionalidad de peso pesado al middleware para el proveedor de computación 122 AD-Hoc 122 en la red con cable. Sin embargo, este enfoque es algo limitado en términos de aplicabilidad generalizada y escalabilidad como consecuencia de la concentración de funcionalidad en la parte cableada de la red. Si JMS se adapta a entornos completamente ad-hoc, donde no hay infraestructura fija disponible, y donde los nodos cambian la ubicación y el estado de manera muy dinámica, se deben tener en cuenta más problemas. En primer lugar, el descubrimiento necesita usar un modelo resistente pero distribuido: en este entorno extremadamente dinámico, las soluciones estáticas son inaceptables. Como se discutió en la Sección 2, un administrador de JMS define las colas y temas del proveedor. Luego, los clientes pueden aprender sobre ellos usando la interfaz Java Naming y Directorio (JNDI). Sin embargo, debido a la forma en que se diseña JNDI, debe estar en alcance un nodo JNDI (o más de uno) para obtener un enlace de un nombre a una dirección (es decir, saber dónde está una cola/tema específico). En entornos ad-hoc móviles, el proceso de descubrimiento no puede asumir la existencia de un conjunto fijo de servidores de descubrimiento que siempre son accesibles, ya que esto no coincidiría con la dinámica de las redes ad-hoc. En segundo lugar, un proveedor de JMS, como lo sugiere la especificación JMS, también debe ser accesible por cada nodo en la red, para comunicarse. Esto supone una arquitectura muy centralizada, que nuevamente no coincide con los requisitos de una configuración ad-hoc móvil, en la que los nodos pueden ser en movimiento y escasos: se necesita una solución más distribuida y dinámica. Sin embargo, la persistencia es la funcionalidad esencial en los entornos de comunicación asincrónica, ya que los hosts están, por definición, conectados en diferentes momentos. En la siguiente sección, discutiremos nuestra experiencia en el diseño e implementación de JMS para redes ad-hoc móviles.4. JMSFOR NEDES AD-HOC MOBILES 4.1 La adaptación de JMS para redes móviles ad-hoc que desarrolla aplicaciones para redes móviles es aún más desafiante: además de las mismas consideraciones que para entornos inalámbricos infraestructurados, como las capacidades de dispositivos limitados y las restricciones de potencia, existenProblemas de tasa de cambio de conectividad de red y la falta de una infraestructura de enrutamiento estático. En consecuencia, ahora describimos un intento inicial de adaptar la especificación JMS para apuntar a los requisitos particulares relacionados con los escenarios ad-hoc. Como se discute en la Sección 3, una aplicación JMS puede usar el punto a otro y la publicación de los estilos de mensajería. Modelo de punto a punto El modelo de punto a punto se basa en el concepto de colas, que se utilizan para permitir la comunicación asincrónica entre el productor de un mensaje y posibles consumidores diferentes. En nuestra solución, la ubicación de las colas está determinada por un proceso de negociación que depende de la aplicación. Por ejemplo, supongamos que es posible conocer a priori, o es posible determinar dinámicamente, que un cierto host es el receptor de la mayor parte de los mensajes enviados a una cola particular. En este caso, la ubicación óptima de la cola puede estar en este host en particular. En general, vale la pena señalar que, de acuerdo con la especificación JMS y los patrones de diseño sugeridos, es común y preferible que un cliente tenga todos sus mensajes entregados a una sola cola. Las colas se anuncian periódicamente a los hosts que están dentro del rango de transmisión o que son accesibles por medio del protocolo de comunicación sincrónica subyacente, si se proporciona. Es importante tener en cuenta que, a nivel de middleware, es lógicamente irrelevante si la capa de red implementa alguna forma de enrutamiento ad-hoc (aunque considerablemente más eficiente si lo hace);El middleware solo considera información sobre qué nodos se puede acceder activamente en cualquier momento. Los anfitriones que reciben mensajes publicitarios agregan entradas a su registro JNDI. Cada entrada se caracteriza por un contrato de arrendamiento (un mecanismo similar al presente en Jini [15]). Un contrato de arrendamiento representa el tiempo de validez de una entrada en particular. Si no se actualiza un contrato de arrendamiento (es decir, su vida no se extiende), puede expirar y, en consecuencia, la entrada se elimina del registro. En otras palabras, el anfitrión asume que la cola será inalcanzable desde ese momento. Esto puede ser causado, por ejemplo, si un host que almacena la cola se vuelve inalcanzable. Un host que inicia un proceso de descubrimiento encontrará los temas y las colas presentes en su parte conectada de la red de manera directa. Para entregar un mensaje a un host que no está actualmente en Reach1, utilizamos un protocolo de enrutamiento epidémico asíncrono que se discutirá en detalle en la Sección 4.2. Si dos hosts están en la misma nube (es decir, existe una ruta conectada entre ellos), pero no hay un protocolo sincrónico disponible, los mensajes se envían utilizando el protocolo epidémico. En este caso, la latencia de entrega será baja como resultado de la rapidez de propagación de la infección en la nube conectada (ver también los resultados de la simulación en la Sección 5). Dada la existencia de un protocolo epidémico, el mecanismo de descubrimiento consiste en anunciar las colas a los huéspedes que actualmente son inalcanzables utilizando mecanismos análogos. Publish-suscribir el modelo En el modelo Publish-Subscribe, algunos de los hosts están designados de manera similar para mantener temas y suscripciones de almacenamiento, como antes. Los temas se anuncian a través del registro de la misma manera que las colas, y un cliente que desea suscribirse a un tema debe registrarse con el cliente que posee el tema. Cuando un cliente desea enviar un mensaje a la lista de temas, lo envía al titular del tema (de la misma manera que enviaría un mensaje a una cola). El titular del tema luego reenvía el mensaje a todos los suscriptores, utilizando el protocolo sincrónico si es posible, el protocolo de epidemia de otra manera. Vale la pena señalar que usamos un solo mensaje con múltiples destinatarios, en lugar de múltiples mensajes con múltiples destinatarios. Cuando se entrega un mensaje a uno de los suscriptores, este destinatario se elimina de la lista. Para eliminar las otras replicas posibles, empleamos mensajes de reconocimiento (discutidos en la Sección 4.4), devueltos de la misma manera que un mensaje normal. También hemos adaptado los conceptos de suscripciones duraderas y no duraderas para configuraciones ad-hoc. En plataformas fijas, se mantienen suscripciones duraderas durante las desconexiones de los clientes, ya sean intencionales o son el resultado de fallas. En los sistemas tradicionales, mientras que un suscriptor duradero está desconectado del servidor, es responsable de almacenar mensajes. Cuando el suscriptor duradero se vuelve a conectar, el servidor lo envía todos los mensajes no vencidos. El problema es que, en nuestro escenario, las desconexiones son la Norma 1 En teoría, no es posible enviar un mensaje a un compañero que nunca se haya accesible en el pasado, ya que no puede haber entrada presente en el registro. Sin embargo, para superar esta posible limitación, proporcionamos una primitiva a través del cual se puede agregar información al registro sin usar los canales normales.123 Middleware 2004 Companion en lugar de la excepción. En otras palabras, no podemos considerar las desconexiones como fallas. Por estas razones, adoptamos una semántica ligeramente diferente. Con respecto a las suscripciones duraderas, si un suscriptor se desconecta, las notificaciones no se almacenan, pero se envían utilizando el protocolo epidémico en lugar del protocolo sincrónico. En otras palabras, las notificaciones duraderas siguen siendo válidas durante las posibles desconexiones del suscriptor. Por otro lado, si un suscriptor no duradero se desconecta, su suscripción se elimina;En otras palabras, durante las desconexiones, las notificaciones no se envían utilizando el protocolo epidémico, sino que solo explotan el protocolo sincrónico. Si el tema se vuelve accesible para este host nuevamente, debe hacer otra suscripción para recibir las notificaciones. Los mensajes de la suscripción se entregan de la misma manera que los mensajes de suscripción. Es importante tener en cuenta que los suscriptores duraderos tienen explícitamente darse de baja de un tema para detener el proceso de notificación;Sin embargo, todas las suscripciones duraderas tienen un tiempo de vencimiento predefinido para hacer frente a los casos de suscriptores que no se reúnen nuevamente debido a sus movimientos o fallas. Esta característica se proporciona claramente para limitar el número de mensajes innecesarios enviados alrededor de la red.4.2 Entrega de mensajes utilizando el enrutamiento epidémico En esta sección, examinamos un posible mecanismo que permitirá la entrega de mensajes en una red parcialmente conectada. El mecanismo que discutimos está destinado a demostrar la viabilidad;Los mecanismos de comunicación más eficientes para este entorno son complejos y son objeto de otro artículo [13]. La entrega de mensajes asíncronos descrito anteriormente se basa en un protocolo típico de enrutamiento de estilo epidémico puro [16]. Un mensaje que debe enviarse se replica en cada host en alcance. De esta manera, las copias de los mensajes se extienden rápidamente a través de redes conectadas, como una infección. Si un host se conecta a otra nube de nodos móviles, durante su movimiento, el mensaje se extiende a través de esta colección de hosts. La replicación de datos y mensajes al estilo epidémico se ha explotado en el pasado en muchos campos, comenzando con el área de sistemas de bases de datos distribuidas [2]. Dentro del enrutamiento epidémico, cada host mantiene un búfer que contiene los mensajes que ha creado y las réplicas de los mensajes generados por los otros hosts. Para mejorar el rendimiento, una tabla hash indexa el contenido del búfer. Cuando dos hosts se conectan, el host con el identificador más pequeño inicia una llamada sesión anti-entropía, enviando una lista que contiene los identificadores únicos de los mensajes que actualmente almacena actualmente. El otro anfitrión evalúa esta lista y envía una lista que contiene los identificadores que almacena que no esté presente en el otro host, junto con los mensajes que el otro no tiene. El host que ha comenzado la sesión recibe la lista y, de la misma manera, envía los mensajes que no están presentes en el otro host. Si se produce el desbordamiento del búfer, se eliminan los mensajes. La fiabilidad ofrecida por este protocolo suele ser el mejor esfuerzo, ya que no hay garantía de que un mensaje eventualmente se entregará a su destinatario. Claramente, la relación de entrega del protocolo aumenta proporcionalmente al tiempo de retraso máximo permitido y el tamaño del búfer en cada huésped (se pueden encontrar resultados de simulación interesantes en [16]).4.3 Adaptación del modelo de mensaje JMS En esta sección, analizaremos los aspectos de nuestra adaptación de la especificación relacionada con el llamado modelo de mensaje JMS [5]. De acuerdo con esto, los mensajes JMS se caracterizan por algunas propiedades definidas utilizando el campo de encabezado, que contiene valores utilizados por clientes y proveedores para su entrega. Los aspectos discutidos en el resto de esta sección son válidos para ambos modelos (punto a punto y publicar suscripción). Un mensaje JMS puede ser persistente o no persistente. Según la especificación de JMS, los mensajes persistentes deben entregarse con un mayor grado de confiabilidad que los no participantes. Sin embargo, vale la pena señalar que no es posible garantizar la confiabilidad de una vez y solo una de la superación para los mensajes persistentes como se define en la especificación, ya que, como discutimos en la subsección anterior, el protocolo epidémico subyacente puede garantizar solo el mejor esfuerzoentrega. Sin embargo, los clientes mantienen una lista de los identificadores de los mensajes recibidos recientemente para evitar la entrega de duplicados de mensajes. En otras palabras, proporcionamos a las aplicaciones confiabilidad en Mostonce para ambos tipos de mensajes. Para implementar diferentes niveles de confiabilidad, Emma trata los mensajes persistentes y no persistentes de manera diferente, durante la ejecución del protocolo de epidemia anti-entropía. Dado que el espacio de búfer de mensajes es limitado, los mensajes persistentes se replican preferentemente utilizando el espacio libre disponible. Si esto es insuficiente y los mensajes no persistentes están presentes en el búfer, estos se reemplazan. Solo las entregas exitosas de los mensajes persistentes se notifican a los remitentes. Según la especificación JMS, es posible asignar una prioridad a cada mensaje. Los mensajes con prioridades más altas se entregan de manera preferencial. Como se discutió anteriormente, los mensajes persistentes se priorizan por encima de los no persistentes. Otra selección se basa en sus prioridades. Los mensajes con prioridades más altas se tratan de manera preferencial. De hecho, si no hay suficiente espacio para replicar todos los mensajes persistentes, se utiliza un mecanismo basado en prioridades para eliminar y replicar mensajes no persistentes (y, si es necesario, mensajes persistentes). Los mensajes se eliminan de los buffers utilizando el valor de tiempo de vencimiento que los remitentes pueden establecer. Esta es una forma de libre espacio en los buffers (uno elimina preferentemente mensajes más antiguos en casos de conflicto);eliminar réplicas rancias en el sistema;y para limitar el tiempo para el cual los destinos deben retener los identificadores de mensajes para deshacerse de los duplicados.4.4 Mecanismos de confiabilidad y reconocimiento Como ya se discutió, la entrega de mensajes más a la vez es lo mejor que se puede lograr en términos de semántica de entrega en entornos ad-hoc parcialmente conectados. Sin embargo, es posible mejorar la confiabilidad del sistema con mecanismos de reconocimiento eficientes. Emma proporciona un mecanismo para la notificación de falla a las aplicaciones si el reconocimiento no se recibe dentro de un tiempo de espera dado (que los desarrolladores de aplicaciones pueden configurar). Este mecanismo es el que distingue la entrega de mensajes persistentes y no persistentes en nuestra implementación de JMS: las entregas de los primeros son notificadas a los remitentes, mientras que los segundos no lo son. Utilizamos mensajes de reconocimiento no solo para informar a los remitentes sobre la entrega exitosa de mensajes, sino también para eliminar las réplicas de los mensajes entregados que aún están presentes en la red. Cada host mantiene una lista del middleware de mensajes para la computación generalizada y ad-hoc 124 entregada con éxito que se actualiza como parte del proceso normal de intercambio de información entre los hosts. Las listas se intercambian durante los primeros pasos del protocolo epidémico antientrópico con una cierta frecuencia predefinida. En el caso de mensajes con múltiples destinatarios, también se almacena una lista de los destinatarios reales. Cuando un host recibe la lista, verifica su búfer de mensajes y lo actualiza de acuerdo con las siguientes reglas: (1) si un mensaje tiene un solo destinatario y se ha entregado, se elimina del búfer;(2) Si un mensaje tiene múltiples destinatarios, los identificadores de los hosts entregados se eliminan de la lista asociada de destinatarios. Si la longitud resultante de la lista de destinatarios es cero, el mensaje se elimina del búfer. Estas listas tienen, claramente, dimensiones finitas y se implementan como colas circulares. Este mecanismo simple, junto con el uso de marcas de tiempo de vencimiento, garantiza que las viejas notificaciones de reconocimiento se eliminen del sistema después de un período de tiempo limitado. Para mejorar la confiabilidad de EMMA, se podría desarrollar un mecanismo de diseño para la replicación inteligente de colas y temas basados en la información del contexto. Sin embargo, esto aún no es parte de la arquitectura actual de Emma.5. Implementación y evaluación preliminar implementamos un prototipo de nuestra plataforma utilizando el perfil personal J2ME. El tamaño del ejecutable es de aproximadamente 250 kb, incluido el archivo jar JMS 1.1;Esta es una figura perfectamente aceptable dada la memoria disponible de los dispositivos móviles actuales en el mercado. Probamos nuestro prototipo en PDA HP IPAQ que ejecutan Linux, interconectados con Wavelan y en varias computadoras portátiles con la misma interfaz de red. También evaluamos la plataforma de middleware utilizando el simulador de eventos discretos Omnet ++ [17] para explorar una gama de escenarios móviles que incorporaron un número más realista de hosts de lo que se logró experimentalmente. Más específicamente, evaluamos el rendimiento del sistema en términos de relación de entrega y retraso promedio, variando la densidad de la población y el tamaño del amortiguador, y utilizando mensajes persistentes y no persistentes con diferentes prioridades. Los resultados de la simulación muestran que el rendimiento de EMMAS, en términos de relación de entrega y retraso de mensajes persistentes con prioridades más altas, es bueno. En general, es evidente que la relación de entrega está fuertemente relacionada con el dimensionamiento correcto de los amortiguadores al retraso máximo aceptable. Además, los algoritmos epidémicos pueden garantizar una alta relación de entrega si uno evalúa el rendimiento durante un intervalo de tiempo suficiente para la diseminación de las réplicas de mensajes (es decir, la propagación de la infección) en una gran parte de la red ad-hoc. Una consecuencia del problema de dimensionamiento es que la escalabilidad puede verse gravemente afectada en el middleware de pares para la computación móvil debido a la pobreza de recursos de los dispositivos (memoria limitada para almacenar mensajes temporalmente) y el número de posibles interconexiones en la configuración ad-hoc.. Lo que es peor es que las formas comunes de organización comercial y social (seis grados de separación) significan que incluso los valores de TTL modestos en los mensajes conducirán a una inundación generalizada de mensajes epidémicos. Este problema surge debido a la falta de inteligencia en el protocolo de epidemia, y puede abordarse seleccionando nodos portadores para mensajes con mayor cuidado. Sin embargo, los detalles de este proceso están fuera del alcance de este documento (pero se pueden encontrar en [13]) y no afectan las bases sobre las que se basa el middleware de Emma: la capacidad de entregar mensajes de manera asincrónica.6. Vista crítica del estado del arte El diseño de plataformas de middleware para la informática móvil requiere que los investigadores respondan preguntas nuevas y fundamentalmente diferentes;Simplemente asumir la presencia de porciones con cable de la red en la que puede residir la funcionalidad centralizada no es generalizada. Por lo tanto, es necesario investigar principios de diseño novedosos y diseñar patrones arquitectónicos que difieran de los que tradicionalmente explotan en el diseño de middleware para sistemas fijos. Como ejemplo, considere la tendencia reciente de capas cruzadas en las redes ad-hoc [1]. Esta es una forma de repensar el diseño de sistemas de software, abandonar explícitamente las formas clásicas de capas, ya que, aunque esta separación de las preocupaciones proporciona portabilidad, lo hace a expensas de posibles ganancias de eficiencia. Creemos que es posible ver nuestro enfoque como una instancia de capas cruzadas. De hecho, hemos agregado el protocolo de red epidémica a nivel de middleware y, al mismo tiempo, hemos utilizado el protocolo de red sincrónico existente si está presente tanto en la entrega de mensajes (capas tradicionales) como en informar el middleware sobre cuándo se pueden entregar mensajes porrevelando detalles de las tablas de reenvío (violación de la capa). Por esta razón, preferimos considerarlos conjuntamente como la capa de comunicación de nuestra plataforma juntas, proporcionando una entrega de mensajes más eficiente. Otro aspecto interesante es la explotación del contexto y la información del sistema para mejorar el rendimiento de las plataformas de middleware móviles. Nuevamente, como resultado de la adopción de una metodología de captura cruzada, podemos crear sistemas que recopilen información del sistema operativo subyacente y los componentes de comunicación para permitir la adaptación del comportamiento. Podemos resumir este enfoque de diseño conceptual diciendo que las plataformas de middleware no solo deben ser contexto (es decir, deben poder extraer y analizar información del contexto circundante) sino también consciente del sistema (es decir, deberían poder reunirinformación de los componentes de software y hardware del sistema móvil). Se han desarrollado varios sistemas de middleware para admitir redes ad-hoc con el uso de la comunicación asincrónica (como Lime, XMiddle, Steam [11]). En particular, la plataforma Steam es un ejemplo interesante de middleware basado en eventos para redes ad-hoc, proporcionando la entrega de mensajes conscientes de la ubicación y una solución efectiva para el filtrado de eventos. Una discusión sobre JMS y su realización móvil ya se ha realizado en las Secciones 4 y 2. La compañía suiza que Softwired ha desarrollado el primer Middleware JMS para la informática móvil, llamada IBUS Mobile [10]. Los componentes principales de esta arquitectura típicamente basada en infraestructura son el proveedor de JMS, la llamada puerta de enlace móvil JMS, que se implementa en un host fijo y una biblioteca de cliente JMS ligera. La puerta de enlace se utiliza para la comunicación entre el servidor de aplicaciones y los hosts móviles. El proveedor de JMS ve la puerta de enlace como un cliente JMS normal. El proveedor de JMS puede ser cualquier servidor de aplicaciones habilitado para JMS, como BEA WebLogic. Pronto [19] es un ejemplo del sistema de dleware acompañante Mid125 Middleware 2004 basado en mensajes que está específicamente diseñado para entornos móviles. La plataforma está compuesta por tres clases de componentes: clientes móviles que implementan la especificación JMS, las puertas de enlace que controlan el tráfico, garantizan la eficiencia y las posibles personalizaciones de los usuarios utilizando diferentes complementos y servidores JMS. Son posibles diferentes configuraciones de estos componentes;Con respecto a las aplicaciones de redes ad hoc móviles, lo más interesante es el JMS sin servidor. El objetivo de esta configuración es adaptar JMS a un modelo descentralizado. El modelo de publicación de publicación explota la eficiencia y la escalabilidad del protocolo de multidifusión IP subyacente. Se proporcionan servicios de entrega de mensajes poco confiables y confiables: la confiabilidad se proporciona a través de un protocolo negativo basado en el reconocimiento. Pronto representa una buena solución para las redes móviles basadas en infraestructura, pero no se dirige adecuadamente a la configuración AD-Hoc, ya que los nodos móviles dependen de servidores fijos para el intercambio de mensajes. Existen otra madre implementada para entornos móviles;Sin embargo, generalmente son extensiones directas del middleware existente [8]. La única implementación de MOM diseñada específicamente para redes ad-hoc móviles se desarrolló en la Universidad de Newcastle [18]. Este trabajo es nuevamente una adaptación de JMS;El enfoque de esa implementación está en la comunicación grupal y el uso de algoritmos de enrutamiento de nivel de aplicación para la entrega de mensajes de los temas. Sin embargo, hay una serie de diferencias en el enfoque de nuestro trabajo. La importancia que atribuimos a las desconexiones hace que la persistencia sea un requisito vital para cualquier middleware que deba usarse en redes ad-hoc móviles. Los autores de [18] indican la persistencia como posible trabajo futuro, no considerando el hecho de que enrutar un mensaje a un host no conectado dará como resultado una falla de entrega. Esta es una limitación notable en los entornos móviles donde las desconexiones impredecibles son la norma en lugar de la excepción.7. Hoja de ruta y conclusiones La comunicación asincrónica es un paradigma de comunicación útil para las redes ad-hoc móviles, ya que los hosts pueden venir, ir y recoger mensajes cuando sea conveniente, también tiene en cuenta su disponibilidad de recursos (por ejemplo, potencia, niveles de conectividad). En este artículo hemos descrito el estado del arte en términos de MOM para los sistemas móviles. También hemos mostrado una prueba de adaptación conceptual de JMS al escenario extremo de redes ad-hoc móviles parcialmente conectadas. Hemos descrito y discutido las características y diferencias de nuestra solución con respecto a las implementaciones tradicionales de JMS y las adaptaciones existentes para configuraciones móviles. Sin embargo, las compensaciones entre el enrutamiento a nivel de aplicación y el uso de recursos también deben investigarse, ya que los dispositivos móviles son comúnmente escasos/recursos. Una limitación clave de este trabajo es el algoritmo epidémico de bajo rendimiento y un avance importante en la práctica de este trabajo requiere un algoritmo que equilibre mejor las necesidades de eficiencia y probabilidad de entrega de mensajes. Actualmente estamos trabajando en algoritmos y protocolos que, explotando las técnicas probabilísticas y estadísticas sobre la base de pequeñas cantidades de información intercambiada, pueden mejorar considerablemente la eficiencia en términos de recursos (memoria, ancho de banda, etc.) y la confiabilidad de nuestra plataforma Middleware de nuestra plataforma Middleware (Middleware[13]. Un desarrollo de la investigación futurista, que puede tomar estas ideas de adaptación de la mensajería de middleware para entornos móviles es la introducción de más extensiones de comunicación orientadas a la movilidad, por ejemplo, el soporte de geocast (es decir, la capacidad de enviar mensajes a áreas geográficas específicas).8. Referencias [1] M. Conti, G. Maselli, G. Turi y S. Giordano. Capazos cruzados en el diseño de red ad-hoc móvil. IEEE Computer, 37 (2): 48-51, febrero de 2004. [2] A. Demers, D. Greene, C. Hauser, W. Irish, J. Larson, S. Shenker, H. Sturgis, D. Swinehart,y D. Terry. Algoritmos epidémicos para el mantenimiento de la base de datos replicado. En el sexto simposio sobre principios de computación distribuida, páginas 1-12, agosto de 1987. [3] A. Doria, M. Uden y D. P. Pandey. Proporcionando conectividad a la comunidad nómada de Saami. En Actas de la Segunda Conferencia Internacional sobre Diseño Abierto de Colaboración para la Innovación Sostenible, diciembre de 2002. [4] M. Haahr, R. Cunningham y V. Cahill. Apoyo a las aplicaciones CORBA en un entorno móvil. En la 5ª Conferencia Internacional sobre Computación y Redes Móviles (Mobicom99), páginas 36-47. ACM, agosto de 1999. [5] M. Hapner, R. Burridge, R. Sharma, J. Fialli y K. Stout. Servicio de mensajes Java Especificación Versión 1.1. Sun Microsystems, Inc., abril de 2002. http://java.sun.com/products/jms/.[6] J. Hart. WebSphere MQ: Conectando sus aplicaciones sin programación compleja. IBM WebSphere Software White Papers, 2003. [7] S. Hayward y M. Pezzini. Casarse con el middleware y la computación móvil. Informe de investigación del Grupo Gartner, septiembre de 2001. [8] IBM. WebSphere MQ Everyplace versión 2.0, noviembre de 2002. http://www-3.ibm.com/software/integration/wmqe/.[9] ITU. Conectando comunidades remotas. Documentos de la Cumbre Mundial sobre la Sociedad de la Información, 2003. http://www.itu.int/osg/spu/wsis-themes.[10] S. Maffeis. Introducción de JMS inalámbrico. Softwired AG, www.sofwired-inc.com, 2002. [11] C. Mascolo, L. Capra y W. Emmerich. Middleware para computación móvil. En E. Gregori, G. Anastasi y S. Basagni, editores, conferencias avanzadas sobre redes, volumen 2497 de las notas de la conferencia en informática, páginas 20-58. Springer Verlag, 2002. [12] Microsoft. Microsoft Message Queing (MSMQ) Versión 2.0 Documentación.[13] M. Musolesi, S. Hailes y C. Mascolo. Enrutamiento adaptativo para redes ad-hoc móviles conectadas intermitentemente. Informe técnico, UCL-CS Research Note, julio de 2004. Enviado para su publicación.[14] Sun Microsystems. Java Naming and Directory Interface (JNDI) Documentación Versión 1.2.2003. http://java.sun.com/products/jndi/.[15] Sun Microsystems. Jini Especificación Versión 2.0, 2003. http://java.sun.com/products/jini/.[16] A. Vahdat y D. Becker. Enrutamiento epidémico para redes ad-hoc parcialmente conectadas. Informe técnico CS-2000-06, Departamento de Ciencias de la Computación, Universidad de Duke, 2000. [17] A. Vargas. El sistema de simulación de eventos discretos OMNET ++. En Actas de la simulación europea multiconferencia (ESM2001), Praga, junio de 2001. [18] E. Vollset, D. Ingham y P. Ezhilchelvan. JMS en redes ad-hoc móviles. En Personal Wireless Communications (PWC), páginas 40-52, Venecia, septiembre de 2003. [19] E. Yoneki y J. Bacon. PRONTO: Mobilegateway con paradigma de publicación de publicación sobre la red inalámbrica. Informe técnico 559, Universidad de Cambridge, Laboratorio de Computación, febrero de 2003. Middleware para computación generalizada y ad-hoc 126