Asignación de tareas distribuidas en las redes sociales Mathijs de Weerdt Delft Technical University Delft, Países Bajos M.M.Deweerdt@tudelft.nl Yingqian Zhang Delft Technical University Delft, Países Bajos Yingqian.zhang@tudelft.nl Tomas Klos Center for Mathematics and Computer Science (CWI)), Países Bajos tomas.klos@cwi.nl Resumen Este documento propone una nueva variante del problema de asignación de tareas, donde los agentes están conectados en una red social y las tareas llegan a los agentes distribuidos a través de la red. Mostramos que la complejidad de este problema sigue siendo Nphard. Por otra parte, no se approximable dentro de algún factor. Desarrollamos un algoritmo basado en el protocolo de red de contrato. Nuestro algoritmo está completamente distribuido, y supone que los agentes solo tienen conocimiento local sobre tareas y recursos. Realizamos un conjunto de experimentos para evaluar el rendimiento y la escalabilidad del algoritmo propuesto en términos de calidad de solución y tiempo de cálculo. Se utilizan tres tipos diferentes de redes, a saber, las redes de pequeños mundos, aleatorios y sin escala, para representar diversas relaciones sociales entre agentes en aplicaciones realistas. Los resultados demuestran que nuestro algoritmo funciona bien y que escala bien a aplicaciones a gran escala. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial distribuida]: Sistemas multiagentes Algoritmos de términos generales, Experimentación 1. Introducción Los últimos años han visto mucho trabajo en métodos de asignación de tareas y recursos, que potencialmente pueden aplicarse a muchas aplicaciones del mundo real. Sin embargo, algunas aplicaciones interesantes en las que las relaciones entre los agentes juegan un papel requieren un modelo un poco más general. Tales situaciones aparecen con mucha frecuencia en los escenarios del mundo real, y los desarrollos tecnológicos recientes están trayendo más de ellas dentro del rango de métodos de asignación de tareas. Especialmente en las aplicaciones comerciales, la selección e interacción preferenciales de los socios es muy común, y este aspecto se vuelve más importante para la investigación de asignación de tareas, en la medida en que los desarrollos tecnológicos deben poder respaldarlo. Por ejemplo, el desarrollo de tecnologías semánticas de la web y la red conduce a una atención mayor y renovada para el potencial de la web para apoyar los procesos comerciales [7, 15]. Como ejemplo, las organizaciones virtuales (VO) se están reinventando en el contexto de la red, donde están compuestas por una serie de entidades autónomas (que representan diferentes individuos, departamentos y organizaciones), cada una de las cuales tiene una variedad de problemas.Resolver capacidades y recursos a su disposición [15, p.237]. La pregunta es cómo los VO deben ser compuestos y compuestos dinámicamente de agentes individuales, cuando se deben realizar diferentes tareas y subtareas. Esto se haría asignándolos a diferentes agentes que pueden ser capaces de realizar diferentes subconjuntos de esas tareas. Del mismo modo, la formación de la cadena de suministro (SCF) se ocupa de la asignación, posiblemente ad-hoc, de los servicios a los proveedores en la cadena de suministro, de tal manera que se optimiza las ganancias generales [6, 21]. Tradicionalmente, tales decisiones de asignación se han analizado utilizando la economía de costos de transacción (TCE) [4], que toma la transacción entre las etapas consecutivas de desarrollo como su unidad básica de análisis, y considera la empresa y el mercado como formas estructurales alternativas para organizar transacciones.(Costo de transacción) La economía se ha basado tradicionalmente en el análisis de las estadísticas comparativas: el problema central de la organización económica se considera la adaptación de las formas organizacionales a las características de las transacciones. Más recientemente, el padre fundador de TCE, Ronald Coase, reconoció que este es un enfoque demasiado simplista [5, p.245]: El análisis no puede limitarse a lo que sucede dentro de una sola empresa.(...) Lo que estamos tratando es una estructura compleja interrelacionada. En este artículo, estudiamos el problema de la asignación de tareas desde la perspectiva de una estructura interrelacionada tan compleja. En particular, el mercado no puede considerarse como una forma organizativa sin considerar socios específicos para interactuar en el mercado [11]. Específicamente, por lo tanto, consideramos que los agentes están conectados entre sí en una red social. Además, esta red no está completamente conectada: según lo informado por la literatura empresarial, las empresas generalmente han establecido relaciones laborales con números limitados de socios preferidos [10];Estos son los que consideran cuando llegan nuevas tareas y tienen que formar cadenas de suministro para asignar esas tareas [19]. Además de modelar la interrelada 500 978-81-904262-7-5 (RPS) c 2007 Ifaamas Structure entre socios comerciales, la red social introducida en este documento también se puede utilizar para representar otros tipos de conexiones o restricciones entre las entidades autónomas que surgende otros dominios de aplicación. La siguiente sección ofrece una descripción formal del problema de asignación de tareas en las redes sociales. En la Sección 3, demostramos que la complejidad de este problema sigue siendo NP-Hard. Luego procedemos a desarrollar un algoritmo distribuido en la Sección 4, y realizamos una serie de experimentos con este algoritmo, como se describe en la Sección 5. La Sección 6 discute el trabajo relacionado y la Sección 7 concluye.2. Descripción del problema Formulamos el problema de asignación de tareas sociales en esta sección. Hay un conjunto A de agentes: a = {a1 ,..., soy}. Los agentes necesitan recursos para completar las tareas. Sea r = {r1 ,..., rk} denota la recopilación de los tipos de recursos disponibles para los agentes A. Cada agente A ∈ A controla una cantidad fija de recursos para cada tipo de recurso en R, que se define por una función de recursos: RSC: A × R → N. Además, suponemos que los agentes están conectados por una red social. Definición 1 (red social). Una red social del agente Sn = (A, AE) es un gráfico no dirigido, donde los vértices A son agentes, y cada borde (AI, AJ) ∈ Ae indica la existencia de una conexión social entre los agentes AI y AJ. Suponga un conjunto de tareas t = {t1, t2 ,..., TN} llega a una red social de este agente. Cada tarea t ∈ T se define por una tupla u (t), rsc (t), loc (t), donde u (t) es la utilidad obtenida si se logra la tarea t, y la función de recursos rsc: t × r→ N Especifica la cantidad de recursos necesarios para el logro de la tarea t.Además, una función de ubicación LOC: T → A define las ubicaciones (es decir, agentes) en las que las tareas llegan a la red social. Un agente A que es la ubicación de una tarea t, es decir, loc (t) = a, se llama administrador de esta tarea. Cada tarea t ∈ T necesita algunos recursos específicos de los agentes para completar la tarea. La asignación exacta de tareas a los agentes se define mediante una asignación de tareas. Definición 2 (asignación de tareas). Dado un conjunto de tareas t = {t1 ,..., tn} y un conjunto de agentes a = {a1 ,..., AM} En una red social Sn, una asignación de tareas es un mapeo φ: T × A × R → N. Una asignación de tareas válida en SN debe satisfacer las siguientes restricciones: • Una asignación de tareas debe ser correcta. Cada agente a ∈ A no puede usar más que sus recursos disponibles, es decir, para cada r ∈ R, p t∈T φ (t, a, r) ≤ rsc (a, r).• Una asignación de tareas debe estar completa. Para cada tarea t ∈ T, todos los recursos de los agentes asignados son suficientes, es decir, para cada r ∈ R, p a∈A φ (t, a, r) ≥ rsc (t, r), o t no se asigna, es decir, φ φ(t, ·, ·) = 0. • Una asignación de tareas debe obedecer las relaciones sociales. Cada tarea t ∈ T solo puede asignarse a los agentes que son vecinos (directos) de agente loc (t) en la red social Sn. Cada agente que puede contribuir a una tarea se denomina contratista. Escribimos Tφ para representar las tareas que están completamente asignadas en φ. La utilidad de φ es entonces la suma de las utilidades de cada tarea en tφ, es decir, uφ = p t∈Tφ u (t). Usando esta notación, definimos la asignación de tareas eficiente a continuación. Definición 3 (asignación de tareas eficientes). Decimos que una asignación de tareas φ es eficiente si es válida y Uφ se maximiza, es decir, uφ = max (p t∈Tφ u (t)). Ahora estamos listos para definir el problema de asignación de tareas en la red social que estudiamos en este documento. Definición 4 (problema de asignación de tareas sociales). Dado un conjunto de agentes un conectado por una red social sn = (a, ae), y un conjunto finito de tareas t, el problema de asignación de tareas sociales (o estabilizador para abreviar) es el problema de encontrar la asignación de tareas eficiente φ, comoque φ es válido y el bienestar social Uφ se maximiza.3. Resultados de la complejidad El problema de asignación de tareas tradicional, Toque (sin la condición de la red social SN), es NP-Completo [18], y la complejidad proviene del hecho de que necesitamos evaluar el número exponencial de subconjuntos del conjunto de tareas. Aunque podemos considerar el grifo como un caso especial del STAP al suponer que los agentes están completamente conectados, no podemos usar directamente los resultados de la complejidad del TAP, ya que estudiamos el STAP en una red social arbitraria, que, como argumentamos en la introducción., debe estar parcialmente conectado. Ahora mostramos que el TAP con una red social arbitraria también es NP complete, incluso cuando la utilidad de cada tarea es 1, y la cantidad de todos los recursos requeridos y disponibles es 1. Teorema 1. Dado el problema de asignación de tareas sociales con una red social arbitraria, como se define en la definición 4, el problema de decidir si una asignación de tareas φ con utilidad más de K existe es completar NP. Prueba. Primero mostramos que el problema está en NP. Dada una instancia del problema y un entero K, podemos verificar en tiempo polinomial si una asignación φ es una asignación válida y si la utilidad de φ es mayor que k.Ahora demostramos que el STAP es NP-HARD al mostrar que el conjunto máximo independiente ≤p STAP. Dado un gráfico no dirigido g = (v, e) y un entero k, construimos una red g = (v, e) que tiene una asignación de tareas eficiente con k tareas de utilidad 1 asignada si y solo si G tiene un conjunto independiente (Es) de tamaño k.av1 av3 ae3 rsc (ae1) = {e1} rsc (ae4) = {e4} av4 ae2 av2 ae4 ae1 rsc (ae2) = {e2} {e3} rsc (av3) = {v3} rsc (av4) = {v4} t1 = {v1, e1, e3} t2 = {v2, e1, e2} rsc (ae3) = rsc (av1) = {v1} rsc (av2) = {v2} t3 = {v3, e3, e4} t4= {V4, E2, E4} E1 E2 E4 E3 V1 V2 V4V3 Figura 1: El problema MIS puede reducirse a la STAP. La figura izquierda es un gráfico no dirigido G, que tiene la solución óptima {v1, v4} o {v2, v3};La figura correcta es la instancia construida de la STAP, donde la asignación óptima es {t1, t4} o {t2, t3}. Una instancia de la siguiente construcción se muestra en la Figura 1. Para cada nodo v ∈ V y cada borde e ∈ E en el gráfico G, creamos un agente de vértice AV y un agente de borde AE en g. El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 501 Cuando V incidió a E en G, agregamos correspondientemente un borde E en G entre AV y AE. Asignamos a cada agente en un recurso G, que está relacionado con el nodo o el borde en el gráfico G, es decir, para cada v ∈ V, RSC (av) = {V} (aquí escribimos RSC (a) y RSC ((t) para representar el conjunto de recursos disponibles para/requerido por A y T), y para cada e ∈ E, rsc (ae) = {e}. Cada agente de vértice avi en g tiene una tarea TI que requiere un conjunto de recursos vecinos ti = {vi} ∪ {e | e = (u, vi) ∈ E}. No hay tarea en los agentes de borde en g. Definimos la utilidad 1 para cada tarea, y la cantidad de todos los recursos requeridos y disponibles para ser 1. Tomado una instancia del problema de IS, suponga que hay una solución de tamaño K, es decir, un subconjunto n ⊆ V tal que no se unan dos vértices en n un borde en E y | n |= k.N especifica un conjunto de agentes de vértice y en el gráfico correspondiente g. Dados dos agentes A1, A2 ∈ An, ahora sabemos que no hay un agente de borde AE conectado a A1 y A2. Por lo tanto, para cada agente a ∈ An, A asigna su tarea a los agentes de borde que están conectados a a. Todos los demás agentes de vértice A /∈ An no pueden asignar sus tareas, ya que los recursos requeridos de los agentes de borde ya son utilizados por los agentes A ∈ An. El conjunto de tareas de los agentes y (| an | = k) es, por lo tanto, el conjunto máximo de tareas que se pueden asignar. La utilidad de esta asignación es k.Del mismo modo, si hay una solución para el STAP con el valor de utilidad K, y el conjunto de tareas asignados es n, entonces para el problema es, existe un conjunto independiente máximo de N de tamaño K en G. Se puede encontrar un ejemplo en la figura1. Acabamos de demostrar que el STAP es NP-Hard para un gráfico arbitrario. En nuestra prueba, la complejidad proviene de la introducción de una red social. Uno puede esperar que la complejidad de este problema pueda reducirse para algunas redes donde el número de vecinos de los agentes está limitado por una constante fija. Ahora damos un resultado de complejidad en esta clase de redes de la siguiente manera. Teorema 2. Deje que el número de vecinos de cada agente en la red social SN esté limitado por δ para δ ≥ 3. Calcular la asignación de tareas eficiente dada dicha red es NP-Complete. Además, no es aproximado dentro de Δε para algunos ε> 0. Prueba. Se ha demostrado en [2] que el problema de conjunto independiente máximo en el caso del grado limitado por δ para δ ≥ 3 es NP-completado y no es aproximado dentro de δε para algunos ε> 0. Utilizando la reducción similar de la prueba del teorema 1, este resultado también es válido para el STAP. Dado que nuestro problema es tan difícil como se muestra en el Teorema 1, no es posible dar el peor de los casos mejor que Δε para cualquier algoritmo de tiempo polinomial, a menos que P = NP.4. Algoritmos Para lidiar con el problema de asignar tareas en una red social, presentamos un algoritmo distribuido. Presentamos este algoritmo describiendo el protocolo para los agentes. Después de eso, damos el algoritmo óptimo y centralizado y un algoritmo de límite superior, que utilizamos en la Sección 5 para comparar la calidad de nuestro algoritmo distribuido.4.1 Protocolo para la asignación de tareas distribuidas Podemos resumir la descripción del problema de asignación de tareas en las redes sociales de la Sección 2 de la siguiente manera. Algoritmo 1 Protocolo de asignación distribuida codiciosa (GDAP). Cada gerente A calcula la eficiencia E (t) para cada una de sus tareas t ∈ Ta, y luego mientras ta = ∅: 1. Cada administrador A selecciona la tarea más eficiente t ∈ Ta tal que para cada tarea t ∈ Ta: e (t) ≤ e (t).2. Cada gerente A solicita ayuda para T de todos sus vecinos (de a) informando a estos vecinos sobre la eficiencia E (t) y los recursos requeridos para t.3. Los contratistas reciben y almacenan todas las solicitudes, y luego ofrecen todos los recursos relevantes al Gerente para la tarea con la más alta eficiencia.4. Los gerentes que han recibido ofertas suficientes asignan sus tareas e informan a cada contratista qué parte de la oferta es aceptada. Cuando se asigna una tarea, o cuando un gerente ha recibido ofertas de todos los vecinos, pero aún no puede satisfacer su tarea, la tarea se elimina de la lista de tareas TA.5. Los contratistas actualizan sus recursos usados.tener una red (social) de agentes. Cada agente tiene un conjunto de recursos de diferentes tipos a su disposición. También tenemos un conjunto de tareas. Cada tarea requiere algunos recursos, tiene un beneficio fijo y se encuentra en cierto agente. Este agente se llama gerente. Solo permitimos que los agentes vecinos ayuden con una tarea. Estos agentes se llaman contratistas. Los agentes pueden cumplir el papel de gerente y contratista. El problema es averiguar qué tareas ejecutar y qué recursos de qué contratistas usar para estas tareas. La idea del protocolo es la siguiente. Todos los agentes del gerente a ∈ Un intento de encontrar contratistas vecinos para ayudarlos con sus tareas TA = {ti ∈ T |loc (ti) = a}. Comienzan con ofrecer la tarea que es más eficiente en términos de la relación entre los beneficios y los recursos requeridos. De todas las tareas ofrecidas, los contratistas seleccionan la tarea con la más alta eficiencia y envían una oferta al gerente relacionado. Una oferta consiste en todos los recursos que el agente puede suministrar para esta tarea. Si se han ofrecido recursos suficientes, el gerente selecciona los recursos requeridos e informa a todos los contratistas de su elección. La eficiencia de una tarea se define de la siguiente manera: Definición 5. La eficiencia E de una tarea t ∈ T se define por la utilidad de esta tarea dividida por la suma de todos los recursos requeridos: e (t) = u (t) p r∈R rsc (t, r). Una descripción más detallada de este protocolo se puede encontrar en el Algoritmo 1. Aquí también se define cómo determinar cuándo ya no se debe ofrecer una tarea, porque es imposible cumplir localmente. Obviamente, ya no se ofrece una tarea cuando se ha asignado. Este protocolo es tal que, cuando no dos tareas tienen exactamente la misma eficiencia, en cada iteración, al menos una tarea se elimina de una lista de tareas.1 A partir de esto sigue la propiedad de cálculo y comunicación del algoritmo. Proposición 1. Para una estampa con tareas n y agentes M, el tiempo de ejecución del algoritmo distribuido es O (NM), y el número de mensajes de comunicación es O (N2 M).1 Incluso cuando algunas tareas tienen la misma eficiencia, es sencillo hacer que este resultado funcione. Por ejemplo, la implementación puede garantizar que los contratistas elijan la tarea con el ID de tarea más bajo.502 El sexto intl. Conf.En agentes autónomos y algoritmo de sistemas de agentes múltiples (AAMAS 07) Algoritmo 2 Asignación óptima de tareas sociales (OPT). Repita lo siguiente para cada combinación de tareas: 1. Si la recompensa total para esta combinación es más alta que cualquier combinación anterior, pruebe si esta combinación es factible de la siguiente manera: 2. Cree un problema de flujo de red para cada tipo de recurso r ∈ R (por separado) de la siguiente manera: (a) Cree una fuente S y un sumidero S.(b) Para cada agente a ∈ A, cree un nodo de agente y un borde de S a este nodo con capacidad igual a la cantidad de recursos de tipo R que tiene el agente A.(c) Para cada tarea t ∈ T, cree un nodo de tarea y un borde de este nodo a S con una capacidad igual a la cantidad de recursos de la tarea T de tipo R requiere.(d) Para cada agente A conecte el nodo del agente a todos los nodos de tareas de las tareas vecinas, es decir, t ∈ {t ∈ T |(a, loc (t)) ∈ Ae}. Dé esta conexión la capacidad ilimitada.3. Resuelva el problema de flujo máximo para las redes de flujo creadas. Si el flujo máximo en cada red es igual a los recursos requeridos totales de ese tipo, la combinación actual de tareas es factible. En ese caso, esta es la mejor combinación actual de tareas. Prueba. En el peor de los casos, en cada iteración se elimina exactamente una tarea de una lista de tareas, por lo que hay n iteraciones. En cada iteración en el peor de los casos (es decir, una red totalmente conectada), para cada uno de los gerentes O (n), se envían mensajes O (M). A continuación, la tarea con la más alta eficiencia puede ser seleccionada por cada contratista en O (N). La asignación de una asignación se puede hacer en o (m). Esto conduce a un total de operaciones O (N + M) para cada iteración y, por lo tanto, las operaciones O (N2 + NM) en total. El número de mensajes enviados es o (n (nm + nm + nm)) = o (n2 m). Establecemos la calidad de este protocolo experimentalmente (en la Sección 5). Preferiblemente, comparamos los resultados con la solución óptima.4.2 Asignación óptima de tareas sociales El algoritmo de asignación de tareas óptimo debe lidiar con las restricciones planteadas por la red social. Para este problema NPComplete, utilizamos un algoritmo exponencial de fuerza bruta para considerar combinaciones relevantes de tareas para ejecutar. Para cada combinación, utilizamos un algoritmo de flujo máximo para verificar si los recursos son suficientes para el subconjunto de tareas seleccionadas. La red de flujo describe qué recursos se pueden utilizar para qué tareas, dependiendo de la red social. Si el flujo máximo es igual a la suma de todos los recursos requeridos por el subconjunto de tareas, sabemos que existe una solución factible (ver Algoritmo 2). Claramente, no podemos esperar que este algoritmo óptimo pueda encontrar soluciones para tamaños de problemas más grandes. Para establecer la calidad de nuestro protocolo para grandes instancias, utilizamos el siguiente método para determinar un límite superior.4.3 Bound superior para la asignación de tareas sociales Dado un problema de asignación de tareas sociales, si el número de tipos de recursos para cada tarea t ∈ T está limitado por 1, el algoritmo 3 un límite superior para la asignación de tareas sociales (UB). Cree un problema de flujo de red con los costos de la siguiente manera: 1. Crea una fuente S y un sumidero S.2. Para cada agente a ∈ A y cada tipo de recurso ri ∈ R, cree un nodo de recurso de agente AI, y un borde de S a este nodo con capacidad igual a la cantidad de recursos del Tipo R Agente A tiene disponible y con costos 0.3. Para cada tarea t ∈ T y cada tipo de recurso ri ∈ R, cree un nodo de recursos de tarea Ti, y un borde de este nodo a S con capacidad igual a la cantidad de recursos de la tarea T de tipo R requiere y los costos −E (t).4. Para cada tipo de recurso ri ∈ R y para cada agente A conecte el nodo de recurso de agente ai a todos los nodos de recursos de tareas ti para tareas vecinas t ∈ {t ∈ T |(a, loc (t)) ∈ Ae o a = loc (t)}. Dé esta conexión capacidad ilimitada y cero costos.5. Cree un borde directamente de S a S con capacidad ilimitada y cero costos. Resuelva el problema de red de flujo de costos mínimo para esta red. Los costos de la red resultante son un límite superior para el problema de asignación de tareas sociales.El problema es polinómicamente solucionable transformándolo en un problema de red de flujo. Nuestro método para calcular eficientemente un límite superior para STAP hace uso de este caso especial al convertir cualquier instancia de Stap dada P en un nuevo problema P, donde cada tarea solo tiene un tipo de recurso. Más específicamente, para cada tarea t ∈ T con utilidad u (t), hacemos lo siguiente. Sea M el número de tipos de recursos {R1 ,..., rm} requerido por t.Luego dividimos t en un conjunto de tareas m t = {t1 ,..., tm} donde cada tarea TI solo tiene un tipo de recurso único (de {r1, ..., rm}) y cada tarea tiene una parte justa de la utilidad, es decir, la eficiencia de t de la definición 5 veces la cantidad de estoTipo de recurso RSC (TI, RI). Después de realizar esta conversión polinomial para cada tarea en t, el problema original P se convierte en el caso especial p. Tenga en cuenta que el conjunto de asignaciones válidas en P es solo un subconjunto del conjunto de asignaciones válidas en P, porque ahora es posible asignar parcialmente una tarea. A partir de esto, es fácil ver que la solución de P proporciona un límite superior de la solución del problema original P. Para calcular la solución óptima para P, la transformamos en un problema de flujo de costo mínimo. Modelamos el costo en la red de flujo mediante la negación de la nueva utilidad de tareas. Se utiliza una implementación en tiempo polinomial de un algoritmo de flujo de costo mínimo de escala [9] para el cálculo. El flujo de costo mínimo resultante representa una asignación máxima de las tareas para p. El modelado detallado se describe en el Algoritmo 3. En la siguiente sección, utilizamos este límite superior para estimar la calidad del GDAP para instancias a gran escala.5. Experimentos implementamos el Protocolo de asignación distribuida codiciosa (GDAP), el algoritmo de asignación óptimo (OPT) y el algoritmo de límite superior (UB) en Java, y los probó en una PC Linux. El propósito de estos experimentos es estudiar el rendimiento del algoritmo distribuido en diferentes entornos de problemas utilizando diferentes redes sociales. El Sexth Intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 503 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 0.4 0.4 0.6 0.8 1 1.2 1.4 1.6 Recompensa- GDAP Random - GDAP Free - GDAP Figura 2: Las cualidades de solución del GDAP y el límite superior dependen de la relación de recursos.0 5 10 15 20 25 30 30 0 2 4 6 8 10 12 14 16 18 Número Fagents Grado de escala aleatoria pequeña Figura 3: El histograma de los grados.Las mediciones de formio son la calidad de la solución y el tiempo de cálculo, donde la calidad de la solución (SQ) se calcula de la siguiente manera. Cuando el número de tareas es pequeño, comparamos la salida del algoritmo distribuido con la solución óptima, es decir, sq = gdap op t, pero si no es factible calcular la solución óptima, usamos el valor devuelto por el límite superiorAlgoritmo para la evaluación, es decir, SQ = GDAP UB. Para ver si este último es una buena medida, también comparamos la calidad de la solución superior con la solución óptima para problemas más pequeños. A continuación, describimos la configuración de todos los experimentos y presentamos los resultados.5.1 Configuraciones experimentales Consideramos varios entornos experimentales. En todos los entornos, los agentes están conectados por una red social. En los experimentos, se utilizan tres redes diferentes para simular las relaciones sociales entre los agentes en posibles problemas del mundo real. Las redes del mundo pequeño son redes donde la mayoría de los vecinos de un agente también están conectados entre sí. Para los experimentos utilizamos un método para generar redes aleatorias de mundo pequeño propuestos por Watts et al.[22], con una probabilidad de reencuentro fija P = 0.05. Las redes sin escala tienen la propiedad de que un par de nodos tienen muchas conexiones, y muchos nodos tienen solo una pequeña cantidad de conexiones. Para generarlos, utilizamos la implementación en la Biblioteca Jung del generador propuesto por Barab´asi y Albert [3]. También generamos redes aleatorias de la siguiente manera. Primero conectamos a cada agente a otro agente de modo que todos los agentes estén conectados. A continuación, agregamos al azar las conexiones hasta que se haya alcanzado el grado promedio deseado. Ahora describimos las diferentes configuraciones utilizadas en nuestros experimentos con problemas pequeños y a gran escala. Configuración 1. El número de agentes es 40, y el número de tareas es 20. El número de diferentes tipos de recursos está limitado por 5, y el número promedio de recursos requeridos por una tarea es 30. En consecuencia, el número total de recursos requeridos por las tareas se soluciona. Sin embargo, los recursos disponibles para los agentes son variados. Definimos la relación de recursos para referirse a la relación entre el número total de recursos disponibles y el número total de recursos requeridos. Los recursos se asignan de manera uniforme a los agentes. Los grados promedio de las redes también pueden cambiar. En esta configuración, los beneficios de la tarea se distribuyen normalmente en torno a la cantidad de recursos requeridos. Configuración 2. Esta configuración es similar a la configuración 1, pero aquí dejamos que los beneficios de las tareas varíen dramáticamente-40% de las tareas tienen un beneficio alrededor de 10 veces mayor que el otro 60% de las tareas. Configuración 3. Esta configuración es para problemas a gran escala. La relación entre el número de agentes y el número de tareas se establece en 5/3, y el número de agentes varía de 100 a 2000. También solucionamos la relación de recursos a 1.2 y el grado promedio a 6. El número de diferentes tipos de recursos es 20, y el requisito promedio de recursos de una tarea es de 100. Los beneficios de la tarea se distribuyen normalmente.5.2 Resultados experimentales Los experimentos se realizan con las tres configuraciones diferentes en las tres redes diferentes mencionadas anteriormente, donde cada datos registrados es el promedio en 20 instancias aleatorias.5.2.1 Experimento 1 Configuración experimental 1 se usa para este conjunto de experimentos. Nos gustaría ver cómo se comporta el GDAP en las diferentes redes cuando el número de recursos disponibles para los agentes está cambiando. También estudiamos el comportamiento de nuestro algoritmo de límite superior. Para este experimento solucionamos el número promedio de vecinos (grado) en cada tipo de red a seis. En la Figura 2 vemos cómo depende la calidad del límite superior y el algoritmo GDAP de la relación de recursos. Sorprendentemente, para las relaciones de recursos más bajas, nuestro GDAP está mucho más cerca de la asignación óptima que el límite superior. Cuando la relación de recursos crece por encima de 1.5, los gráficos del límite superior y el GDAP convergen, lo que significa que ambos están realmente cerca de la solución óptima. Esto puede explicarse por el hecho de que cuando hay muchos recursos disponibles, todas las tareas se pueden asignar sin ningún conflicto. Sin embargo, cuando los recursos son muy escasos, el límite superior es demasiado optimista, ya que se basa en la asignación de subtareas por tipo de recurso, y no razona cuántas tareas se pueden asignar por completo. También notamos en el gráfico que la calidad de la solución del GDAP en las tres redes es bastante alta (más de 0.8) cuando el recurso disponible es muy limitado (0.3). Se cae por debajo de 0.8 con una mayor relación y aumenta nuevamente una vez que haya muchos recursos disponibles (relación de recursos 0.9). Claramente, si 504 el sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 2 4 6 6 8 10 12 16 RecompensasGDAP Random - GDAP Free - GDAP Figura 4: La calidad del GDAP y el límite superior dependen del grado de red.Los recursos son realmente escasos, solo unas pocas tareas pueden asignarse con éxito incluso por el algoritmo óptimo. Por lo tanto, el GDAP puede dar una buena asignación. Aunque las diferencias son menores, también se puede ver que los resultados para la red del mundo pequeño son consistentemente ligeramente mejores que los de las redes aleatorias, que a su lugar superan las redes sin escala. Esto puede entenderse observando la distribución del grado de agentes, como se muestra en la Figura 3. En este experimento, en la red del mundo pequeño, casi todos los gerentes tienen un grado de seis. En redes aleatorias, el grado varía entre uno y aproximadamente diez. Sin embargo, en la red sin escala, la mayoría de los nodos tienen solo tres o cuatro conexiones, y solo unas pocas tienen hasta veinte conexiones. Como veremos en el próximo experimento, tener más conexiones significa obtener mejores resultados. Para el próximo experimento, fijamos la relación de recursos a 1.0 y estudiamos la calidad del algoritmo GDAP de límite superior y el algoritmo GDAP relacionado con el grado de la red social. El resultado se puede encontrar en la Figura 4. En esta figura podemos ver que un grado promedio alto también conduce a la convergencia del límite superior y el GDAP. Obviamente, cuando los gerentes tienen muchas conexiones, se hace más fácil asignar tareas. Una excepción es, similar a lo que hemos visto en la Figura 2, que la solución del GDAP también es muy buena si las conexiones son extremadamente limitadas (grado 2), debido al hecho de que el número de tareas posiblemente asignadas es muy pequeña. Una vez más, vemos que el límite superior no es tan bueno para los problemas en los que los recursos son difíciles de alcanzar, es decir, en las redes sociales con un grado promedio bajo.2 Dado que la calidad de la solución depende claramente de la relación de recursos, así como del grado de lo social.Red, estudiamos el efecto de cambiar ambos, para ver si se influyen entre sí. La Figura 5 muestra cómo la calidad de la solución depende tanto de la relación de recursos como del grado de red. Este gráfico confirma los resultados de que el GDAP funciona mejor para problemas con una relación de recursos más alta y más alta. Sin embargo, ahora también está más claro que funciona mejor para una disponibilidad de recursos y muy bajo grado. Para este experimento con 40 agentes y 20 tareas, el peor rendimiento se cumple para instancias con grado seis y la relación de recursos 0.6 a instancias con grado doce y relación recursos 0.3. Pero incluso para esos casos, el rendimiento se encuentra por encima de 0.7.2 La desviación estándar consistente de aproximadamente el 15% en las 20 instancias problemáticas no se muestra como barras de error en estos primeros gráficos, porque ofuscaría las interesantes correlaciones que ahora se pueden ver.4 6 8 10 12 14 16 0.4 0.6 0.8 1 1.2 1.4 1.6 0.7 0.75 0.8 0.85 0.9 0.95 1 Recompensa relativa Relación de recursos promedio de grado pequeño Recompensa relativa Figura 5: La calidad del GDAP depende tanto de la relación de recursos como de la red de la red y el grado de red de la red.5.2.2 Experimento 2 Para estudiar la robustez del GDAP en diferentes configuraciones de problemas, generamos casos en los que la distribución de beneficios de la tarea es diferente: el 40% de las tareas obtienen un beneficio 10 veces mayor (como se describe en la configuración 2). El efecto de esta distribución diferente se puede ver en la Figura 6. Estos dos gráficos muestran que los resultados para la distribución de beneficios de la tarea sesgada son ligeramente mejores en promedio, tanto cuando varían la relación de recursos como cuando varían el grado promedio de la red. Argumentamos que esto puede explicarse por la naturaleza codiciosa de GDAP, lo que hace que las tareas con alta eficiencia se asignen primero, y hace que el algoritmo funcione mejor en este entorno heterogéneo.5.2.3 Experimento 3 El propósito de este experimento final es probar si el algoritmo se puede escalar a grandes problemas, como las aplicaciones que se ejecutan en Internet. Por lo tanto, generamos casos en los que el número de agentes varía de 100 a 2000, y aumentamos simultáneamente el número de tareas de 166 a 3333 (configuración 3). La Figura 7 muestra el tiempo de ejecución para estas instancias en una máquina Linux con un procesador AMD Opteron 2.4 GHz. Estos gráficos confirman el análisis teórico de la sección anterior, diciendo que tanto el límite superior como el GDAP son polinomiales. De hecho, los gráficos muestran que el GDAP casi se comporta linealmente. Aquí vemos que la localidad del GDAP realmente ayuda a reducir el tiempo de cálculo. También tenga en cuenta que el GDAP requiere aún menos tiempo de cálculo que el límite superior. La calidad del GDAP para estas grandes instancias no se puede comparar con la solución óptima. Por lo tanto, en la Figura 8 se usa el límite superior. Este resultado muestra que el GDAP se comporta de manera estable y consistente bien con el creciente tamaño del problema. También muestra una vez más que el GDAP funciona mejor en una red de mundo pequeño.6. La asignación de tareas de trabajo relacionadas en sistemas multiagentes ha sido investigada por muchos investigadores en los últimos años con diferentes supuestos y énfasis. Sin embargo, la mayor parte de la investigación hasta la fecha sobre la asignación de tareas no considera las conexiones sociales entre los agentes, y estudia el problema en un sexto INTL centralizado. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 505 0.65 0.7 0.75 0.8 0.85 0.9 0.95 1 0.4 0.6 0.8 1 1.2 1.4 1.6 Recompensa La relación de recurso de recompensa de recompensa en el mundo pequeño sesgo pequeño sesgo uniforme uniforme uniforme uniforme uniformelibre 0.7 0.75 0.8 0.85 0.9 0.95 1 2 4 6 8 10 12 14 16 Recompensay una distribución de beneficios de tarea sesgada relacionada con la relación de recursos (el primer gráfico) y el grado de red (el segundo gráfico).configuración. Por ejemplo, Kraus et al.[12] Desarrolle un protocolo de subasta que permita a los agentes formar coaliciones con limitaciones de tiempo. Asume que cada agente conoce las capacidades de todos los demás. El protocolo propuesto está centralizado, donde un gerente es responsable de asignar las tareas a todas las coaliciones. Manisterski en Al.[14] Discuta las posibilidades de lograr asignaciones eficientes en entornos cooperativos y no cooperativos. Proponen un algoritmo centralizado para encontrar la solución óptima. En contraste con este trabajo, presentamos también un protocolo eficiente completamente distribuido que tiene en cuenta la red social. La asignación de tareas también ha sido estudiada en entornos distribuidos por, por ejemplo, Shehory y Kraus [18] y por Lerman y Shehory [13]. Proponen algoritmos distribuidos con baja complejidad de comunicación para formar coaliciones en sistemas multiagentes a gran escala. Sin embargo, no asumen la existencia de ninguna red de agentes. El trabajo de Sander et al.[16] Introduce algoritmos basados en geometría computacional para la asignación de tareas distribuidas en dominios geográficos. Los agentes pueden moverse y buscar activamente tareas, y la capacidad de los agentes para realizar tareas es homogénea. Para aplicar su enfoque, los agentes deben tener algún conocimiento sobre las posiciones geográficas de las tareas y algunos otros agentes. Otro trabajo [17] propone un mecanismo de ubicación para sistemas abiertos multiagentes para asignar tareas a agentes desconocidos. En este enfoque, cada agente almacena una lista de agentes que conocen. El análisis de la complejidad de comunicación de este método se basa en gráficos similares a la red, mientras que investigamos cómo resolver eficientemente la asignación de tareas en una red social, cuya topología puede ser arbitraria. Las redes también se han empleado en el contexto de la asignación de tareas en algunos otros trabajos, por ejemplo, para limitar el 0 1000 2000 3000 4000 5000 6000 7000 0 200 400 600 800 1000 1200 1400 1600 1800 2000 Agentes de tiempo superior Bound - Pequeño pequeño-No superior del mundo - Bound superior aleatorio - GDAP sin escala - GDAP de mundo pequeño - GDAP aleatorio - Figura 7 sin escala: El tiempo de ejecución del algoritmo GDAP.0.75 0.8 0.85 0.9 0.95 1 0 200 400 600 800 1000 1200 1400 1600 1800 2000 Recompensas Agentes de recompensainteracciones entre agentes y mediadores [1]. Los mediadores en este contexto son agentes que reciben la tarea y tienen conexiones con otros agentes. Rompen la tarea en subtareas y negocian con otros agentes para obtener compromisos para ejecutar estas subtareas. Su enfoque está en modelar el proceso de decisión de un solo mediador. Otro enfoque es dividir la red en camarillas de nodos, que representan coaliciones que los agentes involucrados pueden usar como mecanismo de coordinación [20]. El enfoque de ese trabajo se distribuye la formación de la coalición entre los agentes, pero en nuestro enfoque, no necesitamos agentes para formar grupos antes de asignar tareas. Easwaran y Pitt [6] estudian tareas complejas que requieren servicios para su logro. El problema se refiere a la asignación de subtareas a los proveedores de servicios en una cadena de suministro. Otro estudio de la asignación de tareas en las cadenas de suministro es [21], donde se argumenta que la característica definitoria de la formación de la cadena de suministro es la descomposición jerárquica de la subtarea (HSD). HSD se implementa utilizando redes de dependencia de tareas (TDN), con agentes y bienes como nodos, y relaciones de E/S entre ellas como bordes. Aquí, se da la red y el problema es seleccionar un subgrafio, para el cual los autores proponen un algoritmo basado en el mercado, en particular, una serie de subastas. En comparación con estos trabajos, nuestro enfoque es más general en el sentido de que somos capaces de modelar diferentes tipos de conexiones o restricciones entre los agentes para diferentes dominios problemáticos además de la formación de la cadena de suministro. Finalmente, las redes sociales se han utilizado en el contexto de la formación del equipo. El trabajo anterior ha demostrado cómo aprender qué relaciones son más beneficiosas a largo plazo [8] y adaptar la red social en consecuencia. Creemos que estos resultados también pueden transferirse al dominio de la asignación de tareas, dejando esto como un tema para un estudio posterior.506 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 7. Conclusiones En este documento estudiamos el problema de asignación de tareas en una red social (STAP), que puede verse como una variante nueva y más general del TAP. Creemos que tiene una gran cantidad de potencial para problemas realistas. Proporcionamos resultados de complejidad en calcular la solución eficiente para el STAP, así como un límite en los posibles algoritmos de aproximación. A continuación, presentamos un protocolo distribuido, relacionado con el protocolo ContractNet. También introdujimos un algoritmo exponencial para calcular la solución óptima, así como un algoritmo rápido de conflicto superior. Finalmente, utilizamos la solución óptima y el límite superior (para instancias más grandes) para realizar un extenso conjunto de experimentos para evaluar la calidad de la solución y la eficiencia computacional del algoritmo distribuido propuesto en diferentes tipos de redes, a saber, las redes de mundo pequeño., redes aleatorias y redes sin escala. Los resultados presentados en este documento muestran que el algoritmo distribuido funciona bien en redes de pequeños mundo, sin escala y aleatorios, y para muchos entornos diferentes. También se realizaron otros experimentos (por ejemplo, en redes de cuadrícula) y estos resultados se mantuvieron en una gama más amplia de escenarios. Además, demostramos que escala bien en redes grandes, tanto en términos de calidad como de tiempo de cálculo requerido. Los resultados también sugieren que las redes del mundo pequeño son ligeramente mejor adecuados para la asignación de tareas locales, porque no hay nodos con muy pocos vecinos. Hay muchas extensiones interesantes en nuestro trabajo actual. En este artículo, nos centramos en el aspecto computacional en el diseño del algoritmo distribuido. En nuestro trabajo futuro, también nos gustaría abordar algunos de los problemas relacionados en la teoría de juegos, como los agentes estratégicos, y mostrar propiedades deseables de un protocolo distribuido en tal contexto. En el algoritmo actual, suponemos que los agentes solo pueden contactar a sus vecinos para solicitar recursos, lo que puede explicar por qué nuestro algoritmo no funciona tan bien en las redes libres de escamas como en las redes del mundo pequeño. Nuestro trabajo futuro puede permitir a los agentes reasignar (sub) tareas. Estamos interesados en ver cómo tales interacciones afectarán el rendimiento de la asignación de tareas en diferentes redes sociales. Un tercer tema interesante para trabajos adicionales es la adición de información de reputación entre los agentes. Esto puede ayudar a modelar las relaciones comerciales cambiantes e incentivar a los agentes a seguir el protocolo. Finalmente, sería interesante estudiar instancias de la vida real del problema de asignación de tareas sociales, y ver cómo se relacionan con las redes generadas al azar de diferentes tipos estudiados en este documento. Expresiones de gratitud. Este trabajo está respaldado por la División de Ciencias Aplicadas de NWO y el Ministerio de Asuntos Económicos.8. Referencias [1] S. Abdallah y V. Lesser. Asignación de tareas de modelado utilizando un modelo teórico de decisión. En Proc. Aamas, páginas 719-726. ACM, 2005. [2] N. Alon, U. Feige, A. Wigderson y D. Zuckerman. Productos gráficos derandomizados. Complexidad computacional, 5 (1): 60-75, 1995. [3] A.-L.Barab´asi y R. Albert. Aparición de escala en redes aleatorias. Science, 286 (5439): 509-512, 1999. [4] R. H. Coase. La naturaleza de la empresa. EconomicA ns, 4 (16): 386-405, 1937. [5] R. H. Coase. Mi evolución como economista. En W. Breit y R. W. Spencer, editores, Lives of the Laureates, páginas 227-249. MIT Press, 1995. [6] A. M. Easwaran y J. Pitt. Formación de la cadena de suministro en sistemas abiertos de agentes múltiples basados en el mercado. Internacional J. de inteligencia y aplicaciones computacionales, 2 (3): 349-363, 2002. [7] I. Foster, N. R. Jennings y C. Kesselman. El cerebro se encuentra con la fuerza: por qué la red y los agentes se necesitan mutuamente. En Proc. Aamas, páginas 8-15, Washington, DC, EE. UU., 2004. IEEE Sociedad de computadoras.[8] M. E. Gaston y M. Desjardins. Redes organizadas por agente para la formación de equipo dinámico. En Proc. Aamas, páginas 230-237, Nueva York, NY, EE. UU., 2005. ACM Press.[9] A. Goldberg. Una implementación eficiente de un algoritmo de flujo de costo mínimo de escala. J. de algoritmos, 22: 1-29, 1997. [10] R. Gulati. ¿Se confía en la familiaridad? Las implicaciones de los lazos repetidos para la elección contractual en las alianzas. Academy of Management Journal, 38 (1): 85-112, 1995. [11] T. Klos y B. Nooteboom. Costo de transacción computacional basada en agentes Economía. Dynamics and Control, 25 (3-4): 503-526, 01. [12] S. Kraus, O. Shehory y G. Taase. Formación de la coalición con información heterogénea incierta. En Proc. Aamas, páginas 1-8. ACM, 2003. [13] K. Lerman y O. Shehory. Formación de coalición para mercados electrónicos a gran escala. En Proc. ICMAS, páginas 167-174. IEEE Computer Society, 2000. [14] E. Manisterski, E. David, S. Kraus y N. Jennings. Formando grupos de agentes eficientes para completar tareas complejas. En Proc. Aamas, páginas 257-264. ACM, 2006. [15] J. Patel et al. Organizaciones virtuales basadas en agentes para la red. Multi-agente y sistemas de cuadrícula, 1 (4): 237-249, 2005. [16] P. V. Sander, D. Peleshchuk y B. J. Grosz. Un algoritmo distribuido escalable para una asignación de tareas eficiente. En Proc. AAMAS, páginas 1191-1198, Nueva York, NY, EE. UU., 2002. ACM Press.[17] O. Shehory. Un mecanismo de ubicación de agente escalable. En Proc. Atal, volumen 1757 de LNCS, páginas 162-172. Springer, 2000. [18] O. Shehory y S. Kraus. Métodos para la asignación de tareas a través de la formación de la coalición del agente. Artificial Intelligence, 101 (1-2): 165-200, 1998. [19] R. M. Sreenath y M. P. Singh. Selección de servicio basada en agentes. Web Semantics, 1 (3): 261-279, 2004. [20] P. T. Toˇsi´c y G. A. Agha. Formación de coalición distribuida basada en camarilla máxima para la asignación de tareas en sistemas de agentes múltiples a gran escala. En Proc. MMAS, volumen 3446 de LNAi, páginas 104-120. Springer, 2005. [21] W. E. Walsh y M. P. Wellman. Modelado de la formación de la cadena de suministro en sistemas multiagente. En Proc. AMEC II, Volumen 1788 de LNAi, páginas 94-101. Springer, 2000. [22] D. J. Watts y S. H. Strogatz. Dinámica colectiva de pequeñas redes mundiales. Nature, 393: 440-442, 1998. El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 507