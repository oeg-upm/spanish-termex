Paquete de paquete: un servicio de cuadrícula multipolicia adaptable para la comparación de secuencias biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus Unb - ICIC Norte, Sub -Solo Brasilia, Brasil MSousa@unb.BRA ALBA Cristina M. A. Melo Universidad de Brasilia Campus Unb - ICC Norte, Sub-Solo Brasilia, Brasil Alves@unb.br Resumen En este documento, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas de explosión en un entorno de cuadrícula contra segmentos de bases de datos de secuencia. El marco, llamado PackageBlast, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de la ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida al poder computacional actual de los nodos. Nuestros resultados presentan muy buenas velocidades y también muestran que ninguna estrategia de asignación única puede lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y descriptores de sujetos c.2.4 [Sistemas distribuidos]: aplicaciones distribuidas;J.3 [Life and Medical Sciences]: Biología y Genética 1. Introducción La comparación de secuencia biológica (o alineación de secuencias) es uno de los problemas más importantes en la biología computacional, dado el número y la diversidad de las secuencias y la frecuencia en que se necesita resolver a diario. SW [14] es un algoritmo exacto que encuentra la mejor alineación local entre dos secuencias de tamaño N en el tiempo cuadrático y el espacio. En los proyectos del genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo tanto, una solución O (N2) es costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas poderosas a escala global. Esto condujo a la idea de la computación de la red, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que se distribuyen geográficamente [5]. La programación de recursos es uno de los componentes más importantes de un sistema de cuadrícula. La elección de los mejores recursos para una aplicación en particular se llama asignación de tareas, que es un problema NP-Completo. Las aplicaciones de la cuadrícula generalmente no tienen altas tasas de comunicación y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones de maestría/esclavos, se propusieron muchas políticas de asignación de tareas, como la auto programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso a la aplicación y del entorno en el que se ejecuta [13]. En este documento, proponemos PackageBlast, un servicio adaptativo de cuadrícula múltiple de política para ejecutar búsquedas de explosión en cuadrículas compuestas por bases de datos genéticas segmentadas. PaqueteBlast se ejecuta en Globus 3 [4] y, a estas alturas, proporciona cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de cuadrícula que ejecuta explosión con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este artículo está organizado de la siguiente forma: La Sección 2 presenta el problema de comparación de secuencia y el algoritmo BLAST. La Sección 3 describe políticas de asignación para cuadrículas. La Sección 4 discute el trabajo relacionado. La Sección 5 presenta el diseño de PackageBlast. Los resultados experimentales se discuten en la Sección 6. La Sección 7 concluye el documento.2. Comparación de secuencia Para comparar dos secuencias, debemos encontrar la mejor alineación, que es colocar una secuencia por encima de la otra dejando claro la correspondencia entre caracteres similares [7]. Dada una alineación entre dos secuencias, generalmente se asocia una puntuación para él de la siguiente manera (Figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. La puntuación es la suma de todos los valores y la puntuación máxima es la similitud entre las secuencias. Para calcular las alineaciones de secuencia locales exactas, [14] propuso un algoritmo (SW), basado en programación dinámica, con tiempo cuadrático y complejidad espacial. Por lo general, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. En este momento, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios de genes públicos más importantes. Debido al 156 g a c g g a t a g g a t c c g g a a a t a g +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 σ = 6 Figura 1: Ejemplo de una alineación con puntaje 6 tasa de crecimiento actual, estas bases de datos lograrán Terabytes Soon Terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se produzca la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la velocidad a la que el método no identifica secuencias similares, mientras que la sensibilidad es la velocidad a la que el método identifica secuencias que no son similares [7]. Blast [1] es el método heurístico más utilizado para la comparación de secuencias.2.1 La explosión del algoritmo BLAST (herramienta básica de alineación local) [1] es un conjunto de programas utilizados para buscar bases de datos de ADN y proteínas para las similitudes entre secuencias. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencia de la consulta y base de datos (Tabla 1). Tabla 1: algunos de los programas de programas de explosión de programas de programas de programación de la base de datos BLASTN Nucleótido de nucleótido de Blastp Ninguno Proteína BLASTP Proteína Ninguna consulta de nucleótidos de proteína Blastx La primera versión de la explosión buscó similitudes locales sin tener en cuenta espacios (brechas). En 1996-1997, surgieron dos versiones expulsadas de Blast: NCBI-BLAST [3] y Wu-Blast [6]. Básicamente, el algoritmo procede en tres pasos: siembra, extensión y evaluación. En el paso de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras coinciden con secuencias de la base de datos y se usan como semillas de alineación si sus puntajes son más altos que un umbral T. En el paso de extensión, se generan alineaciones a partir de semillas. Un parámetro X mantiene el historial de alineación reciente y controla este paso. Una vez que se extienden las semillas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSP (pares de segmentos de alta puntuación). Se utiliza un nuevo parámetro, s, para clasificar las alineaciones. La combinación de parámetros W, T, X y S se usa para determinar la sensibilidad y la velocidad de las búsquedas de explosión.3. La asignación de tareas para las redes 3.1 Computación de la cuadrícula de la cuadrícula se desarrolló inicialmente para permitir el intercambio de recursos entre las instituciones científicas que necesitaban compartir datos, software y energía computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en un estándar de facto para la infraestructura informática de la red. Globus implementa un conjunto de protocolos, API y servicios utilizados por cientos de aplicaciones de cuadrícula en todo el mundo. En 2002, el Global Grid Forum (GGF) introdujo la arquitectura de servicios de cuadrícula abierta (OGSA) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de cuadrícula basada en servicios web para lograr la interoperabilidad utilizando los estándares de la industria. Se desarrollaron muchas implementaciones de arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se implementa en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de la cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de tamaño más pequeño que se pueden distribuir a nodos esclavos para el procesamiento paralelo. Un problema muy importante para resolverse en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a los procesadores para maximizar el rendimiento del sistema [13]. En este problema, se supone que no existen relaciones de precedencia entre las tareas.3.2 Estrategias de asignación de tareas Dada una aplicación de maestría/esclavo compuesta por un maestro de esclavos M y S, el asignación de funciones de asignación (M, SI, N, S) determina cuántas tareas de n deben asignarse a un esclavo SI (Ecuación 1), donde A (N, S) representa una política de asignación. El factor de peso (M, SI, S) se definió por [13] (Ecuación 2) y proporciona pesos para cada esclavo SI, en función de su tasa de procesamiento estáticamente conocida (WorkerRate).Asignar (M, Si, N, S) = A (N, S) ∗ W Eightf Actor (M, Si, S) (1) W Eightf Actor (M, Si, S) = P ∗ W orkerrate (M, Si) P i = 1 w orkerrate (M, Si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A (n, s) de la ecuación 1. 3.3 fijo (programación estática) La estrategia fija [13] distribuyeTodas las unidades de trabajo de manera uniforme a los nodos de los esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (Ecuación 3). A (N, S) = N S (3) 3.4 Self Self Self Self Progreduling (SS) [15] distribuye una sola unidad de trabajo a cada nodo esclavo (Ecuación 4). A (N, S) = 1, mientras que las unidades de trabajo aún se dejan asignar (4) en SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente exige mucha comunicación, ya que cada recuperación de la unidad de trabajo requiere una interacción con el maestro.3.5 Self-programación trapezoidal (TSS) Auto-sheduling trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño de disminución lineal. Esta estrategia utiliza dos variables, pasos y δ, que representan el número total de pasos de asignación y el factor de reducción de bloques, respectivamente (Ecuaciones 5 y 6).Pasos = 4ns n + 2s (5) 157 δ = n - 2s 2s (pasos - 1) (6) TSS calcula la longitud del bloque STH usando la diferencia entre la longitud del primer bloque y la reducción total de la última S -1 bloques (ecuación 7). A (s, n, s) = max n 2s-[(s-1) ∗ δ], 1 (7) 3.6 Self Self Self Selfeduling guiado (GSS) [11] asigna unidades de trabajo en grupos cuyos cuyosLa longitud disminuye exponencialmente. Su objetivo es crear una compensación entre el número de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (Ecuación 8). A (S, N, S) = Máx N 1 - 1 S S - 1 S, 1, S> 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s.En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (Ecuación 10).Round (s) = (s - 1) s + 1 (9) a (s, n, s) = max n s ∗ 2round (s), 1 (10) 4. Se propuso el trabajo relacionado Mpiblast [2] para los grupos y tiene dos fases. Primero, la base de datos genética está segmentada. Luego, las consultas se distribuyen uniformemente entre los nodos. Si el nodo no tiene un fragmento de base de datos, se realiza una copia local. Se propone un método que asocie los fragmentos de datos a los nodos, tratando de minimizar el número de copias. BLAST ++ [10] agrupa múltiples secuencias para reducir el número de accesos de base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (Sección 3.3). Cada trabajador ejecuta Blast ++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. Gridblast [9] es una aplicación de cuadrícula maestra/esclava que usa Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y Minmax. De ellos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para usar Minmax, se debe conocer el tiempo de ejecución total de cada tarea de explosión. Habiendo decidido qué secuencias se compararán con cada nodo, GridBlast envía las secuencias, los archivos ejecutables y la base de datos completa al nodo elegido. Cuando termina la búsqueda, los resultados se compacen y se envían al maestro. Grid BLAST Toolkit (GBTK) [12] es un portal web para ejecutar búsquedas de explosión en Globus 3. Todas las bases de datos genéticas se colocan estáticamente en los nodos de la cuadrícula (sin replicación). GBTK es una aplicación maestra/esclava que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, se selecciona. Si el nodo no está disponible, se elige el nodo menos cargado y se le copia la base de datos. Segmento de base de datos de Internet de SlaVeslava de Internet, pero solo parte de él se procesa en cada nodo, la base de datos se replica en los nodos, Figura 2: Mecanismo de segmentación y distribución de paquetes de paquete.5. Diseño de paquetes de paquete, proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas de explosión contra segmentos de base de datos de secuencia. El marco, llamado PackageBlast, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestra/esclava. También proponemos una estrategia para calcular el peso de ejecución de nodos de cuadrícula que distribuye unidades de trabajo (segmentos de base de datos) a nodos de cuadrícula de acuerdo con su potencia computacional actual.5.1 La segmentación de la segmentación y la replicación de la base de datos consiste en la división de un archivo de base de datos en muchas partes de tamaño más pequeño, llamados segmentos, que se pueden procesar de forma independiente. Permite que los nodos de la cuadrícula busquen partes más pequeñas de una base de datos de secuencia, reduciendo el número de accesos de disco y, por lo tanto, mejorando el rendimiento de la explosión. Además, se puede comparar una sola secuencia de consulta con todos los segmentos en paralelo. Al igual que en Mpiblast (Sección 4), decidimos usar la segmentación de la base de datos en PackageBlast con una herramienta NCBI llamada FormatDB, que se modificó para generar más segmentos de bases de datos de tamaño más pequeño. Optamos por replicar la base de datos segmentada en cada nodo de la cuadrícula de esclavos para mejorar los tiempos de acceso de datos y para proporcionar un potencial de tolerancia a fallas. La Figura 2 ilustra esto.5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para cada situación. Por lo tanto, proponemos el uso de un marco donde se pueden incorporar muchas políticas de asignación. Por ahora, nuestro marco contiene cinco políticas de asignación: fijo, SS, GSS, TSS, FAC2, todos descritos en la Sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación, que es la más apropiada para su entorno y sus parámetros de explosión. Además de eso, proponemos PSS (autoestimulación adaptativa ponderada de paquete), una nueva estrategia que adapta la política de asignación elegida a una red con carga de trabajo local. Teniendo en cuenta la heterogeneidad y las características dinámicas de la cuadrícula, PSS puede modificar la duración de las unidades de trabajo durante la ejecución, basada en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de la unidad de trabajo se muestra en la Ecuación 11, donde A (N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y nodos P y φ (M, PI, P) es el peso calculado por PSS. A (N, P) puede ser una política de asignación predefinida o una definida por el usuario.158 Asignar (M, PI, N, P) = A (N, P) ∗ φ (M, PI, P) (11) Para distribuir segmentos de base de datos a los nodos, el maestro analiza las notificaciones periódicas de esclavos. La expresión utilizada es φ (m, pi, p) (ecuación 12), definida como la media ponderada de las últimas notificaciones Ω enviadas por cada nodo esclavo Pi. Φ (m, pi, p) = p ∗ p i = 1 γ (m, pi, ω) γ (m, pi, ω) p i = 1 p i = 1 γ (m, pi, ω) γ (m, pi, ω) (12) γ (m, pi, ω) (ecuación 13) especifica el tiempo de computación promedio de un segmento en un nodo pi, considerando las últimas notificaciones de te (m, pi, τ), que esEl tiempo de cálculo promedio de las unidades de trabajo τ (segmentos de base de datos) asignado por el maestro M a un esclavo PI. En el momento del cálculo de γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con las notificaciones K totales ya recibidas. Γ (m, pi, ω) = min (Ω, k) j = 1 t e (m, pi, τ) min (ω, k) (13) 5.3 paquetes de arquitectura general de arquitectura general se diseñó como un servicio de cuadrícula sobre Globus 3,Basado en servicios web y Java. La Figura 3 presenta la arquitectura PackageBlast. BLAST recibe estrategias maestras de asignación de unidades de trabajo Generar unidades de trabajo Distribuir informes Generar unidades de trabajo (a esclavas) Informes Búsquedas Figura 3: Arquitectura de paquete. Las estrategias de asignación del módulo contienen implementaciones para las políticas de asignación predefinidas (fijo, SS, GSS, TSS y FAC2) y también hace posible la creación de nuevas estrategias de asignación. El módulo genera unidades de trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, según la política de asignación elegida. Distribuir unidades de trabajo es el módulo responsable de la comunicación entre los nodos maestros y esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, los informes de generación del módulo obtienen las salidas intermedias enviadas por los nodos esclavos a través de la transferencia de archivos y los fusiona en un informe de salida de explosión única. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia que se comparará y elige la estrategia de asignación. El nodo maestro inicia la ejecución y espera las conexiones de esclavos. Para comenzar a procesar, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir conexiones de los esclavos, el maestro les notifica sobre sus segmentos iniciales para comparar. El esclavo procesa los segmentos de base de datos τ y notifica al maestro, que utiliza las últimas notificaciones Ω para calcular el siguiente tamaño del bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informando a sus nuevos segmentos para procesar. Este flujo continúa hasta que se procesan todos los segmentos.6. Resultados experimentales El paquete de paquetes se evaluó en un lecho de prueba de cuadrícula de 16 nodos, compuesto por dos laboratorios, interconectados por una red local. Se utilizaron once escritorios (P01-11) y un cuaderno (NB) en Labpos y se usaron cuatro escritorios (L01-04) en Laico (Tabla 2). Todos los nodos de la cuadrícula usaron Linux con Globus 3.2.1, NCBI Blast 2.2.10 y Java VM 1.4.2. Tabla 2: Características del lecho de prueba de la cuadrícula. Nombres de nodos CPU Memoria principal HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB Para investigar la cepa de rendimiento Ganesde PackageBlast, ejecutamos Blastx en nodos de cuadrícula 2, 4, 8 y 16. Cada búsqueda de explosión comparó una secuencia de ADN real de 10kbp con la base de datos genética NR de 1.2GB segmentada en 167 partes de 5 MB cada una. Se emplearon estrategias de asignación fija, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la Tabla 3. Tabla 3: Tiempos de ejecución para Blastx. Estrategia 2 nodos 4 nodos 8 nodos 16 nodos fijados 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Tabla 4 Presenta tiempos de ejecución en una sola máquina y agitación absoluta para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número determinado de nodos. Para calcular las velocidades absolutas, la versión secuencial de BLAST se ejecutó con la base de datos no segmentada NR. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. Nodo Seqtime 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30 30.00 00 00 00 00 00T. Teniendo en cuenta el peor nodo (L04), promedio (P01) y Best (NB) en la cuadrícula, las velocidades obtenidas fueron superlineales, cerca de lineal y sublineal, respectivamente. En la Tabla 3, también se puede notar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBlast con 16 nodos de cuadrícula, introduciendo la carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de la explosión y consistió en la ejecución 159 de FormatDB en la base de datos NR. Se simularon tres escenarios (Tabla 5): 1) con la estrategia de PSS, pero sin carga de trabajo;2) con la estrategia de PSS y la carga de trabajo (PSS 2X), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración precedente;y 3) ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. La ganancia es la comparación de sin PSS con la estrategia de PSS 2X con PSS PSS 2X sin PSS ganancia fija 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% AS del queEsperado, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijos y GSS) obtuvieron un gran beneficio al usar PSS. Esto se debe al hecho de que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5,56% en su tiempo de ejecución. PSS usa dos parámetros: τ y Ω (Sección 5.2). Variamos estos parámetros para evaluar el comportamiento de PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (FormatDB) cuando comienza la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo del caso anterior, pero continuó hasta el final. El objetivo era evaluar las tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: ganancia porcentual obtenida por PSS variando los parámetros τ y ω. En el escenario 1, cuando se considera una historia muy reciente (τ = 1 y ω = 1), PSS intenta adaptarse a una situación que desaparecerá en breve. Para τ = 5 y ω = 4, PSS tarda más en notar la modificación y las tareas de corta duración tienen un bajo impacto. Por otro lado, en el escenario 2, τ = 1, Ω = 1 presenta mejores resultados que τ = 5, ω = 4, porque cambia los pesos más rápido.7. Conclusión En este artículo, propusimos y evaluamos PackageBlast, un servicio adaptativo de cuadrícula múltiple para ejecutar búsquedas maestro/esclavas. PackageBlast contiene un marco donde el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de cuadrícula no dedicado heterogéneo. Los resultados recopilados ejecutando PackageBlast con 5 políticas de asignación en un lecho de prueba de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10kbp con la base de datos genética NR, pudimos reducir el tiempo de ejecución de 30.88 min a 2.11 min. Además, demostramos que, en nuestro Bed Test, no existe una política de asignación que siempre logre el mejor rendimiento y que sea evidente la importancia de proporcionar múltiples políticas. Además, mostramos que la introducción de PSS condujo a muy buenas ganancias de rendimiento para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBlast en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de la base de datos genómica y las operaciones dinámicas de unión/licencia para esclavos.8. Referencias [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineación local. Journal of Molecular Biology, 215: 403-410, 1990. [2] A. Darling, L. Carey y W. Feng. El diseño, implementación y evaluación de Mpiblast.4ta Conferencia Internacional sobre Clusters de Linux, 2003. [3] S. F. A. et al. BLAST BLAST y PSI-BLAST: una nueva generación de programas de búsqueda de bases de datos de proteínas. Nucleic Acids Research, 25 (17): 3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: un kit de herramientas de infraestructura metacomputación. Revista Internacional de Aplicaciones de Supercomputador, 11 (2): 115-128, 1997. [5] I. Foster y C. Kesselman. La cuadrícula: plan de una futura infraestructura informática. Morgan-Kauffman, 1999. [6] W. Gish. Washington University Blast.http://blast.wustl.edu, 1996-2002.[7] D. Gusfield. Algoritmos en cuerdas, árboles y secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factoring: un método para programar bucles paralelos. Comunicaciones de la ACM, 35 (8): 90-101, 1992. [9] A. Krishnan. Gridblast: explosión de alto rendimiento en la cuadrícula. Simposio sobre biocomputación, enero de 2003. [10] D. Peng., W. Yan y Z. Lei. Paralelización de Blast ++. Informe técnico, Singapur-Mit, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Auto-scheduling guiado: un esquema de programación práctica para supercomputadoras paralelas. Transacciones IEEE en computadoras, 36 (12): 1425-1439, diciembre de 1987. [12] M. K. Satish y R. R. Joshi. GBTK: un conjunto de herramientas para la implementación de la red de BLAST.7ª Conferencia Internacional HPCasia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones de maestría/trabajador en recursos computacionales distribuidos. Tesis doctoral, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147: 195-197, 1981. [15] P. Tang y P. C. Yew. Procesador Auto-scheduling para múltiples bucles paralelos anidados. En int. Conf.En el procesamiento paralelo (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Auto-sheduling trapezoidal: un esquema práctico para compiladores paralelos. Transacciones IEEE en sistemas paralelos y distribuidos, 4 (1): 87-98, enero de 1993. 160