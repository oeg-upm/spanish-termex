Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47

Grupo Burton, 2005. 47