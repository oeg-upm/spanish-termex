Un Sistema Multiagente para la Construcción de Ontologías Dinámicas Kévin Ottens ∗ IRIT, Université Paul Sabatier 118 Route de Narbonne F-31062 TOULOUSE ottens@irit.fr Marie-Pierre Gleizes IRIT, Université Paul Sabatier 118 Route de Narbonne F-31062 TOULOUSE gleizes@irit.fr Pierre Glize IRIT, Université Paul Sabatier 118 Route de Narbonne F-31062 TOULOUSE glize@irit.fr RESUMEN La construcción de ontologías a partir de texto sigue siendo una tarea que consume mucho tiempo, lo que justifica el crecimiento del Aprendizaje de Ontologías. Nuestro sistema llamado Dynamo está diseñado dentro de este dominio, pero siguiendo un enfoque original basado en una arquitectura multiagente adaptativa. En este artículo presentamos un algoritmo de agrupamiento jerárquico distribuido, núcleo de nuestro enfoque. Se evalúa y se compara con un algoritmo centralizado más convencional. También presentamos cómo ha sido mejorado utilizando un enfoque de múltiples criterios. Con esos resultados en mente, discutimos los límites de nuestro sistema y añadimos como perspectivas las modificaciones necesarias para alcanzar una solución completa de construcción de ontologías. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente Términos Generales Algoritmos, Experimentación 1. INTRODUCCIÓN En la actualidad, está bien establecido que las ontologías son necesarias para la web semántica, la gestión del conocimiento, B2B... Para la gestión del conocimiento, las ontologías se utilizan para anotar documentos y mejorar la recuperación de información. Pero construir una ontología manualmente es un proceso lento, tedioso, costoso, complejo y que consume mucho tiempo. Actualmente, un verdadero desafío radica en construirlos de forma automática o semiautomática y mantenerlos actualizados. Significaría crear ontologías dinámicas [10] y justifica la aparición de técnicas de aprendizaje de ontologías [14] [13]. Nuestra investigación se centra en Dynamo (acrónimo de DYNAMic Ontologies), una herramienta basada en un sistema multiagente adaptativo para construir y mantener una ontología a partir de un conjunto específico de textos de un dominio. Nuestro objetivo no es construir una ontología jerárquica exhaustiva y general, sino una específica para un dominio. Proponemos una herramienta semi-automatizada ya que se requiere un recurso externo: el ontólogo. Un ontólogo es una especie de ingeniero cognitivo, o analista, que utiliza información de textos y entrevistas con expertos para diseñar ontologías. En el campo de los agentes múltiples, las ontologías generalmente permiten que los agentes se entiendan entre sí [12]. A veces se utilizan para facilitar el proceso de construcción de la ontología, en particular en contextos colaborativos [3], pero rara vez representan la ontología en sí misma [16]. La mayoría de los trabajos interesados en la construcción de ontologías [7] proponen el refinamiento de las ontologías. Este proceso consiste en utilizar una ontología existente y construir una nueva a partir de ella. Este enfoque es diferente de nuestro enfoque porque Dynamo comienza desde cero. Los investigadores, que trabajan en la construcción de ontologías a partir de textos, afirman que el trabajo a automatizar requiere recursos externos como un diccionario [14] o acceso a la web [5]. En nuestro trabajo, proponemos una interacción entre el ontólogo y el sistema, nuestro recurso externo radica tanto en los textos como en el ontólogo. Este documento primero presenta, en la sección 2, la visión general del sistema Dynamo. En particular, los motivos que llevaron a su creación y su arquitectura general. Luego, en la sección 3 discutimos el algoritmo de clustering distribuido utilizado en Dynamo y lo comparamos con un enfoque más clásico y centralizado. La sección 4 está dedicada a mejorar el comportamiento de los agentes que fue diseñado teniendo en cuenta criterios ignorados por el agrupamiento. Y finalmente, en la sección 5, discutimos las limitaciones de nuestro enfoque y explicamos cómo se abordarán en trabajos futuros. DYNAMO RESUMEN 2.1 Ontología como un Sistema Multiagente Dynamo tiene como objetivo reducir la necesidad de acciones manuales en el procesamiento de los resultados del análisis de texto y sugerir un inicio de red conceptual para construir ontologías de manera más eficiente. El enfoque elegido es completamente original en nuestro conocimiento y utiliza un sistema multiagente adaptativo. Esta elección se basa en las cualidades ofrecidas por el sistema multiagente: pueden facilitar el diseño interactivo de un sistema (en nuestro caso, una red conceptual), permiten su construcción incremental al tener en cuenta progresivamente nuevos datos (provenientes del análisis de texto y la interacción del usuario) y, por último pero no menos importante, pueden distribuirse fácilmente a través de una red informática. Dynamo realiza un análisis sintáctico y terminológico de textos como entrada. Utiliza varios criterios basados en estadísticas calculadas a partir de los contextos lingüísticos de los términos para crear y posicionar los conceptos. Como resultado, Dynamo proporciona al analista una organización jerárquica de conceptos (el sistema multiagente en sí mismo) que puede ser validada, refinada o modificada, hasta que obtenga un estado satisfactorio de la red semántica. Una ontología puede ser vista como un mapa estable constituido por entidades conceptuales, representadas aquí por agentes, vinculadas por relaciones etiquetadas. Por lo tanto, nuestro enfoque considera una ontología como un tipo de equilibrio entre sus concepto-agentes, donde sus fuerzas están definidas por sus relaciones potenciales. La modificación de la ontología es una perturbación del equilibrio previo por la aparición o desaparición de agentes o relaciones. De esta manera, una ontología dinámica es un proceso de autoorganización que ocurre cuando se incluyen nuevos textos en el corpus, o cuando el ontólogo interactúa con él. Para apoyar la flexibilidad necesaria de dicho sistema, utilizamos un sistema multiagente autoorganizado basado en un enfoque cooperativo [9]. Seguimos el método ADELFE [4] propuesto para guiar el diseño de este tipo de sistema multiagente. Se justifica cómo diseñamos algunas de las reglas utilizadas por nuestros agentes para maximizar el grado de cooperación dentro del sistema multiagente de Dynamos. 2.2 Arquitectura Propuesta En esta sección, presentamos nuestra arquitectura del sistema. Aborda las necesidades de la Ingeniería del Conocimiento en el contexto de la gestión y mantenimiento dinámico de ontologías cuando la ontología está vinculada a una colección de documentos. El sistema Dynamo consta de tres partes (cf. figura 1): • una red de términos, obtenida gracias a una herramienta de extracción de términos utilizada para preprocesar el corpus textual, • un sistema multiagente que utiliza la red de términos para realizar un agrupamiento jerárquico con el fin de obtener una taxonomía de conceptos, • una interfaz que permite al ontólogo visualizar y controlar el proceso de agrupamiento. El extractor de términos que utilizamos es Syntex, un software que ha sido utilizado eficientemente para tareas de construcción de ontologías [11]. Principalmente lo seleccionamos por su robustez y la gran cantidad de información extraída. En particular, crea una red de Expansión de Cabeza que ya ha demostrado ser interesante para un sistema de agrupamiento [1]. En una red de este tipo, cada término está vinculado a su término principal y, es decir, a la subfrase máxima ubicada como término principal de su término de expansión, y también a todos los términos para los cuales es un término principal o un término de expansión. Por ejemplo, la ingeniería del conocimiento a partir de texto tiene como término principal la ingeniería del conocimiento y como término de expansión el texto. Además, la ingeniería del conocimiento se compone del conocimiento como término principal y la ingeniería como término de expansión. Con Dynamo, el término de red obtenido como resultado del extractor se almacena en una base de datos. Para cada par de términos, asumimos que es posible calcular un valor de similitud para realizar un agrupamiento [6] [1]. Debido a la naturaleza de los datos, nos estamos enfocando únicamente en la computación de similitud entre objetos descritos gracias a variables binarias, lo que significa que cada elemento está descrito por la presencia o ausencia de un conjunto de características [15]. En el caso de los términos, generalmente estamos tratando con sus contextos de uso. Con Syntex, esos contextos son identificados por términos y caracterizados por algunas relaciones sintácticas. El sistema multiagente Dynamo implementa el algoritmo de clustering distribuido descrito en detalle en la sección 3 y las reglas descritas en la sección 4. Está diseñado para ser tanto el sistema que produce la estructura resultante como la estructura en sí misma. Significa que cada agente representa una clase en la taxonomía. Entonces, la salida del sistema es la organización obtenida a partir de la interacción entre agentes, teniendo en cuenta la retroalimentación proveniente del ontólogo cuando modifica la taxonomía dada sus necesidades o experiencia. CLUSTERING DISTRIBUIDO Esta sección presenta el algoritmo de clustering distribuido utilizado en Dynamo. Por el bien de la comprensión, y debido a su evaluación en la sección 3.1, recordamos el algoritmo centralizado básico utilizado para un agrupamiento jerárquico ascendente en un espacio no métrico, cuando se dispone de una medida de similitud simétrica [15] (que es el caso de las medidas utilizadas en nuestro sistema). Algoritmo 1: Algoritmo de agrupamiento jerárquico ascendente centralizado Datos: Lista L de elementos para organizar como una jerarquía Resultado: Raíz R de la jerarquía mientras longitud(L) > 1 hacer max ← 0; A ← nil; B ← nil; para i ← 1 a longitud(L) hacer I ← L[i]; para j ← i + 1 a longitud(L) hacer J ← L[j]; sim ← similitud(I, J); si sim > max entonces max ← sim; A ← I; B ← J; fin si fin para fin para quitar(A, L); quitar(B, L); agregar((A, B), L); fin mientras R ← L[1]; En el algoritmo 1, para cada paso de agrupamiento, se determina el par de elementos más similares. Esos dos elementos están agrupados en un conjunto, y la clase resultante se añade a la lista de elementos restantes. Este algoritmo se detiene cuando la lista tiene solo un elemento restante. 2 es decir, la subfrase máxima ubicada como cola del término The Sixth Intl. La jerarquía resultante del algoritmo 1 siempre es un árbol binario debido a la forma en que se realiza el agrupamiento. Además, agrupar los elementos más similares es equivalente a alejarlos de los menos similares. Nuestro algoritmo distribuido está diseñado basándose en esos dos hechos. Se ejecuta de forma simultánea en cada uno de los agentes del sistema. Cabe destacar que, en lo que sigue de este artículo, utilizamos para ambos algoritmos una similitud de Anderberg (con α = 0.75) y una estrategia de agrupamiento de enlace promedio [15]. Esas decisiones tienen un impacto en el árbol resultante, pero no afectan ni la ejecución global del algoritmo ni su complejidad. Ahora presentamos el algoritmo distribuido utilizado en nuestro sistema. Se inicia de la siguiente manera: • se crea un agente TOP que no tiene padre, será la raíz de la taxonomía resultante, • se crea un agente para cada término que se va a posicionar en la taxonomía, todos tienen como padre a TOP. Una vez que se establece esta estructura básica, el algoritmo se ejecuta hasta que alcanza el equilibrio y luego proporciona la taxonomía resultante. El proceso de la primera etapa (figura 2) se activa cuando un agente (aquí Ak) tiene más de un hermano (ya que queremos obtener un árbol binario). Luego envía un mensaje a su padre P indicando a su hermano más diferente (aquí A1). Entonces P recibe el mismo tipo de mensaje de cada uno de sus hijos. En lo siguiente, este tipo de mensaje se llamará voto. A continuación, cuando P ha recibido mensajes de todos sus hijos, comienza el segundo paso (figura 3). Gracias a los mensajes recibidos que indican las preferencias de sus hijos, P puede determinar tres subgrupos entre sus hijos: el hijo que recibió más votos de sus hermanos, es decir, el hijo que es más diferente del mayor número de sus hermanos. En caso de empate, uno de los ganadores es elegido al azar (aquí A1), los niños que permitieron la elección del primer grupo, es decir, los agentes que eligieron a su hermano del primer grupo como el más diferente (aquí Ak a An), los niños restantes (aquí A2 a Ak−1). Entonces P crea un nuevo agente P (teniendo a P como padre) y pide a los agentes del segundo grupo (aquí los agentes Ak a An) que lo elijan como su nuevo padre. Ak−1 Ak AnA2A1 P P ...... ...... 

Ak−1 Ak AnA2A1 P P ...... ...... Figura 4: Agrupamiento distribuido: Paso 3 Finalmente, el paso 3 (figura 4) es trivial. Los niños rechazados por P (aquí el agente A2 a An) tienen en cuenta su mensaje y eligen a P como su nuevo padre. La jerarquía acaba de crear un nuevo nivel intermedio. Ten en cuenta que este algoritmo generalmente converge, ya que el número de hermanos de un agente disminuye. Cuando un agente tiene solamente un hermano restante, su actividad se detiene (aunque sigue procesando los mensajes que llegan de sus hijos). Sin embargo, en algunos casos podemos llegar a un conflicto circular en el procedimiento de votación cuando, por ejemplo, A vota en contra de B, B en contra de C y C en contra de A. Con el sistema actual no se puede tomar ninguna decisión. El procedimiento actual debería mejorarse para abordar esto, probablemente utilizando un método de votación clasificado. 3.1 Evaluación Cuantitativa Ahora, evaluamos las propiedades de nuestro algoritmo distribuido. Se requiere comenzar con una evaluación cuantitativa, basada en su complejidad, mientras se compara con el algoritmo 1 de la sección anterior. Su complejidad teórica se calcula para el peor caso, considerando la operación de cálculo de similitud como elemental. Para el algoritmo distribuido, el peor caso significa que en cada ejecución, solo se puede crear un grupo de dos elementos. Bajo esas condiciones, para un conjunto de datos dado de n elementos, podemos determinar la cantidad de cálculos de similitud. Para el algoritmo 1, notamos que l = longitud(L), luego el bucle más interno se ejecuta l - i veces. Y su cuerpo tiene la única computación de similitud, por lo que su costo es l−i. El segundo bucle for se ejecuta l veces para i que varía de 1 a l. Entonces su costo es Pl i=1(l − i) que puede simplificarse en l×(l−1) 2. Finalmente, para cada ejecución del bucle while, l se reduce de n a 1, lo que nos da t1(n) como la cantidad de cálculos de similitud para el algoritmo 1: t1(n) = nX l=1 l × (l − 1) 2 (1) Para el algoritmo distribuido, en un paso dado, cada uno de los l agentes evalúa la similitud con sus l −1 compañeros. Entonces, cada paso tiene un costo de l × (l − 1). Entonces, se crean grupos y se realiza otra votación con l disminuido en uno (ya que asumimos el peor caso, solo se forman grupos de tamaño 2 o l −1). Dado que l es igual a n en la primera ejecución, obtenemos tdist(n) como la cantidad de cálculos de similitud para el algoritmo distribuido: tdist(n) = nX l=1 l × (l − 1) (2) Ambos algoritmos tienen una complejidad O(n3). Pero en el peor de los casos, el algoritmo distribuido realiza el doble del número de el1288 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) operaciones elementales realizadas por el algoritmo centralizado. Esta brecha proviene de la toma de decisiones local en cada agente. Debido a esto, los cálculos de similitud se realizan dos veces para cada par de agentes. Podríamos concebir que un agente envía el resultado de su cálculo a su par. Sin embargo, simplemente trasladaría el problema al generar más comunicación en el sistema. 0 20000 40000 60000 80000 100000 120000 140000 160000 180000 10 20 30 40 50 60 70 80 90 100 Cantidad de comparaciones Cantidad de términos de entrada 1. Algoritmo distribuido (en promedio, con mínimo y máximo) 2. Polinomio logarítmico 3. En la Figura 5 se muestra el algoritmo centralizado: Resultados experimentales. En un segundo paso, la complejidad promedio del algoritmo ha sido determinada mediante experimentos. El sistema multiagente ha sido ejecutado con conjuntos de datos de entrada generados aleatoriamente que van desde diez hasta cien términos. El valor dado es el promedio de las comparaciones realizadas para cien ejecuciones sin interacción del usuario. Resulta en las gráficas de la figura 5. El algoritmo es entonces más eficiente en promedio que el algoritmo centralizado, y su complejidad promedio está por debajo del peor caso. Se puede explicar por la baja probabilidad de que un conjunto de datos obligue al sistema a crear solo grupos mínimos (dos elementos) o máximos (n − 1 elementos) para cada paso de razonamiento. La curva número 2 representa el polinomio logarítmico que minimiza el error con respecto a la curva número 1. El término de mayor grado de este polinomio es n2 log(n), por lo tanto, nuestro algoritmo distribuido tiene una complejidad O(n2 log(n)) en promedio. Finalmente, notemos la reducida variación de las actuaciones promedio con el máximo y el mínimo. En el peor caso para 100 términos, la variación es de 1,960.75 para un promedio de 40,550.10 (alrededor del 5%), lo que muestra la buena estabilidad del sistema. Aunque los resultados cuantitativos son interesantes, la verdadera ventaja de este enfoque proviene de características más cualitativas que presentaremos en esta sección. Todos son ventajas obtenidas gracias al uso de un sistema multiagente adaptativo. La principal ventaja del uso de un sistema multiagente para una tarea de agrupamiento es introducir dinamismo en dicho sistema. El ontólogo puede hacer modificaciones y la jerarquía se adapta dependiendo de la solicitud. Es particularmente interesante en un contexto de ingeniería del conocimiento. De hecho, la jerarquía creada por el sistema está destinada a ser modificada por el ontólogo ya que es el resultado de un cálculo estadístico. Durante la revisión necesaria de los textos para examinar los contextos de uso de los términos [2], el ontólogo podrá interpretar el contenido real y revisar la propuesta del sistema. Es extremadamente difícil lograr esto con un enfoque centralizado de caja negra. En la mayoría de los casos, uno tiene que encontrar qué paso de razonamiento generó el error y modificar manualmente la clase resultante. Desafortunadamente, en este caso, todos los pasos de razonamiento que ocurrieron después de la creación de la clase modificada se pierden y deben ser recalculados teniendo en cuenta la modificación. Por eso, un sistema como ASIUM [6] intenta suavizar el problema con una colaboración entre el sistema y el usuario mostrando al ontólogo las clases creadas después de cada paso de razonamiento. Pero el ontólogo puede cometer un error y darse cuenta de ello demasiado tarde. Figura 6: Árbol de agentes conceptuales después de la estabilización autónoma del sistema. Para ilustrar nuestras afirmaciones, presentamos un ejemplo gracias a algunas capturas de pantalla del prototipo en funcionamiento probado en un corpus relacionado con la medicina. Al utilizar datos de prueba y permitir que el sistema funcione por sí mismo, obtenemos la jerarquía de la figura 6 después de la estabilización. Es evidente que el concepto descrito por el término lesión está mal ubicado. Las computaciones de similitud lo sitúan más cerca de femme (mujer) y chirurgien (cirujano) que de infección, gastro-enteritis y hepatitis. Esta posición incorrecta para la lesión se explica por el hecho de que sin la entrada del ontólogo, el razonamiento se basa únicamente en criterios estadísticos. Figura 7: Árbol de agentes conceptuales después de la modificación del ontólogo. Luego, el ontólogo reemplaza el concepto en la rama derecha, afectando a ConceptAgent:8 como su nuevo padre. El nombre ConceptAgent:X se asigna automáticamente a un agente conceptual que no está descrito por un término. El sistema reacciona por sí mismo y perfecciona la jerarquía de agrupación para obtener un árbol binario creando ConceptAgent:11. El nuevo estado estable es el de la figura 7. Este acoplamiento sistema-usuario es necesario para construir una ontología, pero no se necesita ningún ajuste particular al principio del algoritmo distribuido ya que cada agente realiza un procesamiento local autónomo y se comunica con su vecindario a través de mensajes. Además, este algoritmo puede ser distribuido de facto en una red de computadoras. La comunicación entre agentes se realiza enviando mensajes y cada uno mantiene su autonomía de decisión. Entonces, una modificación del sistema para hacerlo funcionar en red no requeriría ajustar el algoritmo. Por el contrario, solo sería necesario reestructurar la capa de comunicación y el proceso de creación de agentes, ya que en nuestra implementación actual no están en red. 4. EN LA JERARQUÍA DE MÚLTIPLES CRITERIOS En las secciones anteriores, asumimos que la similitud se puede calcular para cualquier par de términos. Pero, tan pronto como se utilizan datos reales, esta propiedad ya no se verifica. Algunos términos no tienen ningún valor de similitud con ningún término extraído. Además, para los nodos hoja a veces es interesante utilizar otros medios para posicionarlos en la jerarquía. Para esta estructuración de bajo nivel, los ontólogos generalmente se basan en The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1289 sus elecciones en heurísticas simples. Usando esta observación, construimos un nuevo conjunto de reglas, que no se basan en la similitud para respaldar la estructuración de bajo nivel. 4.1 Agregar reglas de cobertura de cabeza En este caso, los agentes pueden actuar con un punto de vista muy local simplemente mirando la relación padre/hijo. Cada agente puede intentar determinar si su padre es adecuado. Es posible adivinar esto porque cada agente conceptual está descrito por un conjunto de términos y gracias a la red de términos de Expansión de Cabeza. En el siguiente TX será el conjunto de términos que describen el concepto del agente X y head(TX) el conjunto de todos los términos que son cabeza de al menos un elemento de TX. Gracias a esas dos notaciones podemos describir la función de adecuación entre un padre P y un hijo C: a(P, C) = |TP ∩ head(TC )| |TP ∪ head(TC )| (3) Entonces, el mejor padre para C es el agente P que maximiza a(P, C). Un agente insatisfecho con su padre puede intentar encontrar uno mejor evaluando la idoneidad de los candidatos. Diseñamos un algoritmo complementario para dirigir esta búsqueda: cuando un agente C no está satisfecho con su padre P, evalúa a(Bi, C) con todos sus hermanos (notados Bi); luego se elige como nuevo padre aquel que maximice a(Bi, C). Figura 8: Árbol de agentes conceptuales después de la estabilización autónoma del sistema sin la regla de cobertura de cabeza. Ahora ilustramos este comportamiento de regla con un ejemplo. La Figura 8 muestra el estado del sistema después de la estabilización en los datos de prueba. Podemos notar que la hepatitis viral todavía está vinculada a la raíz taxonómica. Se debe al hecho de que no hay valor de similitud entre el término hepatitis viral y ninguno de los términos de los otros agentes conceptuales. Figura 9: Árbol de agentes conceptuales después de la activación de la regla de cobertura de la cabeza. Tras activar la regla de cobertura de la cabeza y permitir que el sistema se estabilice nuevamente, obtenemos la figura 9. Podemos ver que la hepatitis viral se deslizó a través de la rama que llevaba a la hepatitis y la eligió como su nueva progenitora. Es una elección por defecto sensata, ya que la hepatitis viral es un término más específico que la hepatitis. Esta regla tiende a hacer que los agentes descritos por un conjunto de términos se conviertan en hojas del árbol conceptual. Aborda nuestra preocupación por mejorar la estructuración de bajo nivel de nuestra taxonomía. Pero obviamente nuestros agentes carecen de un método para retroceder en caso de modificaciones en la taxonomía que los ubicarían en la rama incorrecta. Ese es uno de los puntos en los que nuestro sistema aún debe ser mejorado al agregar otro conjunto de reglas. 4.2 Sobre el uso de varios criterios En las secciones y ejemplos anteriores, solo utilizamos un algoritmo a la vez. El algoritmo de agrupamiento distribuido tiende a introducir nuevas capas en la taxonomía, mientras que el algoritmo de cobertura de cabeza tiende a empujar algunos de los agentes hacia las hojas de la taxonomía. Obviamente plantea la pregunta sobre cómo lidiar con múltiples criterios en la construcción de nuestra taxonomía, y cómo los agentes determinan sus prioridades en un momento dado. La solución que elegimos proviene de la búsqueda de minimizar la falta de cooperación dentro del sistema de acuerdo con el método ADELFE. Cada agente calcula tres grados de no cooperación y elige su prioridad actual dependiendo de cuál grado sea el más alto. Para un agente A dado que tiene un padre P, un conjunto de hermanos Bi y que recibió un conjunto de mensajes Mk con prioridad pk, los tres grados de no cooperación son: • μH (A) = 1 − a(P, A), es el grado de no cooperación de cobertura de cabeza, determinado por la cobertura de cabeza del padre, • μB(A) = max(1 − similitud(A, Bi)), es el grado de no cooperación de hermandad, determinado por el peor hermano de A en cuanto a similitudes, • μM (A) = max(pk), es el grado de no cooperación de mensaje, determinado por el mensaje más urgente recibido. Entonces, el grado de no cooperación μ(A) del agente A es: μ(A) = max(μH (A), μB(A), μM (A)) (4) Luego, tenemos tres casos que determinan qué tipo de acción elegirá A: • si μ(A) = μH (A) entonces A utilizará el algoritmo de cobertura de cabeza que detallamos en la subsección anterior • si μ(A) = μB(A) entonces A utilizará el algoritmo de agrupamiento distribuido (ver sección 3) • si μ(A) = μM (A) entonces A procesará Mk inmediatamente para ayudar a su remitente Estos tres casos resumen las actividades actuales de nuestros agentes: tienen que encontrar el mejor padre para ellos (μ(A) = μH (A)), mejorar la estructuración a través del agrupamiento (μ(A) = μB(A)) y procesar otros mensajes de agentes (μ(A) = μM (A)) para ayudarlos a cumplir sus propios objetivos. 4.3 Complejidad Experimental Revisitada Evaluamos la complejidad experimental de todo el sistema multiagente cuando todas las reglas están activadas. En este caso, la métrica utilizada es el número de mensajes intercambiados en el sistema. Una vez más, el sistema ha sido ejecutado con conjuntos de datos de entrada que van desde diez hasta cien términos. El valor dado es el promedio del número de mensajes enviados en el sistema en su totalidad durante cien ejecuciones sin interacción del usuario. Resulta en las gráficas de la figura 10. La curva número 1 representa el promedio del valor obtenido. La curva número 2 representa el promedio del valor obtenido cuando solo se activa el algoritmo de agrupamiento distribuido, no el conjunto completo de reglas. La curva número 3 representa el polinomio que minimiza el error con la curva número 1. El término de mayor grado de este polinomio es en n3, entonces nuestro sistema multiagente tiene una complejidad O(n3). Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 0 5000 10000 15000 20000 25000 10 20 30 40 50 60 70 80 90 100 Cantidad de mensajes Cantidad de términos de entrada 1. Dinamo, todas las reglas (en promedio, con mínimo y máximo) 2. Agrupamiento distribuido solo (en promedio) 2. Figura 10: Resultados experimentales en promedio de un polinomio cúbico. Además, notemos la variación muy pequeña de las actuaciones promedio con el máximo y el mínimo. En el peor caso para 100 términos, la variación es de 126.73 para un promedio de 20,737.03 (alrededor del 0.6%), lo que demuestra la excelente estabilidad del sistema. Finalmente, las reglas adicionales de cobertura de cabeza son una verdadera mejora sobre el algoritmo distribuido por sí solo. Introducen más restricciones y se alcanza el punto de estabilidad con menos interacciones y toma de decisiones por parte de los agentes. Significa que se intercambian menos mensajes en el sistema al obtener un árbol de mayor calidad para el ontólogo. 5. DISCUSIÓN Y PERSPECTIVAS 5.1 Limitación actual de nuestro enfoque La limitación más importante de nuestro algoritmo actual es que el resultado depende del orden en que se agregan los datos. Cuando el sistema funciona por sí solo en un conjunto de datos fijo proporcionado durante la inicialización, el resultado final es equivalente a lo que podríamos obtener con un algoritmo centralizado. Por el contrario, añadir un nuevo elemento después de una primera estabilización tiene un impacto en el resultado final. Figura 11: Árbol de agentes conceptuales después de la estabilización autónoma del sistema. Para ilustrar nuestras afirmaciones, presentamos otro ejemplo del sistema en funcionamiento. Al utilizar datos de prueba y permitir que el sistema funcione por sí mismo, obtenemos la jerarquía de la figura 11 después de la estabilización. Figura 12: Árbol de agentes conceptuales después de tener en cuenta la hepatitis. Luego, el ontólogo interactúa con el sistema y agrega un nuevo concepto descrito por el término hepatitis y vinculado a la raíz. El sistema reacciona y se estabiliza, luego obtenemos la figura 12 como resultado. La hepatitis se encuentra en la rama derecha, pero no hemos obtenido la misma organización que la figura 6 del ejemplo anterior. Necesitamos mejorar nuestro algoritmo distribuido para permitir que un concepto se mueva a lo largo de una rama. Actualmente estamos trabajando en las reglas requeridas, pero la comparación con el algoritmo centralizado se volverá muy difícil. En particular, ya que tendrán en cuenta criterios ignorados por el algoritmo centralizado. 5.2 Poda para la construcción de ontologías En la sección 3, presentamos el algoritmo de agrupamiento distribuido utilizado en el sistema Dynamo. Dado que este trabajo se basó inicialmente en este algoritmo, introdujo un claro sesgo hacia los árboles binarios como resultado. Pero debemos tener en cuenta que estamos tratando de obtener taxonomías que sean más refinadas y concisas. Aunque la regla de cobertura de la cabeza es una mejora porque se basa en cómo generalmente trabajan los ontólogos, solo aborda la estructuración a un nivel bajo y no a los niveles intermedios del árbol. Al observar la figura 7, es evidente que se podría realizar una poda en la taxonomía. En particular, dado que la lesión se movió, el ConceptAgent:9 podría ser eliminado, ya no es necesario. Además, la rama que comienza con ConceptAgent:8 respeta claramente la restricción de formar un árbol binario, pero sería más útil para el usuario en una forma más compacta y significativa. En este caso, ConceptAgent:10 y ConceptAgent:11 probablemente podrían fusionarse. Actualmente, nuestro sistema cuenta con las reglas necesarias para crear niveles intermedios en la taxonomía, o para que los conceptos se desplacen hacia la hoja. Como señalamos, no es suficiente, por lo que se necesitan nuevas reglas para permitir eliminar nodos del árbol o moverlos hacia la raíz. La mayor parte del trabajo necesario para desarrollar esas reglas consiste en encontrar la información estadística relevante que respaldará al ontólogo. CONCLUSIÓN Después de ser presentada como una solución prometedora, garantizar la calidad del modelo y su riqueza terminológica, la construcción de ontologías a partir del análisis de corpus textual es difícil y costosa. Requiere supervisión del analista y tener en cuenta el objetivo de la ontología. El uso de herramientas de procesamiento de lenguaje natural facilita la localización del conocimiento en textos a través del uso del lenguaje. Dicho esto, esas herramientas producen una gran cantidad de datos léxicos o gramaticales que no son triviales de examinar para definir elementos conceptuales. Nuestra contribución radica en este paso del proceso de modelado a partir de textos, antes de intentar normalizar o formalizar el resultado. Propusimos un enfoque basado en un sistema multiagente adaptativo para proporcionar al ontólogo una primera estructura taxonómica de conceptos. Nuestro sistema hace uso de una red terminológica resultante de un análisis realizado por Syntex. El estado actual de nuestro software permite producir estructuras simples, proponérselas al ontólogo y hacerlas evolucionar dependiendo de las modificaciones que él realice. Las actuaciones del sistema son interesantes y algunos aspectos son incluso comparables a su contraparte centralizada. Sus fortalezas son principalmente cualitativas ya que permite interacciones de usuario más sutiles y una adaptación progresiva a nueva información basada en el lenguaje. Desde el punto de vista de la construcción de la ontología, este trabajo es un primer paso que muestra la relevancia de nuestro enfoque. Debe continuar, tanto para garantizar una mejor robustez durante la clasificación, como para obtener estructuras semánticas más ricas que simples árboles. De estas mejoras, nos estamos enfocando principalmente en la poda para obtener mejores taxonomías. Actualmente estamos trabajando en el criterio para activar las acciones complementarias de los cambios de estructura aplicados por nuestro algoritmo de agrupamiento. En otras palabras, este algoritmo se introduce en el Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1291 niveles intermedios, y necesitamos poder eliminarlos si es necesario, para alcanzar un equilibrio dinámico. También desde el punto de vista de la ingeniería multiagente, su uso en un contexto de ontología dinámica ha demostrado su relevancia. Estas ontologías dinámicas pueden ser vistas como una resolución de problemas complejos, en tal caso la autoorganización a través de la cooperación ha sido una solución eficiente. Y, en general, es probable que sea interesante para otras tareas relacionadas con el diseño, incluso si nos estamos enfocando únicamente en la ingeniería del conocimiento en este artículo. Por supuesto, nuestro sistema aún requiere más trabajo de evaluación y validación para determinar con precisión las ventajas y desventajas de este enfoque. Estamos planeando trabajar en ese tipo de comparación en un futuro cercano. 7. REFERENCIAS [1] H. Assadi. Construcción de una ontología regional a partir de texto y su uso dentro de un sistema documental. Actas de la Conferencia Internacional sobre Ontología Formal y Sistemas de Información - FOIS98, páginas 236-249, 1998. [2] N. Aussenac-Gilles y D. Sörgel. Análisis de texto para ingeniería de ontologías y terminología. Revista de Ontología Aplicada, 2005. [3] J. Bao y V. Honavar. Construcción colaborativa de ontologías con wiki@nt. Actas del Taller de Evaluación de Herramientas Basadas en Ontologías (EON2004), 2004. [4] C. Bernon, V. Camps, M.-P. Gleizes y G. Picard. Metodologías Orientadas a Agentes, capítulo 7. Ingeniería de Sistemas Multiagente Autoadaptativos: la Metodología ADELFE, páginas 172-202. Idea Group Publishing, 2005. [5] C. Brewster, F. Ciravegna y Y. Wilks. Antecedentes y conocimiento previo en la construcción dinámica de ontologías. Taller de la Web Semántica, SIGIR03, agosto de 2003. [6] D. Faure y C. Nedellec. Un método de agrupamiento conceptual basado en corpus para marcos verbales y adquisición de ontologías. Taller LREC sobre la adaptación de recursos léxicos y corpus a sublenguajes y aplicaciones, 1998. [7] F. Gandon. Ingeniería de Ontologías: una Encuesta y un Retorno de Experiencia. INRIA, 2002. [8] J.-P. Georgé, G. Picard, M.-P. Gleizes y P. Glize. Diseño Vivo para Sistemas Computacionales Abiertos. 12º Talleres Internacionales de la IEEE sobre Tecnologías Habilitadoras, Infraestructura para Empresas Colaborativas, páginas 389-394, junio de 2003. [9] M.-P. Gleizes, V. Camps y P. Glize. Una teoría de computación emergente basada en la autoorganización cooperativa para sistemas artificiales adaptativos. Cuarto Congreso Europeo de Ciencias de los Sistemas, septiembre de 1999. [10] J. Heflin y J. Hendler. Ontologías dinámicas en la web. Conferencia de la Asociación Americana de Inteligencia Artificial, 2000. [11] S. Le Moigno, J. Charlet, D. Bourigault y M.-C. Jaulent. Extracción de terminología del texto para construir una ontología en cuidados intensivos quirúrgicos. Actas del simposio anual de la AMIA 2002, 2002. [12] K. Lister, L. Sterling y K. Taveter. Reconciliando diferencias ontológicas mediante agentes asistentes. AAMAS06, mayo de 2006. [13] A. Maedche. Aprendizaje de ontologías para la Web Semántica. Editorial Kluwer Academic, 2002. [14] A. Maedche y S. Staab. Extracción de ontologías a partir de texto. EKAW 2000, páginas 189-202, 2000. [15] C. D. Manning y H. Schütze. Fundamentos del Procesamiento del Lenguaje Natural Estadístico. El MIT Press, Cambridge, Massachusetts, 1999. [16] H. V. D. Parunak, R. Rohwer, T. C. Belding y S. Brueckner. Clustering jerárquico descentralizado dinámico en cualquier momento. 29ª Conferencia Internacional Anual de ACM SIGIR sobre Investigación y Desarrollo en Recuperación de Información, agosto de 2006. 1292 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)