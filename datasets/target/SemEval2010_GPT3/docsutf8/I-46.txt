Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \{xj} si xj ∈ f, y qi \{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but "Sistla" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. 

Traducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.

MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. 

Editorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)