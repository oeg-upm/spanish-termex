Un Enfoque Holístico para la Computación de Alto Rendimiento: Experiencia con Xgrid David Przybyla Escuela de Arte y Diseño Ringling 2700 North Tamiami Trail Sarasota, Florida 34234 941-309-4720 dprzybyl@ringling.edu Karissa Miller Escuela de Arte y Diseño Ringling 2700 North Tamiami Trail Sarasota, Florida 34234 941-359-7670 kmiller@ringling.edu Mahmoud Pegah Escuela de Arte y Diseño Ringling 2700 North Tamiami Trail Sarasota, Florida 34234 941-359-7625 mpegah@ringling.edu RESUMEN La Escuela de Arte y Diseño Ringling es un colegio de cuatro años completamente acreditado en artes visuales y diseño. Con una proporción de estudiantes por computadora mejor que 2 a 1, la Escuela Ringling ha logrado un reconocimiento nacional por su integración a gran escala de la tecnología en la educación universitaria de arte visual y diseño. Hemos descubierto que Mac OS X es el mejor sistema operativo para entrenar a futuros artistas y diseñadores. Además, ahora podemos comprar Macs para ejecutar gráficos de alta gama, edición de video no lineal, animación, multimedia, producción web y aplicaciones de video digital en lugar de costosas estaciones de trabajo UNIX. A medida que los artistas visuales pasan de la pintura en lienzo a crear en el ámbito digital, la demanda de un entorno informático de alto rendimiento aumenta. En nuestros laboratorios de computación públicos, los estudiantes utilizan las computadoras con mayor frecuencia durante el horario laboral; por la noche y los fines de semana, las computadoras solo se utilizan ligeramente. Para aprovechar el tiempo de procesamiento perdido en tareas como la renderización de video, estamos probando Xgrid, un conjunto de aplicaciones de Mac OS X recientemente desarrollado por Apple para computación de alto rendimiento en paralelo y distribuida. Como con cualquier implementación de nueva tecnología, los gerentes de IT necesitan considerar una serie de factores al evaluar, planificar e implementar Xgrid. Por lo tanto, nos gustaría compartir la información valiosa que aprendimos de nuestra implementación de un entorno Xgrid con nuestros colegas. En nuestro informe, abordaremos temas como la evaluación de las necesidades para la computación en red, las posibles aplicaciones, las herramientas de gestión, la seguridad, la autenticación, la integración en la infraestructura existente, el soporte de aplicaciones, la formación de usuarios y el soporte al usuario. Además, discutiremos los problemas que surgieron y las lecciones aprendidas durante y después del proceso de implementación. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos y aplicaciones distribuidas. Gestión de términos generales, documentación, rendimiento, diseño, economía, confiabilidad, experimentación. 1. La computación en malla no tiene una definición única y universalmente aceptada. La tecnología detrás del modelo de computación en malla no es nueva. Sus raíces se encuentran en modelos tempranos de computación distribuida que se remontan a principios de la década de 1980, donde los científicos aprovecharon la potencia de cálculo de estaciones de trabajo inactivas para permitir que aplicaciones intensivas en cálculos se ejecutaran en múltiples estaciones de trabajo, acortando drásticamente los tiempos de procesamiento. Aunque existían numerosos modelos de computación distribuida disponibles para aplicaciones científicas específicas de disciplinas, solo recientemente han surgido las herramientas para utilizar aplicaciones de propósito general en una red. Por consiguiente, el modelo de computación en malla está ganando popularidad y se ha convertido en una pieza clave de la computación de servicios públicos. Dado que en la industria de la tecnología de la información se utilizan diversos modelos informáticos de forma intercambiable con la computación en malla, primero clasificamos las similitudes y diferencias entre estos modelos informáticos para poder situar la computación en malla en perspectiva. 1.1 Agrupamiento Un clúster es un grupo de máquinas en una configuración fija unidas para operar y ser gestionadas como una sola entidad para aumentar la robustez y el rendimiento. El clúster aparece como un sistema único de alta velocidad o un sistema único altamente disponible. En este modelo, los recursos no pueden entrar y salir del grupo según sea necesario. Hay al menos dos tipos de clústeres: clústeres paralelos y clústeres de alta disponibilidad. Las máquinas agrupadas suelen estar en proximidad espacial, como en la misma sala de servidores, y dedicadas únicamente a su tarea. En un clúster de alta disponibilidad, cada máquina proporciona el mismo servicio. Si una máquina falla, otra asume su carga de trabajo de manera fluida. Por ejemplo, cada computadora podría ser un servidor web para un sitio web. Si un servidor web falla, otro proporciona el servicio, de modo que el sitio web rara vez, si es que alguna vez, se cae. Un clúster paralelo es un tipo de supercomputadora. Los problemas se dividen en muchas partes, y a los miembros individuales del grupo se les asigna una parte del problema para resolver. Un ejemplo de un clúster paralelo está compuesto por computadoras Apple Power Mac G5 en la Universidad de Virginia Tech [1]. 1.2 Computación Distribuida La computación distribuida expande espacialmente los servicios de red de manera que los componentes que proporcionan los servicios están separados. El objetivo principal de este modelo informático es consolidar la potencia de procesamiento a través de una red. Un ejemplo simple es distribuir servicios como el almacenamiento y la impresión de archivos, el servicio web y el almacenamiento de datos en múltiples máquinas en lugar de que una sola máquina maneje todas las tareas. La computación distribuida también puede ser más detallada, donde incluso una sola aplicación se divide en partes y cada parte se encuentra en máquinas diferentes: un procesador de texto en un servidor, un corrector ortográfico en un segundo servidor, etc. 1.3 Computación de utilidad Literalmente, la computación de utilidad se asemeja a servicios comunes como el teléfono o el servicio eléctrico. Un proveedor de servicios pone a disposición del cliente recursos informáticos y gestión de infraestructura según sea necesario, y cobra por el uso en lugar de una tarifa fija. Lo importante a tener en cuenta es que los recursos solo se utilizan según sea necesario y no se dedican a un único cliente. 1.4 Computación en malla La computación en malla contiene aspectos de clústeres, computación distribuida y computación de utilidad. En el sentido más básico, la red convierte un grupo de sistemas heterogéneos en un entorno informático centralizado pero flexible que puede trabajar en tareas demasiado intensivas en tiempo para los sistemas individuales. Los miembros de la red no necesariamente están en proximidad, pero simplemente deben ser accesibles a través de una red; la red puede acceder a computadoras en una LAN, WAN o en cualquier parte del mundo a través de Internet. Además, las computadoras que conforman la red no necesitan estar dedicadas a la red; en cambio, pueden funcionar como estaciones de trabajo normales y luego anunciar su disponibilidad a la red cuando no estén en uso. La última característica es la más fundamental para la cuadrícula descrita en este documento. Un ejemplo conocido de una cuadrícula ad hoc es el proyecto SETI@home [2] de la Universidad de California en Berkeley, que permite a cualquier persona en el mundo con una computadora y una conexión a Internet donar tiempo de procesador no utilizado para analizar datos de radiotelescopio. 1.5 Comparación entre la Cuadrícula y el Clúster Una cuadrícula informática amplía las capacidades del clúster al perder sus límites espaciales, de modo que cualquier computadora accesible a través de la red adquiere el potencial de aumentar la cuadrícula. Una característica fundamental de la cuadrícula es que se escala bien. La potencia de procesamiento de cualquier máquina agregada a la red está disponible de inmediato para resolver problemas. Además, las máquinas en la red pueden ser estaciones de trabajo de propósito general, lo que reduce el costo de expandir la red. EVALUACIÓN DE LA NECESIDAD DE COMPUTACIÓN EN GRILLA El uso efectivo de una grilla requiere una computación que pueda dividirse en tareas independientes (es decir, paralelas). Los resultados de cada tarea no pueden depender de los resultados de ninguna otra tarea, por lo que los miembros de la cuadrícula pueden resolver las tareas en paralelo. Una vez que las tareas hayan sido completadas, los resultados pueden ser ensamblados en la solución. Ejemplos de cálculos paralelizables son el conjunto de Mandelbrot de fractales, los cálculos de Monte Carlo utilizados en disciplinas como la Física del Estado Sólido y los fotogramas individuales de una animación renderizada. Este documento se ocupa del último ejemplo. 2.1 Aplicaciones apropiadas para la computación en malla. Las aplicaciones utilizadas en la computación en malla deben estar específicamente diseñadas para su uso en malla, o ser scriptables de tal manera que puedan recibir datos de la malla, procesar los datos y luego devolver resultados. En otras palabras, los mejores candidatos para la computación en malla son aplicaciones que ejecutan cálculos iguales o muy similares en un gran número de conjuntos de datos sin depender de los resultados previamente calculados. Las aplicaciones que dependen en gran medida del manejo de datos en lugar de la potencia de procesamiento suelen ser más adecuadas para ejecutarse en un entorno tradicional que en una plataforma de grid. Por supuesto, las aplicaciones también deben ejecutarse en la plataforma informática que aloja la red. Nuestro interés está en utilizar la aplicación Alias Maya [3] con Apples Xgrid [4] en Mac OS X. Las aplicaciones comerciales suelen tener requisitos estrictos de licencia. Esta es una preocupación importante si instalamos una aplicación comercial como Maya en todos los miembros de nuestra red. Por su naturaleza, el tamaño de la cuadrícula puede cambiar a medida que cambia el número de computadoras inactivas. ¿Cuántas licencias serán necesarias? Nuestra resolución de este problema se discutirá en una sección posterior. 2.2 Integración en la Infraestructura Existente La red requiere un controlador que reconozca cuándo los miembros de la red están disponibles y distribuya tareas a los miembros disponibles. El controlador debe poder ver a los miembros en la red. Esto no requiere que los miembros estén en la misma subred que el controlador, pero si no lo están, cualquier cortafuegos y enrutadores intermedios deben estar configurados para permitir el tráfico de la red. 3. XGRID Xgrid es la implementación de grid de Apple. Fue inspirado por Zilla, una aplicación de agrupamiento de escritorio desarrollada por NeXT y adquirida por Apple. En este informe describimos la Vista Previa de la Tecnología Xgrid 2, una descarga gratuita que requiere Mac OS X 10.2.8 o posterior y un mínimo de 128 MB de RAM [5]. Xgrid aprovecha la tradicional facilidad de uso y configuración de Apple. Si los miembros de la red están en la misma subred, por defecto Xgrid descubre automáticamente los recursos disponibles a través de Rendezvous [6]. Las tareas se envían a la cuadrícula a través de una interfaz GUI o por línea de comandos. Un panel de preferencias del sistema controla cuándo cada computadora está disponible en la red. Puede ser mejor ver Xgrid como un facilitador. La arquitectura Xgrid se encarga de la distribución de software y datos, la ejecución de tareas y la agregación de resultados. Sin embargo, Xgrid no realiza los cálculos reales. 3.1 Componentes de Xgrid Xgrid tiene tres componentes principales: el cliente, el controlador y el agente. Cada componente está incluido en la instalación predeterminada, y cualquier computadora puede configurarse fácilmente para asumir cualquier rol. De hecho, para fines de prueba, una computadora puede asumir simultáneamente todos los roles en modo local. El modo de producción más típico se llama modo de clúster. El cliente envía trabajos al controlador a través de la interfaz gráfica de Xgrid o la línea de comandos. El cliente define cómo se dividirá el trabajo en tareas para la cuadrícula. Si se deben enviar archivos o ejecutables como parte de un trabajo, deben residir en el cliente o en una ubicación accesible para el cliente. Cuando un trabajo está completo, el cliente puede recuperar los resultados desde el controlador. Un cliente solo puede conectarse a un controlador a la vez. El controlador ejecuta el proceso GridServer. Encola las tareas recibidas de los clientes, distribuye esas tareas a los agentes y gestiona el cambio automático si un agente no puede completar una tarea. En la Vista Previa de Tecnología Xgrid 2, un controlador puede manejar un máximo de 10,000 conexiones de agentes. Solo puede existir un controlador por cuadrícula lógica. Los agentes ejecutan el proceso GridAgent. Cuando el proceso GridAgent se inicia, se registra con un controlador; un agente solo puede estar conectado a un controlador a la vez. Los agentes reciben tareas de su controlador, realizan los cálculos especificados y luego envían los resultados de vuelta al controlador. Un agente puede configurarse para siempre aceptar tareas, o solo aceptarlas cuando la computadora no está ocupada. 3.2 Seguridad y Autenticación Por defecto, Xgrid requiere dos contraseñas. Primero, un cliente necesita una contraseña para acceder a un controlador. Segundo, el controlador necesita una contraseña para acceder a un agente. Cualquiera de los requisitos de contraseña se puede desactivar. Xgrid utiliza un protocolo de autenticación mutua bidireccional con hashes MD5. En este momento, el cifrado de datos solo se utiliza para contraseñas. Como se mencionó anteriormente, un agente se registra con un controlador cuando el proceso GridAgent se inicia. No hay un método nativo para que el controlador rechace agentes, por lo que debe aceptar cualquier agente que se registre. Esto significa que cualquier agente podría enviar un trabajo que consuma un exceso de procesador y espacio en disco en los agentes. Por supuesto, dado que Mac OS X es un sistema operativo basado en BSD, el controlador podría emplear métodos de Unix para restringir las conexiones de red desde los agentes. Los demonios de Xgrid se ejecutan como el usuario nobody, lo que significa que los demonios pueden leer, escribir o ejecutar cualquier archivo según los permisos mundiales. Por lo tanto, los trabajos de Xgrid pueden ejecutar muchos comandos y escribir en /tmp y /Volumes. En general, esto no es un riesgo de seguridad importante, pero requiere un nivel de confianza entre todos los miembros de la red. 3.3 Uso de Xgrid 3.3.1 Instalación La instalación básica de Xgrid y su configuración se describe tanto en la documentación de Apple [5] como en línea en el sitio web de la Universidad de Utah [8]. La instalación es sencilla y no ofrece opciones de personalización. Esto significa que cada computadora en la que se instala Xgrid tiene el potencial de ser un cliente, controlador o agente. Configuración de agentes y controladores 3.3.2 Los agentes y controladores se pueden configurar a través del Panel de Preferencias de Xgrid en las Preferencias del Sistema o archivos XML en /Library/Preferences. Aquí se inician los procesos GridServer y GridAgent, se establecen las contraseñas y se selecciona el método de descubrimiento del controlador utilizado por los agentes. Por defecto, los agentes utilizan Rendezvous para encontrar un controlador, aunque los agentes también pueden configurarse para buscar un host específico. El panel de preferencias de Xgrid también establece si los Agentes siempre aceptarán trabajos, o solo los aceptarán cuando estén inactivos. En términos de Xgrid, inactivo significa que el protector de pantalla de Xgrid se ha activado, o que el ratón y el teclado no se han utilizado durante más de 15 minutos. Aunque el agente esté configurado para siempre aceptar tareas, si la computadora está siendo utilizada, estas tareas se ejecutarán en segundo plano con baja prioridad. Sin embargo, si un agente solo acepta trabajos cuando está inactivo, cualquier tarea incompleta que se esté realizando cuando la computadora deja de estar inactiva se detiene de inmediato y se pierden los resultados intermedios. Entonces, el controlador asigna la tarea a otro miembro disponible de la red. La publicidad del controlador a través de Rendezvous se puede desactivar editando /Library/Preferences/com.apple.xgrid.controller.plist. Sin embargo, esto no evitará que un agente se conecte al controlador por nombre de host. 3.3.3 Envío de trabajos desde un cliente Xgrid El cliente envía trabajos al controlador ya sea a través de la interfaz gráfica de Xgrid o la línea de comandos. La interfaz gráfica de Xgrid envía trabajos a través de pequeñas aplicaciones llamadas plug-ins. Los complementos de muestra son proporcionados por Apple, pero solo son útiles para pruebas simples o como ejemplos de cómo crear un complemento personalizado. Si queremos utilizar Xgrid para trabajos útiles, necesitaremos un complemento personalizado. James Reynolds detalla la creación de complementos personalizados en el sitio web del sistema operativo Mac de la Universidad de Utah [8]. Xgrid almacena los complementos en /Library/Xgrid/Plug-ins o ~/Library/Xgrid/Plug-ins, dependiendo de si el complemento fue instalado con Xgrid o creado por un usuario. El parámetro principal del complemento es el comando, que incluye el ejecutable que ejecutarán los agentes. Otro parámetro importante es el directorio de trabajo. Este directorio contiene archivos necesarios que no están instalados en los agentes ni disponibles para ellos a través de una red. El directorio de trabajo siempre se copiará en cada agente, por lo que es mejor mantener este directorio pequeño. Si los archivos están instalados en los agentes o disponibles a través de una red, el parámetro del directorio de trabajo no es necesario. La línea de comandos permite acceder a las opciones disponibles con el complemento de la interfaz gráfica de usuario (GUI), pero puede ser un poco más engorrosa. Sin embargo, es probable que la línea de comandos sea el método de elección para trabajos serios. Los argumentos de comando deben incluirse en un script a menos que sean muy básicos. Este puede ser un script de shell, perl o python, siempre y cuando el agente pueda interpretarlo. 3.3.4 Ejecución del trabajo de Xgrid Cuando se inicia el trabajo de Xgrid, el comando le indica al controlador cómo dividir el trabajo en tareas para los agentes. Entonces, el comando se comprime con tar y gzip y se envía a cada agente; si hay un directorio de trabajo, este también se comprime con tar y gzip y se envía a los agentes. Los agentes extraen estos archivos en /tmp y ejecutan la tarea. Recuerde que dado que el proceso GridAgent se ejecuta como el usuario nobody, todo lo asociado con el comando debe estar disponible para nobody. Los ejecutables llamados por el comando deben estar instalados en los agentes a menos que sean muy simples. Si el ejecutable depende de bibliotecas u otros archivos, es posible que no funcione correctamente si se transfiere, incluso si los archivos dependientes están referenciados en el directorio de trabajo. Cuando la tarea esté completa, los resultados estarán disponibles para el cliente. En principio, los resultados se envían al cliente, pero si esto realmente sucede depende del comando. Si los resultados no se envían al cliente, estarán en /tmp en cada agente. Cuando esté disponible, una mejor solución es dirigir los resultados a un volumen de red accesible para el cliente. 3.4 Limitaciones e idiosincrasias Dado que Xgrid solo se encuentra en su segunda versión preliminar, existen algunas imperfecciones y limitaciones. Apple reconoce algunas limitaciones [7]. Por ejemplo, el controlador no puede determinar si un agente es confiable y siempre copia el comando y el directorio de trabajo al agente sin verificar si estos existen en el agente. Otras limitaciones probablemente son solo un subproducto de un trabajo inacabado. Ni el cliente ni el controlador pueden especificar qué agentes recibirán las tareas, lo cual es especialmente importante si los agentes contienen una variedad de tipos y velocidades de procesadores y el usuario desea optimizar los cálculos. En este momento, la mejor solución a este problema puede ser dividir las computadoras en múltiples rejillas lógicas. Tampoco hay una forma estándar de monitorear el progreso de un trabajo en ejecución en cada agente. La interfaz gráfica de Xgrid y la línea de comandos indican qué agentes están trabajando en las tareas, pero no dan ninguna indicación del progreso. Finalmente, en este momento solo los clientes de Mac OS X pueden enviar trabajos a la red. El marco existe para permitir a terceros escribir complementos para otras variantes de Unix, pero Apple no los ha creado. 4. IMPLEMENTACIÓN DE XGRID Nuestro objetivo es crear una granja de renderizado Xgrid para Alias Maya. La Escuela Ringling tiene alrededor de 400 Apple Power Mac G4 y G5 en 13 laboratorios de computación. Las computadoras van desde G4 de un solo procesador de 733 MHz y G4 de doble procesador de 500 MHz y 1 GHz hasta G5 de doble procesador de 1.8 GHz. Todos estos ordenadores se utilizan ligeramente por la tarde y los fines de semana y representan un enorme recurso de procesamiento para nuestros proyectos de renderizado de estudiantes. 4.1 Instalación de software Durante nuestras pruebas de Xgrid, cargamos software en cada ordenador varias veces, incluidos los sistemas operativos. Ahorramos tiempo al facilitar nuestras instalaciones con el software de demonio de administración remota (radmind) desarrollado en la Universidad de Michigan [9], [10]. Todo lo que instalamos para probar fue primero creado como una carga base o sobrecarga de radmind. Por lo tanto, Mac OS X, Mac OS X Developer Tools, Xgrid, POV-Ray [11] y Alias Maya se almacenaron en un servidor radmind y luego se instalaron en nuestras computadoras de prueba cuando fue necesario. 4.2 Pruebas Iniciales Utilizamos seis Apple Power Mac G5 de doble procesador de 1.8 GHz para nuestras pruebas de Xgrid. Cada computadora ejecutaba Mac OS X 10.3.3 y contenía 1 GB de RAM. Como se muestra en la Figura 1, una computadora actuó como cliente y controlador, mientras que las otras cinco actuaron como agentes. Antes de intentar el renderizado de Maya con Xgrid, realizamos cálculos básicos para afianzar nuestra comprensión de Xgrid. La documentación de Xgrid de Apples es escasa, por lo que encontrar sitios web útiles facilitó nuestro aprendizaje. Primero ejecutamos el complemento del conjunto de Mandelbrot proporcionado por Apple, lo que nos permitió probar la funcionalidad básica de nuestra cuadrícula. Luego realizamos una prueba de rendimiento con la aplicación de código abierto POV-Ray, tal como lo describieron Daniel Côté [12] y James Reynolds [8]. Nuestros resultados mostraron que un G5 de doble procesador tardó 104 minutos en renderizar la imagen de referencia de POV-Ray. Dividir la imagen en tres partes iguales y enviar las partes a tres agentes utilizando Xgrid tomó 47 minutos. Sin embargo, dos agentes terminaron su renderización en 30 minutos, mientras que el tercer agente tardó 47 minutos; el render completo solo fue tan rápido como el agente más lento. Estos resultados nos dieron dos piezas importantes de información. Primero, el tiempo de procesamiento mucho más largo para una de las tareas indicaba que debíamos tener cuidado en cómo dividimos los trabajos en tareas para los agentes. Todas las partes del renderizado no tomarán la misma cantidad de tiempo, incluso si el tamaño de píxel es el mismo. Segundo, dado que POV-Ray no puede aprovechar ambos procesadores en un G5, tampoco puede hacerlo una tarea de Xgrid ejecutando POV-Ray. Alias Maya no tiene esta limitación. 4.3 Renderizando con Alias Maya 6 Primero instalamos Alias Maya 6 para Mac OS X en el cliente/controlador y en cada agente. Maya 6 requiere licencias para ser utilizada como una aplicación de estación de trabajo. Sin embargo, si solo se utiliza para renderizar desde la línea de comandos o un script, no se necesita licencia. Por lo tanto, creamos una instalación mínima de Maya como una sobrecarga de radmind. La aplicación fue instalada en un directorio oculto dentro de /Applications. Esto se hizo para que los usuarios normales de las estaciones de trabajo no encuentren y traten de ejecutar Maya, lo cual fallaría porque estas instalaciones no están licenciadas para tal uso. Además, Maya requiere la existencia de un directorio que termine en la ruta /maya. El directorio debe ser legible y escribible por el usuario Maya. Para un usuario que ejecuta Maya en una estación de trabajo Mac OS X, la ruta suele ser ~/Documents/maya. A menos que se especifique lo contrario, este directorio será la ubicación predeterminada para los datos y archivos de salida de Maya. Si el directorio no figura 1. Prueba de cuadrícula Xgrid. Si el volumen de red de trabajos de datos 122 no existe, Maya intentará crearlo, incluso si el usuario especifica que los datos y los archivos de salida existen en otras ubicaciones. Sin embargo, Xgrid se ejecuta como el usuario nobody, el cual no tiene un directorio de inicio. Maya no puede crear el directorio necesario y en su lugar busca /Alias/maya. Este directorio tampoco existe, y el usuario nobody no tiene los permisos suficientes para crearlo. Nuestra solución fue crear manualmente /Alias/maya y dar al usuario permisos de lectura y escritura a nobody. También creamos un volumen de red para el almacenamiento tanto de los datos de renderización como de los fotogramas renderizados resultantes. Esto evitó enviar los archivos de Maya y las texturas asociadas a cada agente como parte de un directorio de trabajo. Una solución funcionó bien para nosotros porque nuestras computadoras están geográficamente cerca en una LAN; si una mayor distancia hubiera separado a los agentes del cliente/controlador, especificar un directorio de trabajo podría haber sido una mejor solución. Finalmente, creamos un complemento de GUI personalizado para Xgrid. El comando de plug-in llama a un script de Perl con tres argumentos. Dos argumentos especifican los fotogramas de inicio y fin de la renderización y el tercer argumento el número de fotogramas en cada tarea (que llamamos tamaño del clúster). El script luego calcula el número total de trabajos y los distribuye entre los agentes. Por ejemplo, si comenzamos en el fotograma 201 y terminamos en el fotograma 225, con 5 fotogramas por trabajo, el complemento creará 5 trabajos y los enviará a los agentes. Una vez que los trabajos son enviados a los agentes, el script ejecuta el comando /usr/sbin/Render en cada agente con los parámetros apropiados para el trabajo en particular. Los resultados se envían al volumen de red. Con la configuración descrita, pudimos renderizar con Alias Maya 6 en nuestra cuadrícula de pruebas. La velocidad de renderizado no era importante en este momento; nuestro primer objetivo era implementar la cuadrícula, y en eso tuvimos éxito. 4.3.1 Pseudo Código para Script de Perl en Plug-in Personalizado de Xgrid En esta sección resumimos en un formato simplificado de pseudo código el script de Perl utilizado en nuestro plug-in de Xgrid. agent_jobs{ • Leer fotograma inicial, fotograma final y tamaño de clúster de renderizado. • Comprobar si el renderizado se puede dividir en un número entero de trabajos basado en el tamaño del clúster. • Si no hay un número entero de trabajos, reducir el tamaño del clúster del último trabajo y establecer su último fotograma como el fotograma final del renderizado. • Determinar el fotograma inicial y final para cada trabajo. • Ejecutar el comando de Renderizado. } 4.4 Lecciones Aprendidas El renderizado con Maya desde la interfaz gráfica de usuario de Xgrid no fue trivial. La falta de documentación de Xgrid y los requisitos de Maya se combinaron en un panorama confuso, donde era difícil decidir la verdadera causa de los problemas que encontramos. Se requirió prueba y error para determinar la mejor manera de configurar nuestra cuadrícula. El primer obstáculo fue crear el directorio /Alias/maya con permisos de lectura y escritura para el usuario nobody. El segundo obstáculo fue descubrir que obteníamos el mejor rendimiento al almacenar los datos de renderización en un volumen de red. El último obstáculo importante fue recuperar nuestros resultados de los agentes. A diferencia de las pruebas de renderizado de POV-Ray, nuestros resultados iniciales de Maya nunca fueron devueltos al cliente; en su lugar, Maya almacenó los resultados en /tmp en cada agente. Especificar en el complemento dónde enviar los resultados no cambiaría este comportamiento. Decidimos que probablemente se trataba de un problema de Maya en lugar de un problema de Xgrid, y la solución fue enviar los resultados al volumen de red a través del script de Perl. 5. Los planes futuros de Maya en Xgrid aún no están listos para ser utilizados por los estudiantes de la Escuela Ringling. Para hacer esto, debemos abordar al menos las siguientes preocupaciones. • Continuar nuestras pruebas de renderizado a través de la línea de comandos en lugar del complemento de la interfaz gráfica de usuario (GUI). Esto será esencial para el siguiente paso. • Desarrollar una interfaz adecuada para que los usuarios envíen trabajos al controlador Xgrid. Esto probablemente será una extensión de la interfaz web de nuestra granja de renderizado existente, donde el estudiante especifica parámetros que se colocan en un script que emite el comando de Renderizado. Realizar pruebas de renderizado de Maya con Xgrid programadas. Parte de esto debería comparar los tiempos de renderizado para Power Mac G4 y G5. 6. CONCLUSIÓN La computación en malla sigue avanzando. Recientemente, la industria de tecnologías de la información ha presenciado la aparición de numerosos tipos de aplicaciones de cuadrícula contemporáneas, además del marco de cuadrícula tradicional para aplicaciones intensivas en cálculos. Por ejemplo, las aplicaciones peer-to-peer como Kazaa se basan en redes de almacenamiento que no comparten potencia de procesamiento, sino un protocolo elegante para intercambiar archivos entre sistemas. Aunque en nuestros campus desalentamos a los estudiantes de utilizar aplicaciones de intercambio de música entre pares, el mismo protocolo puede ser utilizado en aplicaciones como el soporte de decisiones y la minería de datos. El proyecto de red del National Virtual Collaboratory [13] conectará a investigadores de terremotos en todo Estados Unidos con recursos informáticos, permitiéndoles compartir conjuntos de datos extremadamente grandes, equipos de investigación y trabajar juntos como equipos virtuales a través de Internet. Hay una variedad de nuevos jugadores de cuadrícula en el mundo de la tecnología de la información que están expandiendo el modelo de computación en cuadrícula y avanzando la tecnología de cuadrícula al siguiente nivel. SAP [14] está pilotando un proyecto para habilitar la cuadrícula en las aplicaciones de SAP ERP, Dell [15] se ha asociado con Platform Computing para consolidar recursos informáticos y proporcionar sistemas habilitados para la cuadrícula para aplicaciones intensivas en cálculos, Oracle ha integrado soporte para la computación en cuadrícula en su lanzamiento 10g [16], United Devices [17] ofrece servicios de alojamiento para la cuadrícula bajo demanda, y Sun Microsystems continúa con su investigación y desarrollo del motor de cuadrícula Suns N1 [18], que combina plataformas de cuadrícula y de agrupamiento. Simplemente, la computación en malla está en auge. Los beneficios potenciales de la computación en red son colosales en el aprendizaje de la educación superior, mientras que los costos de implementación son bajos. Hoy en día, sería difícil identificar una aplicación con un retorno de inversión tan alto como la computación en red en las divisiones de tecnología de la información en instituciones de educación superior. Es un error pasar por alto esta tecnología con un retorno de inversión tan alto. 123 7. AGRADECIMIENTOS Los autores desean agradecer a Scott Hanselman del equipo de IT en la Escuela de Arte y Diseño Ringling por brindar aportes valiosos en la planificación de nuestras pruebas Xgrid. También nos gustaría agradecer a los participantes de la Lista de Correo de Xgrid [13] por brindar información sobre muchas áreas de Xgrid. 8. REFERENCIAS [1] Investigación Académica de Apple, http://www.apple.com/education/science/profiles/vatech/. [2] SETI@home: Búsqueda de Inteligencia Extraterrestre desde casa. http://setiathome.ssl.berkeley.edu/. [3] Alias, http://www.alias.com/. [4] Apple Computer, Xgrid, http://www.apple.com/acg/xgrid/. [5] Guía de Xgrid, http://www.apple.com/acg/xgrid/, 2004. [6] Características de Apple Mac OS X, http://www.apple.com/macosx/features/rendezvous/. [7] Página del Manual de Xgrid, 2004. [8] James Reynolds, Presentación de Xgrid, Universidad de Utah, http://www.macos.utah.edu:16080/xgrid/, 2004. [9] Grupo de Unix de Sistemas de Investigación, Radmind, Universidad de Michigan, http://rsug.itd.umich.edu/software/radmind. [10]Uso de las Herramientas de Línea de Comandos de Radmind para Mantener Múltiples Máquinas Mac OS X, http://rsug.itd.umich.edu/software/radmind/files/radmindtutorial-0.8.1.pdf. [11]POV-Ray, http://www.povray.org/. [12]Daniel Côté, Ejemplo de Xgrid: Renderización gráfica paralela en POVray, http://unu.novajo.ca/simple/, 2004. [13]NEESgrid, http://www.neesgrid.org/. [14]SAP, http://www.sap.com/. [15]Platform Computing, http://platform.com/. [16]Grid, http://www.oracle.com/technologies/grid/. [17]United Devices, Inc., http://ud.com/. [18]N1 Grid Engine 6, http://www.sun.com/software/gridware/index.html/. [19]Lista de Correo de Usuarios de Xgrid, http://www.lists.apple.com/mailman/listinfo/xgridusers/.