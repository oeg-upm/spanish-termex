Control de acceso reforzado por cifrado en redes de publicación/suscripción multi-dominio dinámicas de Lauri I.W. Los sistemas de publicación/suscripción proporcionan una infraestructura de comunicaciones distribuida eficiente, basada en eventos y de amplia área. Los sistemas de publicación/suscripción a gran escala probablemente emplearán componentes de la red de transporte de eventos propiedad de organizaciones cooperativas pero independientes. A medida que aumenta el número de participantes en la red, la seguridad se convierte en una preocupación creciente. Este documento amplía trabajos anteriores para presentar y evaluar una infraestructura segura de publicación/suscripción multi-dominio que respalda y hace cumplir un control de acceso detallado sobre los atributos individuales de los tipos de eventos. La actualización de claves nos permite garantizar la seguridad hacia adelante y hacia atrás cuando los brokers de eventos se unen y abandonan la red. Demostramos que los costos de tiempo y espacio pueden minimizarse mediante una cuidadosa consideración de las técnicas de encriptación, y mediante el uso de almacenamiento en caché para disminuir las desencriptaciones innecesarias. Mostramos que nuestro enfoque tiene un menor sobrecosto de comunicación general que los enfoques existentes para lograr el mismo grado de control sobre la seguridad en redes de publicación/suscripción. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Seguridad, Rendimiento 1. La publicación/suscripción es muy adecuada como mecanismo de comunicación para construir aplicaciones distribuidas a escala de Internet basadas en eventos. Gran parte de su capacidad de escala en el número de participantes proviene de su desacoplamiento de editores y suscriptores al colocar un servicio de entrega de eventos asincrónicos entre ellos. En sistemas de publicación/suscripción a escala verdaderamente de Internet, el servicio de entrega de eventos incluirá un gran conjunto de nodos de intermediación interconectados que abarcan una amplia área geográfica (y, por lo tanto, de red). Sin embargo, los sistemas de publicación/suscripción que abarcan una amplia área geográfica probablemente también abarcarán múltiples dominios administrativos, ya sean dominios administrativos independientes dentro de una sola organización, múltiples organizaciones independientes o una combinación de ambos. Si bien las capacidades de comunicación de los sistemas de publicación/suscripción están bien probadas, es probable que abarcar múltiples dominios administrativos requiera abordar consideraciones de seguridad. Dado que la seguridad y el control de acceso son casi lo opuesto a la desvinculación, hasta ahora relativamente poca investigación de publicación/suscripción se ha centrado en la seguridad. Nuestro objetivo general de investigación es desarrollar redes de publicación/suscripción a escala de Internet que proporcionen una entrega segura y eficiente de eventos, tolerancia a fallos y auto recuperación en la infraestructura de entrega, y una interfaz de eventos conveniente. En [12] Pesonen et al. proponen una arquitectura de control de acceso basada en capacidades y multidominio para sistemas de publicación/suscripción. La arquitectura proporciona un mecanismo para autorizar a los clientes de eventos a publicar y suscribirse a tipos de eventos. Los privilegios del cliente son verificados por el corredor local al que se conecta el cliente para acceder al sistema de publicación/suscripción. El enfoque implementa control de acceso en el borde de la red del broker y asume que todos los brokers pueden ser confiados para hacer cumplir las políticas de control de acceso correctamente. Cualquier corredor malicioso, comprometido o no autorizado tiene libertad para leer y escribir cualquier evento que pase a través de él en su camino desde los editores hasta los suscriptores. Esto podría ser aceptable en un sistema relativamente pequeño implementado dentro de una sola organización, pero no es apropiado en un entorno multi-dominio en el que las organizaciones comparten una infraestructura común. Proponemos hacer cumplir el control de acceso dentro de la red de intermediarios mediante la encriptación del contenido de los eventos, y que la política dicte los controles sobre las claves de encriptación necesarias. Con el contenido del evento encriptado, solo aquellos corredores autorizados para acceder a las claves de cifrado pueden acceder al contenido del evento (es decir, publicar, suscribirse o filtrar). Movemos de manera efectiva la aplicación del control de acceso de los corredores a los gestores de claves de cifrado. Esperamos que el control de acceso deba ser aplicado en un sistema de publicación/suscripción multi-dominio cuando múltiples organizaciones forman un sistema de publicación/suscripción compartido pero ejecutan múltiples aplicaciones independientes. El control de acceso también puede ser necesario cuando una sola organización consta de múltiples subdominios que entregan datos confidenciales a través del sistema de publicación/suscripción de toda la organización. Ambos casos requieren control de acceso porque la entrega de eventos en una infraestructura dinámica de publicación/suscripción basada en una red de intermediarios compartidos puede llevar a que los eventos sean enrutados a través de dominios no autorizados en su camino desde los editores hasta los suscriptores. Hay dos beneficios particulares al compartir la infraestructura de publicación/suscripción, ambos relacionados con la red de intermediarios. Primero, los corredores de intercambio crearán una red físicamente más grande que proporcionará un alcance geográfico mayor. Segundo, aumentar la interconectividad de los corredores permitirá que el sistema de publicación/suscripción proporcione una mayor tolerancia a fallos. La Figura 1 muestra la red de publicación/suscripción de múltiples dominios que utilizamos como ejemplo a lo largo de este documento. Está basado en las Fuerzas de Policía del Reino Unido, y mostramos tres subdominios particulares: Dominio de la Policía Metropolitana. Este dominio contiene un conjunto de cámaras de circuito cerrado de televisión que publican información sobre los movimientos de vehículos en el área de Londres. Hemos incluido al Detective Smith como suscriptor en este dominio. Dominio del Servicio de Cargo por Congestión. Los cargos que se aplican a los vehículos que han pasado por la zona de la tarifa de congestión de Londres cada día son emitidos por sistemas dentro de este dominio. Los datos de reconocimiento de matrículas provienen de las cámaras en el Dominio de la Policía Metropolitana. El hecho de que los CCS solo estén autorizados para leer un subconjunto de los datos de eventos del vehículo ejercerá algunas de las características clave del control de acceso del sistema de publicación/suscripción ejecutable presentado en este documento. Dominio PITO. La Organización de Tecnología de la Información de la Policía (PITO) es el centro desde el cual se gestionan los estándares de datos de la Policía. Es el propietario del tipo de evento en este escenario particular. El cifrado protege la confidencialidad de los eventos en caso de que sean transportados a través de dominios no autorizados. Sin embargo, encriptar eventos completos significa que los corredores no autorizados no pueden tomar decisiones de enrutamiento eficientes. Nuestro enfoque es aplicar cifrado a los atributos individuales de los eventos. De esta manera, nuestra política de control de acceso de múltiples dominios funciona con una granularidad más fina: los editores y suscriptores pueden tener autorización para acceder a un subconjunto de los atributos disponibles. En los casos en los que se utilizan eventos no encriptados para el enrutamiento, podemos reducir el número total de eventos enviados a través del sistema sin revelar los valores de atributos sensibles. En nuestro escenario de ejemplo, el Servicio de Carga por Congestión solo estaría autorizado para leer el campo de la matrícula de los avistamientos de vehículos; el atributo de ubicación no sería descifrado. Así preservamos la privacidad de los conductores mientras permitimos que el CCS haga su trabajo utilizando la infraestructura de publicación/suscripción compartida. Supongamos que una detective del Servicio de Policía Metropolitana está investigando un crimen y está interesada en avistamientos de un vehículo específico. El detective obtiene una orden judicial que le autoriza a suscribirse a los eventos de matrícula del número de matrícula específico relacionado con su caso. Los sistemas actuales de control de acceso de publicación/suscripción hacen cumplir la seguridad en el borde de la red del intermediario donde los clientes se conectan a él. Sin embargo, este enfoque a menudo no será aceptable en sistemas a escala de Internet. Proponemos reforzar la seguridad dentro de la red del intermediario, así como en los extremos a los que se conectan los clientes de eventos, mediante la encriptación del contenido del evento. Las publicaciones serán encriptadas con sus claves de encriptación específicas del tipo de evento. Al controlar el acceso a las claves de cifrado, podemos controlar el acceso a los tipos de eventos. El enfoque propuesto permite a los intermediarios de eventos dirigir eventos incluso cuando solo tienen acceso a un subconjunto de las posibles claves de cifrado. Introducimos sistemas de publicación/suscripción descentralizados y criptografía relevante en la Sección 2. En la Sección 3 presentamos nuestro modelo para cifrar el contenido del evento tanto a nivel del evento como a nivel del atributo. La sección 4 trata sobre la gestión de claves de cifrado en sistemas de publicación/suscripción multi-dominio. Evaluamos analíticamente el rendimiento de nuestra propuesta en la Sección 5. Finalmente, la Sección 6 discute el trabajo relacionado en la seguridad de los sistemas de publicación/suscripción y la Sección 7 ofrece observaciones finales. ANTECEDENTES En esta sección proporcionamos una breve introducción a los sistemas de publicación/suscripción descentralizados. Indicamos nuestras suposiciones sobre los sistemas de publicación/suscripción multi-dominio, y describimos cómo estas suposiciones influyen en los desarrollos que hemos realizado a partir de nuestro trabajo previamente publicado. 2.1 Sistemas de Publicación/Suscripción Descentralizados Un sistema de publicación/suscripción incluye editores, suscriptores y un servicio de eventos. Los editores publican eventos, los suscriptores se suscriben a eventos de interés para ellos, y el servicio de eventos es responsable de entregar los eventos publicados a todos los suscriptores cuyos intereses coincidan con el evento dado. El servicio de eventos en un sistema de publicación/suscripción descentralizado se distribuye en varios nodos de intermediarios. Juntos, estos corredores forman una red que es responsable de mantener las rutas de enrutamiento necesarias desde los editores hasta los suscriptores. Los clientes (editores y suscriptores) se conectan a un intermediario local, el cual es completamente confiable para el cliente. En nuestra discusión nos referimos a los corredores de alojamiento de clientes como corredores de alojamiento de editores (PHB) o corredores de alojamiento de suscriptores (SHB) dependiendo de si el cliente conectado es un editor o un suscriptor, respectivamente. Un corredor local suele ser parte del mismo dominio que el cliente, o es propiedad de un proveedor de servicios en quien el cliente confía. Una red de corredores puede tener una topología estática (por ejemplo, Siena [3] y Gryphon [14]) o una topología dinámica (por ejemplo, Escribe [4] y Hermes [13]). Nuestro enfoque propuesto funcionará en ambos casos. Una topología estática permite al administrador del sistema construir dominios de confianza y de esa manera mejorar la eficiencia del enrutamiento al evitar encriptaciones innecesarias (ver Sección 3.4), lo cual es muy difícil con una topología dinámica. Por otro lado, una topología dinámica permite que la red de corredores se reequilibre dinámicamente cuando los corredores se unen o abandonan la red, ya sea de manera controlada o como resultado de una falla en la red o en un nodo. Nuestro trabajo se basa en el sistema Hermes. Hermes es un middleware de publicación/suscripción basado en contenido que incluye un sólido soporte para tipos de eventos. En otras palabras, cada publicación es una instancia de un tipo de evento predefinido particular. Las publicaciones son verificadas en el corredor local de cada editorial. Nuestro esquema de cifrado a nivel de atributo asume que los eventos están tipificados. Hermes utiliza una red superpuesta estructurada como transporte y, por lo tanto, tiene una topología dinámica. Una publicación de Hermes consiste en un identificador de tipo de evento y un conjunto de pares de valores de atributos. El identificador de tipo es el hash SHA-1 del nombre del tipo de evento. Se utiliza para dirigir la publicación a través de la red del intermediario de eventos. Convenientemente oculta el tipo de publicación, es decir, los corredores no pueden ver qué eventos están pasando a través de ellos a menos que estén al tanto del nombre y del identificador específico del tipo de evento. 2.2 Tipos de Eventos Seguros Pesonen et al. introdujeron tipos de eventos seguros en [11], cuya integridad y autenticidad pueden ser confirmadas mediante la verificación de sus firmas digitales. Un efecto secundario útil de los tipos de eventos seguros son sus nombres de tipo de evento y atributos globalmente únicos. Estos nombres pueden ser referidos por políticas de control de acceso. En este documento utilizamos el nombre seguro del tipo de evento o atributo para referirnos a la clave de cifrado utilizada para encriptar el evento o atributo. 2.3 Control de Acceso Basado en Capacidades Pesonen et al. propusieron una arquitectura de control de acceso basada en capacidades para sistemas de publicación/suscripción multidominio en [12]. El modelo trata los tipos de eventos como recursos a los que los editores, suscriptores y corredores de eventos desean acceder. El propietario del tipo de evento es responsable de gestionar el control de acceso para un tipo de evento emitiendo certificados de autorización de Infraestructura de Clave Pública Simple (SPKI) que otorgan al titular acceso al tipo de evento especificado. Por ejemplo, a los editores autorizados se les habrá expedido un certificado de autorización que especifica que el editor, identificado por la clave pública, está autorizado para publicar instancias del tipo de evento especificado en el certificado. En este documento aprovechamos el mecanismo de control de acceso mencionado anteriormente al controlar el acceso a las claves de cifrado utilizando los mismos certificados de autorización. Es decir, un editor autorizado para publicar un determinado tipo de evento también está autorizado para acceder a las claves de cifrado utilizadas para proteger eventos de ese tipo. Discutimos esto con más detalle en la Sección 4. 2.4 Modelo de amenazas El objetivo del mecanismo propuesto es hacer cumplir el control de acceso para los participantes autorizados en el sistema. En nuestro caso, el primer nivel de control de acceso se aplica cuando el participante intenta unirse a la red de publicación/suscripción. Los corredores de eventos no autorizados no tienen permitido unirse a la red de corredores. Del mismo modo, los clientes de eventos no autorizados no tienen permitido conectarse a un intermediario de eventos. Todas las conexiones en la red de corredores entre corredores de eventos y clientes de eventos utilizan Seguridad de la Capa de Transporte (TLS) [5] para prevenir el acceso no autorizado en la capa de transporte. La arquitectura del sistema de publicación/suscripción implica que los clientes de eventos deben conectarse a los intermediarios de eventos para poder acceder al sistema de publicación/suscripción. Por lo tanto, asumimos que estos clientes no representan una amenaza. El cliente del evento depende completamente del corredor de eventos local para acceder a la red del corredor. Por lo tanto, el cliente del evento no puede acceder a ningún evento sin la ayuda del corredor local. Los corredores, por otro lado, son capaces de analizar todos los eventos en el sistema que pasan a través de ellos. Un corredor puede analizar tanto el tráfico del evento como el número y los nombres de los atributos que se completan en un evento (en el caso del cifrado a nivel de atributo). Existen enfoques viables para prevenir el análisis de tráfico mediante la inserción de eventos aleatorios en el flujo de eventos con el fin de producir un patrón de tráfico uniforme. Del mismo modo, el contenido del atributo se puede rellenar a una longitud estándar para evitar filtrar información al adversario. Si bien el análisis de tráfico es una preocupación importante, no lo hemos abordado más en este documento. 3. CIFRADO DE CONTENIDO DE EVENTOS Proponemos hacer cumplir el control de acceso en una red de intermediarios descentralizada mediante el cifrado de los contenidos de los eventos publicados y controlando el acceso a las claves de cifrado. Efectivamente trasladamos la responsabilidad del control de acceso de la red de intermediarios a los gestores de claves. Se asume que todos los clientes tienen acceso a un corredor en quien puedan confiar y que esté autorizado para acceder al contenido del evento requerido por el cliente. Esto nos permite implementar el cifrado del contenido del evento dentro de la red del intermediario sin involucrar a los clientes. Al delegar las tareas de encriptación a los corredores, reducimos el número de nodos necesarios para tener acceso a una clave de encriptación determinada. Los beneficios son triples: i) menos nodos manejan la clave de cifrado confidencial, por lo que hay menos posibilidades de que la clave sea revelada; ii) las actualizaciones de clave involucran menos nodos, lo que significa que el algoritmo de gestión de claves incurrirá en menores costos de comunicación y procesamiento para el sistema de publicación/suscripción; y iii) el broker local descifrará un evento una vez y lo entregará a todos los suscriptores, en lugar de a cada suscriptor. Las claves de cifrado se cambian con el tiempo en respuesta a los brokers que se unen o abandonan la red, y periódicamente para reducir la cantidad de tiempo que se utiliza una sola clave. Esto se discute en la Sección 4.2 teniendo que descifrar el mismo evento. Delegar las tareas de encriptación al intermediario local es apropiado, ya que la encriptación es una característica del middleware utilizada para hacer cumplir el control de acceso dentro del sistema de middleware. Si las aplicaciones necesitan manejar datos encriptados en la capa de la aplicación, pueden publicar datos encriptados a través del sistema de publicación/suscripción. Podemos implementar el cifrado ya sea a nivel de evento o a nivel de atributo. El cifrado de eventos es más simple, requiere menos claves, menos operaciones criptográficas independientes y, por lo tanto, suele ser más rápido. El cifrado de atributos permite el control de acceso a nivel de atributo, lo que significa que tenemos un mecanismo de control de acceso más expresivo y potente, aunque generalmente conlleva una penalización de rendimiento mayor. En esta sección discutimos la encriptación del contenido del evento tanto a nivel del evento como a nivel del atributo; evitando la filtración de información a corredores no autorizados mediante la encriptación de los filtros de suscripción; evitando encriptaciones innecesarias entre corredores autorizados; y finalmente, cómo se implementó la encriptación del contenido del evento en nuestro prototipo. Ten en cuenta que dado que ningún cliente de publicación/suscripción tiene acceso a las claves de cifrado, cualquier cifrado realizado por los brokers es necesariamente completamente transparente para todos los clientes. 3.1 Cifrado de Eventos En el cifrado de eventos, todos los atributos del evento se cifran como un único bloque de texto plano. El identificador del tipo de evento se deja intacto (es decir, en texto plano) para facilitar el enrutamiento de eventos en la red de intermediarios. El identificador del tipo de evento único a nivel mundial especifica la clave de cifrado utilizada para cifrar el contenido del evento. Cada tipo de evento en el sistema tendrá su propia clave de encriptación individual. Las claves se actualizan, como se discute en la Sección 4.2. Durante el tránsito, el evento consistirá en una tupla que contiene el identificador de tipo, una marca de tiempo de publicación, el texto cifrado y una etiqueta de autenticación del mensaje: <identificador de tipo, marca de tiempo, texto cifrado, etiqueta de autenticación>. Los brokers de eventos que están autorizados para acceder al evento, y por lo tanto tienen acceso a la clave de encriptación, pueden desencriptar el evento e implementar el enrutamiento basado en contenido. Los intermediarios de eventos que no tengan acceso a la clave de encriptación se verán obligados a enrutar el evento basándose únicamente en su tipo. Es decir, no podrán tomar decisiones inteligentes sobre si los eventos no necesitan ser transmitidos por sus enlaces salientes. El cifrado del evento resulta en un cifrado en el broker que aloja al publicador, y una descifrado en cada broker intermedio de filtrado y en el broker que aloja al suscriptor por el que pase el evento, independientemente del número de atributos. Esto resulta en una ventaja de rendimiento significativa en comparación con el cifrado de atributos. 3.2 Cifrado de Atributos En el cifrado de atributos, cada valor de atributo en un evento se cifra por separado con su propia clave de cifrado. La clave de encriptación se identifica por los atributos identificador único global (el identificador único global de evento define un espacio de nombres dentro del cual el identificador de atributo es un nombre completamente calificado). El identificador de tipo de evento se deja intacto para facilitar el enrutamiento de eventos para corredores no autorizados. Los identificadores de atributos también se mantienen intactos para permitir que los corredores autorizados descifren los valores de atributos con las claves correctas. Los corredores autorizados para acceder a algunos de los atributos en un evento pueden implementar enrutamiento basado en contenido sobre los atributos a los que tienen acceso. Un evento con atributos encriptados en tránsito consta del identificador del tipo de evento, una marca de tiempo de publicación y un conjunto de tuplas de atributos: <identificador de tipo, marca de tiempo, atributos>. Las tuplas de atributos consisten en un identificador de atributo, texto cifrado y una etiqueta de autenticación de mensaje: <id de atributo, texto cifrado, etiqueta de autenticación>. El identificador del atributo es el hash SHA-1 del nombre del atributo utilizado en la definición del tipo de evento. El uso del identificador de atributo en el evento publicado en lugar del nombre del atributo evita que partes no autorizadas aprendan qué atributos están incluidos en la publicación. En comparación con el cifrado de eventos, el cifrado de atributos generalmente resulta en mayores costos de procesamiento, ya que cada atributo se cifra por separado. En el proceso de encriptación, la inicialización del algoritmo de encriptación ocupa una parte significativa del tiempo total de ejecución del algoritmo. Una vez que el algoritmo está inicializado, aumentar la cantidad de datos a ser encriptados no afecta mucho el tiempo de ejecución. Esta disparidad se enfatiza en el cifrado de atributos, donde un algoritmo de cifrado debe ser inicializado para cada atributo por separado, y la cantidad de datos cifrados es relativamente pequeña. Como resultado, el cifrado de atributos conlleva mayores costos de procesamiento en comparación con el cifrado de eventos, lo cual se puede ver claramente en los resultados de rendimiento en la Sección 5. La ventaja del cifrado de atributos es que el propietario del tipo puede controlar el acceso al tipo de evento a nivel de atributo. El propietario del tipo de evento puede permitir que los clientes tengan diferentes niveles de acceso al mismo tipo de evento. Además, el cifrado a nivel de atributo permite el enrutamiento basado en el contenido en casos en los que un intermediario solo tiene acceso a algunos de los atributos del evento, reduciendo así el impacto general de la entrega de eventos en la red de intermediarios. Por lo tanto, la elección entre cifrado de eventos y cifrado de atributos es un compromiso entre expresividad y rendimiento, y depende de los requisitos de la aplicación distribuida. La expresividad proporcionada por el cifrado de atributos puede ser emulada introduciendo un nuevo tipo de evento para cada grupo de suscriptores con la misma autorización. El editor publicaría entonces una instancia de cada uno de estos tipos en lugar de publicar solo un evento combinado. Por ejemplo, en nuestra red policial de Londres, las cámaras de control de congestión tendrían que publicar un evento para el CCS y otro para el detective. Este enfoque podría volverse difícil de gestionar si los atributos tienen una variedad de propiedades de seguridad, ya que se requeriría un gran número de tipos de eventos y las políticas y suscripciones podrían cambiar dinámicamente. Este enfoque crea un gran número de eventos adicionales que deben ser enrutados a través de la red, como se muestra en la Sección 5.3. 3.3 Cifrado de suscripciones. Para proteger completamente la confidencialidad del contenido de los eventos, también debemos cifrar las suscripciones. Las suscripciones encriptadas garantizan: i) que solo los corredores autorizados pueden enviar suscripciones a la red de corredores, y ii) que los corredores no autorizados no obtienen información sobre el contenido del evento al monitorear qué suscripciones coincide con un evento dado. Por ejemplo, en el primer caso un corredor no autorizado puede crear suscripciones con filtros adecuadamente elegidos, dirigirlas hacia la raíz del árbol de difusión de eventos y monitorear qué eventos le fueron entregados como coincidentes con la suscripción. El hecho de que el evento coincidiera con la suscripción filtraría información al corredor sobre el contenido del evento incluso si el evento seguía encriptado. En el segundo caso, aunque un corredor no autorizado no pudiera crear suscripciones por sí mismo, aún podría revisar las suscripciones que se dirigían a través de él, tomar nota de los filtros de esas suscripciones y monitorear qué eventos le son entregados por corredores aguas arriba que coincidan con los filtros de suscripción. Esto revelaría nuevamente información sobre el contenido del evento al corredor no autorizado. En el caso de cifrar eventos completos, también ciframos el filtro de suscripción completo. El identificador del tipo de evento en la suscripción debe mantenerse intacto para permitir a los corredores de bolsa dirigir los eventos según su tema cuando no estén autorizados a acceder al filtro. En tales casos, se requiere que el corredor no autorizado asuma que los eventos de ese tipo coinciden con todas las expresiones de filtro. Cada filtro de atributo se encripta de forma individual, al igual que al encriptar una publicación. Además del identificador del tipo de evento, los identificadores de atributos también se dejan intactos para permitir que los corredores autorizados descifren esos filtros a los que tienen acceso, y enrutan el evento en función de si coincide con los filtros descifrados. 3.4 Evitar Operaciones Criptográficas Innecesarias No es necesario cifrar el contenido del evento si el corredor actual y el siguiente corredor en el árbol de difusión de eventos tienen las mismas credenciales con respecto al tipo de evento en cuestión. Por ejemplo, se puede asumir que todos los corredores dentro de una organización compartirían las mismas credenciales y, por lo tanto, siempre que el siguiente corredor sea miembro del mismo dominio, el evento puede ser enrutado hacia él en texto plano. Con el cifrado de atributos es posible que el corredor vecino esté autorizado para acceder a un subconjunto de los atributos descifrados, en cuyo caso los atributos a los que el corredor no está autorizado a acceder se le pasarían cifrados. Para saber cuándo es seguro pasar el evento en forma de texto plano, los corredores intercambian credenciales como parte de un saludo cuando se conectan entre sí. En los casos en que los corredores puedan verificar las credenciales de los demás, los agregarán a la tabla de enrutamiento para futuras referencias. Si un corredor adquiere nuevas credenciales después del saludo inicial, presentará estas nuevas credenciales a sus vecinos mientras esté en sesión. Independientemente de sus corredores vecinos, el PHB siempre cifrará el contenido del evento, ya que es más económico cifrar el evento una vez en la raíz del árbol de difusión de eventos. En Hermes, el nodo de encuentro para cada tipo de evento se selecciona de forma uniformemente aleatoria (el nombre del tipo de evento se hashea con el algoritmo de hash SHA-1 para producir el tipo de evento 108 PHB IBIB IB SHB RN IB SHB Figura 2: La dirección de los nodos está distribuida de manera uniforme en toda la red, por lo que los nodos de encuentro pueden encontrarse fuera del dominio que posee un tipo de evento IB IB SHBPHBP S Encripta Filtra desde la caché Desencripta, entrega Desencripta, filtra Texto plano Caché de texto plano (la mayoría de los datos) Caché de texto plano (algunos datos) Diferentes dominios Cifrado CLAVE Figura 3: Almacenamiento en caché de datos desencriptados para aumentar la eficiencia al entregar a pares con privilegios de seguridad equivalentes, luego el identificador se utiliza para seleccionar el nodo de encuentro en la red superpuesta estructurada). Por lo tanto, es probable que el nodo de encuentro resida fuera del dominio actual. Esta situación está ilustrada en el árbol de difusión del evento en la Figura 2. Incluso con aplicaciones internas del dominio, donde el evento puede ser enviado desde el publicador a todos los suscriptores en forma de texto plano, el contenido del evento en la mayoría de los casos tendrá que ser encriptado para poder ser enviado al nodo de encuentro. Para evitar desciframientos innecesarios, adjuntamos una caché de contenido en texto plano a los eventos encriptados. Un corredor llena la caché con contenido que ha descifrado, por ejemplo, para filtrar en el contenido. El caché es accedido por el intermediario cuando entrega un evento a un suscriptor local después de verificar primero si el evento coincide con el filtro de suscripción, pero el intermediario también envía el caché al siguiente intermediario con el evento encriptado. El siguiente corredor puede buscar el atributo en la caché en lugar de tener que descifrarlo. Si el evento se envía a un corredor no autorizado, la caché se descartará antes de que se envíe el evento. Obviamente, enviar la caché con el evento encriptado aumentará el costo de comunicación, pero esto se compensa con el ahorro en el procesamiento de encriptación/desencriptación. En la Fig. 3 vemos dos flujos de texto sin formato en caché separados que acompañan a un evento dependiendo de las relaciones entre intermediarios en dos dominios diferentes. Mostramos en la Sección 5.2 que el costo adicional de enviar mensajes encriptados con una caché de texto completo incurre en casi ningún costo adicional en comparación con el envío de mensajes de texto plano. 3.5 Implementación En nuestra implementación hemos utilizado el modo de operación EAX [2] al encriptar eventos, atributos y filtros de suscripción. EAX es un modo de operación para cifradores de bloque, también llamado algoritmo de Cifrado Autenticado con Datos Asociados (AEAD) que proporciona simultáneamente confidencialidad de datos y protección de integridad. El algoritmo implementa un esquema de dos pasos donde durante el primer paso se encripta el texto plano, y en el segundo paso se genera un código de autenticación de mensaje (MAC) para los datos encriptados. El modo EAX es compatible con cualquier cifrador de bloques. Decidimos utilizar el algoritmo Estándar de Encriptación Avanzada (AES) en nuestra implementación, debido a su estatus estándar y al hecho de que el algoritmo ha sido sometido a un exhaustivo criptoanálisis durante su existencia y hasta el momento no se han encontrado vulnerabilidades graves. Además de proporcionar confidencialidad e integridad, el modo EAX utiliza el cifrado de bloque subyacente en modo de contador (modo CTR) [21]. Un cifrado de bloque en modo de contador se utiliza para producir una secuencia de bits de clave que luego se XORean con el texto plano. El modo CTR transforma efectivamente un cifrado por bloques en un cifrado de flujo. La ventaja de los cifrados de flujo es que el texto cifrado tiene la misma longitud que el texto plano, mientras que con los cifrados de bloque el texto plano debe ser rellenado a un múltiplo de la longitud del bloque del cifrado de bloque (por ejemplo, el tamaño de bloque de AES es de 128 bits). Evitar el relleno es muy importante en el cifrado de atributos, ya que el relleno podría aumentar el tamaño del atributo de manera desproporcionada. Por ejemplo, un solo entero podría tener una longitud de 32 bits, que se rellenaría a 128 bits si usáramos un cifrado por bloques. Con el cifrado de eventos, la expansión del mensaje no es tan relevante, ya que la longitud del relleno necesario para alcanzar el siguiente múltiplo de 16 bytes probablemente será una pequeña proporción de la longitud total del texto plano. En el modo de cifrado, el algoritmo EAX toma como entrada un nonce (un número usado una vez), una clave de cifrado y el texto plano, y devuelve el texto cifrado y una etiqueta de autenticación. En el modo de descifrado, el algoritmo toma como entrada la clave de cifrado, el texto cifrado y la etiqueta de autenticación, y devuelve ya sea el texto plano, o un error si la verificación de autenticación falló. El nonce se expande a la longitud del bloque del cifrado de bloque subyacente al pasar a través de una construcción OMAC (ver [7]). Es importante que los valores de nonce particulares no se reutilicen, de lo contrario, el cifrado de bloques en modo CTR produciría una secuencia de clave idéntica. En nuestra implementación utilizamos la marca de tiempo del evento definida por PHB (valor de 64 bits que cuenta los milisegundos desde el 1 de enero de 1970 UTC) seguida de la identidad de PHB (es decir, la clave pública) como nonce. El corredor es responsable de asegurarse de que las marcas de tiempo aumenten de forma monótona. La etiqueta de autenticación se añade al texto cifrado producido para crear un par ordenado. Con el cifrado de eventos se crea una única etiqueta para el evento cifrado. Con el cifrado de atributo 109, cada atributo se cifra y autentica por separado, y todos tienen sus etiquetas individuales. La longitud de la etiqueta es configurable en EAX sin restricciones, lo que permite al usuario hacer un equilibrio entre las garantías de autenticidad proporcionadas por EAX y la sobrecarga de comunicación añadida. Utilizamos una longitud de etiqueta de 16 bytes en nuestra implementación, pero se podría hacer que la longitud de la etiqueta sea un parámetro definido por el publicador/suscriptor para cada publicación/suscripción o incluirlo en la definición del tipo de evento para hacerlo un parámetro específico del tipo. EAX también admite incluir datos asociados no encriptados en el cálculo de la etiqueta. La integridad de estos datos está protegida, pero sigue siendo legible por todos. Esta característica podría ser utilizada con cifrado de eventos en casos donde parte del contenido del evento es público y, por lo tanto, sería útil para enrutamiento basado en contenido. La integridad de los datos seguiría protegida contra cambios, pero los intermediarios no autorizados podrían aplicar filtros. Hemos incluido el identificador del tipo de evento como datos asociados para proteger su integridad. Otros algoritmos AEAD incluyen el modo de libro de códigos de desplazamiento (OCB) [17] y el modo de contador con CBC-MAC (CCM) [22]. A diferencia del modo EAX, el modo OCB solo requiere un paso sobre el texto plano, lo que lo hace aproximadamente el doble de rápido que EAX. Desafortunadamente, el modo OCB tiene una solicitud de patente en los Estados Unidos, lo que restringe su uso. El modo CCM es el predecesor del modo EAX. Fue desarrollado con el fin de proporcionar una alternativa gratuita a OCB. El EAX se desarrolló más tarde para abordar algunos problemas con CCM [18]. De manera similar a EAX, CCM también es un modo de dos pasadas. 4. GESTIÓN DE CLAVES En ambos enfoques de cifrado, el contenido del evento cifrado tiene un identificador único a nivel mundial (es decir, el tipo de evento o el identificador del atributo). Ese identificador se utiliza para determinar la clave de encriptación que se debe usar al encriptar o desencriptar el contenido. Cada tipo de evento, en el cifrado de eventos, y atributo, en el cifrado de atributos, tiene su propia clave de cifrado individual. Al controlar el acceso a la clave de cifrado, controlamos efectivamente el acceso al contenido del evento cifrado. Para controlar el acceso a las claves de cifrado, formamos un grupo de claves de intermediarios para cada clave de cifrado individual. El grupo clave se utiliza para actualizar la clave cuando sea necesario y para entregar la nueva clave a todos los miembros actuales del grupo clave. El gerente del grupo clave es responsable de verificar que un nuevo miembro que solicita unirse al grupo clave esté autorizado para hacerlo. Por lo tanto, el administrador del grupo clave debe ser confiable por el propietario del tipo para hacer cumplir la política de control de acceso. Suponemos que el administrador del grupo clave es o bien un tercero de confianza o, alternativamente, un miembro del dominio de propietarios del tipo. En [12] Pesonen et al. propusieron una arquitectura de control de acceso basada en capacidades para sistemas de publicación/suscripción multi-dominio. El enfoque utiliza capacidades para descentralizar la política de control de acceso entre los nodos de publicación/suscripción (es decir, clientes y corredores): cada nodo posee un conjunto de capacidades que definen la autoridad otorgada a ese nodo. La autoridad para acceder a un tipo de evento específico es otorgada por el propietario de ese tipo al emitir una capacidad a un nodo. La capacidad define el tipo de evento, la acción y los atributos que el Propietario del Tipo, el Corredor, y el Administrador de Claves deben seguir. 1. Conceder autorización para la clave de la placa de número. 2. El Corredor solicita unirse al grupo de claves de la placa de número. 5. Si el corredor cumple con todas las verificaciones, comenzará a recibir las claves apropiadas. 3. El Administrador de Claves puede verificar las credenciales de los corredores en el Servicio de Control de Acceso. 4. El Administrador de Claves puede verificar que el Propietario del Tipo permita el acceso. Figura 4: Los pasos involucrados para que un corredor tenga éxito al unirse a un grupo de claves al que el nodo está autorizado a acceder. Por ejemplo, una tupla <NP, suscribirse, *> autorizaría al propietario a suscribirse a eventos de matrícula con acceso a todos los atributos en los eventos publicados. La secuencia de eventos necesarios para que un corredor se una con éxito a un grupo clave se muestra en la Figura 4. Tanto el corredor de alojamiento del cliente como el cliente deben estar autorizados para realizar la solicitud del cliente. Es decir, si el cliente realiza una solicitud de suscripción para eventos de matrícula, tanto el cliente como el corredor local deben estar autorizados para suscribirse a eventos de matrícula. Esto se debe a que, desde la perspectiva de la red de corredores, el corredor local actúa como un intermediario para el cliente. Utilizamos las mismas capacidades para autorizar la membresía en un grupo clave que se utilizan para autorizar las solicitudes de publicación/suscripción. No hacerlo podría llevar a la situación inconsistente en la que un SHB está autorizado para realizar una suscripción en nombre de sus clientes, pero no puede descifrar el contenido de eventos entrantes para ellos. En el ejemplo de la Matrícula anterior, el corredor local que posee la capacidad mencionada está autorizado para unirse al grupo clave de Matrícula, así como a los grupos clave de todos los atributos en el tipo de evento de Matrícula. La encriptación de contenido de eventos en un sistema de publicación/suscripción multi-dominio descentralizado puede considerarse como una subcategoría de la comunicación de grupo segura. En ambos casos, el sistema de gestión de claves debe escalar bien con el número de clientes, los clientes pueden estar distribuidos en áreas geográficas extensas, puede haber altas tasas de rotación en la membresía del grupo, y todos los miembros deben estar sincronizados entre sí en tiempo para poder utilizar la misma clave de cifrado al mismo tiempo. Existen varios protocolos de gestión de claves escalables para comunicación segura en grupo [15]. Hemos implementado el protocolo del Árbol de Función Unidireccional (OFT) [8] como una prueba de concepto. Decidimos implementar OFT debido a su relativa simplicidad y buen rendimiento. Nuestra implementación utiliza la misma red de superposición estructurada utilizada por la red de intermediarios como transporte. El protocolo OFT se basa en un árbol binario donde los participantes se encuentran en las hojas del árbol. Escalando en log2n en costos de procesamiento y comunicación, así como en el tamaño del estado almacenado en cada participante, lo cual hemos verificado en nuestras simulaciones. 4.2 Actualización de claves Tradicionalmente, en los esquemas de gestión de claves de grupo, la clave de cifrado se actualiza cuando un nuevo miembro se une al grupo, un miembro existente abandona el grupo o expira un temporizador. Actualizar la clave cuando un nuevo miembro se une proporciona secrecía hacia atrás, es decir, se evita que el nuevo miembro acceda a los mensajes antiguos. Refrescar la clave de manera similar cuando un miembro existente se va proporciona secreto hacia adelante, es decir, se evita que el antiguo miembro acceda a los mensajes futuros. Se emiten actualizaciones periódicas desencadenadas por temporizador para limitar el daño causado por la clave actual comprometida. Aunque los protocolos de gestión de claves de última generación son eficientes, refrescar la clave innecesariamente introduce tráfico adicional y procesamiento entre los miembros del grupo de claves. En nuestro caso, la membresía del grupo clave se basa en que el corredor posea una capacidad que lo autorice a unirse al grupo clave. La capacidad tiene un conjunto de condiciones de validez que, en su forma más simple, definen un período de tiempo durante el cual el certificado es válido, y en casos más complejos implican verificaciones en línea hacia el emisor. Para evitar actualizaciones innecesarias de claves, el administrador de claves examina las condiciones de validez del certificado del miembro que se une o abandona. En caso de unirse a un miembro, si el gerente puede asegurar que el certificado era válido en el momento de la actualización de clave anterior, se puede evitar una nueva actualización de clave. De manera similar, en lugar de actualizar la clave inmediatamente cuando un miembro abandona el grupo de claves, el administrador de claves puede almacenar en caché sus credenciales y actualizar la clave solo cuando las credenciales expiren. Estas situaciones están ilustradas en la Fig. 5. Se puede asumir que las credenciales otorgadas a los corredores son relativamente estáticas, es decir, una vez que un dominio está autorizado para acceder a un tipo de evento, la autoridad será delegada a todos los corredores de ese dominio, y tendrán la autoridad en el futuro previsible. Se implementaría un control de acceso más detallado y dinámico en el borde de la red del intermediario entre los clientes y los intermediarios que alojan a los clientes. Cuando se actualiza una clave de encriptación, la nueva clave se etiqueta con una marca de tiempo. La clave de encriptación a utilizar para un evento dado se selecciona en función de la marca de tiempo de publicación del evento. Las llaves antiguas se mantendrán durante un tiempo razonable para permitir cierta desviación del reloj. Establecer este valor es parte del protocolo de gestión de claves, aunque exactamente cuánto tiempo debe ser dependerá de la naturaleza de la aplicación y posiblemente del tamaño de la red. Se puede configurar de forma independiente por grupo de teclas si es necesario. 5. EVALUACIÓN Para evaluar el rendimiento del cifrado de contenido del evento, hemos implementado ambos enfoques de cifrado ejecutándose en nuestra implementación del middleware de publicación/suscripción Hermes. La implementación admite tres modos: contenido en texto plano, cifrado de eventos y cifrado de atributos, en un único sistema de publicación/suscripción. Realizamos tres pruebas de rendimiento en un simulador de eventos discretos. El simulador se ejecutó en una estación de trabajo Intel P4 de 3.2GHz con 1GB de memoria principal. Decidimos realizar las pruebas en un simulador de eventos en lugar de en un sistema desplegado real para poder medir el tiempo total que lleva manejar todos los mensajes en el sistema. Las siguientes secciones describen con más detalle las configuraciones específicas de las pruebas y los resultados. 5.1 Sobrecarga de Extremo a Extremo La prueba de sobrecarga de extremo a extremo muestra cuánto se vio afectado el rendimiento general del mensaje del simulador por la encriptación del contenido del evento. Formamos una red de corredores con dos corredores, adjuntamos un editor a uno de ellos y un suscriptor al otro. El suscriptor se suscribió al tipo de evento anunciado sin ningún filtro, es decir, cada publicación coincidía con la publicación del suscriptor y, por lo tanto, se entregaba al suscriptor. El test mide el tiempo combinado que se tarda en publicar y entregar 100,000 eventos. Si el contenido está encriptado, esto incluye tanto encriptar el contenido en el PHB como desencriptarlo en el SHB. En la prueba, el número de atributos en el tipo de evento se incrementa de 1 a 25 (el eje x). Cada atributo se establece como una cadena de 30 caracteres. Para cada número de atributos en el tipo de evento, el editor publica 100,000 eventos, y se mide el tiempo transcurrido para derivar el rendimiento del mensaje. El test se repitió cinco veces para cada número de atributos y utilizamos el promedio de todas las iteraciones en el gráfico, pero los resultados fueron altamente consistentes, por lo que la desviación estándar no se muestra. Los mismos tests se realizaron sin encriptación de contenido, encriptación de eventos y encriptación de atributos. Como se puede ver en la Fig. 6, el cifrado del contenido del evento introduce una gran sobrecarga en comparación con no usar cifrado. El rendimiento al utilizar cifrado de atributos con un tipo de evento con un atributo es del 46% del rendimiento logrado cuando los eventos se envían en texto plano. Cuando el número de atributos aumenta, la brecha de rendimiento también aumenta: con diez atributos, el rendimiento con cifrado de atributos ha disminuido al 11.7% del rendimiento en texto plano. El cifrado de eventos es más eficiente, debido a un menor número de operaciones de cifrado. El aumento en la cantidad de datos encriptados no afecta tanto al rendimiento como lo hace el número de operaciones de encriptación individuales. La diferencia en el rendimiento con la encriptación de eventos y la encriptación de atributos con solo un atributo es causada por el mecanismo de serialización de objetos de Java: en el caso de la encriptación de eventos, se serializa toda la estructura de atributos, lo que resulta en más objetos que al serializar un único valor de atributo. Una implementación más eficiente proporcionaría su propio mecanismo de empaquetado. Ten en cuenta que la implementación de EAX que utilizamos hace pasar el nonce (es decir, el vector de inicialización) a través de una construcción OMAC para aumentar su aleatoriedad. Dado que no es necesario mantener en secreto el nonce (solo que sea único), existe un posible compromiso entre tiempo y espacio que aún no hemos investigado al adjuntar atributos de nonce adicionales a los que ya se les ha aplicado este constructo OMAC. Eventos Internos del Dominio 5.2. Explicamos en la Sección 3.4 que el descifrado y cifrado del contenido del evento pueden evitarse si ambos corredores están autorizados para acceder al contenido del evento. Este test fue diseñado para demostrar que el uso del mecanismo de contenido de eventos encriptado entre dos corredores autorizados solo incurre en una pequeña sobrecarga de rendimiento. En esta prueba formamos nuevamente una red de corredores con dos corredores. 111 Programa de actualización de claves Corredor 1 uniéndose y saliendo del grupo de claves Corredor 2 uniéndose y saliendo del grupo de claves Tiempos reales de actualización de claves Tiempo Un día Las credenciales del grupo de claves de los corredores son válidas Tiempo real de unión Tiempo real de salida Un día Un día Figura 5: Cómo se ve afectado el programa de actualización de claves por la unión y salida de corredores de grupos de claves 0 5000 10000 15000 20000 25000 30000 35000 0 5 10 15 20 25 Mensajes por segundo Número de atributos Sin cifrado Cifrado de atributos Cifrado de contenido completo Figura 6: Rendimiento de eventos en un simulador Ambos corredores están configurados con las mismas credenciales. El editor está vinculado a uno de los corredores y el suscriptor al otro, y nuevamente el suscriptor no especifica ningún filtro en su suscripción. El editor publica 100,000 eventos y la prueba mide el tiempo transcurrido para derivar el rendimiento del mensaje del sistema. El contenido del evento está encriptado fuera de la medición de tiempo, es decir, el costo de encriptación no está incluido en las mediciones. El objetivo es modelar un entorno donde un corredor ha recibido un mensaje de otro corredor autorizado, y enruta el evento a un tercer corredor autorizado. En este escenario, el intermediario central no necesita descifrar ni cifrar el contenido del evento. Como se muestra en la Fig. 2, el tiempo transcurrido se midió a medida que el número de atributos en el evento publicado aumentaba de 1 a 25. Los valores de atributo en cada caso son cadenas de 30 caracteres. Cada prueba se repite cinco veces y utilizamos el promedio de todas las iteraciones en el gráfico. El mismo test fue luego repetido sin encriptación, con encriptación de eventos y con encriptación de atributos activada. Los modos encriptados siguen muy de cerca uno al otro. Predeciblemente, el modo de texto sin formato funciona un poco mejor para todos los recuentos de atributos. La diferencia puede explicarse parcialmente porque los eventos encriptados son de mayor tamaño, ya que incluyen tanto el texto plano como el contenido encriptado en esta prueba. La diferencia en el rendimiento es del 3.7% con un atributo y del 2.5% con 25 atributos. Creemos que la rugosidad de los gráficos puede ser explicada por el recolector de basura de Java interfiriendo con la simulación. El hecho de que los tres gráficos muestren las mismas irregularidades respalda esta teoría. A través de la definición de múltiples tipos de eventos, es posible emular la expresividad del cifrado de atributos utilizando solo el cifrado del contenido del evento. El último test que realizamos fue para mostrar la sobrecarga de comunicación causada por esta técnica de emulación, en comparación con el uso de cifrado de atributos reales. En la prueba formamos una red de corredores de 2000 corredores. Adjuntamos un editor a uno de los corredores, y un número creciente de suscriptores a los corredores restantes. Cada suscriptor simula un grupo de suscriptores que tienen los mismos derechos de acceso al evento publicado. Cada grupo de suscriptores tiene su propio tipo de evento en la prueba. El resultado de esta prueba se muestra en la Figura 8. El número de grupos de suscriptores se incrementa de 1 a 50 (el eje x). Para cada grupo de suscriptores n, el editor publica un evento para representar el uso de cifrado de atributos y n eventos que representan los eventos para cada grupo de suscriptores. Contamos el número de saltos que cada publicación realiza a través de la red de intermediarios (eje y). Ten en cuenta que la Fig. 8 muestra cargas de trabajo más allá de lo que esperaríamos en un uso común, en el que es probable que muchos tipos de eventos contengan menos de diez atributos. Los grupos de suscriptores utilizados en esta prueba representan conjuntos de permisos disjuntos sobre los atributos de eventos. El número de estos conjuntos puede determinarse a partir de la política de control de acceso particular en uso, pero será un valor menor o igual al factorial del número de atributos en un tipo de evento dado. Los gráficos indican que el cifrado por atributo funciona mejor que el cifrado por evento incluso para un pequeño número de grupos de suscriptores. De hecho, con solo dos grupos de suscriptores (por ejemplo, el caso de eventos de matrícula), el recuento de saltos aumenta de 7.2 saltos para el cifrado de atributos a 16.6 saltos para el cifrado de eventos. Con 10 grupos de suscriptores, los números correspondientes son 24.2 y 251.0, es decir, una diferencia de un orden de magnitud. 6. TRABAJO RELACIONADO Wang et al. han categorizado los diversos problemas de seguridad que deben abordarse en los sistemas de publicación/suscripción en el futuro en [20]. El artículo es una visión general exhaustiva de los problemas de seguridad en los sistemas de publicación/suscripción y, como tal, intenta llamar la atención sobre los problemas en lugar de proporcionar soluciones. Bacon et al. en [1] examinan el uso del control de acceso basado en roles en sistemas de publicación/suscripción distribuidos de múltiples dominios. Su trabajo es complementario a este documento: el RBAC distribuido es una posible formalización de políticas que podría utilizar los mecanismos de aplicación que hemos presentado. Opyrchal y Prakash abordan el problema de la confidencialidad de eventos en el último enlace entre el suscriptor y el SHB en [10]. Ellos afirman correctamente que un enfoque de comunicación de grupo seguro es inviable en un entorno como el de publicar/suscribir que tiene membresías de grupo altamente dinámicas. Como solución, proponen un esquema que utiliza el almacenamiento en caché de claves y la agrupación de suscriptores para minimizar el número de cifrados necesarios al entregar una publicación de un SHB a un conjunto de suscriptores coincidentes. En nuestro trabajo asumimos que el SHB es lo suficientemente potente como para manejar una conexión segura de TLS para cada suscriptor local. Tanto Srivatsa et al. [19] como Raiciu et al. [16] presentan mecanismos para proteger la confidencialidad de los mensajes en infraestructuras descentralizadas de publicación/suscripción. En comparación con nuestro trabajo, ambos artículos tienen como objetivo proporcionar los medios para proteger la integridad y confidencialidad de los mensajes, mientras que el objetivo de nuestro trabajo es hacer cumplir el control de acceso dentro de la red del intermediario. Raiciu et al. asumen en su trabajo que ninguno de los intermediarios en la red es de confianza y, por lo tanto, todos los eventos están encriptados desde el publicador hasta el suscriptor y que todas las coincidencias se basan en eventos encriptados. Por el contrario, asumimos que algunos de los intermediarios en el camino de una publicación son de confianza para acceder a esa publicación y, por lo tanto, pueden implementar la coincidencia de eventos. También asumimos que los corredores de publicación y suscripción alojados son siempre de confianza para acceder a la publicación. Las contribuciones de Srivatsa et al. y Raiciu et al. son complementarias a las contribuciones en este artículo. Finalmente, Fiege et al. abordan el tema relacionado con la visibilidad de eventos en [6]. Si bien el trabajo se centró en el uso de alcances como mecanismo para estructurar sistemas basados en eventos a gran escala, la noción de visibilidad de eventos sí se relaciona con el control de acceso en cierta medida. 7. CONCLUSIONES El cifrado del contenido del evento puede ser utilizado para hacer cumplir una política de control de acceso mientras los eventos están en tránsito en la red de intermediarios de un sistema de publicación/suscripción multi-dominio. El cifrado genera una sobrecarga, pero i) puede que no haya alternativa cuando se requiere control de acceso, y ii) la penalización en el rendimiento puede reducirse con optimizaciones de implementación, como pasar contenido en texto plano almacenado en caché junto con contenido cifrado entre intermediarios con credenciales de seguridad idénticas. Esto es especialmente apropiado si las conexiones de intermediario a intermediario están aseguradas por defecto, de modo que el espionaje de cables no sea un problema. El cifrado a nivel de atributo se puede implementar para hacer cumplir políticas de control de acceso detalladas. Además de proporcionar control de acceso a nivel de atributo, el cifrado de atributos permite a los intermediarios parcialmente autorizados implementar enrutamiento basado en contenido basado en los atributos a los que tienen acceso. Nuestros experimentos muestran que i) al almacenar en caché el contenido de texto plano y cifrado cuando es posible, podemos ofrecer un rendimiento comparable a los eventos de texto plano, y ii) que la encriptación de atributos dentro de un evento incurre en mucho menos sobrecarga que definir tipos de eventos separados para los atributos que necesitan diferentes niveles de protección. En entornos que comprenden múltiples dominios, donde los brokers de eventos tienen diferentes credenciales de seguridad, hemos cuantificado cómo se puede hacer un equilibrio entre el rendimiento y la expresividad. Agradecimientos Nos gustaría agradecer a los revisores anónimos por sus comentarios muy útiles. Lauri Pesonen cuenta con el apoyo del EPSRC (GR/T28164) y la Fundación Nokia. David Eyers cuenta con el apoyo de EPSRC (GR/S94919). 114 8. REFERENCIAS [1] J. Bacon, D. M. Eyers, K. Moody y L. I. W. Pesonen. Asegurando la publicación/suscripción para sistemas multi-dominio. En G. Alonso, editor, Middleware, volumen 3790 de las Notas de Conferencia en Ciencias de la Computación, páginas 1-20. Springer, 2005. [2] M. Bellare, P. Rogaway, y D. Wagner. Eax: Un modo de autenticación y cifrado convencional. Archivo de Criptología ePrint, Reporte 2003/069, 2003. http://eprint.iacr.org/. [3] A. Carzaniga, D. S. Rosenblum y A. L. Wolf. Diseño y evaluación de un servicio de notificación de eventos de amplia área. ACM Transactions on Computer Systems, 19(3):332-383, ago. 2001. [4] M. Castro, P. Druschel, A. Kermarrec y A. Rowstron. SCRIBE: Una infraestructura de multidifusión a nivel de aplicación a gran escala y descentralizada. Revista IEEE sobre Áreas Seleccionadas en Comunicaciones (JSAC), 20(8):1489-1499, Oct. 2002. [5] T. Dierks y C. Allen. El protocolo TLS, versión 1.0. RFC 2246, Grupo de Trabajo de Ingeniería de Internet, enero de 1999. [6] L. Fiege, M. Mezini, G. M uhl y A. P. Buchmann. Diseñando sistemas basados en eventos con alcances. En ECOOP 02: Actas de la 16ª Conferencia Europea sobre Programación Orientada a Objetos, páginas 309-333, Londres, Reino Unido, 2002. Springer-Verlag. [7] T. Iwata y I. Iurosawa. OMAC: One-key CBC MAC, 14 de enero de 2002. [8] D. A. McGrew y A. T. Sherman. Establecimiento de clave en grupos grandes y dinámicos utilizando árboles de funciones unidireccionales. Informe técnico 0755, Laboratorios TIS en Network Associates, Inc., Glenwood, MD, mayo de 1998. [9] Instituto Nacional de Estándares y Tecnología (NIST). Estándar de Cifrado Avanzado (AES). Publicación de Normas Federales de Procesamiento de Información (FIPS PUB) 197, noviembre de 2001. [10] L. Opyrchal y A. Prakash. Distribución segura de eventos en sistemas de publicación y suscripción basados en contenido. En Actas del 10º Simposio de Seguridad USENIX. USENIX, ago. 2001. [11] L. I. W. Pesonen y J. Bacon. Tipos de eventos seguros en sistemas de publicación/suscripción basados en contenido y multi-dominio. En SEM 05: Actas del 5º taller internacional sobre ingeniería de software y middleware, páginas 98-105, Nueva York, NY, EE. UU., septiembre de 2005. ACM Press. [12] L. I. W. Pesonen, D. M. Eyers y J. Bacon. Una arquitectura de control de acceso basada en capacidades para sistemas de publicación/suscripción multi-dominio. En Actas del Simposio sobre Aplicaciones y la Internet (SAINT 2006), páginas 222-228, Phoenix, AZ, enero de 2006. IEEE. [13] P. R. Pietzuch y J. M. Bacon. Hermes: Una arquitectura middleware distribuida basada en eventos. En Actas del 1er Taller Internacional sobre Sistemas Basados en Eventos Distribuidos (DEBS02), páginas 611-618, Viena, Austria, julio de 2002. IEEE. [14] P. R. Pietzuch y S. Bhola. Control de congestión en un middleware orientado a mensajes confiable y escalable. En M. Endler y D. Schmidt, editores, Actas del 4to Congreso Internacional. Conferencia sobre Middleware (Middleware 03), páginas 202-221, Río de Janeiro, Brasil, junio de 2003. Springer. [15] S. Rafaeli y D. Hutchison. Una encuesta sobre la gestión de claves para la comunicación segura en grupo. ACM Computing Surveys, 35(3):309-329, 2003. [16] C. Raiciu y D. S. Rosenblum. Habilitando la confidencialidad en infraestructuras de publicación/suscripción basadas en contenido. En Securecomm 06: Actas de la Segunda Conferencia Internacional IEEE/CreatNet sobre Seguridad y Privacidad en Redes de Comunicación, 2006. [17] P. Rogaway, M. Bellare, J. Negro, y T. Krovetz. OCB: un modo de operación de cifrado de bloque para una eficiente encriptación autenticada. En la Conferencia ACM sobre Seguridad Informática y de Comunicaciones, páginas 196-205, 2001. [18] P. Rogaway y D. Wagner. Una crítica de CCM, febrero de 2003. [19] M. Srivatsa y L. Liu. Asegurando servicios de superposición de publicación-suscripción con eventguard. En CCS 05: Actas de la 12ª conferencia de ACM sobre seguridad informática y de comunicaciones, páginas 289-298, Nueva York, NY, EE. UU., 2005. ACM Press. [20] C. Wang, A. Carzaniga, D. Evans, y A. L. Wolf. Problemas de seguridad y requisitos en sistemas de publicación-suscripción a escala de internet. En Actas de la 35ª Conferencia Internacional de Ciencias de Sistemas de Hawái (HICSS02), Isla Grande, HI, EE. UU., 2002. IEEE. [21] D. Whitfield y M. Hellman. Privacidad y autenticación: Una introducción a la criptografía. En Actas del IEEE, volumen 67, páginas 397-427, 1979. [22] D. Whiting, R. Housley y N. Ferguson. Contraataque con CBC-MAC (CCM). RFC 3610, Grupo de Trabajo de Ingeniería de Internet, septiembre de 2003. 115