Diseño de mecanismos automatizados de interés propio e implicaciones para subastas combinatorias óptimas∗ Vincent Conitzer Universidad Carnegie Mellon 5000 Forbes Avenue Pittsburgh, PA 15213, EE. UU. conitzer@cs.cmu.edu Tuomas Sandholm Universidad Carnegie Mellon 5000 Forbes Avenue Pittsburgh, PA 15213, EE. UU. sandholm@cs.cmu.edu RESUMEN A menudo, un resultado debe ser elegido en base a las preferencias reportadas por un grupo de agentes. La dificultad clave es que los agentes pueden informar sus preferencias de manera insincera para hacer que el resultado elegido les resulte más favorable. El diseño de mecanismos es el arte de diseñar las reglas del juego de manera que los agentes estén motivados a informar sus preferencias de manera veraz, y se elija un resultado deseable. En un enfoque recientemente propuesto, llamado diseño de mecanismos automatizado, se calcula un mecanismo para la configuración de agregación de preferencias actual. Esto tiene varias ventajas, pero el inconveniente es que el problema de optimización del diseño del mecanismo debe resolverse de nuevo cada vez. A diferencia de trabajos anteriores sobre el diseño automatizado de mecanismos que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño automatizado de mecanismos donde el diseñador está interesado en sí mismo. En este caso, al centro solo le importa qué resultado se elige y qué pagos se le hacen. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a asegurar que cada agente esté al menos tan bien como estaría si no hubiera participado en el mecanismo. En este contexto, demostramos que el diseño de mecanismos deterministas óptimos es NP-completo en dos casos especiales importantes: cuando el centro está interesado solo en los pagos realizados hacia él, y cuando los pagos no son posibles y el centro está interesado solo en el resultado elegido. Luego mostramos cómo permitir la aleatorización en el mecanismo hace que los problemas en este entorno sean computacionalmente fáciles. Finalmente, demostramos que el problema de AMD que maximiza el pago está estrechamente relacionado con una variante interesante del problema de diseño de subasta combinatoria óptima (maximizadora de ingresos), donde los postores tienen preferencias solo por lo mejor. Mostramos que aquí también, diseñar una subasta determinista óptima es NP-completo, pero diseñar una subasta aleatoria óptima es fácil. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía Términos Generales Algoritmos, Economía, Teoría 1. En entornos multiagentes, a menudo se debe elegir un resultado en función de las preferencias informadas por un grupo de agentes. Tales resultados podrían ser presidentes potenciales, planes conjuntos, asignaciones de bienes o recursos, etc. El agregador de preferencias generalmente no conoce las preferencias de los agentes de antemano. Más bien, los agentes informan sus preferencias al coordinador. Desafortunadamente, un agente puede tener un incentivo para informar incorrectamente sus preferencias con el fin de engañar al mecanismo y lograr que seleccione un resultado que sea más deseable para el agente que el resultado que se seleccionaría si el agente revelara sus preferencias de manera honesta. Tal manipulación es indeseable porque los mecanismos de agregación de preferencias están diseñados para agrupar las preferencias de una manera socialmente deseable, y si los agentes revelan sus preferencias de manera insincera, se podría elegir un resultado socialmente indeseable. La manipulabilidad es un problema generalizado en los mecanismos de agregación de preferencias. Un resultado negativo seminal, el teorema de Gibbard-Satterthwaite, muestra que bajo cualquier esquema de agregación de preferencias no dictatorial, si hay al menos 3 posibles resultados, existen preferencias bajo las cuales un agente está mejor reportando falsamente [10, 23]. (Un esquema de agregación de preferencias se llama dictatorial si uno de los agentes dicta el resultado sin importar las preferencias que reporten los otros agentes). Lo que le gustaría hacer al agregador es diseñar un mecanismo de agregación de preferencias para que 1) los agentes interesados reporten sus preferencias de manera veraz, y 2) el mecanismo elija un resultado que sea deseable desde la perspectiva de algún objetivo. Esta es la configuración clásica del diseño de mecanismos en la teoría de juegos. En este documento, estudiamos el caso en el que el diseñador actúa por interés propio, es decir, al diseñador no le importa directamente cómo se relaciona el resultado con las preferencias de los agentes, sino que está más preocupado por su propia agenda sobre cuál resultado debería ser elegido y en maximizar los pagos para sí mismo. Este es el entorno de diseño de mecanismos más relevante para el comercio electrónico. En el caso en que el diseñador del mecanismo esté interesado en maximizar alguna noción de bienestar social, la importancia de recopilar las preferencias de los agentes es clara. Quizás sea menos obvio por qué deberían ser recopilados cuando el diseñador está interesado en sí mismo y, por lo tanto, su objetivo no está directamente relacionado con las preferencias de los agentes. La razón de esto es que a menudo las preferencias de los agentes imponen límites en cómo el diseñador elige el resultado y los pagos. La restricción más común de este tipo es la de racionalidad individual (RI), lo que significa que el mecanismo no puede dejar a ningún agente en una situación peor a la que hubiera estado si no hubiera participado en el mecanismo. Por ejemplo, en el contexto del diseño óptimo de subastas, el diseñador (subastador) solo se preocupa por cuántos ingresos se recaudan, y no en sí mismo por cuán bien la asignación del bien (o bienes) corresponde a las preferencias de los agentes. Sin embargo, el diseñador no puede obligar a un agente a pagar más de lo que valora el paquete de bienes asignado a él. Por lo tanto, incluso un diseñador interesado en sí mismo elegirá un resultado que beneficie razonablemente a los agentes. Por otro lado, el diseñador no necesariamente elegirá un resultado que maximice el bienestar social. Por ejemplo, si el diseñador siempre elige un resultado que maximiza el bienestar social con respecto a las preferencias informadas, y obliga a cada agente a pagar la diferencia entre la utilidad que tiene ahora y la utilidad que habría tenido si no hubiera participado en el mecanismo, es fácil ver que los agentes pueden tener un incentivo para informar incorrectamente sus preferencias, lo que puede llevar realmente a recaudar menos ingresos. De hecho, uno de los resultados contraintuitivos de la teoría del diseño de subastas óptimas es que a veces el bien se asigna a nadie incluso cuando el subastador tiene un precio de reserva de 0. El diseño de mecanismos clásicos proporciona algunos mecanismos generales, que, bajo ciertas suposiciones, satisfacen alguna noción de no manipulabilidad y maximizan algún objetivo. La ventaja de estos mecanismos es que no dependen de información (incluso probabilística) sobre las preferencias de los agentes (por ejemplo, el mecanismo de Vickrey-Clarke-Groves (VCG) [24, 4, 11]), o pueden aplicarse fácilmente a cualquier distribución de probabilidad sobre las preferencias (por ejemplo, el mecanismo dAGVA [8, 2], la subasta de Myerson [18], y la subasta multiunidad de Maskin-Riley [17]). Sin embargo, los mecanismos generales también tienen importantes desventajas: • Los mecanismos generales más famosos y ampliamente aplicables, VCG y dAGVA, solo maximizan el bienestar social. Si el diseñador está interesado en sí mismo, como es el caso en muchos entornos de comercio electrónico, estos mecanismos no maximizan el objetivo del diseñador. • Los mecanismos generales que se centran en un diseñador interesado en sí mismo solo son aplicables en entornos muy restringidos, como la subasta de maximización de ingresos esperados de Myerson para vender un solo artículo, y la subasta de maximización de ingresos esperados de Maskin y Riley para vender múltiples unidades idénticas de un artículo. • Incluso en los entornos restringidos en los que se aplican estos mecanismos, solo permiten la maximización de pagos. En la práctica, el diseñador también puede estar interesado en el resultado en sí mismo. Por ejemplo, a un subastador le puede importar qué postor recibe el artículo. • A menudo se asume que los pagos laterales pueden ser utilizados para adaptar los incentivos de los agentes, pero esto no siempre es práctico. Por ejemplo, en los mercados electrónicos basados en trueque, como Recipco, firstbarter.com, BarterOne e Intagio, no se permiten los pagos laterales. Además, entre los agentes de software, podría ser más deseable construir mecanismos que no dependan de la capacidad de realizar pagos, ya que muchos agentes de software no cuentan con la infraestructura para hacer pagos. Por el contrario, seguimos un enfoque reciente donde el mecanismo se diseña automáticamente para el problema específico en cuestión. Este enfoque aborda todos los inconvenientes mencionados anteriormente. Formulamos el problema de diseño de mecanismos como un problema de optimización. La entrada se caracteriza por el número de agentes, los posibles tipos de agentes (preferencias) y las distribuciones previas de los agregadores sobre los tipos de agentes. La salida es un mecanismo no manipulable que es óptimo con respecto a algún objetivo. Este enfoque se llama diseño de mecanismos automatizado. El enfoque de diseño de mecanismos automatizado tiene cuatro ventajas sobre el enfoque clásico de diseñar mecanismos generales. Primero, se puede utilizar incluso en entornos que no cumplen con las suposiciones de los mecanismos clásicos (como la disponibilidad de pagos laterales o que el objetivo sea el bienestar social). Segundo, puede permitir a uno eludir resultados de imposibilidad (como el teorema de Gibbard-Satterthwaite) que establecen que no existe un mecanismo que sea deseable para todas las preferencias. Cuando el mecanismo está diseñado para la configuración actual, no importa que no funcione de manera más general. Tercero, puede generar mecanismos mejores (en términos de garantías de no manipulabilidad más sólidas y/o mejores resultados) que los mecanismos clásicos porque el mecanismo aprovecha las particularidades del entorno (la información probabilística que el diseñador tiene sobre los tipos de agentes). Dada la gran cantidad de información que las partes tienen entre sí hoy en día, es probable que este enfoque conduzca a ahorros enormes en comparación con los mecanismos clásicos, que en su mayoría ignoran esa información. Por ejemplo, imagina una empresa creando automáticamente su mecanismo de adquisiciones basado en el conocimiento estadístico sobre sus proveedores, en lugar de utilizar una subasta de adquisiciones descendente clásica. Cuarto, la carga del diseño se traslada de los humanos a una máquina. Sin embargo, el diseño automatizado de mecanismos requiere que el problema de optimización del diseño del mecanismo se resuelva de nuevo para cada configuración. Por lo tanto, su complejidad computacional se convierte en un tema clave. Investigaciones previas han estudiado esta pregunta para diseñadores benevolentes que desean maximizar, por ejemplo, el bienestar social [5, 6]. En este artículo estudiamos la complejidad computacional del diseño automatizado de mecanismos en el caso de un diseñador con interés propio. Esta es una configuración importante para el diseño de mecanismos automatizados debido a la escasez de mecanismos generales en esta área, y al hecho de que en la mayoría de las configuraciones de comercio electrónico el diseñador actúa en su propio interés. También demostramos que este problema está estrechamente relacionado con un problema de diseño de subasta combinatoria óptima (maximización de ingresos) particular. El resto de este documento está organizado de la siguiente manera. En la Sección 2, justificamos el enfoque en mecanismos no manipulables. En la Sección 3, definimos el problema que estudiamos. En la Sección 4, demostramos que diseñar un mecanismo determinista óptimo es NP-completo incluso cuando al diseñador solo le importan los pagos que recibe. En la Sección 5, demostramos que diseñar un mecanismo determinista óptimo también es NP-completo cuando los pagos no son posibles y el diseñador solo está interesado en el resultado elegido. En la Sección 6, demostramos que un mecanismo óptimo aleatorizado puede ser diseñado en tiempo polinómico incluso en el caso general. Finalmente, en la Sección 7, demostramos que para diseñar subastas combinatorias óptimas bajo preferencias de mejor opción solamente, nuestros resultados sobre AMD implican que este problema es NP-completo para subastas determinísticas, pero sencillo para subastas aleatorias. 2. JUSTIFICANDO EL ENFOQUE EN MECANISMOS NO MANIPULABLES Antes de definir el problema computacional del diseño automatizado de mecanismos, debemos justificar nuestro enfoque en mecanismos no manipulables. Después de todo, no es inmediatamente obvio que no haya mecanismos manipulables que, incluso cuando los agentes informan estratégicamente sus tipos y, por lo tanto, a veces de manera no veraz, aún logren mejores resultados (según el objetivo que usemos) que cualquier mecanismo no manipulable. Sin embargo, resulta ser el caso que, dado cualquier mecanismo, podemos construir un mecanismo no manipulable cuyo rendimiento es idéntico, de la siguiente manera. Construimos una capa de interfaz entre los agentes y el mecanismo original. Los agentes informan sus preferencias (o tipos) a la capa de interfaz; posteriormente, la capa de interfaz introduce en el mecanismo original los tipos que los agentes habrían informado estratégicamente al mecanismo original, si sus tipos fueran los declarados a la capa de interfaz. El resultado resultante es el resultado del nuevo mecanismo. Dado que la capa de interfaz actúa estratégicamente en nombre de cada agente, nunca hay un incentivo para informar falsamente a la capa de interfaz; por lo tanto, los tipos informados por la capa de interfaz son los tipos estratégicos que se habrían informado sin la capa de interfaz, por lo que los resultados son exactamente como habrían sido con el mecanismo original. Este argumento es conocido en la literatura de diseño de mecanismos como el principio de revelación [16]. (Existen dificultades computacionales al aplicar el principio de revelación en espacios de resultados y tipos combinatorios grandes [7, 22]). Sin embargo, dado que aquí nos enfocamos en espacios de resultados y tipos representados de forma plana, esto no es una preocupación aquí. Dado esto, podemos centrarnos en mecanismos veraces en el resto del documento. 3. DEFINICIONES Ahora formalizamos el entorno del diseño automatizado de mecanismos. Definición 1. En un entorno de diseño de mecanismos automatizados, se nos proporciona: • un conjunto finito de resultados O; • un conjunto finito de N agentes; • para cada agente i, 1. un conjunto finito de tipos Θi, 2. una distribución de probabilidad γi sobre Θi (en el caso de tipos correlacionados, hay una única distribución conjunta γ sobre Θ1 × . . . × ΘN), y 3. una función de utilidad ui: Θi × O → R; 1 • Una función objetivo cuya expectativa el diseñador desea maximizar. Existen muchas posibles funciones objetivo que el diseñador podría tener, por ejemplo, el bienestar social (donde el diseñador busca maximizar la suma de las utilidades de los agentes), o la utilidad mínima de cualquier agente (donde el diseñador busca maximizar la peor utilidad experimentada por cualquier agente). En ambos casos, el diseñador es benevolente, ya que, de alguna manera, el diseñador está buscando la felicidad colectiva de los agentes. Sin embargo, en este documento nos enfocamos en el caso de un diseñador interesado en sí mismo. Un diseñador egoísta solo se preocupa por el resultado elegido (es decir, al diseñador no le importa cómo se relaciona el resultado con las preferencias de los agentes, sino que tiene una preferencia fija sobre los resultados) y sobre los pagos netos realizados por los agentes, que fluyen hacia el diseñador. Definición 2. Un diseñador interesado tiene una función objetivo dada por g(o) + Σ i=1 πi, donde g : O → R indica las preferencias del diseñador sobre los resultados, y πi es el pago realizado por el agente i. En el caso en que g = 0 en todas partes, se dice que el diseñador está maximizando el pago. En el caso en que los pagos no sean posibles, g constituye la función objetivo por sí sola. Ahora definimos los tipos de mecanismos en estudio. Por el principio de revelación, podemos restringir la atención a mecanismos de revelación directa y veraz, donde los agentes informan directamente sus tipos y nunca tienen incentivos para informarlos de manera incorrecta. Definición 3. Consideramos los siguientes tipos de mecanismos: • Un mecanismo determinista sin pagos consiste en una función de selección de resultados o: Θ1 × Θ2 × . . . × ΘN → O. • Un mecanismo aleatorio sin pagos consiste en una función de selección de distribución p: Θ1 × Θ2 × . . . × ΘN → P(O), donde P(O) es el conjunto de distribuciones de probabilidad sobre O. • Un mecanismo determinista con pagos consiste en una función de selección de resultados o: Θ1 × Θ2 × . . . × ΘN → O y, para cada agente i, una función de selección de pagos πi: Θ1 × Θ2 × . . . × ΘN → R, donde πi(θ1, . . . , θN ) da el pago realizado por el agente i cuando los tipos reportados son θ1, . . . , θN. Aunque esto sigue la notación estándar de la teoría de juegos [16], el hecho de que el agente tenga tanto una función de utilidad como un tipo puede resultar confuso. Los tipos codifican las diversas preferencias posibles que el agente pueda tener, y el tipo de los agentes no es conocido por el agregador. La función de utilidad es un conocimiento común, pero debido a que el tipo de agente es un parámetro en la función de utilidad de los agentes, el agregador no puede saber cuál es la utilidad de los agentes sin conocer el tipo de agente. Un mecanismo aleatorio con pagos consiste en una función de selección de distribución p: Θ1 × Θ2 × . . . × ΘN → P(O), y para cada agente i, una función de selección de pago πi: Θ1 × Θ2 × . . . × ΘN → R. Hay dos tipos de restricciones para el diseñador al construir el mecanismo. 3.1 Restricciones de racionalidad individual (IR) El primer tipo de restricción es el siguiente. La utilidad de cada agente debe ser al menos tan grande como la utilidad de respaldo de los agentes, es decir, la utilidad que el agente recibiría si no participara en el mecanismo. De lo contrario, ese agente no participaría en el mecanismo, y la participación de ningún agente puede perjudicar el objetivo de los diseñadores del mecanismo, ya que en el peor de los casos, el mecanismo puede ignorar a un agente fingiendo que el agente no está presente. (Además, si no se aplicara tal restricción, el diseñador simplemente podría hacer que los agentes paguen una cantidad infinita). Este tipo de restricción se llama restricción de IR (racionalidad individual). Existen tres posibles restricciones de IR diferentes: ex ante, ex interim y ex post, dependiendo de lo que el agente sabe sobre su propio tipo y los tipos de los demás al decidir si participar en el mecanismo. Ex ante IR significa que el agente participaría si no supiera absolutamente nada (ni siquiera su propio tipo). No estudiaremos este concepto en este documento. Ex interim IR significa que el agente siempre participaría si conociera solo su propio tipo, pero no el de los demás. Ex post IR significa que el agente siempre participaría incluso si conociera el tipo de todos. Definiremos formalmente las dos últimas nociones de IR. Primero, necesitamos formalizar el concepto del resultado de respaldo. Suponemos que la utilidad de respaldo de cada agente es cero para cada uno de sus tipos. Esto se hace sin pérdida de generalidad porque podemos agregar un término constante a la función de utilidad de un agente (para un tipo dado), sin afectar el comportamiento de toma de decisiones de ese agente maximizador de utilidad esperada [16]. Definición 4. En cualquier entorno de diseño de mecanismos automatizados con una restricción de IR, existe un resultado de contingencia o0 ∈ O donde, para cualquier agente i y cualquier tipo θi ∈ Θi, tenemos ui(θi, o0) = 0. (Además, en el caso de un diseñador egoísta, g(o0) = 0). Ahora podemos definir las nociones de racionalidad individual. Definición 5. La racionalidad individual (RI) se define como: • Un mecanismo determinista es ex interim RI si para cualquier agente i, y cualquier tipo θi ∈ Θi, tenemos E(θ1,..,θi−1,θi+1,..,θN )|θi [ui(θi, o(θ1, .., θN ))−πi(θ1, .., θN )] ≥ 0. Un mecanismo aleatorio es ex interim IR si para cualquier agente i, y cualquier tipo θi ∈ Θi, tenemos que E(θ1,..,θi−1,θi+1,..,θN )|θi Eo|θ1,..,θn [ui(θi, o)−πi(θ1, .., θN )] ≥ 0. • Un mecanismo determinista es ex post IR si para cualquier agente i, y cualquier vector de tipos (θ1, . . . , θN ) ∈ Θ1 × . . . × ΘN , tenemos que ui(θi, o(θ1, . . . , θN )) − πi(θ1, . . . , θN ) ≥ 0. 2 No aleatorizamos sobre los pagos porque mientras los agentes y el diseñador sean neutrales al riesgo con respecto a los pagos, es decir, su utilidad es lineal en los pagos, no hay razón para aleatorizar sobre los pagos. Un mecanismo aleatorio es ex post IR si para cualquier agente i, y cualquier vector de tipos (θ1, . . . , θN ) ∈ Θ1 × . . . × ΘN , tenemos que Eo|θ1,..,θn [ui(θi, o) − πi(θ1, .., θN )] ≥ 0. Los términos relacionados con los pagos pueden ser omitidos en el caso de que los pagos no sean posibles. 3.2 Restricciones de compatibilidad de incentivos (IC) El segundo tipo de restricción establece que los agentes nunca deben tener un incentivo para informar incorrectamente su tipo (como se justificó anteriormente mediante el principio de revelación). Para este tipo de restricción, las dos variantes más comunes (o conceptos de solución) son la implementación en estrategias dominantes y la implementación en equilibrio de Bayes-Nash. Definición 6. En un entorno de diseño de mecanismos automatizados, se dice que un mecanismo implementa sus funciones de resultado y pago en estrategias dominantes si decir la verdad siempre es óptimo incluso cuando los tipos reportados por los otros agentes ya son conocidos. Formalmente, para cualquier agente i, cualquier vector de tipos (θ1, . . . , θi, . . . , θN ) ∈ Θ1 × . . . × Θi × . . . × ΘN , y cualquier informe de tipo alternativo ˆθi ∈ Θi, en el caso de mecanismos deterministas tenemos que ui(θi, o(θ1, . . . , θi, . . . , θN )) − πi(θ1, . . . , θi, . . . , θN ) ≥ ui(θi, o(θ1, . . . , ˆθi, . . . , θN )) − πi(θ1, . . . , ˆθi, . . . , θN ). En el caso de mecanismos aleatorios tenemos Eo|θ1,..,θi,..,θn [ui(θi, o) − πi(θ1, . . . , θi, . . . , θN )] ≥ Eo|θ1,.., ˆθi,..,θn [ui(θi, o) − πi(θ1, . . . , ˆθi, . . . , θN )]. Los términos relacionados con los pagos pueden ser omitidos en el caso de que los pagos no sean posibles. Por lo tanto, en la implementación de estrategias dominantes, decir la verdad es óptimo independientemente de lo que informen los otros agentes. Si es óptimo solo dado que los otros agentes son veraces, y dado que uno no conoce los tipos de los otros agentes, tenemos implementación en equilibrio de Bayes-Nash. Definición 7. En un entorno de diseño de mecanismos automatizados, se dice que un mecanismo implementa sus funciones de resultado y pago en equilibrio de Bayes-Nash si decir la verdad siempre es óptimo para un agente cuando ese agente aún no sabe nada sobre los tipos de los otros agentes, y los otros agentes están diciendo la verdad. Formalmente, para cualquier agente i, cualquier tipo θi ∈ Θi, y cualquier informe de tipo alternativo ˆθi ∈ Θi, en el caso de mecanismos deterministas tenemos que E(θ1,..,θi−1,θi+1,..,θN )|θi [ui(θi, o(θ1, . . . , θi, . . . , θN ))− πi(θ1, . . . , θi, . . . , θN )] ≥ E(θ1,..,θi−1,θi+1,..,θN )|θi [ui(θi, o(θ1, . . . , ˆθi, . . . , θN ))− πi(θ1, . . . , ˆθi, . . . , θN )]. En el caso de mecanismos aleatorios tenemos que E(θ1,..,θi−1,θi+1,..,θN )|θi Eo|θ1,..,θi,..,θn [ui(θi, o)− πi(θ1, . . . , θi, . . . , θN )] ≥ E(θ1,..,θi−1,θi+1,..,θN )|θi Eo|θ1,.., ˆθi,..,θn [ui(θi, o)− πi(θ1, . . . , ˆθi, . . . , θN )]. Los términos relacionados con los pagos pueden ser omitidos en el caso de que los pagos no sean posibles. 135 3.3 Diseño de mecanismos automatizados Ahora podemos definir el problema computacional que estudiamos. Definición 8. (DISEÑO DE MECANISMOS AUTOMATIZADOS (AMD)) Se nos da: • un entorno de diseño de mecanismos automatizados, • una noción de IR (ex interim, ex post, o ninguna), • un concepto de solución (estrategias dominantes o Bayes-Nash), • si los pagos son posibles, • si la aleatorización es posible, • (en la variante de decisión del problema) un valor objetivo G. Se nos pregunta si existe un mecanismo del tipo especificado (en términos de pagos y aleatorización) que satisfaga tanto la noción de IR como el concepto de solución, y proporcione un valor esperado de al menos G para el objetivo. Un caso especial interesante es aquel en el que solo hay un agente. En este caso, el agente informante siempre sabe todo lo que hay que saber sobre los otros tipos de agentes, porque no hay otros agentes. Dado que el IR ex post y el IR ex interim solo difieren en lo que se asume que un agente sabe sobre los tipos de otros agentes, los dos conceptos de IR coinciden aquí. Además, dado que la implementación en estrategias dominantes y la implementación en equilibrio de Bayes-Nash solo difieren en lo que se asume que un agente sabe sobre los tipos de otros agentes, los dos conceptos de solución coinciden aquí. Esta observación resultará ser una herramienta útil para demostrar resultados de dificultad: si demostramos dificultad computacional en el escenario de un solo agente, esto implica inmediatamente dificultad para ambos conceptos de IR, para ambos conceptos de solución, para cualquier número de agentes. 4. En esta sección demostramos que es NP-completo diseñar un mecanismo determinístico que maximice la suma esperada de los pagos recolectados de los agentes. Mostramos que este problema es difícil incluso en el entorno de un solo agente, demostrando así de inmediato que es difícil para ambos conceptos de IR, para ambos conceptos de solución. Para demostrar la NP-dureza, reducimos desde el problema MINSAT. Definición 9 (MINSAT). Se nos da una fórmula φ en forma normal conjuntiva, representada por un conjunto de variables booleanas V y un conjunto de cláusulas C, y un entero K (K < |C|). Se nos pregunta si existe una asignación a las variables en V tal que se satisfacen a lo sumo K cláusulas en φ. MINSAT fue recientemente demostrado como NP-completo [14]. Ahora podemos presentar nuestro resultado. Teorema 1. El problema determinista de maximización de pagos de AMD es NP-completo, incluso para un solo agente, incluso con una distribución uniforme de tipos. Prueba. Es fácil demostrar que el problema está en NP. Para demostrar la NP-dificultad, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista de maximización de pagos de un solo agente. Sea el conjunto de tipos de agentes Θ = {θc : c ∈ C} ∪ {θv : v ∈ V}, donde C es el conjunto de cláusulas en la instancia de MINSAT, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Deje que el conjunto de resultados sea O = {o0} ∪ {oc : c ∈ C} ∪ {ol : l ∈ L}, donde L es el conjunto de literales, es decir, L = {+v : v ∈ V } ∪ {−v : v ∈ V }. Que la notación v(l) = v denote que v es la variable correspondiente al literal l, es decir, l ∈ {+v, −v}. Sea l ∈ c denota que el literal l ocurre en la cláusula c. Entonces, la función de utilidad de los agentes está dada por u(θc, ol) = |Θ| + 1 para todo l ∈ L con l ∈ c; u(θc, ol) = 0 para todo l ∈ L con l /∈ c; u(θc, oc) = |Θ| + 1; u(θc, oc) = 0 para todo c ∈ C con c = c; u(θv, ol) = |Θ| para todo l ∈ L con v(l) = v; u(θv, ol) = 0 para todo l ∈ L con v(l) = v; u(θv, oc) = 0 para todo c ∈ C. El objetivo de la instancia de AMD es G = |Θ| + |C|−K |Θ|, donde K es el objetivo de la instancia de MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución para la instancia de MINSAT. Que la asignación de valores de verdad a las variables en esta solución esté dada por la función f: V → L (donde v(f(v)) = v para todo v ∈ V). Entonces, para cada v ∈ V, sea o(θv) = of(v) y π(θv) = |Θ|. Para cada c ∈ C, sea o(θc) = oc; sea π(θc) = |Θ| + 1 si c no está satisfecha en la solución MINSAT, y π(θc) = |Θ| si c está satisfecha. Es sencillo comprobar que se cumple la restricción de IR. Ahora verificamos que el agente no tenga incentivos para informar de manera incorrecta. Si el tipo de los agentes es θv, entonces cualquier otro informe le dará un resultado que no es mejor, por un pago que no es menor, por lo que no tiene incentivo para informar de manera incorrecta. Si el tipo de los agentes es algún θc donde c es una cláusula satisfecha, nuevamente, cualquier otro informe le dará un resultado que no es mejor, por un pago que no es menor, por lo que no tiene incentivos para informar de manera incorrecta. El último caso a verificar es cuando el tipo de agentes es algún θc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informarlo conduce a un resultado ol para un literal l ∈ c, precisamente porque la cláusula no se satisface en la instancia de MINSAT. Porque además, ningún tipo que no sea θc conduce al resultado oc, informar cualquier otro tipo dará como resultado una utilidad de 0, mientras que aún se requiere un pago de al menos |Θ| por parte del agente. Claramente, el agente está mejor reportando honestamente, para una utilidad total de 0. Esto establece que el agente nunca tiene un incentivo para informar de manera incorrecta. Finalmente, demostramos que se alcanza el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), el pago esperado de este mecanismo es |V||Θ|+s|Θ|+(|C|−s)(|Θ|+1) |Θ| ≥ |V||Θ|+K|Θ|+(|C|−K)(|Θ|+1) |Θ| = |Θ| + |C|−K |Θ| = G. Por lo tanto, hay una solución para la instancia AMD. Ahora supongamos que hay una solución para la instancia de AMD, dada por una función de resultado o y una función de pago π. Primero, supongamos que existe algún v ∈ V tal que o(θv) /∈ {o+v, o−v}. Entonces, la utilidad que el agente obtiene del resultado dado para este tipo es 0, y por lo tanto, según la IR, no se puede extraer ningún pago del agente para este tipo. Dado que, nuevamente por IR, el pago máximo que se puede extraer para cualquier otro tipo es |Θ| + 1, se sigue que el pago esperado máximo que se podría obtener es a lo sumo (|Θ|−1)(|Θ|+1) |Θ| < |Θ| < G, lo cual contradice que esta sea una solución para la instancia de AMD. Se deduce que en la solución de la instancia de AMD, para cada v ∈ V, o(θv) ∈ {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece como verdadero si o(θv) = o+v, y falso si o(θv) = o−v. Reclamamos que esta tarea es una solución a la instancia de MINSAT. Por la restricción de IR, el pago máximo que podemos extraer de cualquier tipo θv es |Θ|. Dado que no puede haber incentivos para que el agente informe falsamente, para cualquier cláusula c satisfecha por la asignación dada, el pago máximo que podemos extraer para el tipo correspondiente θc es |Θ|. (Pues si extrajéramos más de este tipo, la utilidad del agente en este caso sería menor que 1; y si v es la variable que satisface c en la asignación, de modo que o(θv) = ol donde l ocurre en c, entonces al agente le convendría más informar θv en lugar del informe veraz θc, para obtener un resultado que valga |Θ|+1 para él mientras tiene que pagar como máximo |Θ|.) Finalmente, para cualquier cláusula insatisfecha c, según la restricción de IR, el pago máximo que podemos extraer para el tipo correspondiente θc es |Θ| + 1. Se deduce que el pago esperado de nuestro mecanismo es a lo sumo V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ, donde s es el número de cláusulas satisfechas. Dado que nuestro mecanismo logra el objetivo, se sigue que V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ ≥ G, lo cual, mediante simples manipulaciones algebraicas, es equivalente a s ≤ K. Por lo tanto, hay una solución para la instancia de MINSAT. Dado que AMD, que maximiza el pago, es solo un caso especial de AMD para un diseñador egoísta en el que el diseñador no tiene preferencias sobre el resultado elegido, esto implica inmediatamente dificultades para el caso general de AMD para un diseñador egoísta en el que los pagos son posibles. Sin embargo, esto aún no implica dureza para el caso especial donde los pagos no son posibles. Demostraremos la dificultad en este caso en la próxima sección. 5. En esta sección demostramos que es NP-completo diseñar un mecanismo determinista que maximice la expectativa del objetivo del diseñador cuando no son posibles los pagos. Mostramos que este problema es difícil incluso en el entorno de un solo agente, demostrando así de inmediato que es difícil para ambos conceptos de IR, para ambos conceptos de solución. Teorema 2. Sin pagos, el diseño determinista de AMD para un diseñador egoísta es NP-completo, incluso para un solo agente, incluso con una distribución uniforme sobre los tipos. Prueba. Es fácil demostrar que el problema está en NP. Para demostrar la NP-dificultad, reducimos una instancia arbitraria de MINSAT a la siguiente instancia de AMD determinista auto-interesada de un solo agente sin pagos. Sea el conjunto de tipos de agentes Θ = {θc : c ∈ C} ∪ {θv : v ∈ V}, donde C es el conjunto de cláusulas en la instancia de MINSAT, y V es el conjunto de variables. Que la distribución de probabilidad sobre estos tipos sea uniforme. Deje que el conjunto de resultados sea O = {o0} ∪ {oc : c ∈ C} ∪ {ol : l ∈ L} ∪ {o∗}, donde L es el conjunto de literales, es decir, L = {+v : v ∈ V} ∪ {−v : v ∈ V}. Que la notación v(l) = v denote que v es la variable correspondiente al literal l, es decir, l ∈ {+v, −v}. Deje que l ∈ c denote que el literal l ocurre en la cláusula c. Luego, deje que la función de utilidad de los agentes esté dada por u(θc, ol) = 2 para todo l ∈ L con l ∈ c; u(θc, ol) = −1 para todo l ∈ L con l /∈ c; u(θc, oc) = 2; u(θc, oc) = −1 para todo c ∈ C con c = c; u(θc, o∗) = 1; u(θv, ol) = 1 para todo l ∈ L con v(l) = v; u(θv, ol) = −1 para todo l ∈ L con v(l) = v; u(θv, oc) = −1 para todo c ∈ C; u(θv, o∗) = −1. Que la función objetivo de los diseñadores esté dada por g(o∗ ) = |Θ|+1; g(ol) = |Θ| para todo l ∈ L; g(oc) = |Θ| para todo c ∈ C. El objetivo de la instancia de AMD es G = |Θ| + |C|−K |Θ| , donde K es el objetivo de la instancia de MINSAT. Mostramos que las instancias son equivalentes. Primero, supongamos que hay una solución para la instancia de MINSAT. Que la asignación de valores de verdad a las variables en esta solución esté dada por la función f: V → L (donde v(f(v)) = v para todo v ∈ V). Entonces, para cada v ∈ V, sea o(θv) = of(v). Para cada c ∈ C que se cumpla en la solución MINSAT, sea o(θc) = oc; para cada c ∈ C no satisfecho, sea o(θc) = o∗. Es sencillo comprobar que se cumple la restricción de IR. Ahora verificamos que el agente no tenga incentivos para informar de manera incorrecta. Si el tipo de los agentes es algún θv, está obteniendo la utilidad máxima para ese tipo, por lo que no tiene incentivos para reportar de manera incorrecta. Si el tipo de los agentes es algún θc donde c es una cláusula satisfecha, nuevamente, está obteniendo la utilidad máxima para ese tipo, por lo que no tiene incentivos para informar de manera incorrecta. El último caso a verificar es cuando el tipo de agentes es algún θc donde c es una cláusula insatisfecha. En este caso, observamos que para ninguno de los tipos, informarlo conduce a un resultado ol para un literal l ∈ c, precisamente porque la cláusula no se satisface en la instancia de MINSAT. Debido a que tampoco ningún tipo conduce al resultado oc, no hay ningún resultado que el mecanismo seleccione que le daría al agente una utilidad mayor a 1 para el tipo θc, y por lo tanto el agente no tiene incentivo para informar falsamente. Esto establece que el agente nunca tiene un incentivo para informar de manera incorrecta. Finalmente, demostramos que se alcanza el objetivo. Si s es el número de cláusulas satisfechas en la solución MINSAT (de modo que s ≤ K), entonces el valor esperado de la función objetivo de los diseñadores es |V||Θ|+s|Θ|+(|C|−s)(|Θ|+1) |Θ| ≥ |V||Θ|+K|Θ|+(|C|−K)(|Θ|+1) |Θ| = |Θ| + |C|−K |Θ| = G. Por lo tanto, hay una solución para la instancia AMD. Ahora supongamos que hay una solución para la instancia de AMD, dada por una función de resultado o. Primero, supongamos que existe algún v ∈ V tal que o(θv) /∈ {o+v, o−v}. El único otro resultado que el mecanismo puede elegir bajo la restricción de IR es o0. Esto tiene un valor objetivo de 0, y dado que el valor más alto que la función objetivo alcanza es |Θ| + 1, se sigue que el valor esperado máximo de la función objetivo que se podría obtener es a lo sumo (|Θ|−1)(|Θ|+1) |Θ| < |Θ| < G, lo que contradice que esta sea una solución para la instancia de AMD. Se deduce que en la solución de la instancia de AMD, para cada v ∈ V, o(θv) ∈ {o+v, o−v}. Podemos interpretar esto como una asignación de valores de verdad a las variables: v se establece como verdadero si o(θv) = o+v, y falso si o(θv) = o-v. Reclamamos que esta tarea es una solución a la instancia de MINSAT. Por lo anterior, para cualquier tipo θv, el valor de la función objetivo en este mecanismo será |Θ|. Para cualquier cláusula c satisfecha por la asignación dada, el valor de la función objetivo en el caso en que el agente informe el tipo θc será como máximo |Θ|. (Esto se debe a que no podemos elegir el resultado o∗ para dicho tipo, ya que en este caso el agente tendría un incentivo para informar θv en su lugar, donde v es la variable que satisface c en la asignación (de modo que o(θv) = ol donde l ocurre en c).) Finalmente, para cualquier cláusula insatisfecha c, el valor máximo que la función objetivo puede alcanzar en el caso en que el agente informa el tipo θc es |Θ| + 1, simplemente porque este es el valor más grande que la función alcanza en cualquier momento. Se deduce que el valor esperado de la función objetivo para nuestro mecanismo es a lo sumo V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ, donde s es el número de cláusulas 137 satisfechas. Dado que nuestro mecanismo logra el objetivo, se sigue que V |Θ|+s|Θ|+(|C|−s)(|Θ|+1) Θ ≥ G, lo cual, mediante simples manipulaciones algebraicas, es equivalente a s ≤ K. Por lo tanto, hay una solución para la instancia MINSAT. Ambos de nuestros resultados de dureza se basaron en la restricción de que el mecanismo debería ser determinista. En la siguiente sección, mostramos que la dificultad del diseño desaparece cuando permitimos la aleatorización en el mecanismo. 6. La aleatorización de AMD para un diseñador interesado en sí mismo es fácil. Ahora mostramos cómo permitir la aleatorización sobre los resultados hace que el problema de AMD auto-interesado sea manejable a través de la programación lineal, para cualquier número constante de agentes. Teorema 3. El AMD aleatorio con interés propio con un número constante de agentes es resoluble en tiempo polinómico mediante programación lineal, tanto con pagos como sin pagos, tanto para IR ex post como ex interim, y tanto para la implementación en estrategias dominantes como para la implementación en equilibrio de Bayes-Nash, incluso si los tipos están correlacionados. Prueba. Dado que los programas lineales pueden resolverse en tiempo polinómico [13], todo lo que necesitamos demostrar es que el número de variables y ecuaciones en nuestro programa es polinomial para cualquier número constante de agentes, es decir, exponencial solo en N. En todo momento, para determinar el tamaño del programa lineal, consideremos T = maxi{|Θi|}. Las variables de nuestro programa lineal serán las probabilidades (p(θ1, θ2, . . . , θN ))(o) (como máximo TN |O| variables) y los pagos πi(θ1, θ2, . . . , θN ) (como máximo NTN variables). (Mostramos el programa lineal para el caso en que los pagos son posibles; el caso sin pagos se obtiene fácilmente de esto simplemente omitiendo todas las variables de pago en el programa, o agregando restricciones adicionales que obliguen a los pagos a ser 0). Primero, mostramos las restricciones de IR. Para el IR ex post, agregamos las siguientes restricciones (como máximo NTN) al LP: • Para cada i ∈ {1, 2, . . . , N}, y para cada (θ1, θ2, . . . , θN ) ∈ Θ1 × Θ2 × . . . × ΘN , agregamos ( o∈O (p(θ1, θ2, . . . , θN ))(o)u(θi, o)) − πi(θ1, θ2, . . . , θN ) ≥ 0. Para el ex interino IR, agregamos las siguientes restricciones (como máximo NT) al LP: • Para cada i ∈ {1, 2, . . . , N}, para cada θi ∈ Θi, agregamos θ1,... ,θN γ(θ1, . . . , θN |θi)(( o∈O (p(θ1, θ2, . . . , θN ))(o)u(θi, o))− πi(θ1, θ2, . . . , θN )) ≥ 0. Ahora, mostramos las restricciones del concepto de solución. Para la implementación en estrategias dominantes, agregamos las siguientes (a lo sumo NTN+1) restricciones al LP: • Para cada i ∈ {1, 2, . . . , N}, para cada (θ1, θ2, . . . , θi, . . . , θN ) ∈ Θ1 × Θ2 × . . . × ΘN, y para cada informe de tipo de alternativa ˆθi ∈ Θi, agregamos la restricción ( o∈O (p(θ1, θ2, . . . , θi, . . . , θN ))(o)u(θi, o)) − πi(θ1, θ2, . . . , θi, . . . , θN ) ≥ ( o∈O (p(θ1, θ2, . . . , ˆθi, . . . , θN ))(o)u(θi, o)) − πi(θ1, θ2, . . . , ˆθi, . . . , θN ). Finalmente, para la implementación en el equilibrio de Bayes-Nash, agregamos las siguientes (a lo sumo NT2) restricciones al LP: • Para cada i ∈ {1, 2, ..., N}, para cada θi ∈ Θi, y para cada informe de tipo de alternativa ˆθi ∈ Θi, agregamos la restricción θ1,...,θN γ(θ1, ..., θN |θi)(( o∈O (p(θ1, θ2, ..., θi, ..., θN ))(o)u(θi, o)) − πi(θ1, θ2, ..., θi, ..., θN )) ≥ θ1,...,θN γ(θ1, ..., θN |θi)(( o∈O (p(θ1, θ2, ..., ˆθi, ..., θN ))(o)u(θi, o)) − πi(θ1, θ2, ..., ˆθi, ..., θN )). Todo lo que queda por hacer es dar la expresión que el diseñador busca maximizar, que es: • θ1,...,θN γ(θ1, ..., θN )(( o∈O (p(θ1, θ2, ..., θi, ..., θN ))(o)g(o)) + N i=1 πi(θ1, θ2, ..., θN )). Como indicamos, el número de variables y restricciones es exponencial solo en N, por lo tanto, el programa lineal tiene un tamaño polinómico para un número constante de agentes. Por lo tanto, el problema es resoluble en tiempo polinómico. IMPLICACIONES PARA UN PROBLEMA DE DISEÑO DE SUBASTA COMBINATORIA ÓPTIMA En esta sección, demostraremos algunas consecuencias interesantes del problema de diseño de mecanismos automatizados para un diseñador interesado en sí mismo en el diseño de subastas combinatorias óptimas. Considera una subasta combinatoria con un conjunto S de artículos en venta. Para cualquier conjunto B ⊆ S, dejemos que ui(θi, B) sea la utilidad del postor i al recibir el conjunto B cuando el tipo del postor es θi. El problema de diseño de subasta óptima consiste en especificar las reglas de la subasta de manera que se maximice los ingresos esperados para el subastador. (Por el principio de revelación, sin pérdida de generalidad, podemos asumir que la subasta es veraz). El problema de diseño de subasta óptima se resuelve para el caso de un solo artículo mediante la famosa subasta de Myerson [18]. Sin embargo, el diseño de subastas óptimas en subastas combinatorias es un problema de investigación abierto reconocido [3, 25]. El problema está abierto incluso si solo hay dos artículos en venta. (El caso de dos artículos con una forma muy especial de complementariedad y sin sustituibilidad ha sido resuelto recientemente [1].) Supongamos que tenemos disposición libre: los artículos pueden ser desechados sin costo alguno. Además, supongamos que las preferencias de los postores tienen la siguiente estructura: cuando un postor recibe un conjunto de artículos, la utilidad del postor por ese conjunto está determinada únicamente por el mejor artículo en el conjunto. (Enfatizamos que qué artículo es el mejor puede depender del tipo de postor). Definición 10. Se dice que el postor i tiene preferencias solo por lo mejor sobre paquetes de artículos si existe una función vi: Θi × S → R tal que para cualquier θi ∈ Θi, para cualquier B ⊆ S, ui(θi, B) = maxs∈B vi(θi, s). Hacemos la siguiente observación útil en este contexto: no tiene sentido otorgarle a un postor más de un artículo. La razón es que si el postor está informando honestamente, quitarle todos los artículos menos el de mayor valor no perjudicará al postor; y, mediante la disposición gratuita, hacerlo solo reducirá el incentivo para que este postor informe falsamente este tipo, cuando en realidad tiene otro tipo. Ahora demostramos que el problema de diseñar una subasta óptima determinista es NP-completo, mediante una reducción del problema AMD de maximización de pagos. Teorema 4. Dado un problema de diseño de subasta combinatoria óptima bajo preferencias de mejor opción (dado por un conjunto de artículos S y para cada postor i, un espacio de tipos finitos Θi y una función vi : Θi × S → R tal que para cualquier θi ∈ Θi, para cualquier B ⊆ S, ui(θi, B) = maxs∈B vi(θi, s)), diseñar la subasta determinística óptima es NP-completo, incluso para un único postor con una distribución uniforme sobre los tipos. Prueba. El problema está en NP porque podemos generar de manera no determinista una regla de asignación, y luego establecer los pagos utilizando programación lineal. Para demostrar la NP-dificultad, reducimos una instancia arbitraria de AMD determinista que maximiza el pago, con un único agente y una distribución uniforme de tipos, al siguiente problema de diseño de subasta combinatoria óptima con una única postor con preferencias de solo los mejores. Para cada resultado o ∈ O en la instancia de AMD (excepto el resultado o0), que haya un artículo so ∈ S. Que el espacio de tipos sea el mismo, y que v(θi, so) = ui(θi, o) (donde u está especificado en la instancia de AMD). Que el valor objetivo de ingresos esperados sea el mismo en ambas instancias. Mostramos que las instancias son equivalentes. Primero supongamos que existe una solución para la instancia de AMD, dada por una función de resultado y una función de pago. Entonces, si la solución de AMD elige el resultado o para un tipo, en la solución de subasta óptima, asignamos {so} al postor para este tipo. (A menos que o = o0, en cuyo caso asignamos {} al postor). Que las funciones de pago sean las mismas en ambas instancias. Entonces, la utilidad que recibe un agente por informar un tipo (dado el tipo verdadero) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivos en la solución óptima de la subasta. Además, dado que la distribución del tipo y la función de pago son iguales, los ingresos esperados para el subastador/diseñador son los mismos. Se deduce que existe una solución para la instancia de diseño de subasta óptima. Ahora supongamos que existe una solución para la instancia de diseño de subasta óptima. Por la observación de que como máximo se puede tener un artículo, podemos asumir sin pérdida de generalidad que la solución nunca asigna más de un artículo. Entonces, si la solución de subasta óptima asigna el artículo al postor para un tipo, en la solución de AMD, permita que el mecanismo elija el resultado o para ese tipo. Si la solución de subasta óptima no asigna nada al postor para un tipo, en la solución AMD, permita que el mecanismo elija el resultado o0 para ese tipo. Que las funciones de pago sean las mismas. Entonces, la utilidad que recibe un agente por informar un tipo (dado el tipo real) en cualquiera de las soluciones es la misma, por lo que tenemos compatibilidad de incentivos en la solución AMD. Además, dado que la distribución del tipo y la función de pago son iguales, los ingresos esperados para el diseñador/subastador son los mismos. Se deduce que existe una solución para la instancia de AMD. Afortunadamente, también podemos extender el resultado de facilidad para mecanismos aleatorios a este escenario de subasta combinatoria, lo que nos proporciona uno de los pocos algoritmos de tiempo polinómico conocidos para un problema de diseño óptimo de subasta combinatoria. Teorema 5. Dado un problema de diseño de subasta combinatoria óptima bajo preferencias de mejor opción (dado por un conjunto de elementos S y para cada postor i, un espacio de tipos finitos Θi y una función vi : Θi × S → R tal que para cualquier θi ∈ Θi, para cualquier B ⊆ S, ui(θi, B) = maxs∈B vi(θi, s)), si el número de postores es una constante k, entonces la subasta aleatoria óptima puede ser diseñada en tiempo polinómico. (Para cualquier restricción de IC e IR.) Prueba. Por la observación de que a lo sumo un artículo, podemos sin pérdida de generalidad restringirnos a asignaciones donde cada postor recibe como máximo un artículo. Hay menos de (|S| + 1)k asignaciones de ese tipo, es decir, un número polinómico de asignaciones. Dado que podemos enumerar explícitamente los resultados, simplemente podemos resolver esto como una instancia de AMD que maximiza el pago, con programación lineal. 8. Investigaciones relacionadas sobre la complejidad en el diseño de mecanismos. Ha habido un considerable interés reciente en el diseño de mecanismos en la informática. Parte de ello se ha centrado en cuestiones de complejidad computacional, pero la mayor parte de ese trabajo ha buscado diseñar mecanismos que sean fáciles de ejecutar (por ejemplo, [20, 15, 19, 9, 12]), en lugar de estudiar la complejidad de diseñar el mecanismo. La pieza más cercana de trabajo anterior estudió la complejidad del diseño automatizado de mecanismos por un diseñador benevolente [5, 6]. Roughgarden ha estudiado la complejidad de diseñar una buena topología de red para agentes que eligen egoístamente los enlaces que utilizan [21]. Esto está relacionado con el diseño de mecanismos, pero difiere significativamente en que el diseñador solo tiene un control restringido sobre las reglas del juego porque no hay ninguna parte que pueda imponer el resultado (o pagos laterales). Además, no hay un informe explícito de preferencias. 9. CONCLUSIONES E INVESTIGACIONES FUTURAS A menudo, un resultado debe ser elegido en función de las preferencias informadas por un grupo de agentes. La dificultad clave es que los agentes pueden informar sus preferencias de manera insincera para hacer que el resultado elegido les sea más favorable. El diseño de mecanismos es el arte de diseñar las reglas del juego de manera que los agentes estén motivados a informar sus preferencias de manera veraz, y se elija un resultado deseable. En un enfoque recientemente emergente llamado diseño de mecanismos automatizado, se calcula un mecanismo para la configuración específica de agregación de preferencias en cuestión. Esto tiene varias ventajas, pero el inconveniente es que el problema de optimización del diseño del mecanismo debe resolverse de nuevo cada vez. A diferencia de trabajos anteriores sobre diseño automatizado de mecanismos que estudiaron a un diseñador benevolente, en este artículo estudiamos problemas de diseño automatizado de mecanismos donde el diseñador está interesado en sí mismo, un entorno mucho más relevante para el comercio electrónico. En este contexto, al centro solo le importa qué resultado se elige y qué pagos se le realizan. La razón por la que las preferencias de los agentes son relevantes es que el centro está obligado a asegurar que cada agente esté al menos tan bien como estaría si no hubiera participado en el mecanismo. En este escenario, demostramos que diseñar un mecanismo determinista óptimo es NP-completo en dos casos especiales importantes: cuando el centro está interesado solo en los pagos realizados hacia él, y cuando los pagos no son posibles y el centro está interesado solo en el resultado elegido. Estos resultados de dureza implican dificultad en todos los entornos de diseño de mecanismos automatizados más generales con un diseñador egoísta. Los resultados de dureza se aplican ya sea que las restricciones de racionalidad individual (participación) se apliquen ex interim o ex post, y ya sea que el concepto de solución sea la implementación de estrategias dominantes o la implementación del equilibrio de Bayes-Nash. Luego demostramos que permitir la aleatorización en el mecanismo hace que el problema de diseño en todos estos escenarios sea computacionalmente sencillo. Finalmente, demostramos que el problema de AMD que maximiza el pago está estrechamente relacionado con una variante interesante del problema de diseño de subasta combinatoria óptima (que maximiza los ingresos), donde los postores tienen preferencias solo por lo mejor. Mostramos que aquí también, diseñar un mecanismo determinístico óptimo es NP-completo incluso con un agente, pero diseñar un mecanismo aleatorio óptimo es fácil. La investigación futura incluye estudiar el diseño automatizado de mecanismos con un diseñador interesado en sí mismo en entornos más restringidos, como subastas (donde el objetivo del diseñador puede incluir preferencias sobre qué postor debería recibir el bien, así como los pagos). También queremos estudiar la complejidad del diseño de mecanismos automatizados en entornos donde los espacios de resultados y tipos tienen una estructura especial para que puedan representarse de manera más concisa. Finalmente, planeamos reunir un conjunto de datos de problemas de diseño de mecanismos del mundo real, tanto históricos como actuales, y aplicar el diseño de mecanismos automatizado a esos problemas. 10. REFERENCIAS [1] M. Armstrong. Subastas multi-objetivo óptimas. Revisión de Estudios Económicos, 67:455-481, 2000. [2] K. Arrow. La doctrina de los derechos de propiedad y la revelación de la demanda bajo información incompleta. En M. Boskin, editor, Economía y bienestar humano. New York Academic Press, 1979. [3] C. Avery y T. Hendershott. Agrupación y subastas óptimas de múltiples productos. Revisión de Estudios Económicos, 67:483-497, 2000. [4] E. H. Clarke. Precios escalonados de bienes públicos. Elección Pública, 11:17-33, 1971. [5] V. Conitzer y T. Sandholm. Complejidad del diseño de mecanismos. En Actas de la 18ª Conferencia Anual sobre Incertidumbre en Inteligencia Artificial (UAI-02), páginas 103-110, Edmonton, Canadá, 2002. [6] V. Conitzer y T. Sandholm. Diseño de mecanismos automatizados: Resultados de complejidad derivados del entorno de un solo agente. En Actas de la 5ta Conferencia Internacional de Comercio Electrónico (ICEC-03), páginas 17-24, Pittsburgh, PA, EE. UU., 2003. [7] V. Conitzer y T. Sandholm. Críticas computacionales del principio de revelación. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), Nueva York, NY, 2004. Breve ensayo. La versión completa apareció en el taller AAMAS-03 sobre Comercio Electrónico Mediado por Agentes (AMEC). [8] C. d'Aspremont y L. A. Gérard-Varet. Incentivos e información incompleta. Revista de Economía Pública, 11:25-45, 1979. [9] J. Feigenbaum, C. Papadimitriou y S. Shenker. Compartiendo el costo de las transmisiones de multidifusión. Revista de Ciencias de la Computación y de Sistemas, 63:21-41, 2001. Versión temprana en las Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 2000. [10] A. Gibbard. Manipulación de esquemas de votación. Econometrica, 41:587-602, 1973. [11] T. Groves.
Econometrica, 41:587-602, 1973. [11] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J. Hershberger y S. Suri. Precios de Vickrey y caminos más cortos: ¿Cuánto vale una arista? En Actas del Simposio Anual sobre Fundamentos de la Ciencia de la Computación (FOCS), 2001. [13] L. Khachiyan. Un algoritmo polinómico en programación lineal. Matemática soviética. Doklady, 20:191-194, 1979. [14] R. Kohli, R. Krishnamurthi y P. Mirchandani. El problema de satisfacibilidad mínimo. Revista SIAM de Matemáticas Discretas, 7(2):275-283, 1994. [15] D. Lehmann, L. I. O'Callaghan y Y. Shoham. Revelación de la verdad en subastas combinatorias rápidas y aproximadamente eficientes. Revista de la ACM, 49(5):577-602, 2002. La versión inicial apareció en las Actas de la Conferencia de Comercio Electrónico de la ACM (ACM-EC), 1999. [16] A. Mas-Colell, M. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [17] E. S. Maskin y J. Riley. Subastas multiunidad óptimas. En F. Hahn, editor, "La economía de los mercados faltantes, la información y los juegos", capítulo 14, páginas 312-335. Clarendon Press, Oxford, 1989. [18] R. Myerson.
Prensa Clarendon, Oxford, 1989. [18] R. Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [19] N. Nisan y A. Ronen. Mecanismos VCG computacionalmente factibles. En Actas de la Conferencia de la ACM sobre Comercio Electrónico (ACM-EC), páginas 242-252, Minneapolis, MN, 2000. [20] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. Versión temprana en las Actas del Simposio Anual de la ACM sobre Teoría de la Computación (STOC), 1999. [21] T. Roughgarden. Diseñar redes para usuarios egoístas es difícil. En Actas del Simposio Anual sobre Fundamentos de la Ciencia de la Computación (FOCS), 2001. [22] T. Sandholm. Problemas en subastas computacionales de Vickrey. Revista Internacional de Comercio Electrónico, 4(3):107-129, 2000. Número especial sobre la Aplicación de Agentes Inteligentes para el Comercio Electrónico. Una versión corta y temprana apareció en la Segunda Conferencia Internacional sobre Sistemas Multiagente (ICMAS), páginas 299-306, 1996. [23] M. A. Satterthwaite. In Spanish, the translation would be: "Inmutabilidad estratégica y condiciones de Arrow: teoremas de existencia y correspondencia para procedimientos de votación y funciones de bienestar social." Revista de Teoría Económica, 10:187-217, 1975. [24] W. Vickrey. Contrarrestando la especulación, subastas y ofertas selladas competitivas. Revista de Finanzas, 16:8-37, 1961. [25] R. V. Vohra. Problemas de investigación en subastas combinatorias. Mimeo, versión 29 de octubre de 2001. 141