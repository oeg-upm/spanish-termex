Adaptando Middleware de Mensajería Asincrónica a Redes Ad-hoc Mirco Musolesi Dept. Las características de los entornos móviles, con la posibilidad de desconexiones frecuentes y ancho de banda fluctuante, han obligado a replantear el middleware tradicional. En particular, los paradigmas de comunicación síncrona a menudo empleados en middleware estándar no parecen ser particularmente adecuados para entornos ad-hoc, en los que ni siquiera se puede asumir la disponibilidad intermitente de una red troncal. En cambio, la comunicación asincrónica parece ser un paradigma generalmente más adecuado para este tipo de entornos. Se ha desarrollado y utilizado middleware orientado a mensajes para sistemas tradicionales con el fin de proporcionar un paradigma de comunicación asíncrona para sistemas distribuidos, y, recientemente, también para algunos sistemas específicos de computación móvil. En este artículo, presentamos nuestra experiencia en el diseño, implementación y evaluación de EMMA (Middleware de Mensajería Epidémica para redes ad-hoc), una adaptación del Servicio de Mensajes Java (JMS) para entornos móviles ad-hoc. Discutimos en detalle los desafíos de diseño y algunas posibles soluciones, mostrando un ejemplo concreto de la viabilidad y adecuación de la aplicación del paradigma asíncrono en este contexto y delineando un plan de investigación para los próximos años. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; C.2.1 [Arquitectura y Diseño de Redes]: Comunicación Inalámbrica Términos Generales DISEÑO, ALGORITMOS 1. INTRODUCCIÓN Con la creciente popularidad de los dispositivos móviles y su amplia adopción, existe una clara necesidad de permitir el desarrollo de un amplio espectro de aplicaciones que operen de manera efectiva en dicho entorno. Lamentablemente, esto está lejos de ser simple: los dispositivos móviles son cada vez más heterogéneos en cuanto a capacidades de procesamiento, tamaño de memoria, capacidad de batería e interfaces de red. Cada una de estas configuraciones tiene características sustancialmente diferentes que son estáticamente distintas, por ejemplo, hay una gran diferencia en la capacidad entre un mote de Berkeley y un portátil equipado con 802.11g, y que varían dinámicamente, como en situaciones de ancho de banda fluctuante y conectividad intermitente. Los entornos móviles ad hoc tienen un elemento adicional de complejidad en que son completamente descentralizados. Para poder desarrollar aplicaciones para entornos tan complejos, es esencial contar con una forma adecuada de middleware si se busca lograr un desarrollo rentable. En este artículo, examinamos uno de los aspectos fundamentales de middleware para entornos móviles ad-hoc: el de los primitivos de comunicación. Tradicionalmente, los primitivos de middleware más utilizados para la comunicación asumen la presencia simultánea de ambos puntos finales en una red, ya que la estabilidad y la ubicuidad de la infraestructura de redes no es una suposición irrazonable para la mayoría de los entornos cableados. En otras palabras, la mayoría de los paradigmas de comunicación son síncronos: middleware orientado a objetos como CORBA y Java RMI son ejemplos típicos de middleware basado en comunicación síncrona. En los últimos años, ha habido un creciente interés en plataformas basadas en paradigmas de comunicación asincrónica, como los sistemas de publicación-suscripción: estos han sido explotados con mucho éxito donde existe asincronía a nivel de aplicación. De acuerdo con un informe de mercado de Gartner [7]: Dada la popularidad, escalabilidad, flexibilidad y afinidad con arquitecturas móviles e inalámbricas de los middlewares orientados a mensajes (MOM), para el año 2004, es probable que MOM se convierta en la forma dominante de middleware de comunicación para vincular aplicaciones móviles y empresariales (probabilidad del 0.7)... Además, en sistemas ad-hoc móviles, la probabilidad de fragmentación de la red significa que la comunicación síncrona puede resultar impracticable en cualquier caso, lo que da lugar a situaciones en las que el tráfico asincrónico tolerante a retrasos es la única forma de tráfico que podría ser admitida. El middleware para entornos ad-hoc móviles debe, por lo tanto, admitir primitivas de comunicación semi-síncronas o completamente asíncronas si se quiere evitar limitaciones sustanciales en su utilidad. Además del desafío intelectual que implica apoyar este modelo, este trabajo también es interesante porque existen varios ámbitos de aplicación práctica al permitir la comunicación entre comunidades en áreas subdesarrolladas del mundo. Por lo tanto, por ejemplo, proyectos que se han llevado a cabo para ayudar a poblaciones que viven en lugares remotos del mundo como Laponia o en áreas pobres que carecen de infraestructura de conectividad fija. Ha habido intentos de proporcionar middleware móvil con estas propiedades, incluyendo STEAM, LIME, XMIDDLE, Bayou (consulte [11] para una revisión más completa del middleware móvil). Estos modelos difieren considerablemente de los middleware tradicionales existentes en cuanto a los primitivos proporcionados. Además, algunos de ellos fallan en proporcionar una solución para los verdaderos escenarios ad-hoc. Si el éxito proyectado de MOM se convierte en algo parecido a la realidad, habrá muchos programadores con experiencia en ello. La solución ideal al problema del middleware para sistemas ad-hoc es, entonces, permitir a los programadores utilizar los mismos paradigmas y modelos presentados por formas comunes de MOM y asegurar que estos paradigmas sean soportables dentro del entorno móvil. Este enfoque tiene claras ventajas al permitir que las aplicaciones desarrolladas en plataformas de middleware estándar se desplieguen fácilmente en dispositivos móviles. De hecho, algunas investigaciones ya han llevado a la adaptación de plataformas de middleware tradicionales a entornos móviles, principalmente para proporcionar integración entre dispositivos móviles y redes fijas existentes en un entorno nómada (es decir, mixto) [4]. En lo que respecta al middleware orientado a mensajes, las implementaciones actuales, sin embargo, asumen la existencia de una red troncal a la que los hosts móviles se conectan de vez en cuando mientras están en itinerancia [10], o asumen que los nodos siempre son de alguna manera accesibles a través de un camino [18]. No se ha intentado ninguna adaptación a escenarios heterogéneos o completamente ad hoc, con desconexiones frecuentes y nubes periódicamente aisladas de hosts. En el resto de este documento describimos un intento inicial de adaptar middleware orientado a mensajes para que se ajuste a dispositivos móviles y, más específicamente, a redes móviles ad-hoc. En nuestro caso, elegimos examinar JMS, como uno de los sistemas MOM más conocidos. En la última parte de este documento, exploramos las limitaciones de nuestros resultados y describimos los planes que tenemos para llevar a cabo el trabajo más adelante. Los sistemas de middleware orientados a mensajes y el Servicio de Mensajes de Java (JMS) admiten la comunicación entre componentes distribuidos a través del paso de mensajes: el remitente envía un mensaje a colas identificadas, que generalmente residen en un servidor. Un receptor recupera el mensaje de la cola en un momento diferente y puede confirmar la respuesta utilizando el mismo mecanismo asíncrono. La middleware orientada a mensajes soporta la comunicación asíncrona de una manera muy natural, logrando el desacoplamiento de emisores y receptores. Un remitente puede continuar procesando tan pronto como el middleware haya aceptado el mensaje; eventualmente, el receptor enviará un mensaje de confirmación y el remitente podrá recogerlo en un momento conveniente. Sin embargo, dado la forma en que están implementados, estos sistemas de middleware suelen requerir dispositivos con recursos abundantes, especialmente en términos de memoria y espacio en disco, donde se almacenan colas persistentes de mensajes que han sido recibidos pero aún no procesados. Sun Java Message Service [5], IBM WebSphere MQ [6], Microsoft MSMQ [12] son ejemplos de middleware orientado a mensajes muy exitosos para sistemas distribuidos tradicionales. El Servicio de Mensajería de Java (JMS) es una colección de interfaces para la comunicación asincrónica entre componentes distribuidos. Proporciona una forma común para que los programas de Java creen, envíen y reciban mensajes. Los usuarios de JMS suelen ser referidos como clientes. La especificación JMS define además a los proveedores como los componentes encargados de implementar el sistema de mensajería y proporcionar la funcionalidad administrativa y de control (es decir, persistencia y confiabilidad) requerida por el sistema. Los clientes pueden enviar y recibir mensajes, de forma asincrónica, a través del proveedor JMS, que se encarga de la entrega y, posiblemente, de la persistencia de los mensajes. Hay dos tipos de comunicación admitidos: modelos punto a punto y de publicación-suscripción. En el modelo punto a punto, los hosts envían mensajes a colas. Los receptores pueden ser registrados con algunas colas específicas, y pueden recuperar los mensajes de forma asíncrona para luego confirmar su recepción. El modelo de publicación-suscripción se basa en el uso de temas a los que los clientes pueden suscribirse. Los mensajes son enviados a los temas por otros clientes y luego son recibidos de forma asíncrona por todos los clientes suscritos. Los clientes aprenden sobre los temas y colas disponibles a través de la Interfaz de Nombres y Directorios de Java (JNDI) [14]. Las colas y los temas son creados por un administrador en el proveedor y se registran con la interfaz JNDI para su búsqueda. En la siguiente sección, presentamos los desafíos de las redes móviles y mostramos cómo JMS puede adaptarse para cumplir con estos requisitos. 3. JMS PARA COMPUTACIÓN MÓVIL Las redes móviles varían mucho en sus características, desde redes nómadas en las que los nodos se desplazan mientras están desconectados, hasta redes ad-hoc en las que los nodos se mueven libremente y no hay infraestructura. Las redes móviles ad-hoc son más comúnmente aplicables en situaciones donde la supervivencia y la capacidad de despliegue instantáneo son clave: especialmente en aplicaciones militares y de ayuda en casos de desastre. Entre estos dos tipos de redes móviles, sin embargo, existen una serie de posibles combinaciones heterogéneas, donde se utilizan paradigmas nómadas y ad-hoc para interconectar áreas totalmente inalámbricas con redes más estructuradas (como una LAN o Internet). Si bien la especificación JMS ha sido ampliamente implementada y utilizada en sistemas distribuidos tradicionales, las adaptaciones para entornos móviles han sido propuestas recientemente. Los desafíos de adaptar JMS a entornos móviles son considerables; sin embargo, dada su amplia aceptación y uso, existen ventajas considerables al permitir la adaptación de aplicaciones existentes a entornos móviles y al permitir la interoperabilidad de aplicaciones en las regiones cableadas e inalámbricas de una red. En [10], JMS se adaptó a un entorno móvil nómada, donde los hosts móviles pueden ser clientes de JMS y comunicarse a través del proveedor de JMS que, sin embargo, se encuentra en una red troncal, proporcionando fiabilidad y persistencia. El prototipo del cliente presentado en [10] es muy ligero, debido a la delegación de toda la funcionalidad pesada al proveedor Middleware para Computación Pervasive y ad-hoc 122 en la red cableada. Sin embargo, este enfoque es algo limitado en términos de aplicabilidad generalizada y escalabilidad como consecuencia de la concentración de funcionalidad en la parte cableada de la red. Si se quiere adaptar JMS a entornos completamente ad hoc, donde no haya infraestructura fija disponible y donde los nodos cambien de ubicación y estado de forma muy dinámica, se deben tener en cuenta más problemas. En primer lugar, el descubrimiento necesita utilizar un modelo resiliente pero distribuido: en este entorno extremadamente dinámico, las soluciones estáticas son inaceptables. Como se discute en la Sección 2, un administrador de JMS define colas y temas en el proveedor. Los clientes pueden entonces aprender sobre ellos utilizando la Interfaz de Nombres y Directorios de Java (JNDI). Sin embargo, debido a la forma en que está diseñado JNDI, es necesario que un nodo de JNDI (o más de uno) esté al alcance para obtener una vinculación de un nombre a una dirección (es decir, saber dónde se encuentra una cola o un tema específico). En entornos móviles ad-hoc, el proceso de descubrimiento no puede asumir la existencia de un conjunto fijo de servidores de descubrimiento que siempre sean accesibles, ya que esto no coincidiría con la dinámica de las redes ad-hoc. En segundo lugar, un Proveedor de JMS, como sugiere la especificación de JMS, también debe ser accesible para cada nodo en la red, para poder comunicarse. Esto asume una arquitectura muy centralizada, que nuevamente no coincide con los requisitos de un entorno ad-hoc móvil, en el que los nodos pueden estar en movimiento y dispersos: se necesita una solución más distribuida y dinámica. La persistencia es, sin embargo, una funcionalidad esencial en entornos de comunicación asincrónica, ya que los hosts están, por definición, conectados en momentos diferentes. En la siguiente sección, discutiremos nuestra experiencia en el diseño e implementación de JMS para redes móviles ad-hoc. 4. El desarrollo de aplicaciones para redes móviles es aún más desafiante: además de las mismas consideraciones que para entornos inalámbricos infraestructurados, como las limitadas capacidades de los dispositivos y las restricciones de energía, existen problemas relacionados con la velocidad de cambio de la conectividad de la red y la falta de una infraestructura de enrutamiento estática. En consecuencia, ahora describimos un intento inicial de adaptar la especificación JMS para satisfacer los requisitos particulares relacionados con escenarios ad-hoc. Como se discute en la Sección 3, una aplicación JMS puede utilizar tanto el estilo de mensajería punto a punto como el de publicación-suscripción. Modelo de punto a punto. El modelo de punto a punto se basa en el concepto de colas, que se utilizan para habilitar la comunicación asincrónica entre el productor de un mensaje y posibles consumidores diferentes. En nuestra solución, la ubicación de las colas se determina mediante un proceso de negociación que depende de la aplicación. Por ejemplo, supongamos que es posible saber a priori, o es posible determinar dinámicamente, que cierto host es el receptor de la mayor parte de los mensajes enviados a una cola particular. En este caso, la ubicación óptima de la cola bien podría estar en este host en particular. En general, vale la pena señalar que, según la especificación de JMS y los patrones de diseño sugeridos, es común y preferible que un cliente tenga todos sus mensajes entregados a una sola cola. Las colas se anuncian periódicamente a los anfitriones que se encuentran dentro del rango de transmisión o que son alcanzables mediante el protocolo de comunicación síncrona subyacente, si se proporciona. Es importante tener en cuenta que, a nivel de middleware, es lógicamente irrelevante si la capa de red implementa alguna forma de enrutamiento ad-hoc (aunque considerablemente más eficiente si lo hace); el middleware solo considera información sobre qué nodos son accesibles activamente en cualquier momento. Los hosts que reciben mensajes publicitarios agregan entradas a su registro JNDI. Cada entrada se caracteriza por un arrendamiento (un mecanismo similar al presente en Jini [15]). Un contrato de arrendamiento representa el tiempo de validez de una entrada particular. Si un arrendamiento no se renueva (es decir, su vida no se extiende), puede vencer y, en consecuencia, la entrada se elimina del registro. En otras palabras, el anfitrión asume que la cola será inaccesible a partir de ese momento. Esto puede ser causado, por ejemplo, si un host que almacena la cola se vuelve inaccesible. Un host que inicia un proceso de descubrimiento encontrará los temas y las colas presentes en su porción conectada de la red de manera directa. Para enviar un mensaje a un anfitrión que actualmente no está al alcance, utilizamos un protocolo de enrutamiento de epidemia asíncrono que se discutirá en detalle en la Sección 4.2. Si dos hosts están en la misma nube (es decir, existe un camino conectado entre ellos), pero no hay disponible un protocolo síncrono, los mensajes se envían utilizando el protocolo epidémico. En este caso, la latencia de entrega será baja como resultado de la rapidez de propagación de la infección en la nube conectada (ver también los resultados de la simulación en la Sección 5). Dado la existencia de un protocolo de epidemia, el mecanismo de descubrimiento consiste en publicitar las colas a los hosts que actualmente son inalcanzables utilizando mecanismos análogos. En el modelo de publicación-suscripción, algunos de los hosts son designados de manera similar para mantener temas y almacenar suscripciones, como antes. Los temas se anuncian a través del registro de la misma manera que las colas, y un cliente que desee suscribirse a un tema debe registrarse con el cliente que tiene el tema. Cuando un cliente desea enviar un mensaje a la lista de temas, lo envía al titular del tema (de la misma manera que enviaría un mensaje a una cola). El titular del tema luego reenvía el mensaje a todos los suscriptores, utilizando el protocolo síncrono si es posible, de lo contrario el protocolo epidémico. Vale la pena señalar que utilizamos un único mensaje con múltiples destinatarios, en lugar de múltiples mensajes con múltiples destinatarios. Cuando un mensaje es entregado a uno de los suscriptores, este destinatario es eliminado de la lista. Para eliminar las posibles réplicas restantes, empleamos mensajes de acuse de recibo (discutidos en la Sección 4.4), devueltos de la misma manera que un mensaje normal. También hemos adaptado los conceptos de suscripciones duraderas y no duraderas para entornos ad-hoc. En las plataformas fijas, las suscripciones duraderas se mantienen durante las desconexiones de los clientes, ya sean intencionales o resultado de fallas. En los sistemas tradicionales, cuando un suscriptor duradero se desconecta del servidor, es responsable de almacenar los mensajes. Cuando el suscriptor duradero se reconecta, el servidor le envía todos los mensajes no caducados. El problema es que, en nuestro escenario, las desconexiones son la norma. En teoría, no es posible enviar un mensaje a un par que nunca ha sido alcanzable en el pasado, ya que no puede haber ninguna entrada presente en el registro. Sin embargo, para superar esta posible limitación, proporcionamos un mecanismo a través del cual la información puede ser añadida al registro sin utilizar los canales normales. 123 Middleware 2004 Companion en lugar de la excepción. En otras palabras, no podemos considerar las desconexiones como fallos. Por estas razones, adoptamos una semántica ligeramente diferente. En lo que respecta a las suscripciones duraderas, si un suscriptor se desconecta, las notificaciones no se almacenan, sino que se envían utilizando el protocolo epidémico en lugar del protocolo síncrono. En otras palabras, las notificaciones duraderas siguen siendo válidas durante las posibles desconexiones del suscriptor. Por otro lado, si un suscriptor no duradero se desconecta, su suscripción se elimina; en otras palabras, durante las desconexiones, las notificaciones no se envían utilizando el protocolo epidémico, sino que solo se aprovecha el protocolo síncrono. Si el tema vuelve a estar accesible para este anfitrión, deberá realizar otra suscripción para recibir las notificaciones. Los mensajes de baja se entregan de la misma manera que los mensajes de suscripción. Es importante tener en cuenta que los suscriptores duraderos deben darse de baja explícitamente de un tema para detener el proceso de notificación; sin embargo, todas las suscripciones duraderas tienen un tiempo de expiración predefinido para hacer frente a los casos de suscriptores que no vuelven a conectarse debido a sus movimientos o fallos. Esta característica se proporciona claramente para limitar el número de mensajes innecesarios enviados por la red. 4.2 Entrega de mensajes utilizando enrutamiento epidémico En esta sección, examinamos un mecanismo posible que permitirá la entrega de mensajes en una red parcialmente conectada. El mecanismo que discutimos está destinado a demostrar viabilidad; los mecanismos de comunicación más eficientes para este entorno son complejos por sí mismos y son el tema de otro artículo [13]. La entrega de mensajes asincrónica descrita anteriormente se basa en un protocolo de enrutamiento de estilo epidémico puro típico [16]. Un mensaje que necesita ser enviado se replica en cada host al alcance. De esta manera, las copias de los mensajes se propagan rápidamente a través de redes conectadas, como una infección. Si un anfitrión se conecta a otra nube de nodos móviles durante su movimiento, el mensaje se propaga a través de esta colección de anfitriones. La replicación de datos y mensajes en estilo epidémico ha sido explotada en el pasado en muchos campos, comenzando por el área de sistemas de bases de datos distribuidas [2]. Dentro del enrutamiento epidémico, cada anfitrión mantiene un búfer que contiene los mensajes que ha creado y las réplicas de los mensajes generados por los otros anfitriones. Para mejorar el rendimiento, una tabla hash indexa el contenido del búfer. Cuando dos anfitriones se conectan, el anfitrión con el identificador más pequeño inicia una sesión de anti-entropía, enviando una lista que contiene los identificadores únicos de los mensajes que actualmente almacena. El otro anfitrión evalúa esta lista y envía de vuelta una lista que contiene los identificadores que está almacenando y que no están presentes en el otro anfitrión, junto con los mensajes que el otro no tiene. El anfitrión que ha iniciado la sesión recibe la lista y, de la misma manera, envía los mensajes que no están presentes en el otro anfitrión. En caso de producirse un desbordamiento de búfer, los mensajes se descartan. La fiabilidad ofrecida por este protocolo es generalmente de mejor esfuerzo, ya que no hay garantía de que un mensaje finalmente sea entregado a su destinatario. Claramente, la proporción de entrega del protocolo aumenta proporcionalmente al tiempo máximo de retraso permitido y al tamaño del búfer en cada host (pueden encontrarse resultados interesantes de simulación en [16]). 4.3 Adaptación del Modelo de Mensajes JMS En esta sección, analizaremos los aspectos de nuestra adaptación de la especificación relacionados con el llamado Modelo de Mensajes JMS [5]. Según esto, los mensajes JMS se caracterizan por algunas propiedades definidas utilizando el campo de encabezado, que contiene valores que son utilizados tanto por los clientes como por los proveedores para su entrega. Los aspectos discutidos en el resto de esta sección son válidos para ambos modelos (punto a punto y publicar-suscribir). Un mensaje JMS puede ser persistente o no persistente. Según la especificación de JMS, los mensajes persistentes deben entregarse con un grado de confiabilidad mayor que los no persistentes. Sin embargo, vale la pena señalar que no es posible garantizar la fiabilidad de una sola vez para mensajes persistentes según lo definido en la especificación, ya que, como discutimos en la subsección anterior, el protocolo epidémico subyacente solo puede garantizar la entrega de mejor esfuerzo. Sin embargo, los clientes mantienen una lista de los identificadores de los mensajes recibidos recientemente para evitar la entrega de mensajes duplicados. En otras palabras, proporcionamos a las aplicaciones una fiabilidad inmediata para ambos tipos de mensajes. Para implementar diferentes niveles de confiabilidad, EMMA trata de manera diferente los mensajes persistentes y no persistentes durante la ejecución del protocolo epidémico de anti-entropía. Dado que el espacio del búfer de mensajes es limitado, los mensajes persistentes se replican preferentemente utilizando el espacio libre disponible. Si esto es insuficiente y hay mensajes no persistentes presentes en el búfer, estos son reemplazados. Solo se notifican a los remitentes las entregas exitosas de los mensajes persistentes. Según la especificación de JMS, es posible asignar una prioridad a cada mensaje. Los mensajes con prioridades más altas se entregan de manera preferencial. Como se discutió anteriormente, los mensajes persistentes tienen prioridad sobre los no persistentes. La selección adicional se basa en sus prioridades. Los mensajes con prioridades más altas son tratados de manera preferencial. De hecho, si no hay suficiente espacio para replicar todos los mensajes persistentes, se utiliza un mecanismo basado en prioridades para eliminar y replicar los mensajes no persistentes (y, si es necesario, los mensajes persistentes). Los mensajes se eliminan de los buffers utilizando el valor de tiempo de expiración que puede ser establecido por los remitentes. Esta es una forma de liberar espacio en los búferes (se eliminan preferentemente los mensajes más antiguos en casos de conflicto); para eliminar réplicas obsoletas en el sistema; y para limitar el tiempo durante el cual los destinos deben mantener los identificadores de mensajes para desechar duplicados. Mecanismos de fiabilidad y de acuse de recibo Como ya se discutió, la entrega de mensajes como máximo una vez es lo mejor que se puede lograr en términos de semántica de entrega en entornos ad-hoc parcialmente conectados. Sin embargo, es posible mejorar la confiabilidad del sistema con mecanismos de acuse de recibo eficientes. EMMA proporciona un mecanismo de notificación de fallos a las aplicaciones si no se recibe el acuse de recibo dentro de un tiempo límite dado (que puede ser configurado por los desarrolladores de aplicaciones). Este mecanismo es el que distingue la entrega de mensajes persistentes y no persistentes en nuestra implementación de JMS: las entregas de los primeros son notificadas a los remitentes, mientras que los de los segundos no lo son. Utilizamos mensajes de acuse de recibo no solo para informar a los remitentes sobre la entrega exitosa de los mensajes, sino también para eliminar las réplicas de los mensajes entregados que aún están presentes en la red. Cada anfitrión mantiene una lista de los mensajes Middleware para la Computación Pervasiva y Ad-hoc 124 entregados con éxito que se actualiza como parte del proceso normal de intercambio de información entre los anfitriones. Las listas se intercambian durante los primeros pasos del protocolo de epidemia anti-entropía con una frecuencia predefinida. En el caso de mensajes con múltiples destinatarios, también se almacena una lista de los destinatarios reales. Cuando un anfitrión recibe la lista, verifica su búfer de mensajes y lo actualiza de acuerdo con las siguientes reglas: (1) si un mensaje tiene un único destinatario y ha sido entregado, se elimina del búfer; (2) si un mensaje tiene múltiples destinatarios, se eliminan los identificadores de los anfitriones a los que se ha entregado de la lista de destinatarios asociada. Si la longitud resultante de la lista de destinatarios es cero, el mensaje se elimina del búfer. Estas listas tienen, claramente, dimensiones finitas y se implementan como colas circulares. Este mecanismo simple, junto con el uso de marcas de tiempo de expiración, garantiza que las antiguas notificaciones de acuse de recibo sean eliminadas del sistema después de un período de tiempo limitado. Para mejorar la confiabilidad de EMMA, se podría desarrollar un mecanismo de diseño para la replicación inteligente de colas y temas basado en la información de contexto. Sin embargo, esto aún no forma parte de la arquitectura actual de EMMA. 5. IMPLEMENTACIÓN Y EVALUACIÓN PRELIMINAR Implementamos un prototipo de nuestra plataforma utilizando el Perfil Personal J2ME. El tamaño del ejecutable es de aproximadamente 250KB, incluido el archivo jar de JMS 1.1; esta es una cifra perfectamente aceptable dada la memoria disponible de los dispositivos móviles actuales en el mercado. Probamos nuestro prototipo en PDAs HP iPaq con Linux, interconectados con WaveLan, y en varios laptops con la misma interfaz de red. También evaluamos la plataforma de middleware utilizando el simulador de eventos discretos OMNET++ [17] para explorar una variedad de escenarios móviles que incorporaban un número más realista de hosts que el que se podía lograr experimentalmente. Más específicamente, evaluamos el rendimiento del sistema en términos de ratio de entrega y retraso promedio, variando la densidad de población y el tamaño del búfer, y utilizando mensajes persistentes y no persistentes con diferentes prioridades. Los resultados de la simulación muestran que el rendimiento de EMMAs, en términos de ratio de entrega y retraso de mensajes persistentes con prioridades más altas, es bueno. En general, es evidente que la proporción de entrega está fuertemente relacionada con el dimensionamiento correcto de los búferes para el retraso máximo aceptable. Además, los algoritmos epidémicos son capaces de garantizar una alta tasa de entrega si se evalúa el rendimiento durante un intervalo de tiempo suficiente para la difusión de las réplicas de los mensajes (es decir, la propagación de la infección) en una gran parte de la red ad-hoc. Una consecuencia del problema de dimensionamiento es que la escalabilidad puede verse seriamente afectada en middleware peer-to-peer para computación móvil debido a la escasez de recursos de los dispositivos (memoria limitada para almacenar temporalmente mensajes) y al número de posibles interconexiones en entornos ad-hoc. Lo peor es que las formas comunes de organización comercial y social (seis grados de separación) significan que incluso valores modestos de TTL en los mensajes provocarán una difusión generalizada de mensajes epidémicos. Este problema surge debido a la falta de inteligencia en el protocolo de la epidemia, y puede ser abordado seleccionando nodos portadores para los mensajes con mayor cuidado. Sin embargo, los detalles de este proceso están fuera del alcance de este documento (pero pueden encontrarse en [13]) y no afectan la base en la que se basa el middleware EMMA: la capacidad de entregar mensajes de forma asincrónica. 6. VISIÓN CRÍTICA DEL ESTADO DEL ARTE El diseño de plataformas de middleware para la computación móvil requiere que los investigadores respondan a preguntas nuevas y fundamentalmente diferentes; simplemente asumir la presencia de porciones cableadas de la red en las que pueda residir la funcionalidad centralizada no es generalizable. Por lo tanto, es necesario investigar nuevos principios de diseño y idear patrones arquitectónicos que difieran de los tradicionalmente utilizados en el diseño de middleware para sistemas fijos. Como ejemplo, considera la reciente tendencia de superposición de capas en redes ad-hoc [1]. Esta es una forma de replantear el diseño de sistemas de software, abandonando explícitamente las formas clásicas de estratificación, ya que, aunque esta separación de preocupaciones permite la portabilidad, lo hace a expensas de posibles ganancias de eficiencia. Creemos que es posible ver nuestro enfoque como una instancia de superposición de capas. De hecho, hemos añadido el protocolo de red epidémica a nivel de middleware y, al mismo tiempo, hemos utilizado el protocolo de red síncrono existente si está presente tanto en la entrega de mensajes (capas tradicionales) como en informar al middleware sobre cuándo pueden entregarse los mensajes revelando detalles de las tablas de reenvío (violación de capas). Por esta razón, preferimos considerarlos conjuntamente como la capa de comunicación de nuestra plataforma, proporcionando juntos una entrega de mensajes más eficiente. Otro aspecto interesante es la explotación del contexto y la información del sistema para mejorar el rendimiento de las plataformas de middleware móvil. Una vez más, como resultado de adoptar una metodología de capas cruzadas, podemos construir sistemas que recopilan información del sistema operativo subyacente y los componentes de comunicación para permitir la adaptación del comportamiento. Podemos resumir este enfoque de diseño conceptual diciendo que las plataformas de middleware deben ser no solo conscientes del contexto (es decir, deben ser capaces de extraer y analizar información del contexto circundante) sino también conscientes del sistema (es decir, deben ser capaces de recopilar información de los componentes de software y hardware del sistema móvil). Se han desarrollado varios sistemas de middleware para admitir redes ad hoc con el uso de comunicación asíncrona (como LIME, XMIDDLE, STEAM [11]). En particular, la plataforma STEAM es un ejemplo interesante de middleware basado en eventos para redes ad hoc, que proporciona entrega de mensajes con conciencia de ubicación y una solución efectiva para el filtrado de eventos. Una discusión sobre JMS, y su realización móvil, ya ha sido realizada en las Secciones 4 y 2. La empresa suiza Softwired ha desarrollado el primer middleware JMS para computación móvil, llamado iBus Mobile [10]. Los componentes principales de esta arquitectura típicamente basada en infraestructura son el proveedor de JMS, la llamada puerta de enlace móvil de JMS, que se despliega en un host fijo y una biblioteca de cliente JMS ligera. El gateway se utiliza para la comunicación entre el servidor de aplicaciones y los dispositivos móviles. El proveedor JMS ve la pasarela como un cliente JMS normal. El proveedor JMS puede ser cualquier servidor de aplicaciones habilitado para JMS, como BEA Weblogic. Pronto [19] es un ejemplo de un sistema de middleware basado en mensajería, diseñado específicamente para entornos móviles. La plataforma está compuesta por tres clases de componentes: clientes móviles que implementan la especificación JMS, pasarelas que controlan el tráfico, garantizando eficiencia y posibles personalizaciones de usuario utilizando diferentes complementos y servidores JMS. Diferentes configuraciones de estos componentes son posibles; con respecto a las aplicaciones de redes móviles ad hoc, la más interesante es Serverless JMS. El objetivo de esta configuración es adaptar JMS a un modelo descentralizado. El modelo de publicación-suscripción explota la eficiencia y la escalabilidad del protocolo de multidifusión IP subyacente. Se proporcionan servicios de entrega de mensajes poco confiables y confiables: la confiabilidad se logra a través de un protocolo basado en acuse de recibo negativo. Pronto representa una buena solución para redes móviles basadas en infraestructura, pero no se dirige adecuadamente a entornos ad-hoc, ya que los nodos móviles dependen de servidores fijos para el intercambio de mensajes. Existen otras MOM implementadas para entornos móviles; sin embargo, suelen ser extensiones sencillas de middleware existente [8]. La única implementación de MOM específicamente diseñada para redes móviles ad-hoc fue desarrollada en la Universidad de Newcastle [18]. Este trabajo es nuevamente una adaptación de JMS; el enfoque de esa implementación se centra en la comunicación de grupo y el uso de algoritmos de enrutamiento a nivel de aplicación para la entrega de mensajes por tema. Sin embargo, hay una serie de diferencias en el enfoque de nuestro trabajo. La importancia que atribuimos a las desconexiones hace que la persistencia sea un requisito vital para cualquier middleware que necesite ser utilizado en redes móviles ad-hoc. Los autores de [18] señalan la persistencia como un posible trabajo futuro, sin considerar el hecho de que enrutar un mensaje a un host no conectado resultará en un fallo de entrega. Esta es una limitación notable en entornos móviles donde las desconexiones impredecibles son la norma en lugar de la excepción. 7. MAPA Y CONCLUSIONES La comunicación asincrónica es un paradigma de comunicación útil para las redes móviles ad-hoc, ya que permite a los hosts llegar, irse y recoger mensajes cuando sea conveniente, teniendo en cuenta también la disponibilidad de sus recursos (por ejemplo, energía, niveles de conectividad). En este artículo hemos descrito el estado del arte en términos de MOM para sistemas móviles. También hemos demostrado una adaptación de prueba de concepto de JMS al escenario extremo de redes móviles ad-hoc parcialmente conectadas. Hemos descrito y discutido las características y diferencias de nuestra solución con respecto a las implementaciones tradicionales de JMS y las adaptaciones existentes para entornos móviles. Sin embargo, también se deben investigar los compromisos entre el enrutamiento a nivel de aplicación y el uso de recursos, ya que los dispositivos móviles suelen tener escasez de energía/recursos. Una limitación clave de este trabajo es el algoritmo epidémico que tiene un rendimiento deficiente y un avance importante en la practicabilidad de este trabajo requiere un algoritmo que equilibre mejor las necesidades de eficiencia y probabilidad de entrega de mensajes. Actualmente estamos trabajando en algoritmos y protocolos que, aprovechando técnicas probabilísticas y estadísticas sobre la base de pequeñas cantidades de información intercambiada, son capaces de mejorar considerablemente la eficiencia en términos de recursos (memoria, ancho de banda, etc.) y la confiabilidad de nuestra plataforma de middleware [13]. Un desarrollo de investigación futurista, que podría llevar estas ideas de adaptación de middleware de mensajería para entornos móviles más allá, es la introducción de extensiones de comunicación más orientadas a la movilidad, como el soporte de geocast (es decir, la capacidad de enviar mensajes a áreas geográficas específicas). REFERENCIAS [1] M. Conti, G. Maselli, G. Turi y S. Giordano. Diseño de redes móviles ad-hoc con interconexión de capas. IEEE Computer, 37(2):48-51, febrero de 2004. [2] A. Demers, D. Greene, C. Hauser, W. Irish, J. Larson, S. Shenker, H. Sturgis, D. Swinehart y D. Terry. Algoritmos de epidemia para el mantenimiento de bases de datos replicadas. En el Sexto Simposio sobre Principios de Computación Distribuida, páginas 1-12, agosto de 1987. [3] A. Doria, M. Uden y D. P. Pandey. Proporcionando conectividad a la comunidad nómada Saami. En Actas de la Segunda Conferencia Internacional sobre Diseño Colaborativo Abierto para la Innovación Sostenible, diciembre de 2002. [4] M. Haahr, R. Cunningham y V. Cahill. Aplicaciones CORBA en un entorno móvil. En la 5ª Conferencia Internacional sobre Computación y Redes Móviles (MOBICOM99), páginas 36-47. ACM, agosto de 1999. [5] M. Hapner, R. Burridge, R. Sharma, J. Fialli y K. Stout. Especificación del Servicio de Mensajes Java Versión 1.1. Sun Microsystems, Inc., abril de 2002. http://java.sun.com/products/jms/. [6] J. Hart. WebSphere MQ: Conectando sus aplicaciones sin programación compleja. IBM WebSphere Software White Papers, 2003. [7] S. Hayward y M. Pezzini. Casando Middleware y Computación Móvil. Informe de investigación del Grupo Gartner, septiembre de 2001. [8] IBM. WebSphere MQ EveryPlace Versión 2.0, noviembre de 2002. http://www-3.ibm.com/software/integration/wmqe/. [9] UIT. Conectando comunidades remotas. Documentos de la Cumbre Mundial sobre la Sociedad de la Información, 2003. http://www.itu.int/osg/spu/wsis-themes. [10] S. Maffeis. Presentando JMS inalámbrico. Softwired AG, www.sofwired-inc.com, 2002. [11] C. Mascolo, L. Capra y W. Emmerich. Middleware para Computación Móvil. En E. Gregori, G. Anastasi y S. Basagni, editores, Conferencias Avanzadas sobre Redes, volumen 2497 de las Notas de Conferencias en Ciencias de la Computación, páginas 20-58. Springer Verlag, 2002. [12] Microsoft. 

Springer Verlag, 2002. [12] Microsoft. Documentación de Microsoft Message Queuing (MSMQ) Versión 2.0. [13] M. Musolesi, S. Hailes y C. Mascolo. Enrutamiento adaptativo para redes ad-hoc móviles intermitentemente conectadas. Informe técnico, Nota de Investigación UCL-CS, julio de 2004. Enviado para su publicación. [14] Sun Microsystems. Documentación de Java Naming and Directory Interface (JNDI) Versión 1.2. 2003. http://java.sun.com/products/jndi/. [15] Sun Microsystems. Especificación de Jini Versión 2.0, 2003. http://java.sun.com/products/jini/. [16] A. Vahdat y D. Becker. Enrutamiento epidémico para redes ad-hoc parcialmente conectadas. Informe técnico CS-2000-06, Departamento de Ciencias de la Computación, Universidad de Duke, 2000. [17] A. Vargas. El sistema de simulación de eventos discretos OMNeT++. En Actas de la Multiconferencia Europea de Simulación (ESM2001), Praga, junio de 2001. [18] E. Vollset, D. Ingham y P. Ezhilchelvan. JMS en redes móviles ad-hoc. En Comunicaciones Inalámbricas Personales (PWC), páginas 40-52, Venecia, septiembre de 2003. [19] E. Yoneki y J. Bacon. Pronto: Mobilegateway con paradigma de publicación-suscripción sobre red inalámbrica. Informe Técnico 559, Universidad de Cambridge, Laboratorio de Computación, febrero de 2003. Middleware para Computación Pervasive y ad-hoc 126