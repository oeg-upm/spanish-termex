Diseño de mecanismos veraces para programación multidimensional a través de la monotonía cíclica. Ron Lavi. Ingeniería Industrial y Gestión. Instituto de Tecnología Technion - Israel. ronlavi@ie.technion.ac.il. Chaitanya Swamy. Combinatoria y Optimización. Universidad de Waterloo. cswamy@math.uwaterloo.ca. RESUMEN. Consideramos el problema de minimización del makespan en m máquinas no relacionadas en el contexto del diseño algorítmico de mecanismos, donde las máquinas son los jugadores estratégicos. Este es un dominio de programación multidimensional, y los únicos resultados positivos conocidos para la minimización del makespan en dicho dominio son mecanismos de aproximación O(m)-veraces [22, 20]. Estudiamos un caso especial bien fundamentado de este problema, donde el tiempo de procesamiento de un trabajo en cada máquina puede ser bajo o alto, y los valores bajos y altos son públicos y dependen del trabajo. Esto preserva la multidimensionalidad del dominio y generaliza el entorno de máquinas restringidas (es decir, {pj, ∞}) en la programación. Ofrecemos una técnica general para convertir cualquier algoritmo de c-aproximación en un mecanismo de verdad en expectativa de 3c-aproximación. Este es uno de los pocos resultados conocidos que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces de manera de caja negra. Cuando los valores bajos y altos son iguales para todos los trabajos, diseñamos un mecanismo determinístico de aproximación 2-veraz. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Nuestras construcciones son novedosas en dos aspectos. Primero, no utilizamos ni confiamos en definiciones de precios explícitos para demostrar veracidad; en su lugar, diseñamos algoritmos que satisfacen la monotonicidad del ciclo. La monotonía cíclica [23] es una condición necesaria y suficiente para la veracidad, es una generalización de la monotonía de valor para dominios multidimensionales. Sin embargo, mientras que la monotonía de valor se ha utilizado ampliamente y con éxito para diseñar mecanismos veraces en dominios unidimensionales, nuestro trabajo es el primero en aprovechar la monotonía de ciclo en el entorno multidimensional. Segundo, nuestros mecanismos aleatorizados se obtienen primero construyendo un mecanismo fraccional veraz para una relajación fraccional del problema, y luego convirtiéndolo en un mecanismo veraz en expectativa. Esto se basa en una técnica de [16], y muestra la utilidad de los mecanismos fraccionarios en el diseño de mecanismos veraces. Categorías y Descriptores de Asignaturas F.2 [Análisis de Algoritmos y Complejidad de Problemas]; J.4 [Ciencias Sociales y del Comportamiento]: Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN El diseño de mecanismos estudia construcciones algorítmicas bajo la presencia de jugadores estratégicos que poseen los datos de entrada del algoritmo. El diseño de mecanismos algorítmicos se ha centrado principalmente en escenarios en los que el planificador social o diseñador desea maximizar el bienestar social (o, de manera equivalente, minimizar el costo social), o en escenarios de subasta donde la maximización de ingresos es el objetivo principal. Objetivos alternativos de optimización, como aquellos que incorporan criterios de equidad (que han sido investigados algorítmicamente y en teoría de la elección social), han recibido muy poca o ninguna atención. En este artículo, consideramos un objetivo alternativo en el contexto de la programación de máquinas, a saber, la minimización del makespan. Hay n trabajos o tareas que deben asignarse a m máquinas, donde cada trabajo debe asignarse a exactamente una máquina. Asignar un trabajo j a una máquina i incurre en una carga (costo) de pij ≥ 0 en la máquina i, y la carga de una máquina es la suma de las cargas incurridas debido a los trabajos asignados a ella; el objetivo es programar los trabajos de manera que se minimice la carga máxima de una máquina, que se denomina makespan del horario. La minimización del makespan es un objetivo común en entornos de programación, y ha sido estudiada de manera algorítmica en las comunidades de Ciencias de la Computación e Investigación de Operaciones (ver, por ejemplo, la encuesta [12]). Siguiendo el trabajo de Nisan y Ronen [22], consideramos que cada máquina es un jugador estratégico o agente que conoce de forma privada su tiempo de procesamiento para cada trabajo, y puede tergiversar estos valores para disminuir su carga (que es su costo incurrido). Por lo tanto, abordamos el problema a través del diseño de mecanismos: el diseñador social, que posee el conjunto de trabajos a asignar, necesita especificar, además de un horario, pagos adecuados a los jugadores para incentivarlos a revelar sus verdaderos tiempos de procesamiento. Un mecanismo así se llama un mecanismo veraz. El objetivo de minimización del makespan es bastante diferente del objetivo clásico de maximización del bienestar social, donde se busca maximizar el bienestar total (o minimizar el costo total) de todos los jugadores. En cambio, corresponde a maximizar el bienestar mínimo y la noción de equidad de max-min, y parece ser un problema mucho más difícil desde el punto de vista del diseño de mecanismos. En particular, la famosa familia de mecanismos VCG [26, 9, 10] no se aplica aquí, y necesitamos idear nuevas técnicas. La posibilidad de construir un mecanismo veraz para minimizar el makespan está fuertemente relacionada con suposiciones sobre los tiempos de procesamiento de los jugadores, en particular, la dimensionalidad del dominio. Nisan y Ronen consideraron el entorno de máquinas no relacionadas donde los valores de pij pueden ser arbitrarios. Este es un dominio multidimensional, ya que el valor privado de un jugador es todo su vector de tiempos de procesamiento (pij)j. Se conocen muy pocos resultados positivos para dominios multidimensionales en general, y los únicos resultados positivos conocidos para la programación multidimensional son mecanismos de verdad de aproximación O(m) [22, 20]. Enfatizamos que, independientemente de las consideraciones computacionales, no se conoce la existencia de un mecanismo veraz con una proporción de aproximación significativamente mejor (que m) para ningún dominio de programación de este tipo. En el lado negativo, [22] demostró que ningún mecanismo determinístico veraz puede lograr una proporción de aproximación mejor que 2, y fortaleció este límite inferior a m para dos clases específicas de mecanismos determinísticos. Recientemente, [20] extendió este límite inferior a mecanismos aleatorizados, y [8] mejoró el límite inferior determinista. En marcado contraste con el estado de cosas anterior, se conocen resultados mucho más sólidos (y muchos más) positivos para un caso especial del problema de máquinas no relacionadas, a saber, el ajuste de máquinas relacionadas. Aquí, tenemos pij = pj/si para cada i, j, donde pj es conocimiento público, y la velocidad si es el único parámetro privado de la máquina i. Esta suposición hace que el dominio de los tipos de jugadores sea unidimensional. La veracidad en tales dominios es equivalente a una condición de monotonía de valor conveniente [21, 3], lo que parece hacer significativamente más fácil diseñar mecanismos veraces en tales dominios. Archer y Tardos [3] primero consideraron el entorno de máquinas relacionadas y proporcionaron un mecanismo de aproximación 3-veraz-en-expectativa aleatorizado. La brecha entre los dominios unidimensionales y multidimensionales se ejemplifica quizás mejor por el hecho de que [3] mostró que existe un mecanismo veraz que siempre produce un horario óptimo. (Recordemos que en el escenario de máquinas multidimensionales no relacionadas, es imposible obtener un mecanismo veraz con una proporción de aproximación mejor que 2). Varios resultados de seguimiento [2, 4, 1, 13] han fortalecido la noción de veracidad y/o mejorado la proporción de aproximación. Tales dificultades al pasar del entorno unidimensional al multidimensional también surgen en otros contextos de diseño de mecanismos (por ejemplo, subastas combinatorias). Por lo tanto, además de la importancia específica de la programación en entornos estratégicos, las ideas de la programación multidimensional también pueden tener relevancia en el contexto más general del diseño de mecanismos veraces para dominios multidimensionales. En este artículo, consideramos el problema de minimización del makespan para un caso especial de máquinas no relacionadas, donde el tiempo de procesamiento de un trabajo es bajo o alto en cada máquina. Más precisamente, en nuestro entorno, pij ∈ {Lj, Hj} para cada i, j, donde los valores Lj, Hj son conocidos públicamente (Lj ≡bajo, Hj ≡alto). Llamamos a este modelo el caso de dos valores dependiente del trabajo. Este modelo generaliza el clásico escenario de máquinas restringidas, donde pij ∈ {Lj, ∞}, el cual ha sido estudiado de manera exhaustiva desde el punto de vista algorítmico. Un caso especial de nuestro modelo es cuando Lj = L y Hj = H para todos los trabajos j, que denotamos simplemente como el modelo de programación de dos valores. Ambos de nuestros dominios son multidimensionales, ya que las máquinas no están relacionadas: un trabajo puede ser bajo en una máquina y alto en la otra, mientras que otro trabajo puede seguir el patrón opuesto. Por lo tanto, la información privada de cada máquina es un vector que especifica qué trabajos son de baja y alta prioridad en ella. Por lo tanto, conservan la propiedad central que subyace a la dificultad del diseño de mecanismos veraces para máquinas no relacionadas, y al estudiar estas configuraciones especiales esperamos obtener algunas ideas que serán útiles para abordar el problema general. Nuestros Resultados y Técnicas Presentamos varios resultados positivos para nuestros dominios de programación multidimensional. Nuestro primer resultado es un método general para convertir cualquier algoritmo de aproximación c para el escenario de dos valores dependientes del trabajo en un mecanismo de aproximación 3c-veraz en expectativa. Este es uno de los pocos resultados conocidos que utilizan un algoritmo de aproximación de manera de caja negra para obtener un mecanismo veraz para un problema multidimensional. Nuestro resultado implica que existe un mecanismo de aproximación 3-veraz-en-expectativa para el escenario Lj-Hj. Curiosamente, la prueba de veracidad no se basa en proporcionar precios explícitos, y nuestra construcción no necesariamente produce precios computables de manera eficiente (pero la regla de asignación es computable de manera eficiente). Nuestro segundo resultado se aplica al escenario de dos valores (Lj = L, Hj = H), para el cual mejoramos tanto la proporción de aproximación como fortalecemos la noción de veracidad. Obtenemos un mecanismo veraz de aproximación 2 determinista (junto con precios) para este problema. Estos son los primeros mecanismos verídicos con garantías de rendimiento no triviales para un dominio de programación multidimensional. Complementando esto, observamos que incluso este escenario aparentemente simple no admite mecanismos veraces que devuelvan un horario óptimo (a diferencia del caso de máquinas relacionadas). Al explotar la multidimensionalidad del dominio, demostramos que ningún mecanismo determinístico veraz puede obtener una proporción de aproximación mejor que 1.14 para el makespan (independientemente de consideraciones computacionales). La técnica principal, y una de las novedades, que subyace en nuestras construcciones y pruebas, es que no nos basamos en especificaciones de precios explícitos para demostrar la veracidad de nuestros mecanismos. En cambio, explotamos ciertas condiciones de monotonía algorítmica que caracterizan la veracidad para diseñar primero un algoritmo implementable, es decir, un algoritmo para el cual existen precios que garantizan la veracidad, y luego encontrar estos precios (profundizando más en la prueba de implementabilidad). Este tipo de análisis ha sido el método de elección en el diseño de mecanismos veraces para dominios unidimensionales, donde la monotonía del valor proporciona una caracterización conveniente que permite concentrarse en el aspecto algorítmico del problema (ver, por ejemplo, [3, 7, 4, 1, 13]). Pero para dominios multidimensionales, casi todos los resultados positivos han dependido de especificaciones de precios explícitos para demostrar la veracidad (una excepción es el trabajo sobre jugadores de mente única desconocidos en subastas combinatorias [17, 7]), un hecho que una vez más muestra la brecha en nuestra comprensión de los dominios multidimensionales frente a los unidimensionales. Nuestro trabajo es el primero en aprovechar las condiciones de monotonía para el diseño de mecanismos veraces en dominios arbitrarios. La condición de monotonía que utilizamos, a veces llamada monotonía cíclica, fue propuesta por primera vez por Rochet [23] (ver también [11]). Es una generalización de la monotonía del valor y caracteriza completamente la veracidad en todos los dominios. Nuestros métodos y análisis demuestran los beneficios potenciales de esta caracterización, y muestran que la monotonía del ciclo puede ser utilizada de manera efectiva para diseñar mecanismos veraces para dominios multidimensionales. Consideremos, por ejemplo, nuestro primer resultado que muestra que cualquier algoritmo de c-aproximación puede ser exportado a un mecanismo de verdad-en-expectativa de aproximación 3c. A nivel de generalidad de un algoritmo de aproximación arbitrario, parece poco probable que se pueda encontrar precios para demostrar la veracidad del mecanismo construido. Sin embargo, la monotonía del ciclo nos permite demostrar tal afirmación. De hecho, parece necesario que alguna condición basada únicamente en el algoritmo subyacente (y no en los precios) sea requerida para demostrar una afirmación tan general. El método para convertir algoritmos de aproximación en mecanismos veraces implica otra idea novedosa. Nuestro mecanismo aleatorio se obtiene primero construyendo un mecanismo veraz que devuelve un horario fraccional. Moverse a un dominio fraccional nos permite incorporar la veracidad en el algoritmo de aproximación de una manera bastante sencilla, a costa de perder un factor de 2 en la proporción de aproximación. Luego utilizamos un procedimiento adecuado de redondeo aleatorio para convertir la asignación fraccional en una asignación integral aleatoria. Para esto, utilizamos un procedimiento de redondeo reciente de Kumar et al. [14] que está diseñado para la programación de máquinas no relacionadas. Esto preserva la veracidad, pero perdemos otro factor aditivo igual a la proporción de aproximación. Nuestra construcción utiliza y extiende algunas observaciones de Lavi y Swamy [16], y además demuestra los beneficios de los mecanismos fraccionales en el diseño de mecanismos veraces. Trabajo relacionado Nisan y Ronen [22] fueron los primeros en considerar el problema de minimización del makespan para máquinas no relacionadas. Obtuvieron un resultado positivo de aproximación m y demostraron varios límites inferiores. Recientemente, Mualem y Schapira [20] demostraron un límite inferior de 2 en la proporción de aproximación alcanzable por mecanismos veraces en expectativa, y Christodoulou, Koutsoupias y Vidali [8] demostraron un límite inferior de (1 + √ 2) para mecanismos veraces deterministas. Archer y Tardos [3] consideraron primero el problema de máquinas relacionadas y dieron un mecanismo de aproximación de 3 en expectativa veraz. Esto se ha mejorado en [2, 4, 1, 13] a: un mecanismo aleatorio de aproximación 2 [2]; un FPTAS para cualquier número fijo de máquinas dado por Andelman, Azar y Sorani [1], y un mecanismo determinístico de aproximación 3 por Kovács [13]. El problema algorítmico (es decir, sin requerir veracidad) de minimización del makespan en máquinas no relacionadas está bien entendido y se conocen varios algoritmos de aproximación 2. Lenstra, Shmoys y Tardos [18] dieron el primer algoritmo de este tipo. Shmoys y Tardos [25] posteriormente presentaron un algoritmo de aproximación 2 para el problema de asignación generalizada, una generalización donde hay un costo cij por asignar un trabajo j a una máquina i, y el objetivo es minimizar el costo sujeto a un límite en el makespan. Recientemente, Kumar, Marathe, Parthasarathy y Srinivasan [14] presentaron un algoritmo de redondeo aleatorio que produce los mismos límites. Utilizamos su procedimiento en nuestro mecanismo aleatorio. La caracterización de la veracidad para dominios arbitrarios en términos de monotonía de ciclo parece haber sido observada por primera vez por Rochet [23] (ver también Gui et al. [11]). Esto generaliza la condición de monotonicidad del valor para dominios unidimensionales que fue propuesta por Myerson [21] y redescubierta por [3]. Como se mencionó anteriormente, esta condición ha sido explotada en numerosas ocasiones para obtener mecanismos veraces para dominios unidimensionales [3, 7, 4, 1, 13]. Para dominios convexos (es decir, cada conjunto de valores privados de los jugadores es convexo), se sabe que la monotonicidad de ciclo está implicada por una condición más simple, llamada monotonicidad débil [15, 6, 24]. Pero incluso esta condición más simple no ha encontrado mucha aplicación en el diseño de mecanismos veraces para problemas multidimensionales. Otros objetivos distintos a la maximización del bienestar social y la maximización de los ingresos han recibido muy poca atención en el diseño de mecanismos. En el contexto de subastas combinatorias, se han estudiado brevemente los problemas de maximizar el valor mínimo recibido por un jugador y calcular una asignación que minimice la envidia. Lavi, Mualem y Nisan [15] demostraron que el primer objetivo no se puede implementar de manera veraz; Bezakova y Dani [5] presentaron un mecanismo de aproximación del 0.5 para dos jugadores con valoraciones aditivas. Lipton et al. [19] demostraron que el último objetivo no se puede implementar de manera veraz. Estos límites inferiores fueron fortalecidos en [20]. PRELIMINARES 2.1 El dominio de programación En nuestro problema de programación, se nos dan n trabajos y m máquinas, y cada trabajo debe ser asignado a exactamente una máquina. En el escenario de máquinas no relacionadas, cada máquina i está caracterizada por un vector de tiempos de procesamiento (pij)j, donde pij ∈ R≥0 ∪ {∞} denota el tiempo de procesamiento para el trabajo j con el valor ∞ especificando que i no puede procesar j. Consideramos dos casos especiales de este problema: 1. El caso de dos valores dependientes del trabajo, donde pij ∈ {Lj, Hj} para cada i, j, con Lj ≤ Hj, y los valores Lj, Hj son conocidos. Esto generaliza el modelo clásico de programación de máquinas restringidas, donde Hj = ∞. 2. El caso de dos valores, que es un caso especial del anterior donde Lj = L y Hj = H para todos los trabajos j, es decir, pij ∈ {L, H} para cada i, j. Decimos que un trabajo j es bajo en la máquina i si pij = Lj, y alto si pij = Hj. Usaremos los términos horario y tarea indistintamente. Representamos un horario determinístico mediante un vector x = (xij)i,j, donde xij es 1 si el trabajo j está asignado a la máquina i, por lo tanto, tenemos xij ∈ {0, 1} para cada i, j, P i xij = 1 para cada trabajo j. También consideraremos algoritmos aleatorizados y algoritmos que devuelven una asignación fraccional. En ambos entornos, especificaremos nuevamente una asignación mediante un vector x = (xij)i,j con P j xij = 1, pero ahora xij ∈ [0, 1] para cada i, j. Para un algoritmo aleatorio, xij es simplemente la probabilidad de que j sea asignado a i (por lo tanto, x es una combinación convexa de asignaciones enteras). Denotamos la carga de la máquina i (bajo una asignación dada) como li = Σ j xijpij, y el makespan de un horario se define como la carga máxima en cualquier máquina, es decir, maxi li. El objetivo en el problema de minimización del makespan es asignar los trabajos a las máquinas de manera que se minimice el makespan del horario. 2.2 Diseño de mecanismos Consideramos el problema de minimización del makespan en los dominios de programación anteriores en el contexto del diseño de mecanismos. El diseño de mecanismos estudia entornos estratégicos donde el diseñador social necesita garantizar la cooperación de las diferentes entidades involucradas en el procedimiento algorítmico. Siguiendo el trabajo de Nisan y Ronen [22], consideramos que las máquinas son los jugadores estratégicos o agentes. El diseñador social tiene el conjunto de trabajos que deben asignarse, pero no conoce los tiempos de procesamiento (verdaderos) de estos trabajos en las diferentes máquinas. Cada máquina es una entidad egoísta, que conoce de forma privada su propio tiempo de procesamiento para cada trabajo. Una máquina incurre en un costo para la máquina igual al verdadero tiempo de procesamiento del trabajo en la máquina, y una máquina puede optar por tergiversar su vector de tiempos de procesamiento, que son privados, para disminuir su costo. Consideramos mecanismos de revelación directa: cada máquina informa su vector (posiblemente falso) de tiempos de procesamiento, luego el mecanismo calcula un horario y realiza pagos a los jugadores (es decir, máquinas) para compensarlos por el costo que incurren al procesar sus trabajos asignados. Un mecanismo de (revelación directa) consiste en una tupla (x, P): x especifica el horario, y P = {Pi} especifica los pagos entregados a las máquinas, donde tanto x como los Pi son funciones de los tiempos de procesamiento reportados p = (pij)i,j. El objetivo del mecanismo es calcular un horario que tenga un makespan casi óptimo con respecto a los tiempos de procesamiento reales; sin embargo, una máquina i solo está interesada en maximizar su propia utilidad, Pi − li, donde li es su carga bajo la asignación de salida, y puede declarar tiempos de procesamiento falsos si esto pudiera aumentar su utilidad. Por lo tanto, el mecanismo debe incentivar a las máquinas/jugadores a revelar honestamente sus tiempos de procesamiento a través de los pagos. Esto se hace preciso utilizando la noción de veracidad de estrategia dominante. Definición 2.1 (Veracidad) Un mecanismo de programación es veraz si, para cada máquina i, cada vector de tiempos de procesamiento de las otras máquinas, p−i, cada vector verdadero de tiempos de procesamiento p1 i y cualquier otro vector p2 i de la máquina i, tenemos: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) donde (x1 , P1 ) y (x2 , P2 ) son respectivamente el horario y los pagos cuando las otras máquinas declaran p−i y la máquina i declara p1 i y p2 i, es decir, x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) y x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i). Para expresarlo en palabras, en un mecanismo veraz, ninguna máquina puede mejorar su utilidad declarando un tiempo de procesamiento falso, sin importar lo que declaren las otras máquinas. También consideraremos mecanismos fraccionarios que devuelvan una asignación fraccionaria, y mecanismos aleatorizados que pueden lanzar monedas y donde la asignación y los pagos pueden ser variables aleatorias. La noción de veracidad para un mecanismo fraccional es la misma que en la Definición 2.1, donde x1, x2 son ahora asignaciones fraccionarias. Para un mecanismo aleatorio, consideraremos la noción de veracidad en expectativa [3], lo que significa que una máquina (jugadora) maximiza su utilidad esperada al declarar su verdadero vector de tiempo de procesamiento. La desigualdad (1) también define la veracidad en expectativa para un mecanismo aleatorio, donde P1 i, P2 i ahora denotan los pagos esperados realizados al jugador i, x1, x2 son las asignaciones fraccionadas que denotan el horario de los algoritmos aleatorios (es decir, xk ij es la probabilidad de que j sea asignado a i en la salida del horario para (pk i, p−i)). Para nuestros dos dominios de programación, la suposición informativa es que los valores Lj, Hj son de conocimiento público. La información privada de una máquina es qué trabajos tienen valor Lj (o L) y cuáles tienen valor Hj (o H) en ella. Enfatizamos que ambos de nuestros dominios son multidimensionales, ya que cada máquina i necesita especificar un vector que indique qué trabajos son bajos y altos en ella. Aunque la veracidad se define en términos de pagos, resulta que en realidad la veracidad se reduce a una cierta condición algorítmica de monotonicidad. Esto parece haber sido observado por primera vez para dominios multidimensionales por Rochet [23] en 1987, y ha sido utilizado con éxito en el diseño algorítmico de mecanismos varias veces, pero para dominios unidimensionales. Sin embargo, para dominios multidimensionales, la condición de monotonía es más compleja y no ha habido éxito en emplearla en el diseño de mecanismos veraces. La mayoría de los resultados positivos para dominios multidimensionales se han basado en especificaciones de precios explícitas para demostrar la veracidad. Una de las principales contribuciones de este artículo es demostrar que la condición de monotonía para entornos multidimensionales, a veces llamada monotonía cíclica, puede ser efectivamente utilizada para diseñar mecanismos veraces. Incluimos una breve exposición sobre ello para completitud. La exposición aquí se basa en gran medida en [11]. La monotonía cíclica se describe mejor en el marco abstracto de elección social: hay un conjunto finito A de alternativas, hay m jugadores, y cada jugador tiene un tipo privado (función de valoración) v: A → R, donde vi(a) debe interpretarse como su valor para la alternativa a. En el ámbito de la programación, A representa todas las posibles asignaciones de trabajos a máquinas, y vi(a) es el negativo de su carga en el horario a. Que Vi denote el conjunto de todos los posibles tipos de jugador i. Un mecanismo es una tupla (f, {Pi}) donde f : V1 × · · · × Vm → A es el algoritmo para elegir la alternativa, y Pi : V1 × · · · × Vm → A es el precio cobrado al jugador i (en el contexto de programación, el mecanismo paga a los jugadores, lo que corresponde a precios negativos). El mecanismo es veraz si para cada i, cada v−i ∈ V−i = Q i =i Vi, y cualquier vi, vi ∈ Vi, tenemos que vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), donde a = f(vi, v−i) y b = f(vi, v−i). Una pregunta básica que surge es si dado un algoritmo f: V1 × · · · × Vm → A, ¿existen precios que harán que el mecanismo resultante sea veraz? Es bien sabido (ver por ejemplo [15]) que el precio Pi solo puede depender de la alternativa elegida y las otras declaraciones, es decir, podemos escribir Pi : V−i × A → R. Por lo tanto, la veracidad implica que para cada i, cada v−i ∈ V−i, y cualquier vi, vi ∈ Vi con f(vi, v−i) = a y f(vi, v−i) = b, tenemos vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i). Ahora fija un jugador i, y fija las declaraciones v−i de los demás. Buscamos una asignación a las variables {Pa}a∈A tal que vi(a) − vi(b) ≥ Pa − Pb para todo a, b ∈ A y vi ∈ Vi con f(vi, v−i) = a. (Estrictamente hablando, deberíamos usar A = f(Vi, v−i) en lugar de A aquí). Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. 

Defina δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a}. Ahora podemos reformular el problema de asignación de precios anterior: buscamos una asignación a las variables {Pa}a∈A tal que Pa − Pb ≤ δa,b ∀a, b ∈ A (2). Esto se resuelve fácilmente al observar el grafo de asignación y aplicar un resultado básico estándar de teoría de grafos. Definición 3.1 (Gui et al. [11]): El grafo de asignación de f es un grafo dirigido ponderado G = (A, E) donde E = A × A y el peso de una arista b → a (para cualquier a, b ∈ A) es δa,b. Teorema 3.2 Existe una asignación factible para (2) si y solo si el grafo de asignación no tiene ciclos de longitud negativa. Además, si todos los ciclos son no negativos, una asignación factible es 255 obtenida de la siguiente manera: fije un nodo arbitrario a∗ ∈ A y establezca Pa como la longitud del camino más corto desde a∗ hasta a. Esto lleva a la siguiente definición, que es otra forma de expresar la condición de que el grafo de asignación no tenga ciclos negativos. Definición 3.3 (Monotonía de ciclo) Una función de elección social f satisface la monotonía de ciclo si para cada jugador i, cada v−i ∈ V−i, cada entero K, y cada v1 i , . . . , vK i ∈ Vi, Σ k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 donde ak = f(vk i , v−i) para 1 ≤ k ≤ K, y aK+1 = a1. Corolario 3.4 Existen precios P tales que el mecanismo (f, P) es veraz si y solo si f satisface la monotonicidad del ciclo. Ahora consideramos nuestro dominio específico de programación. Fija un jugador i, p−i, y cualquier p1 i, . . . , pK i. Sea x(pk i , p−i) = xk para 1 ≤ k ≤ K, y sea xK+1 = x1 , pK+1 = p1 . xk podría ser una asignación {0, 1} o una asignación fraccional. Tenemos vk i (xk ) = − P j xk ijpk ij, por lo que la monotonía del ciclo se traduce en PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0. Reorganizando, obtenemos KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) Por lo tanto, (3) reduce nuestro problema de diseño de mecanismos a un problema algorítmico concreto. Para la mayor parte de este documento, ignoraremos consecuentemente cualquier consideración estratégica y nos enfocaremos en diseñar un algoritmo de aproximación para minimizar el makespan que cumpla con (3). 4. Una TÉCNICA GENERAL PARA OBTENER MECANISMOS ALEATORIOS En esta sección, consideramos el caso de valores Lj, Hj dependientes del trabajo (con Lj ≤ Hj), que generaliza el modelo clásico de máquinas restringidas (donde Hj = ∞). Mostramos el poder de la aleatorización, al proporcionar una técnica general que convierte cualquier algoritmo de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Este es uno de los pocos resultados que muestra cómo exportar algoritmos de aproximación para un problema multidimensional en mecanismos veraces cuando el algoritmo se proporciona como una caja negra. Nuestra construcción y demostración son simples, y se basan en dos ideas. Primero, como se ha mencionado anteriormente, demostramos la veracidad utilizando la monotonía de ciclo. Parece poco probable que para un algoritmo de aproximación arbitrario dado solo como una caja negra, se pueda encontrar pagos para demostrar la veracidad; pero la ciclo-monotonía nos permite demostrar precisamente esto. Segundo, obtenemos nuestro mecanismo aleatorio mediante (a) primero moviéndonos a un dominio fraccional y construyendo un mecanismo fraccional veraz que puede devolver asignaciones fraccionales; luego (b) utilizando un procedimiento de redondeo para expresar el horario fraccional como una combinación convexa de horarios enteros. Esto se basa en un tema introducido por Lavi y Swamy [16], a saber, el uso de mecanismos fraccionarios para obtener mecanismos veraces en expectativa. No está claro si el Teorema 3.2, y por lo tanto, esta afirmación, se cumple si A no es finito. Debemos señalar, sin embargo, que no se puede simplemente ingresar los resultados de [16]. Sus resultados son válidos para problemas de maximización del bienestar social y se basan en el uso de VCG para obtener un mecanismo fraccional veraz. Sin embargo, VCG no se aplica a la minimización del makespan, y en nuestro caso ni siquiera se conoce la existencia de un mecanismo fraccional veraz cercano a óptimo. Utilizamos el siguiente resultado adaptado de [16]. Lema 4.1 (Lavi y Swamy [16]) Sea M = (x, P) un mecanismo fraccional veraz. Sea A un algoritmo de redondeo aleatorio que, dado un asignación fraccional x, produce una asignación aleatoria X tal que E ˆ Xij ˜ = xij para todo i, j. Entonces existen pagos P tales que el mecanismo M = (A, P) es veraz en promedio. Además, si M es individualmente racional, entonces M es individualmente racional para cada realización de lanzamientos de moneda. Sea OPT(p) el makespan óptimo (sobre horarios enteros) para la instancia p. Como primer paso, tomamos un algoritmo de aproximación c y lo convertimos en un mecanismo fraccional de verdad de aproximación 2c. Esta conversión funciona incluso cuando el algoritmo de aproximación devuelve solo un horario fraccional (satisfaciendo ciertas propiedades) de makespan a lo sumo c · OPT(p) para cada instancia p. Demostramos la veracidad mostrando que el algoritmo fraccional satisface la monotonía de ciclo (3). Observa que el conjunto alternativo de nuestro mecanismo fraccional es finito (aunque el conjunto de todas las asignaciones fraccionales es infinito): su cardinalidad es a lo sumo la del dominio de entrada, que es a lo sumo 2mn en el caso de dos valores. Por lo tanto, podemos aplicar el Corolario 3.4 aquí. Para convertir este mecanismo fraccional veraz en un mecanismo veraz aleatorizado, necesitamos un procedimiento de redondeo aleatorizado que cumpla con los requisitos del Lema 4.1. Afortunadamente, dicho procedimiento ya está proporcionado por Kumar, Marathe, Parthasarathy y Srinivasan [14]. Lema 4.2 (Kumar et al. [14]): Dada una asignación fraccional x y un vector de tiempos de procesamiento p, existe un procedimiento de redondeo aleatorio que produce una asignación X (aleatoria) tal que, 1. para cualquier i, j, E ˆ Xij ˜ = xij. 2. para cualquier i, P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij con probabilidad 1. La propiedad 1 se utilizará para obtener veracidad en la expectativa, y la propiedad 2 nos permitirá demostrar una garantía de aproximación. Primero demostramos que cualquier algoritmo que devuelva una asignación fraccional con ciertas propiedades satisface la monotonía de ciclo. Lema 4.3 Sea A un algoritmo que, para cualquier entrada p, produce una asignación (fraccional) x tal que, si pij = Hj entonces xij ≤ 1/m, y si pij = Lj entonces xij ≥ 1/m. Entonces A satisface la ciclo-monotonía. Prueba. Fija un jugador i y el vector de tiempos de procesamiento de los otros jugadores p−i. Necesitamos demostrar (3), es decir, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 para cada p1 i , . . . , pK i , donde el índice k = K + 1 se toma como k = 1. Demostraremos que para cada trabajo j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Si pk ij es el mismo para todos los k (ya sea siempre Lj o siempre Hj), entonces la desigualdad anterior claramente se cumple. De lo contrario, podemos dividir los índices 1, . . . , K, en segmentos máximos, donde un segmento máximo es un conjunto máximo de índices consecutivos k , k + 1, . . . , k − 1, k (donde K + 1 ≡ 1) tal que pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj. Esto se cumple porque debe haber algún k tal que pk ij = Hj > pk−1 ij = Lj. Tomamos k = k y luego seguimos incluyendo índices en este segmento hasta que alcancemos un k tal que pk ij = Lj y pk+1 ij = Hj. Establecemos k = k, y luego comenzamos un nuevo segmento maximal con índice k + 1. Ten en cuenta que k = k y k + 1 = k − 1. Ahora tenemos un subconjunto de índices y podemos continuar de forma recursiva. Entonces, todos los índices están incluidos en algún segmento maximal. Mostraremos que para cada segmento maximal k, k +1, . . . , k, P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. Agregar esto para cada segmento produce la desigualdad deseada. Así que ahora concéntrate en un segmento maximal k, k + 1, . . . , k − 1, k. Por lo tanto, existe un k∗ tal que para k ≤ k < k∗ , tenemos pk ij = Hj, y para k∗ ≤ k ≤ k , tenemos pk ij = Lj. Ahora el lado izquierdo de la desigualdad anterior para este segmento es simplemente xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, ya que xk ij ≤ 1 m ≤ xk∗ ij dado que pk ij = Hj y pk∗ ij = Lj. Ahora describimos cómo usar un algoritmo de c-aproximación para obtener un algoritmo que cumpla con la propiedad en el Lema 4.3. Para simplificar, primero supongamos que el algoritmo de aproximación devuelve un horario integral. La idea es simplemente difundir este horario. Tomamos cada trabajo j asignado a una máquina de alta y lo asignamos en una extensión de 1/m en todas las máquinas; para cada trabajo j asignado a una máquina de baja, digamos i, asignamos una fracción de 1/m a las otras máquinas donde es baja, y asignamos la fracción restante (que es al menos 1/m) a i. La asignación resultante satisface claramente las propiedades deseadas. También observe que la carga en cualquier máquina ha aumentado como máximo en 1 m · (carga en otras máquinas) ≤ makespan, y por lo tanto el makespan se ha duplicado como máximo. Esta distribución también se puede hacer si el horario inicial es fraccionado. Ahora describimos el algoritmo con precisión. Algoritmo 1 Sea A cualquier algoritmo que, para cualquier entrada p, genere una asignación posiblemente fraccional x tal que xij > 0 implica que pij ≤ T, donde T es el makespan de x. (En particular, cabe destacar que cualquier algoritmo que devuelva una asignación integral tiene estas propiedades). Nuestro algoritmo, al que llamamos A, devuelve la siguiente asignación xF. Inicializar xF ij = 0 para todos los i, j. Para cada i, j, 1. si pij = Hj, establezca xF ij = P i :pi j =Hj xi j/m; 2. si pij = Lj, establezca xF ij = xij + P i =i:pi j =Lj (xi j −xij)/m+ P i :pi j =Hj xi j/m. Teorema 4.4 Supongamos que el algoritmo A cumple las condiciones del Algoritmo 1 y devuelve un makespan de a lo sumo c·OPT(p) para cada p. Entonces, el algoritmo A construido anteriormente es una aproximación 2c, algoritmo fraccional cíclico-monótono. Además, si xF ij > 0 en la entrada p, entonces pij ≤ c · OPT(p). Prueba. Primero, nota que xF es una asignación válida: para cada trabajo j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij)/m = P i xij = 1. También tenemos que si pij = Hj, entonces xFij = Pi: pij = Hj xij/m ≤ 1/m. Si pij = Lj, entonces xF ij = xij(1 − /m) + P i =i xi j/m donde = |{i = i : pi j = Lj}| ≤ m − 1; por lo tanto, xF ij ≥ P i xi j/m ≥ 1/m. Por lo tanto, según el Lema 4.3, A satisface la monotonía de ciclo. La carga total en cualquier máquina i bajo xF es a lo sumo P j: pij = Hj P i: pij = Hj Hj · xi j m + P j: pij = Lj Lj ` xij + P i = i xi j m ´, que es a lo sumo P j pijxij + P i = i P j pijxi j/m ≤ 2c · OPT(p). Finalmente, si xF ij > 0 y pij = Lj, entonces pij ≤ OPT(p). Si pij = Hj, entonces para algún i (posiblemente i) con pij = Hj, tenemos xi j > 0, por lo tanto, por suposición, pij = Hj = pij ≤ c · OPT(p). El Teorema 4.4 combinado con los Lemas 4.1 y 4.2, proporciona un mecanismo de aproximación 3c, veraz en expectativa. La computación de los pagos dependerá del algoritmo de aproximación actual utilizado. La Sección 3, sin embargo, proporciona un procedimiento explícito para calcular los pagos garantizando la veracidad, aunque quizás no en tiempo polinómico. Teorema 4.5 El procedimiento en el Algoritmo 1 convierte cualquier algoritmo fraccional de aproximación c en un mecanismo de aproximación 3c, veraz en expectativa. Tomando A en el Algoritmo 1 como el algoritmo que devuelve una asignación óptima de LP que cumple las condiciones requeridas (ver [18, 25]), obtenemos un mecanismo de aproximación 3. Corolario 4.6 Existe un mecanismo veraz-en-expectativa con una proporción de aproximación de 3 para el escenario Lj-Hj. 5. Un MECANISMO DETERMINISTA PARA EL CASO DE DOS VALORES Presentamos ahora un mecanismo determinista de aproximación 2-veraz para el caso donde pij ∈ {L, H} para todo i, j. En la secuela, a menudo diremos que j está asignado a una máquina de baja carga para indicar que j está asignado a una máquina i donde pij = L. Llamaremos a un trabajo j un trabajo de baja carga de la máquina i si pij = L; la carga baja de i es la carga en i debido a sus trabajos de baja carga, es decir, P j:pij = L xijpij. Como en la Sección 4, nuestro objetivo es obtener un algoritmo de aproximación que cumpla con la monotonía de ciclo. Primero obtenemos una simplificación de la condición (3) para nuestro dominio de programación de dos valores {L, H} (Proposición 5.1) que será conveniente para trabajar. Describimos nuestro algoritmo en la Sección 5.1. En la Sección 5.2, acotamos su garantía de aproximación y demostramos que cumple con la ciclo-monotonía. En la Sección 5.3, calculamos los pagos explícitos proporcionando un mecanismo veraz. Finalmente, en la Sección 5.4 demostramos que ningún mecanismo determinista puede lograr el makespan óptimo. Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Then, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L).

Defina nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ ˛. (5) Entonces, P j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k H − nk+1,k L )(H − L). Sustituyendo esto en (3) y dividiendo por (H − L), obtenemos lo siguiente. Proposición 5.1 La monotonía cíclica en el dominio de programación de dos valores es equivalente a la condición de que, para cada jugador i, cada p−i, cada entero K, y cada p1 i , . . . , pK i , KX k=1 ` nk+1,k H − nk+1,k L ´ ≥ 0. (6) 257 5.1 Algoritmo de aproximación cíclicamente monótono A continuación describimos un algoritmo que satisface la condición (6) y logra una aproximación de 2. Supondremos que L, H son enteros, lo cual no limita la generalidad. Un componente fundamental de nuestro algoritmo será un procedimiento que tome un umbral de carga entero T y calcule una asignación parcial entera x de trabajos a máquinas de manera que (a) un trabajo solo se asigna a una máquina de baja carga; (b) la carga en cualquier máquina sea como máximo T; y (c) se maximice el número de trabajos asignados. Tal asignación se puede calcular resolviendo un problema de flujo máximo: construimos un grafo bipartito dirigido con un nodo para cada trabajo j y cada máquina i, y una arista (j, i) de capacidad infinita si pij = L. También agregamos un nodo fuente s con aristas (s, j) de capacidad 1, y un nodo sumidero t con aristas (i, t) de capacidad T/L. Claramente, cualquier flujo entero en esta red corresponde a una asignación parcial entera válida x de makespan de a lo sumo T, donde xij = 1 si y solo si hay un flujo de 1 en la arista de j a i. Por lo tanto, utilizaremos los términos asignación y flujo indistintamente. Además, siempre hay un flujo máximo integral (ya que todas las capacidades son números enteros). A menudo nos referiremos a dicho flujo máximo como el flujo máximo para (p, T). Necesitamos un concepto adicional antes de describir el algoritmo. Podría haber potencialmente muchos flujos máximos y estaremos interesados en los más equilibrados, los cuales definimos formalmente de la siguiente manera. Arregla algún flujo máximo. Deje que ni p,T sea la cantidad de flujo en el borde (i, t) (o equivalentemente el número de trabajos asignados a i en el horario correspondiente), y deje que np,T sea el tamaño total del flujo máximo, es decir, np,T = Σ i ni p,T. Para cualquier T ≤ T, definimos ni p,T |T = min(ni p,T , T ), es decir, truncamos el flujo/asignación en i para que la carga total en i sea como máximo T. Define np,T |T = P i ni p,T |T . 

Defina np,T |T = P i ni p,T |T. Definimos un flujo o asignación de prefijo-maximal para T de la siguiente manera. Definición 5.2 (Flujo prefijo-maximal) Un flujo para la red anterior con umbral T es prefijo-maximal si para cada entero T ≤ T, tenemos np,T |T = np,T. Es decir, en un flujo de prefijo máximo para (p, T), si truncamos el flujo en algún T ≤ T, nos queda un flujo máximo para (p, T). Un hecho elemental sobre los flujos es que si una asignación/flujo x no es un flujo máximo para (p, T) entonces debe existir un camino de aumento P = (s, j1, i1, . . . , jK , iK , t) en el grafo residual que nos permita aumentar el tamaño del flujo. La interpretación es que en la asignación actual, j1 no está asignado, xi j = 0, lo cual se denota por las aristas directas (j , i), y xi j +1 = 1, lo cual se denota por las aristas inversas (i, j +1). Aumentar x usando P cambia la asignación de manera que cada j se asigna a i en la nueva asignación, lo que aumenta el valor del flujo en 1. Un camino de aumento simple no disminuye la carga de ninguna máquina; por lo tanto, se puede argumentar que siempre existe un flujo maximal de prefijo para un umbral T. Primero calculamos un flujo máximo para el umbral 1, utilizamos caminos de aumento simples para aumentarlo a un flujo máximo para el umbral 2, y repetimos el proceso, cada vez aumentando el flujo máximo para el umbral anterior t a un flujo máximo para el umbral t + 1 utilizando caminos de aumento simples. Algoritmo 2 Dado un vector de tiempos de procesamiento p, construir una asignación de trabajos a máquinas de la siguiente manera. 1. Calcular T∗ (p) = min ˘ T ≥ H, T múltiplo de L : np,T · L + (n − np,T ) · H ≤ m · T ¯ . Se observa que np,T ·L+(n−np,T )·H −m·T es una función decreciente de T, por lo que T∗ (p) se puede calcular en tiempo polinómico mediante búsqueda binaria. Calcular un flujo prefijo-maximal para el umbral T∗ (p) y la asignación parcial correspondiente (es decir, j se asigna a i si hay 1 unidad de flujo en el borde (j, i)). 3. Asigna los trabajos restantes, es decir, los trabajos no asignados en la fase de flujo, de manera codiciosa de la siguiente manera. Considera estos trabajos en un orden arbitrario y asigna cada trabajo a la máquina con la carga actual más baja (donde la carga incluye los trabajos asignados en la fase de flujo). Nuestro algoritmo necesita calcular una asignación prefijo-maximal para el umbral T∗ (p). La prueba que muestra la existencia de un flujo maximal de prefijo solo produce un algoritmo de tiempo pseudopolinomial para calcularlo. Pero hay que tener en cuenta que el flujo máximo permanece igual para cualquier T ≥ T = n · L. Por lo tanto, un flujo maximal de prefijo para T también es maximal de prefijo para cualquier T ≥ T. Por lo tanto, solo necesitamos calcular un flujo maximal de prefijo para T = min{T∗ (p), T }. Esto se puede hacer en tiempo polinómico utilizando el algoritmo de caminos aumentantes iterativos en la prueba de existencia para calcular de forma iterativa el flujo máximo para los múltiplos polinomialmente muchos de L hasta (e incluyendo) T. Teorema 5.3 Se pueden calcular eficientemente pagos que, combinados con el Algoritmo 2, producen un mecanismo veraz de aproximación determinística 2 para el dominio de programación de dos valores. 5.2 Análisis Sea OPT(p) la duración óptima para p. Ahora demostramos que el Algoritmo 2 es un algoritmo de aproximación 2 que cumple con la monotonía cíclica. Esto nos permitirá calcular los pagos en la Sección 5.3 y demostrar el Teorema 5.3. 5.2.1 Prueba de la Aproximación Reclamo 5.4 Si OPT(p) < H, el makespan es a lo sumo OPT(p). Prueba. Si OPT(p) < H, debe ser que el horario óptimo asigna todos los trabajos a máquinas de baja velocidad, por lo que np,OPT(p) = n. Por lo tanto, tenemos T∗ (p) = L · H L. Además, dado que calculamos un flujo maximal de prefijo para el umbral T∗(p), tenemos np,T∗(p)|OPT(p) = np,OPT(p) = n, lo que implica que la carga en cada máquina es a lo sumo OPT(p). Por lo tanto, en este caso el makespan es como máximo (y por lo tanto exactamente) OPT(p). Reclamo 5.5 Si OPT(p) ≥ H, entonces T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L. Prueba. Sea nOPT(p) el número de trabajos asignados a las máquinas de baja en un horario óptimo. La carga total en todas las máquinas es exactamente nOPT(p) · L + (n − nOPT(p)) · H, y como máximo es m · OPT(p), ya que cada máquina tiene una carga de como máximo OPT(p). Entonces, tomando T = L · OPT(p) L ≥ H, dado que np,T ≥ nOPT(p) tenemos que np,T ·L+(n−np,T )·H ≤ m·T. Por lo tanto, T∗ (p), el T más pequeño de este tipo, es a lo sumo L · OPT(p) L. Reclamo 5.6 Cada trabajo asignado en el paso 3 del algoritmo se asigna a una máquina de alta calidad. 258 Prueba. Supongamos que j se asigna a la máquina i en el paso 3. Si pij = L, entonces debemos tener ni p,T ∗(p) = T∗ (p), de lo contrario podríamos haber asignado j a i en el paso 2 para obtener un flujo de valor mayor. Por lo tanto, en el punto justo antes de que se asigne j en el paso 3, la carga de cada máquina debe ser al menos T∗ (p). Por lo tanto, la carga total después de que se asigna j es al menos m · T∗ (p) + L > m · T∗ (p). Pero la carga total es como máximo np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), lo que resulta en una contradicción. Lema 5.7 El algoritmo anterior devuelve un horario con un makespan de a lo sumo OPT(p) + max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p). Prueba. Si OPT(p) < H, entonces, según la Afirmación 5.4, hemos terminado. Entonces supongamos que OPT(p) ≥ H. Por la Afirmación 5.5, sabemos que T∗ (p) ≤ OPT(p) + L. Si no hay trabajos sin asignar después del paso 2 del algoritmo, entonces el tiempo de ejecución es a lo sumo T∗ (p) y hemos terminado. Así que supongamos que hay algunos trabajos no asignados después del paso 2. Mostraremos que el makespan después del paso 3 es a lo sumo T +H ` 1− 1 m ´ donde T = min ˘ T∗ (p), OPT(p) ¯ . Supongamos que la afirmación es falsa. Sea i la máquina con la carga máxima, entonces li > T + H ` 1 − 1 m ´ . Deja que j sea el último trabajo asignado a i en el paso 3, y considera el punto justo antes de que se le asigne a i. Entonces li > T − H/m en este punto. También, dado que j está asignado a i, según nuestra regla codiciosa, la carga en todas las otras máquinas debe ser al menos li. Por lo tanto, la carga total después de que j sea asignado, es al menos H + m · li > m · T (ya que pij = H según la Reclamación 5.6). Además, para cualquier asignación de trabajos a máquinas en el paso 3, la carga total es a lo sumo np,T ∗(p) · L + (n − np,T ∗(p)) · H ya que hay np,T ∗(p) trabajos asignados a máquinas de baja prioridad. Por lo tanto, debemos tener m · T < np,T ∗(p) · L + (n - np,T ∗(p)) · H. Pero argumentaremos que m · T ≥ np,T ∗(p) · L + (n - np,T ∗(p)) · H, lo cual conduce a una contradicción. Si T = T∗ (p), esto se deduce de la definición de T∗ (p). Si T = OPT(p), entonces dejando que nOPT(p) denote el número de trabajos asignados a las máquinas de baja en un horario óptimo, tenemos np,T ∗(p) ≥ nOPT(p). Entonces, np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H. Este es exactamente la carga total en un horario óptimo, que es a lo sumo m · OPT(p). 5.2.2 Prueba de la monotonía del ciclo. Lema 5.8 Considere dos instancias p = (pi, p−i) y p = (pi, p−i) donde pi ≥ pi, es decir, pij ≥ pij ∀j. Si T es un umbral tal que np,T > np,T, entonces todo flujo máximo x para (p, T) debe asignar todos los trabajos j tales que pij = L. Demostración. Que Gp denote el grafo residual para (p, T) y el flujo x. Supongamos por contradicción que existe un trabajo j∗ con pij∗ = L que no está asignado por x. Dado que pi ≥ pi, todos los bordes (j, i) que están presentes en la red para (p, T) también están presentes en la red para (p, T). Por lo tanto, x es un flujo válido para (p, T). Pero no es un flujo máximo, ya que np,T > np,T. Entonces existe un camino de aumento P en el grafo residual para (p, T) y flujo x. Observa que el nodo i debe estar incluido en P, de lo contrario P también sería un camino de aumento en el grafo residual Gp, lo que contradiría el hecho de que x es un flujo máximo. En particular, esto implica que hay un camino P ⊂ P desde i hasta el sumidero t. Sea P = (i, j1, i1, . . . , jK , iK , t). Todos los bordes de P también están presentes como bordes en Gp: todos los bordes inversos (i, j +1) están presentes ya que dicho borde implica que xi j +1 = 1; todos los bordes directos (j, i) están presentes ya que i = i, por lo que pi j = pi j = L, y xi j +1 = 0. Pero luego hay un camino de aumento (j∗ , i, j1, i1, . . . , jK , iK , t) en Gp que contradice la maximalidad de x. Que L denote el vector de tiempo de procesamiento todo bajo. Define TL i (p−i) = T∗ (L, p−i). 

Defina TL i (p−i) = T∗ (L, p−i). Dado que nos estamos enfocando en la máquina i, y p−i está fijo en todo momento, abreviamos TL i (p−i) como TL. Además, sea pL = (L, p−i). Ten en cuenta que T∗ (p) ≥ TL para cada instancia p = (pi, p−i). Corolario 5.9 Sea p = (pi, p−i) cualquier instancia y sea x cualquier flujo prefijo-maximal para (p, T∗ (p)). Entonces, la carga baja en la máquina i es como máximo TL. Prueba. Que T∗ = T∗ (p). Si T∗ = TL, entonces esto es claramente cierto. De lo contrario, considera la asignación x truncada en TL. Dado que x es prefijo-maximal, sabemos que esto constituye un flujo máximo para (p, TL). Además, np,T L < npL,T L porque T∗ > TL. Entonces, según el Lema 5.8, este flujo truncado debe asignar todos los trabajos de baja prioridad de i. Por lo tanto, no puede haber un trabajo j con pij = L que se asigne a i después del umbral TL, ya que entonces j no sería asignado por este flujo truncado. Por lo tanto, la carga baja de i es como máximo TL. Usando estas propiedades, demostraremos la siguiente desigualdad clave: para cualquier p1 = (p−i, p1 i ) y p2 = (p−i, p2 i ), np1,T L ≥ np2,T L − n2,1 H + n2,1 L (7) donde n2,1 H y n2,1 L están definidos en (4) y (5), respectivamente. Observa que esto implica inmediatamente la monotonía del ciclo, ya que si tomamos p1 = pk y p2 = pk+1, entonces (7) implica que npk,T L ≥ npk+1,T L − nk+1,k H + nk+1,k L; sumando esto sobre todos los k = 1, . . . , K da como resultado (6). Lema 5.10 Si T∗ (p1) > TL, entonces se cumple la ecuación (7). Prueba. Que T1 = T∗ (p1) y T2 = T∗ (p2). Toma el flujo máximo de prefijo x2 para (p2, T2), trúnquelo en TL y elimine todos los trabajos de esta asignación que se cuentan en n2,1 H, es decir, todos los trabajos j tales que x2 ij = 1, p2 ij = L, p1 ij = H. Denomina este flujo como x. Observe que x es un flujo válido para (p1, TL), y el tamaño de este flujo es exactamente np2,T 2 |T L −n2,1 H = np2,T L −n2,1 H. Además, ninguno de los trabajos que se cuentan en n2,1 L está asignado por x, ya que cada trabajo j de este tipo tiene prioridad sobre i en p2. Dado que T1 > TL, debemos tener np1,TL < npTL,TL. Por lo tanto, si aumentamos x a un flujo máximo para (p1, TL), entonces, por el Lema 5.8 (con p = pL y p = p1), todos los trabajos correspondientes a n2,1 L deben asignarse en este flujo máximo. Por lo tanto, el tamaño de este flujo máximo es al menos (tamaño de x) + n2,1 L, es decir, np1,T L ≥ np2,T L − n2,1 H + n2,1 L, como se afirma. Lema 5.11 Supongamos que T∗ (p1 ) = TL. Entonces se cumple (7). Prueba. Nuevamente, dejemos que T1 = T∗ (p1) = TL y T2 = T∗ (p2). Que x1, x2 sean la asignación completa, es decir, la asignación después de los pasos 2 y 3, calculada por nuestro algoritmo para p1, p2 respectivamente. Sea S = {j : x2 ij = 1 y p2 ij = L} y S = {j : x2 ij = 1 y p1 ij = L}. Por lo tanto, |S | = |S| − n2,1 H + n2,1 L y |S| = ni p2,T 2 = ni p2,T 2 |T L (por el Corolario 5.9). Sea T = |S| · L. Consideramos dos casos. Supongamos primero que T ≤ TL. Considera el siguiente flujo para (p1, TL): asigna a cada máquina que no sea i la asignación baja de x2 truncada en TL, y asigna los trabajos en S a la máquina i. Este es un flujo válido para (p1, TL) ya que la carga en i es T ≤ TL. Su tamaño es igual a P i =i ni p2,T 2 |T L +|S | = np2,T 2 |T L −n2,1 H +n2,1 L = np2,T L −n2,1 H +n2,1 L. El tamaño del flujo máximo para (p1, TL) no es menor, y se sigue la afirmación. Ahora supongamos que T > TL. Dado que |S| · L ≤ TL (por el Corolario 5.9), se sigue que n2,1 L > n2,1 H ≥ 0. Sea ˆT = T − L ≥ TL ya que T, TL son ambos múltiplos de L. Sea M = np2,T 2 − n2,1 H + n2,1 L = |S | + P i =i ni p2,T 2. Primero demostramos que m · ˆT < M · L + (n − M) · H. (8) Sea N el número de trabajos asignados a la máquina i en x2. La carga en la máquina i es |S|·L+(N −|S|)·H ≥ |S |·L−n2,1 L · L+(N−|S|)·H, lo cual es al menos |S |·L > ˆT ya que n2,1 L ≤ N− |S|. Así obtenemos la desigualdad |S|·L+(N−|S|)·H > ˆT. Ahora considera el punto en la ejecución del algoritmo en la instancia p2 justo antes de que el último trabajo de alta prioridad sea asignado a i en el Paso 3 (debe haber tal trabajo ya que n2,1 L > 0). La carga en i en este punto es |S| · L + (N − |S| − 1) · H, que es al menos |S| · L − L = ˆT por un argumento similar al anterior. Por la propiedad codiciosa, cada i = i también tiene al menos esta carga en este punto, por lo que P j p2 i jx2 i j ≥ ˆT. Sumando estas desigualdades para todos los i = i, y la desigualdad anterior para i, obtenemos que |S| · L + (N − |S|) · H + Σ i = i Σ j p2 i jx2 i j > m ˆT. Pero el lado izquierdo es exactamente M · L + (n − M) · H. Por otro lado, dado que T1 = TL, tenemos m · ˆT ≥ m · TL ≥ np1,T L · L + (n − np1,T L) · H. (9) Combinando (8) y (9), obtenemos que np1,T L > M = np2,T 2 − n2,1 H + n2,1 L ≥ np2,T L − n2,1 H + n2,1 L. El Lema 5.12 del Algoritmo 2 satisface la monotonía del ciclo. Prueba. Tomando p1 = pk y p2 = pk+1 en (7), obtenemos que npk,T L ≥ npk+1,T L −nk+1,k H +nk+1,k L. Sumando esto sobre todos los k = 1, . . . , K (donde K + 1 ≡ 1) se obtiene (6). 5.3 Cálculo de precios Los lemas 5.7 y 5.12 muestran que nuestro algoritmo es un algoritmo de aproximación 2 que satisface la monotonía de ciclo. Por lo tanto, según la discusión en la Sección 3, existen precios que generan un mecanismo veraz. Para obtener un mecanismo de tiempo polinómico, también necesitamos mostrar cómo calcular estos precios (o pagos) en tiempo polinómico. No está claro si el procedimiento descrito en la Sección 3, basado en calcular los caminos más cortos en el grafo de asignación, produce un algoritmo de tiempo polinómico, ya que el grafo de asignación tiene un número exponencial de nodos (uno por cada asignación de salida). En lugar de analizar el grafo de asignación, aprovecharemos nuestra prueba de monotonía del ciclo, en particular, la desigualdad (7), y simplemente detallaremos los pagos. Recuerda que la utilidad de un jugador es ui = Pi − li, donde Pi es el pago realizado al jugador i. Para mayor comodidad, primero especificaremos los pagos negativos (es decir, los PIs serán los precios cobrados a los jugadores) y luego mostraremos que estos pueden ser modificados para que los jugadores tengan utilidades no negativas (si actúan de manera veraz). Que Hi denote el número de trabajos asignados a la máquina i en el paso 3. Por el Corolario 5.6, sabemos que todos estos trabajos están asignados a máquinas de alta calidad (según los pis declarados). Deja que H−i = P i =i Hi y n−i p,T = P i =i ni p,T. El pago Pi al jugador i se define como: Pi(p) = −L · n−i p,T ∗(p) − H · H−i (p) − (H − L) ` np,T ∗(p) − np,T L i (p−i) ´ (10). Podemos interpretar nuestros pagos como igualar el costo de los jugadores a una modificación cuidadosa de la carga total (en el espíritu de los precios VCG). Los primeros y segundos términos en (10), al restarse de la carga li, igualan el costo al total de la carga. El término np,T ∗(p) − np,T L i (p−i) es de hecho igual a n−i p,T ∗(p) − n−i p,T ∗(p)|T L i (p−i) ya que la carga baja en i es a lo sumo TL i (p−i) (según la Reclamación 5.9). Por lo tanto, el último término en la ecuación (10) implica que tratamos los trabajos de baja prioridad que fueron asignados más allá del umbral TL i (p−i) (a máquinas distintas de i) efectivamente como trabajos de alta prioridad para el cálculo total de utilidad desde su punto de vista. No está claro cómo se podrían haber ideado estos pagos de antemano para demostrar la veracidad de nuestro algoritmo. Sin embargo, al depender de la monotonía del ciclo, no solo pudimos argumentar la existencia de pagos, sino que nuestra prueba allanó el camino para inferir realmente estos pagos. El siguiente lema verifica explícitamente que los pagos definidos anteriormente realmente dan lugar a un mecanismo veraz. Lema 5.13 Fija un jugador i y las declaraciones de los otros jugadores p−i. Deje que su tipo verdadero sea p1 i. Entonces, bajo los pagos definidos en (10), la utilidad cuando declara su verdadero tipo p1 i es al menos su utilidad cuando declara cualquier otro tipo p2 i. Prueba. Que c1 i, c2 i denoten su costo total, definido como el negativo de su utilidad, cuando ella declara p1 y p2, respectivamente (y los demás declaran p−i). Dado que p−i está fijo, omitimos p−i de las expresiones a continuación para mayor claridad notacional. La verdadera carga de i cuando declara su verdadero tipo p1 i es L · ni p1,T ∗(p1) + H · Hi (p1), y por lo tanto c1 i = L · np1,T ∗(p1) + H · (n − np1,T ∗(p1)) + (H − L) ` np1,T ∗(p1) − np1,T L i ´ = n · H − (H − L)np1,T L i (11) Por otro lado, la verdadera carga cuando declara p2 i es L · (ni p2,T ∗(p2) − n2,1 H + n2,1 L) + H · (Hi + n2,1 H − n2,1 L) (ya que el vector de tiempo de procesamiento verdadero es p1 i), y así c2 i = n · H − (H − L)np2,T L i + (H − L)n2,1 H − (H − L)n2,1 L. Por lo tanto, (7) implica que c1 i ≤ c2 i. Las especificaciones de precios suelen requerirse para satisfacer, además de la veracidad, la racionalidad individual, es decir, la utilidad de un jugador debe ser no negativa si revela su valor real. Los pagos dados por (10) no son individualmente racionales ya que en realidad le cobran a un jugador una cierta cantidad. Sin embargo, es bien sabido que este problema se puede resolver fácilmente agregando una constante lo suficientemente grande a la definición del precio. En nuestro caso, por ejemplo, dejando que H denote el vector de todas las H, podemos añadir el término n·H −(H −L)n(H,p−i),T L i (p−i) a (10). Ten en cuenta que esto es una constante para el jugador i. Por lo tanto, los nuevos pagos son Pi (p) = n · H − L · n−i p,T ∗(p) − H · H−i (p) − (H −L) ` np,T ∗(p) −np,T L i (p−i) +n(H,p−i),T L i (p−i) ´ . Como se muestra en (11), esto resultará en una utilidad no negativa para i (ya que n(H,p−i),T L i (p−i) ≤ n(pi,p−i),T L i (p−i) para cualquier tipo pi del jugador i). Esta modificación también garantiza la propiedad de normalización adicional deseada de que si un jugador no recibe trabajos, entonces recibe un pago de cero: si el jugador i recibe el conjunto vacío para algún tipo pi, entonces también recibirá el conjunto vacío para el tipo H (esto es fácil de verificar para nuestro algoritmo específico), y para el tipo H, su utilidad es igual a cero; por lo tanto, por veracidad, esta también debe ser la utilidad de cualquier otra declaración que resulte en que i reciba el conjunto vacío. Esto completa la demostración del Teorema 5.3. 260 5.4 Imposibilidad de implementación exacta. Ahora mostramos que, independientemente de consideraciones computacionales, no existe un algoritmo cíclico-monótono para el caso L-H con una proporción de aproximación mejor que 1.14. Sea H = α·L para algún 2 < α < 2.5 que elegiremos más tarde. Hay dos máquinas I, II y siete trabajos. Considera los siguientes dos escenarios: Escenario 1. Cada trabajo tiene el mismo tiempo de procesamiento en ambas máquinas: los trabajos 1-5 son L, y los trabajos 6, 7 son H. Cualquier horario óptimo asigna los trabajos 1-5 a una máquina y los trabajos 6, 7 a la otra, y tiene un makespan OPT1 = 5L. El segundo mejor horario tiene un tiempo de ejecución de al menos Second1 = 2H + L. Escenario 2. Si el algoritmo elige un horario óptimo para el escenario 1, asuma sin pérdida de generalidad que los trabajos 6 y 7 están asignados a la máquina II. En el escenario 2, la máquina I tiene el mismo vector de tiempos de procesamiento. La Máquina II reduce los trabajos 6 y 7 a L y aumenta los trabajos 1-5 a H. Un horario óptimo tiene un tiempo de ejecución de 2L + H, donde la Máquina II realiza los trabajos 6, 7 y uno de los trabajos 1-5. La segunda mejor programación para este escenario tiene un makespan de al menos Second2 = 5L. Teorema 5.14 Ningún mecanismo determinístico y veraz para el problema de programación de dos valores puede obtener una proporción de aproximación mejor que 1.14. Prueba. Primero argumentamos que un algoritmo cíclico-monótono no puede elegir el horario óptimo en ambos escenarios. Esto se debe a que de lo contrario se viola la monotonía del ciclo para la máquina II. Tomando p1 II , p2 II como vectores de tiempos de procesamiento de la máquina II para los escenarios 1, 2 respectivamente, obtenemos P j(p1 II ,j − p2 II ,j)(x2 II ,j −x1 II ,j) = (L−H)(1−0) < 0. Por lo tanto, cualquier mecanismo veraz debe devolver un makespan subóptimo en al menos un escenario, y por lo tanto su ratio de aproximación es al menos min ˘Second1 OPT1 , Second2 OPT2 ¯ ≥ 1.14 para α = 2.364. Observamos que para el caso {Lj, Hj} donde hay una razón común r = Hj Lj para todos los trabajos (esto generaliza el escenario de máquinas restringidas) se puede obtener un mecanismo fraccional veraz (con precios computables eficientemente) que devuelve un horario de makespan de a lo sumo OPT(p) para cada p. Se puede ver cada trabajo j como consistente de Lj subtrabajos de tamaño 1 en una máquina i si pij = Lj, y de tamaño r si pij = Hj. Para esta nueva instancia ˜p, nota que ˜pij ∈ {1, r} para cada i, j. También hay que tener en cuenta que cualquier asignación ˜x para la instancia ˜p se traduce en una asignación fraccional x para p, donde pijxij =P j : subtrabajo de j ˜pij ˜xij. Por lo tanto, si utilizamos el Algoritmo 2 para obtener un horario para la instancia ˜p, la ecuación (6) se traduce precisamente a (3) para la asignación x; además, los precios para ˜p se traducen en precios para la instancia p. El número de subtrabajos asignados a máquinas de baja en la fase de flujo es simplemente el trabajo total asignado a las máquinas de baja. Por lo tanto, podemos implementar la reducción anterior configurando un problema de flujo máximo que parece maximizar el trabajo total asignado a las máquinas de baja capacidad. Además, dado que tenemos un dominio fraccional, podemos utilizar una regla codiciosa más eficiente para empaquetar las porciones no asignadas de trabajos y argumentar que la asignación fraccional tiene un makespan de a lo sumo OPT(p). La asignación x no necesita cumplir la condición de que xij > 0 implica pij ≤ OPT(p) para cualquier r, por lo tanto, el procedimiento de redondeo del Lema 4.2 no produce un mecanismo de aproximación 2-veraz en expectativa. Pero si r > OPT(p) (como en el escenario de máquinas restringidas), esta condición sí se cumple, por lo que obtenemos un mecanismo veraz de aproximación 2. Agradecimientos Agradecemos a Elias Koutsoupias por su ayuda en refinar el análisis del límite inferior en la Sección 5.4, y a los revisores por sus comentarios útiles. 6. REFERENCIAS [1] N. Andelman, Y. Azar y M. Sorani. Mecanismos de aproximación veraces para la programación de máquinas relacionadas egoístas. En Proc. 22º STACS, 69-82, 2005. [2] A. Archer. Mecanismos para la optimización discreta con agentes racionales. Tesis doctoral, Universidad de Cornell, 2004. [3] A. Archer y ´E. This word does not have a meaning in English. Could you please provide more context or clarify the sentence? Mecanismos veraces para agentes de un parámetro. En Proc. 42º FOCS, páginas 482-491, 2001. [4] V. Auletta, R. De-Prisco, P. Penna y G. Persiano. Mecanismos de aproximación veraces determinísticos para máquinas relacionadas con la programación. En Proc. 21º STACS, páginas 608-619, 2004. [5] I. Bez´akov´a y V. Dani. Asignación de bienes indivisibles. En ACM SIGecom Exchanges, 2005. [6] S. Bikhchandani, S. Chatterjee, R. Lavi, A. Mualem, N. Nisan y A. Sen. La debilidad de la monotonicidad caracteriza la implementación de estrategias dominantes determinísticas. Econometrica, 74:1109-1132, 2006. [7] P. Briest, P. Krysta y B. Vocking. Técnicas de aproximación para el diseño de mecanismos utilitarios. En Proc. 37th STOC, páginas 39-48, 2005. [8] G. Christodoulou, E. Koutsoupias y A. Vidali. Un límite inferior para los mecanismos de programación. En Proc. 18th SODA, páginas 1163-1170, 2007. [9] E. Clarke. Precios escalonados de bienes públicos. Elección Pública, 8:17-33, 1971. [10] T. Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [11] H. Gui, R. Muller, y R. V. Vohra. Caracterizando mecanismos de estrategia dominante con tipos multidimensionales, 2004. Documento de trabajo. [12] L. A. Sala. Algoritmos de aproximación para la programación de tareas. En D. Hochbaum, editor, Algoritmos de Aproximación para Problemas NP-Difíciles. PWS Publishing, MA, 1996. [13] A. Kovács. Algoritmo de aproximación rápida y monótona 3 para la programación de máquinas relacionadas. En Proc. 13th ESA, páginas 616-627, 2005. [14] V. S. A. Kumar, M. V. Marathe, S. Parthasarathy y A. Srinivasan. Algoritmos de aproximación para la programación en múltiples máquinas. En Proc. 46th FOCS, páginas 254-263, 2005. [15] R. Lavi, A. Mualem y N. Nisan. Hacia una caracterización de subastas combinatorias veraces. En Proc. 44th FOCS, páginas 574-583, 2003. [16] R. Lavi y C. Swamy. Diseño de mecanismos veraz y casi óptimos a través de programación lineal. En Proc. 46th FOCS, páginas 595-604, 2005. [17] D. Lehmann, L. OCallaghan y Y. Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Revista de la ACM, 49:577-602, 2002. [18] J. K. Lenstra, D. B. Shmoys, y ´E. This word does not have a meaning in English. Could you please provide more context or another sentence for translation? Algoritmos de aproximación para la programación de máquinas paralelas no relacionadas. Matemáticas. Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, and A. Saberi. 

Prog., 46:259-271, 1990. [19] R. J. Lipton, E. Markakis, E. Mossel, y A. Saberi. Sobre asignaciones aproximadamente justas de bienes indivisibles. En Proc. 5to EC, páginas 125-131, 2004. [20] A. Mualem y M. Schapira. Estableciendo límites inferiores en la veracidad. En Proc. 18th SODA, 1143-1152, 2007. [21] R. Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [22] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Economía. Comportamiento, 35:166-196, 2001. [23] J. C. Rochet. Una condición necesaria y suficiente para la racionalización en un contexto cuasilineal. Revista de Economía Matemática, 16:191-200, 1987. [24] M. Saks y L. Yu. La monotonía débil es suficiente para la veracidad en dominios convexos. En Proc. 6to EC, páginas 286-293, 2005. [25] D. B. Shmoys y ´E. This word does not have a specific meaning in English. Could you please provide more context or another sentence for translation? Un algoritmo de aproximación para el problema de asignación generalizada. Programación Matemática, 62:461-474, 1993. [26] W. Vickrey. Contraespeculaciones, subastas y licitaciones selladas competitivas. I'm sorry, but the sentence "J." does not have a clear meaning or context for translation. Could you please provide more information or a complete sentence for me to translate into Spanish? Finanzas, 16:8-37, 1961. 261