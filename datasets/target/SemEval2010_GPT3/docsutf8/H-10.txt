Agrupamiento regularizado para documentos ∗ Fei Wang, Changshui Zhang Laboratorio Clave del Estado de Tecnología Inteligente. En los últimos años, la agrupación de documentos ha estado recibiendo cada vez más atención como una técnica importante y fundamental para la organización no supervisada de documentos, la extracción automática de temas y la recuperación o filtrado rápido de información. En este artículo, proponemos un método novedoso para agrupar documentos utilizando regularización. A diferencia de los métodos de agrupamiento regularizados globalmente tradicionales, nuestro método primero construye un predictor de etiquetas lineal regularizado local para cada vector de documento, y luego combina todos esos regularizadores locales con un regularizador de suavidad global. Así que llamamos a nuestro algoritmo Agrupamiento con Regularización Local y Global (CLGR). Mostraremos que las pertenencias de los documentos a los grupos se pueden lograr mediante la descomposición de los valores propios de una matriz simétrica dispersa, la cual puede resolverse eficientemente mediante métodos iterativos. Finalmente, se presentan nuestras evaluaciones experimentales en varios conjuntos de datos para mostrar las ventajas de CLGR sobre los métodos tradicionales de agrupamiento de documentos. Categorías y Descriptores de Asignaturas H.3.3 [Almacenamiento y Recuperación de Información]: Búsqueda y Recuperación de Información-Agrupamiento; I.2.6 [Inteligencia Artificial]: Aprendizaje-Aprendizaje de Conceptos Términos Generales Algoritmos 1. La agrupación de documentos ha estado recibiendo cada vez más atención como una técnica importante y fundamental para la organización no supervisada de documentos, la extracción automática de temas y la recuperación o filtrado rápido de información. Un buen enfoque de agrupación de documentos puede ayudar a las computadoras a organizar automáticamente el corpus de documentos en una jerarquía de clusters significativa para una navegación eficiente, lo cual es muy valioso para complementar las deficiencias de las tecnologías tradicionales de recuperación de información. Como señaló [8], las necesidades de recuperación de información pueden expresarse mediante un espectro que va desde la búsqueda basada en palabras clave estrechas hasta la exploración de información amplia, como cuáles son los principales eventos internacionales de los últimos meses. Los motores de búsqueda de documentos tradicionales tienden a adaptarse bien al extremo de la búsqueda, es decir, suelen proporcionar búsquedas específicas de documentos que coinciden con la consulta de los usuarios, sin embargo, les resulta difícil satisfacer las necesidades del resto del espectro en el que se necesita información más amplia o vaga. En tales casos, la navegación eficiente a través de una buena jerarquía de clústeres será definitivamente útil. Generalmente, los métodos de agrupamiento de documentos se pueden clasificar principalmente en dos clases: métodos jerárquicos y métodos de partición. Los métodos jerárquicos agrupan los puntos de datos en una estructura de árbol jerárquico utilizando enfoques de abajo hacia arriba o de arriba hacia abajo. Por ejemplo, el clustering jerárquico aglomerativo (HAC) [13] es un método típico de clustering jerárquico ascendente. Toma cada punto de datos como un único clúster para comenzar y luego construye clústeres más grandes agrupando puntos de datos similares juntos hasta que todo el conjunto de datos esté encapsulado en un único clúster final. Por otro lado, los métodos de particionamiento descomponen el conjunto de datos en un número de grupos disjuntos que suelen ser óptimos en términos de algunas funciones de criterio predefinidas. Por ejemplo, K-means es un método de particionamiento típico que tiene como objetivo minimizar la suma de las distancias al cuadrado entre los puntos de datos y sus centros de clúster correspondientes. En este documento, nos centraremos en los métodos de particionamiento. Como sabemos, existen dos problemas principales en los métodos de particionamiento (como Kmeans y el Modelo de Mezcla Gaussiana (GMM) [16]): (1) el criterio predefinido suele ser no convexo, lo que provoca muchas soluciones óptimas locales; (2) el procedimiento iterativo (por ejemplo, el algoritmo de Expectation Maximization (EM)) para optimizar los criterios suele hacer que las soluciones finales dependan en gran medida de las inicializaciones. En las últimas décadas, se han propuesto muchos métodos para superar los problemas mencionados de los métodos de particionamiento [19][28]. Recientemente, otro tipo de métodos de particionamiento basados en agrupamiento en grafos de datos han despertado un considerable interés en la comunidad de aprendizaje automático y minería de datos. La idea básica detrás de estos métodos es modelar primero el conjunto de datos completo como un grafo ponderado, en el que los nodos del grafo representan los puntos de datos y los pesos en los bordes corresponden a las similitudes entre los puntos en pares. Entonces, las asignaciones de clústeres del conjunto de datos se pueden lograr optimizando algunos criterios definidos en el gráfico. Por ejemplo, el Clustering Espectral es uno de los enfoques de clustering basados en grafos más representativos, generalmente tiene como objetivo optimizar algún valor de corte (por ejemplo, Corte normalizado [22], corte de razón [7], corte mínimo-máximo [11]) definidos en un grafo no dirigido. Después de algunas relajaciones, estos criterios generalmente pueden ser optimizados a través de descomposiciones propias, lo cual está garantizado que sea óptimo a nivel global. De esta manera, el agrupamiento espectral evita eficientemente los problemas de los métodos de particionamiento tradicionales que presentamos en el párrafo anterior. En este artículo, proponemos un algoritmo novedoso de agrupamiento de documentos que hereda la superioridad del agrupamiento espectral, es decir, los resultados finales de los grupos también pueden obtenerse explotando la estructura de los autovalores de una matriz simétrica. Sin embargo, a diferencia del agrupamiento espectral, que simplemente impone una restricción de suavidad en las etiquetas de los datos sobre todo el conjunto de datos [2], nuestro método primero construye un predictor de etiquetas lineal regularizado para cada punto de datos a partir de su vecindario como en [25], y luego combina los resultados de todos estos predictores de etiquetas locales con un regularizador de suavidad de etiquetas global. Así que llamamos a nuestro método Agrupamiento con Regularización Local y Global (CLGR). La idea de incorporar tanto información local como global en la predicción de etiquetas está inspirada en los trabajos recientes sobre aprendizaje semi-supervisado [31], y nuestras evaluaciones experimentales en varios conjuntos de datos reales de documentos muestran que CLGR funciona mejor que muchos métodos de agrupamiento de vanguardia. El resto de este documento está organizado de la siguiente manera: en la sección 2 presentaremos nuestro algoritmo CLGR en detalle. Los resultados experimentales en varios conjuntos de datos se presentan en la sección 3, seguidos de las conclusiones y discusiones en la sección 4. El ALGORITMO PROPUESTO En esta sección, presentaremos en detalle nuestro algoritmo de Agrupamiento con Regularización Local y Global (CLGR). Primero veamos cómo se representan los documentos a lo largo de este documento. 2.1 Representación de documentos En nuestro trabajo, todos los documentos se representan mediante vectores de frecuencia de términos ponderados. Sea W = {w1, w2, · · · , wm} el conjunto completo de vocabulario del corpus de documentos (que ha sido preprocesado mediante la eliminación de palabras vacías y operaciones de derivación de palabras). El vector de frecuencia de término xi del documento di se define como xi = [xi1, xi2, · · · , xim]T , xik = tik log n idfk , donde tik es la frecuencia del término wk ∈ W, n es el tamaño del corpus de documentos, idfk es el número de documentos que contienen la palabra wk. De esta manera, xi también se llama la representación TFIDF del documento di. Además, también normalizamos cada xi (1 i n) para que tenga una longitud unitaria, de modo que cada documento esté representado por un vector TF-IDF normalizado. 2.2 Regularización Local Como su nombre sugiere, CLGR está compuesto por dos partes: regularización local y regularización global. En esta subsección introduciremos detalladamente la parte de regularización local. 2.2.1 Motivación Como sabemos que el agrupamiento es un tipo de técnica de aprendizaje, tiene como objetivo organizar el conjunto de datos de una manera razonable. En general, el aprendizaje puede plantearse como un problema de estimación de funciones, a partir del cual podemos obtener una buena función de clasificación que asignará etiquetas al conjunto de datos de entrenamiento e incluso al conjunto de datos de prueba no vistos con algún costo minimizado [24]. Por ejemplo, en el escenario de clasificación de dos clases (en el que conocemos exactamente la etiqueta de cada documento), un clasificador lineal con ajuste de mínimos cuadrados tiene como objetivo aprender un vector columna w de manera que el costo al cuadrado J = 1 n (wT xi − yi)2 (1) se minimice, donde yi ∈ {+1, −1} es la etiqueta de xi. Al tomar ∂J /∂w = 0, obtenemos la solución w∗ = Σ i=1 n xixT i −1 Σ i=1 n xiyi, (2) que puede escribirse en su forma matricial como w∗ = XXT −1 Xy, (3) donde X = [x1, x2, · · · , xn] es una matriz de documentos m × n, y = [y1, y2, · · · , yn]T es el vector de etiquetas. Entonces, para un documento de prueba t, podemos determinar su etiqueta mediante l = signo(w∗T u), donde signo(·) es la función signo. Un problema natural en la ecuación (3) es que la matriz XXT puede ser singular y, por lo tanto, no invertible (por ejemplo, cuando m n). Para evitar tal problema, podemos agregar un término de regularización y minimizar el siguiente criterio J = 1 n n i=1 (wT xi − yi)2 + λ w 2, (5), donde λ es un parámetro de regularización. Entonces, la solución óptima que minimiza J está dada por w∗ = XXT + λnI −1 Xy, (6) donde I es una matriz identidad de tamaño m × m. Se ha informado que el clasificador lineal regularizado puede lograr resultados muy buenos en problemas de clasificación de texto [29]. Sin embargo, a pesar de su éxito empírico, el clasificador lineal regularizado es en realidad un clasificador global, es decir, w∗ se estima utilizando todo el conjunto de entrenamiento. Según [24], esta puede que no sea una idea inteligente, ya que un único w∗ puede que no sea lo suficientemente bueno para predecir las etiquetas de todo el espacio de entrada. Para obtener predicciones más precisas, [6] propuso entrenar clasificadores localmente y utilizarlos para clasificar los puntos de prueba. Por ejemplo, un punto de prueba será clasificado por el clasificador local entrenado utilizando los puntos de entrenamiento ubicados en la vecindad 1. En las siguientes discusiones todos asumimos que los documentos provienen solo de dos clases. Las generalizaciones de nuestro método a casos de múltiples clases se discutirán en la sección 2.5 de él. Aunque este método parece lento y estúpido, se informa que puede obtener mejores rendimientos que usar un clasificador global único en ciertas tareas [6]. 2.2.2 Construyendo los Predictores Localmente Regularizados Inspirados en su éxito, propusimos aplicar los algoritmos de aprendizaje local para el agrupamiento. La idea básica es que, para cada vector de documento xi (1 i n), entrenamos un predictor de etiquetas local basado en su vecindario k-más cercano Ni, y luego lo usamos para predecir la etiqueta de xi. Finalmente combinaremos todos esos predictores locales minimizando la suma de sus errores de predicción. En esta subsección introduciremos cómo construir esos predictores locales. Debido a la simplicidad y efectividad del clasificador lineal regularizado que hemos introducido en la sección 2.2.1, lo elegimos como nuestro predictor de etiquetas local, de modo que para cada documento xi, se minimiza el siguiente criterio Ji = 1 ni xj ∈Ni wT i xj − qj 2 + λi wi 2, (7), donde ni = |Ni| es la cardinalidad de Ni, y qj es la pertenencia al clúster de xj. Luego, utilizando la Ecuación (6), podemos obtener que la solución óptima es w∗ i = XiXT i + λiniI −1 Xiqi, (8), donde Xi = [xi1, xi2, · · · , xini], y usamos xik para denotar al k-ésimo vecino más cercano de xi. qi = [qi1, qi2, · · · , qini]T con qik representando la asignación de clúster de xik. El problema aquí es que XiXT i es una matriz m × m con m ni, es decir, deberíamos calcular la inversa de una matriz m × m para cada vector de documento, lo cual está prohibido computacionalmente. Afortunadamente, tenemos el siguiente teorema: Teorema 1. w∗ i en la Ec. (8) puede ser reescrito como w∗ i = Xi XT i Xi + λiniIi −1 qi, (9), donde Ii es una matriz identidad de tamaño ni × ni. Prueba. Dado que w∗ i = XiXT i + λiniI −1 Xiqi, entonces XiXT i + λiniI w∗ i = Xiqi =⇒ XiXT i w∗ i + λiniw∗ i = Xiqi =⇒ w∗ i = (λini)−1 Xi qi − XT i w∗ i. Sea β = (λini)−1 qi − XT i w∗ i, entonces w∗ i = Xiβ =⇒ λiniβ = qi − XT i w∗ i = qi − XT i Xiβ =⇒ qi = XT i Xi + λiniIi β =⇒ β = XT i Xi + λiniIi −1 qi. Por lo tanto, w∗ i = Xiβ = Xi XT i Xi + λiniIi −1 qi 2. Utilizando el teorema 1, solo necesitamos calcular la inversa de una matriz ni × ni para cada documento para entrenar un predictor de etiquetas local. Además, para un nuevo punto de prueba u que cae en Ni, podemos clasificarlo por el signo de qu = w∗T i u = uT wi = uT Xi XT i Xi + λiniIi −1 qi. Esta es una expresión atractiva ya que podemos determinar la asignación del clúster de u utilizando los productos internos entre los puntos en {u ∪ Ni}, lo que sugiere que un regularizador local de este tipo puede ser fácilmente kernelizado [21] siempre y cuando definamos una función de kernel adecuada. 2.2.3 Combinando los Predictores Regularizados Localmente Una vez que todos los predictores locales hayan sido construidos, los combinaremos minimizando Jl = n i=1 w∗T i xi − qi 2, (10), lo que representa la suma de los errores de predicción de todos los predictores locales. Combinando la Ecuación (10) con la Ecuación (6), podemos obtener Jl = n i=1 w∗T i xi − qi 2 = n i=1 xT i Xi XT i Xi + λiniIi −1 qi − qi 2 = Pq − q 2, (11), donde q = [q1, q2, · · · , qn]T, y P es una matriz n × n construida de la siguiente manera. Sea αi = xT i Xi XT i Xi + λiniIi −1 , entonces Pij = αi j, si xj ∈ Ni 0, de lo contrario , (12) donde Pij es la entrada (i, j)-ésima de P, y αi j representa la entrada j-ésima de αi. Hasta ahora podemos escribir el criterio de agrupamiento combinando predictores de etiquetas lineales localmente regularizados Jl en una forma matemática explícita, y podemos minimizarlo directamente utilizando algunas técnicas estándar de optimización. Sin embargo, los resultados pueden no ser lo suficientemente buenos ya que solo explotamos la información local del conjunto de datos. En la siguiente subsección, introduciremos un criterio de regularización global y lo combinaremos con Jl, que tiene como objetivo encontrar un buen resultado de agrupamiento de manera local-global. 2.3 Regularización Global En el agrupamiento de datos, generalmente requerimos que las asignaciones de clúster de los puntos de datos sean lo suficientemente suaves con respecto a la variedad de datos subyacente, lo que implica (1) que los puntos cercanos tienden a tener las mismas asignaciones de clúster; (2) que los puntos en la misma estructura (por ejemplo, subvariedad o clúster) tienden a tener las mismas asignaciones de clúster [31]. Sin pérdida de generalidad, asumimos que los puntos de datos residen (aproximadamente) en una variedad de baja dimensión M2, y q es la función de asignación de clúster definida en M, es decir, 2 Creemos que los datos de texto también se muestrean de alguna variedad de baja dimensión, ya que es imposible que para todos los x ∈ M, q(x) devuelva la membresía del clúster de x. La suavidad de q sobre M se puede calcular mediante la siguiente integral de Dirichlet [2] D[q] = 1 2 M q(x) 2 dM, (13) donde el gradiente q es un vector en el espacio tangente T Mx, y la integral se toma con respecto a la medida estándar en M. Si restringimos la escala de q por q, q M = 1 (donde ·, · M es el producto interno inducido en M), entonces resulta que encontrar la función más suave que minimiza D[q] se reduce a encontrar las autofunciones del operador Laplace Beltrami L, que se define como Lq −div q, (14) donde div es la divergencia de un campo vectorial. Generalmente, el gráfico se puede ver como la forma discretizada de una variedad. Podemos modelar el conjunto de datos como un grafo ponderado no dirigido como en el agrupamiento espectral [22], donde los nodos del grafo son simplemente los puntos de datos, y los pesos en las aristas representan las similitudes entre pares de puntos. Entonces se puede demostrar que minimizar la Ec. (13) corresponde a minimizar Jg = qT Lq = n i=1 (qi − qj)2 wij, (15), donde q = [q1, q2, · · · , qn]T con qi = q(xi), L es el Laplaciano del grafo con su entrada (i, j)-ésima Lij =    di − wii, si i = j −wij, si xi y xj son adyacentes 0, en otro caso, (16), donde di = j wij es el grado de xi, wij es la similitud entre xi y xj. Si xi y xj son adyacentes, wij generalmente se calcula de la siguiente manera: wij = e − xi−xj 2 2σ2, donde σ es un parámetro dependiente del conjunto de datos. Se ha demostrado que bajo ciertas condiciones, tal forma de wij para determinar los pesos en los bordes del grafo conduce a la convergencia del Laplaciano del grafo al operador Laplace Beltrami [3][18]. En resumen, el uso de la Ec. (15) con pesos exponenciales puede medir de manera efectiva la suavidad de las asignaciones de datos con respecto a la variedad intrínseca de datos. Por lo tanto, lo adoptamos como un regularizador global para penalizar la suavidad de las asignaciones de datos predichas. 2.4 Agrupamiento con Regularización Local y Global Combinando los contenidos que hemos introducido en la sección 2.2 y la sección 2.3, podemos derivar que el criterio de agrupamiento es minq J = Jl + λJg = Pq − q 2 + λqT Lq sujeto a qi ∈ {−1, +1}, (18) donde P está definido como en la Ecuación (12), y λ es un parámetro de regularización para equilibrar Jl y Jg. Sin embargo, los valores discretos llenan todo el espacio muestral de alta dimensionalidad. Y se ha demostrado que los métodos basados en variedades pueden lograr buenos resultados en tareas de clasificación de texto [31]. En este artículo, definimos xi y xj como adyacentes si xi ∈ N(xj) o xj ∈ N(xi). La restricción de pi convierte el problema en un problema de programación entera NP difícil. Una forma natural de hacer que el problema sea resoluble es eliminar la restricción y relajar qi para que sea continuo, luego el objetivo que buscamos minimizar se convierte en J = Pq − q 2 + λqT Lq = qT (P − I)T (P − I)q + λqT Lq = qT (P − I)T (P − I) + λL q, (19) y luego agregamos una restricción adicional qT q = 1 para restringir la escala de q. Entonces nuestro objetivo se convierte en minq J = qT (P − I)T (P − I) + λL q s.t. qT q = 1 (20) Utilizando el método de Lagrange, podemos derivar que la solución óptima q corresponde al menor vector propio de la matriz M = (P − I)T (P − I) + λL, y la asignación de clúster de xi puede determinarse por el signo de qi, es decir, xi se clasificará como clase uno si qi > 0, de lo contrario se clasificará como clase 2. 2.5 CLGR Multiclase En lo anterior hemos introducido el marco básico de Agrupamiento con Regularización Local y Global (CLGR) para el problema de agrupamiento de dos clases, y lo extenderemos al agrupamiento multiclase en esta subsección. Primero asumimos que todos los documentos pertenecen a C clases indexadas por L = {1, 2, · · · , C}. qc es la función de clasificación para la clase c (1 ≤ c ≤ C), tal que qc(xi) devuelve la confianza de que xi pertenece a la clase c. Nuestro objetivo es obtener el valor de qc(xi) (1 ≤ c ≤ C, 1 ≤ i ≤ n), y la asignación de cluster de xi puede ser determinada por {qc(xi)}C c=1 utilizando algunos métodos adecuados de discretización que presentaremos más adelante. Por lo tanto, en este caso de múltiples clases, para cada documento xi (1 i n), construiremos C predictores de etiquetas regularizados localmente lineales cuyos vectores normales son wc∗ i = Xi XT i Xi + λiniIi −1 qc i (1 c C), (21), donde Xi = [xi1, xi2, · · · , xini ] con xik siendo el k-ésimo vecino de xi, y qc i = [qc i1, qc i2, · · · , qc ini ]T con qc ik = qc (xik). Entonces (wc∗ i )T xi devuelve la confianza predicha de xi perteneciente a la clase c. Por lo tanto, el error de predicción local para la clase c se puede definir como J c l = n i=1 (wc∗ i ) T xi − qc i 2 , (22) Y el error de predicción local total se convierte en Jl = C c=1 J c l = C c=1 n i=1 (wc∗ i ) T xi − qc i 2 . (23) Como en la Ec. (11), podemos definir una matriz n×n P (ver Ec. (12)) y reescribir Jl como Jl = C c=1 J c l = C c=1 Pqc − qc 2 . (24) De manera similar, podemos definir el regularizador de suavidad global en el caso de múltiples clases como Jg = C c=1 n i=1 (qc i − qc j )2 wij = C c=1 (qc )T Lqc . (25) Luego, el criterio a minimizar para CLGR en el caso de múltiples clases se convierte en J = Jl + λJg = C c=1 Pqc − qc 2 + λ(qc )T Lqc = C c=1 (qc )T (P − I)T (P − I) + λL qc = trace QT (P − I)T (P − I) + λL Q , (26) donde Q = [q1 , q2 , · · · , qc ] es una matriz n × c, y trace(·) devuelve la traza de una matriz. Al igual que en la ecuación (20), también agregamos la restricción de que QT Q = I para limitar la escala de Q. Entonces nuestro problema de optimización se convierte en minQ J = traza QT (P − I)T (P − I) + λL Q sujeto a. Según el teorema de Ky Fan [28], sabemos que la solución óptima del problema anterior es Q∗ = [q∗ 1, q∗ 2, · · · , q∗ C ]R, donde q∗ k (1 ≤ k ≤ C) es el autovector que corresponde al k-ésimo valor propio más pequeño de la matriz (P − I)T (P − I) + λL, y R es una matriz arbitraria de tamaño C × C. Dado que los valores de las entradas en Q∗ son continuos, necesitamos discretizar aún más Q∗ para obtener las asignaciones de clúster de todos los puntos de datos. Principalmente hay dos enfoques para lograr este objetivo: 1. Como en [20], podemos tratar la i-ésima fila de Q como la incrustación de xi en un espacio de C dimensiones, y aplicar algunos métodos de agrupamiento tradicionales como kmeans para agrupar estas incrustaciones en C grupos. 2. Dado que el Q∗ óptimo no es único (debido a la existencia de una matriz R arbitraria), podemos buscar un R óptimo que rote Q∗ a una matriz de indicación4. El algoritmo detallado se puede consultar en [26]. El procedimiento detallado del algoritmo para CLGR se resume en la tabla 1. 3. EXPERIMENTOS En esta sección, se realizan experimentos para comparar empíricamente los resultados de agrupamiento de CLGR con otros 8 algoritmos representativos de agrupamiento de documentos en 5 conjuntos de datos. Primero presentaremos la información básica de esos conjuntos de datos. 3.1 Conjuntos de datos Utilizamos una variedad de conjuntos de datos, la mayoría de los cuales son frecuentemente utilizados en la investigación de recuperación de información. La Tabla 2 resume las características de los conjuntos de datos. Aquí, una matriz de indicación T es una matriz n×c con su entrada (i, j) Tij ∈ {0, 1} de modo que para cada fila de Q∗ solo hay un 1. Entonces, el xi puede ser asignado al j-ésimo grupo tal que j = argjQ∗ ij = 1. Tabla 1: Agrupamiento con Regularización Local y Global (CLGR) Entrada: 1. Conjunto de datos X = {xi}n i=1; 2. Número de grupos C: 3. Tamaño del vecindario K: 4. Parámetros locales de regularización {λi}n i=1; 5. Parámetro de regularización global λ; Salida: La membresía del clúster de cada punto de datos. Procedimiento: 1. Construir los K vecindarios más cercanos para cada punto de datos; 2. Construya la matriz P utilizando la Ecuación (12); 3. Construya la matriz Laplaciana L utilizando la ecuación (16); 4. Construye la matriz M = (P − I)T (P − I) + λL; 5. Realice la descomposición de valores propios en M y construya la matriz Q∗ de acuerdo con la Ecuación (28); 6. Generar las asignaciones de clúster de cada punto de datos al discretizar adecuadamente Q∗. Tabla 2: Descripciones de los conjuntos de datos de documentos Conjuntos de datos Número de documentos Número de clases CSTR 476 4 WebKB4 4199 4 Reuters 2900 10 WebACE 2340 20 Newsgroup4 3970 4 CSTR. Este es el conjunto de datos de los resúmenes de informes técnicos publicados en el Departamento de Ciencias de la Computación de una universidad. El conjunto de datos contenía 476 resúmenes, los cuales fueron divididos en cuatro áreas de investigación: Procesamiento de Lenguaje Natural (NLP), Robótica/Visión, Sistemas y Teoría. WebKB. El conjunto de datos WebKB contiene páginas web recopiladas de los departamentos de informática de universidades. Hay alrededor de 8280 documentos y están divididos en 7 categorías: estudiante, facultad, personal, curso, proyecto, departamento y otros. El texto sin procesar es de aproximadamente 27MB. Entre estas 7 categorías, estudiante, facultad, curso y proyecto son las cuatro categorías que representan entidades más pobladas. El subconjunto asociado suele ser llamado WebKB4. Reuters. La colección de pruebas de categorización de texto Reuters-21578 contiene documentos recopilados de la agencia de noticias Reuters en 1987. Es un punto de referencia estándar para la categorización de texto y contiene 135 categorías. En nuestros experimentos, utilizamos un subconjunto de la colección de datos que incluye las 10 categorías más frecuentes entre los 135 temas y lo llamamos Reuters-top 10. WebACE. El conjunto de datos WebACE proviene del proyecto WebACE y ha sido utilizado para la agrupación de documentos [17][5]. El conjunto de datos WebACE contiene 2340 documentos que consisten en artículos de noticias del servicio de noticias de Reuters a través de la web en octubre de 1997. Estos documentos están divididos en 20 clases. Not enough context provided. El conjunto de datos News4 utilizado en nuestros experimentos se selecciona del famoso conjunto de datos 20-newsgroups. El tema rec que contiene autos, motocicletas, béisbol y hockey fue seleccionado de la versión 20news-18828. El conjunto de datos News4 contiene 3970 vectores de documentos. Para preprocesar los conjuntos de datos, eliminamos las palabras vacías utilizando una lista estándar de palabras vacías, se omiten todas las etiquetas HTML y se ignoran todos los campos de encabezado excepto el asunto y la organización de los artículos publicados. En todos nuestros experimentos, primero seleccionamos las 1000 palabras principales por información mutua con las etiquetas de clase. 3.2 Métricas de Evaluación En los experimentos, establecemos el número de clústeres igual al número real de clases C para todos los algoritmos de agrupamiento. Para evaluar su rendimiento, comparamos los grupos generados por estos algoritmos con las clases reales mediante el cálculo de las siguientes dos medidas de rendimiento. Precisión de agrupamiento (Acc). La primera medida de rendimiento es la Precisión de Agrupamiento, que descubre la relación uno a uno entre los grupos y las clases, y mide en qué medida cada grupo contenía puntos de datos de la clase correspondiente. Resume todo el grado de coincidencia entre todos los pares de clases y clusters. La precisión del agrupamiento se puede calcular como: Acc = 1 N max   Ck,Lm T(Ck, Lm)   , (29) donde Ck denota el k-ésimo clúster en los resultados finales, y Lm es la verdadera clase m-ésima. T(Ck, Lm) es el número de entidades que pertenecen a la clase m y están asignadas al clúster k. La precisión calcula la suma máxima de T(Ck, Lm) para todos los pares de clústeres y clases, y estos pares no tienen superposiciones. La mayor precisión de agrupamiento significa un mejor rendimiento de agrupamiento. Información Mutua Normalizada (NMI). Otro métrica de evaluación que adoptamos aquí es la Información Mutua Normalizada (NMI) [23], la cual es ampliamente utilizada para determinar la calidad de los grupos. Para dos variables aleatorias X e Y, el NMI se define como: NMI(X, Y) = I(X, Y) H(X)H(Y), donde I(X, Y) es la información mutua entre X e Y, mientras que H(X) y H(Y) son las entropías de X e Y respectivamente. Se puede ver que NMI(X, X) = 1, que es el valor máximo posible de NMI. Dado un resultado de agrupamiento, el NMI en la ecuación (30) se estima como NMI = C k=1 C m=1 nk,mlog n·nk,m nk ˆnm C k=1 nklog nk n C m=1 ˆnmlog ˆnm n, (31), donde nk denota el número de datos contenidos en el grupo Ck (1 k C), ˆnm es el número de datos pertenecientes a la clase m-ésima (1 m C), y nk,m denota el número de datos que están en la intersección entre el grupo Ck y la clase m-ésima. El valor calculado en la Ecuación (31) se utiliza como medida de rendimiento para el resultado de agrupamiento dado. A mayor valor, mejor rendimiento de agrupamiento. 3.3 Comparaciones Hemos realizado evaluaciones de rendimiento exhaustivas probando nuestro método y comparándolo con otros 8 métodos representativos de agrupamiento de datos utilizando las mismas corpora de datos. Los algoritmos que evaluamos se enumeran a continuación. 1. K-means tradicional (KM). 2. K-medias esférico (SKM). La implementación se basa en [9]. 3. Modelo de Mezcla Gaussiana (GMM). La implementación se basa en [16]. 4. Agrupamiento espectral con cortes normalizados (Ncut). La implementación se basa en [26], y la varianza de la similitud gaussiana se determina mediante Escalado Local [30]. Ten en cuenta que el criterio que Ncut busca minimizar es simplemente el regularizador global en nuestro algoritmo CLGR, excepto que Ncut utiliza el Laplaciano normalizado. 5. Agrupamiento utilizando Regularización Local Pura (CPLR). En este método simplemente minimizamos Jl (definido en la Ecuación (24)), y los resultados de agrupamiento pueden obtenerse realizando la descomposición de valores propios en la matriz (I − P)T (I − P) con algunos métodos de discretización adecuados. 6. Iteración de subespacio adaptativa (ASI). La implementación se basa en [14]. 7. Factorización de matrices no negativas (NMF). La implementación se basa en [27]. 8. Factorización Tri-Factorización de Matrices No Negativas (TNMF) [12]. La implementación se basa en [15]. Para la eficiencia computacional, en la implementación de CPLR y nuestro algoritmo CLGR, hemos establecido todos los parámetros de regularización local {λi}n i=1 para ser idénticos, los cuales se establecen mediante búsqueda en cuadrícula de {0.1, 1, 10}. El tamaño de los vecindarios k más cercanos se establece mediante una búsqueda en cuadrícula de {20, 40, 80}. Para el método CLGR, su parámetro de regularización global se establece mediante una búsqueda en cuadrícula de {0.1, 1, 10}. Al construir el regularizador global, hemos adoptado el método de escalamiento local [30] para construir la matriz Laplaciana. El método de discretización final adoptado en estos dos métodos es el mismo que en [26], ya que nuestros experimentos muestran que el uso de dicho método puede lograr mejores resultados que el uso de métodos basados en kmeans como en [20]. 3.4 Resultados Experimentales Los resultados de comparación de precisión de agrupamiento se muestran en la tabla 3, y los resultados de comparación de información mutua normalizada se resumen en la tabla 4. De las dos tablas principalmente observamos que: 1. Nuestro método CLGR supera a todos los demás métodos de agrupamiento de documentos en la mayoría de los conjuntos de datos. Para la agrupación de documentos, el método Spherical k-means suele superar al método tradicional de agrupación k-means, y el método GMM puede lograr resultados competitivos en comparación con el método Spherical k-means; 3. Los resultados obtenidos de los algoritmos tipo k-means y GMM suelen ser peores que los resultados obtenidos de Clustering Espectral. Dado que el Agrupamiento Espectral puede ser visto como una versión ponderada del kernel k-means, puede obtener buenos resultados cuando los clusters de datos tienen formas arbitrarias. Esto corrobora que los vectores de los documentos no están distribuidos regularmente (esféricos o elípticos). 4. Las comparaciones experimentales verifican empíricamente la equivalencia entre NMF y Clustering Espectral, como se muestra en la Tabla 3: Precisión de agrupamiento de los diversos métodos CSTR WebKB4 Reuters WebACE News4 KM 0.4256 0.3888 0.4448 0.4001 0.3527 SKM 0.4690 0.4318 0.5025 0.4458 0.3912 GMM 0.4487 0.4271 0.4897 0.4521 0.3844 NMF 0.5713 0.4418 0.4947 0.4761 0.4213 Ncut 0.5435 0.4521 0.4896 0.4513 0.4189 ASI 0.5621 0.4752 0.5235 0.4823 0.4335 TNMF 0.6040 0.4832 0.5541 0.5102 0.4613 CPLR 0.5974 0.5020 0.4832 0.5213 0.4890 CLGR 0.6235 0.5228 0.5341 0.5376 0.5102 Tabla 4: Resultados de información mutua normalizada de los diversos métodos CSTR WebKB4 Reuters WebACE News4 KM 0.3675 0.3023 0.4012 0.3864 0.3318 SKM 0.4027 0.4155 0.4587 0.4003 0.4085 GMM 0.4034 0.4093 0.4356 0.4209 0.3994 NMF 0.5235 0.4517 0.4402 0.4359 0.4130 Ncut 0.4833 0.4497 0.4392 0.4289 0.4231 ASI 0.5008 0.4833 0.4769 0.4817 0.4503 TNMF 0.5724 0.5011 0.5132 0.5328 0.4749 CPLR 0.5695 0.5231 0.4402 0.5543 0.4690 CLGR 0.6012 0.5434 0.4935 0.5390 0.4908 ha sido demostrado teóricamente en [10]. Se puede observar en las tablas que NMF y el Agrupamiento Espectral suelen llevar a resultados de agrupamiento similares. 5. Los métodos basados en co-agrupamiento (TNMF y ASI) suelen lograr mejores resultados que los métodos tradicionales basados únicamente en vectores de documentos. Dado que estos métodos realizan una selección implícita de características en cada iteración, proporcionan una métrica adaptativa para medir el vecindario y, por lo tanto, tienden a producir mejores resultados de agrupamiento. 6. Los resultados obtenidos a través de CPLR suelen ser mejores que los resultados obtenidos a través de Agrupamiento Espectral, lo cual respalda la teoría de Vapnik [24] de que a veces los algoritmos de aprendizaje local pueden obtener mejores resultados que los algoritmos de aprendizaje global. Además de los experimentos de comparación mencionados anteriormente, también probamos la sensibilidad de los parámetros de nuestro método. Principalmente hay dos conjuntos de parámetros en nuestro algoritmo CLGR, los parámetros de regularización locales y globales ({λi}n i=1 y λ, como hemos mencionado en la sección 3.3, hemos establecido que todos los λis son idénticos a λ∗ en nuestros experimentos), y el tamaño de los vecindarios. Por lo tanto, también hemos realizado dos series de experimentos: 1. Fijando el tamaño de los vecindarios y probando el rendimiento del agrupamiento con diferentes valores de λ∗ y λ. En este conjunto de experimentos, encontramos que nuestro algoritmo CLGR puede lograr buenos resultados cuando los dos parámetros de regularización no son ni demasiado grandes ni demasiado pequeños. Normalmente nuestro método puede lograr buenos resultados cuando λ∗ y λ están alrededor de 0.1. La Figura 1 nos muestra un ejemplo de prueba en el conjunto de datos WebACE. Fijando los parámetros de regularización local y global, y probando el rendimiento del agrupamiento con diferentes valores de -5, -4.5, -4, -3.5, -3, -5, -4.5, -4, -3.5, -3, 0.35, 0.4, 0.45, 0.5, 0.55 para el parámetro de regularización local (valor logarítmico base 2) y para el parámetro de regularización global (valor logarítmico base 2), se obtuvo una precisión de agrupamiento. Figura 1: Resultados de la prueba de sensibilidad de parámetros en el conjunto de datos WebACE con el tamaño de vecindario fijo en 20, donde el eje x e y representan el valor logarítmico base 2 de λ∗ y λ. En este conjunto de experimentos, encontramos que el vecindario con un tamaño demasiado grande o demasiado pequeño deteriorará todos los resultados finales de agrupamiento. Esto puede entenderse fácilmente ya que cuando el tamaño del vecindario es muy pequeño, los puntos de datos utilizados para entrenar los clasificadores locales pueden no ser suficientes; cuando el tamaño del vecindario es muy grande, los clasificadores entrenados tenderán a ser globales y no podrán capturar las características locales típicas. La Figura 2 nos muestra un ejemplo de prueba en el conjunto de datos WebACE. Por lo tanto, podemos ver que nuestro algoritmo CLGR (1) puede lograr resultados satisfactorios y (2) no es muy sensible a la elección de parámetros, lo que lo hace práctico en aplicaciones del mundo real. CONCLUSIONES Y TRABAJOS FUTUROS En este artículo, desarrollamos un nuevo algoritmo de agrupamiento llamado agrupamiento con regularización local y global. Nuestro método conserva el mérito de los algoritmos de aprendizaje local y el agrupamiento espectral. Nuestros experimentos muestran que el algoritmo propuesto supera a la mayoría de los algoritmos de vanguardia en muchos conjuntos de datos de referencia. En el futuro, nos enfocaremos en la selección de parámetros y los problemas de aceleración del algoritmo CLGR. REFERENCIAS [1] L. Baker y A. McCallum. Agrupamiento distribucional de palabras para clasificación de texto. En Actas de la Conferencia Internacional ACM SIGIR sobre Investigación y Desarrollo en Recuperación de Información, 1998. [2] M. Belkin y P. Niyogi. Mapeo de Eigen de Laplaciano para Reducción de Dimensionalidad y Representación de Datos. Computación Neural, 15 (6):1373-1396. Junio de 2003. [3] M. Belkin y P. Niyogi. Hacia una Fundación Teórica para Métodos de Manifold Basados en Laplacianos. En Actas de la 18ª Conferencia sobre Teoría del Aprendizaje (COLT). 2005. 10 20 30 40 50 60 70 80 90 100 0.35 0.4 0.45 0.5 0.55 tamaño de la precisión de agrupamiento del vecindario Figura 2: Resultados de pruebas de sensibilidad de parámetros en el conjunto de datos WebACE con los parámetros de regularización fijados en 0.1, y el tamaño del vecindario variando de 10 a 100. [4] M. Belkin, P. Niyogi y V. Sindhwani. Regularización de variedades: un marco geométrico para el aprendizaje a partir de ejemplos. Revista de Investigación en Aprendizaje Automático 7, 1-48, 2006. [5] D. Boley. División Direccional Principal. Minería de datos y descubrimiento de conocimiento, 2:325-344, 1998. [6] L. Bottou y V. Vapnik. Algoritmos de aprendizaje local. Computación Neural, 4:888-900, 1992. [7] P. K. Chan, D. F. Schlag y J. Y. Zien. Particionamiento y agrupamiento K-way de corte de razón espectral. IEEE Trans. Diseño Asistido por Computadora, 13:1088-1096, Sep. 1994. [8] D. R. Cutting, D. R. Karger, J. O. Pederson y J. W. Tukey. Dispersión/Recolección: Un enfoque basado en clústeres para explorar grandes colecciones de documentos. En Actas de la Conferencia Internacional ACM SIGIR sobre Investigación y Desarrollo en Recuperación de Información, 1992. [9] I. S. Dhillon y D. S. Modha. Descomposiciones de conceptos para datos de texto grandes y dispersos utilizando agrupamiento. Aprendizaje automático, vol. 42(1), páginas 143-175, enero de 2001. [10] C. Ding, X. Él, y H. Simon. Sobre la equivalencia entre la factorización de matrices no negativas y el agrupamiento espectral. En Actas de la Conferencia de Minería de Datos de SIAM, 2005. [11] C. Ding, X. Él, H. Zha, M. Gu y H. D. Simon. Un algoritmo de corte min-max para particionar grafos y agrupar datos. En Proc. de la 1ra Conferencia Internacional sobre Minería de Datos (ICDM), páginas 107-114, 2001. [12] C. Ding, T. Li, W. Peng y H. Park. Tri-factorizaciones de matrices no negativas ortogonales para agrupamiento. En Actas de la Duodécima Conferencia Internacional de la ACM SIGKDD sobre Descubrimiento de Conocimiento y Minería de Datos, 2006. [13] R. O. Duda, P. E. Hart y D. G. Stork. Clasificación de patrones. John Wiley & Sons, Inc., 2001. [14] T. Li, S. Ma y M. Ogihara. Agrupamiento de documentos a través de la Iteración de Subespacios Adaptativos. En Actas de la Conferencia Internacional ACM SIGIR sobre Investigación y Desarrollo en Recuperación de Información, 2004. [15] T. Li y C. Ding. Las relaciones entre varios métodos de factorización de matrices no negativas para agrupamiento. En Actas de la 6ta Conferencia Internacional sobre Minería de Datos (ICDM). 2006. [16] X. Liu y Y. Gong. Agrupación de documentos con capacidades de refinamiento de clústeres y selección de modelos. En Proc. de la Conferencia Internacional ACM SIGIR sobre Investigación y Desarrollo en Recuperación de Información, 2002. [17] E. Han, D. Boley, M. Gini, R. Gross, K. Hastings, G. Karypis, V. Kumar, B. Mobasher y J. Moore. WebACE: Un agente web para la categorización y exploración de documentos. En Actas de la 2ª Conferencia Internacional sobre Agentes Autónomos (Agents98). ACM Press, 1998. [18] M. Hein, J. Y. Audibert y U. von Luxburg. De Gráficas a Variedades - Consistencia Puntual Débil y Fuerte de los Laplacianos de Gráficas. En Actas de la 18ª Conferencia sobre Teoría del Aprendizaje (COLT), 470-485. 2005. [19] J. Él, M. Lan, C.-L. Tan, S.-Y. Sung, y H.-B. Bajo. Inicialización de algoritmos de refinamiento de clústeres: una revisión y estudio comparativo. En Proc. de Inter. Conferencia Conjunta sobre Redes Neuronales, 2004. [20] A. Y. Ng, M. I. Jordan, Y. Weiss. En el agrupamiento espectral: análisis y un algoritmo. En Avances en Sistemas de Procesamiento de Información Neural 14. 2002. [21] B. Sch¨olkopf y A. Smola. Aprendizaje con Kernels. El MIT Press. Cambridge, Massachusetts. 2002. [22] J. Shi y J. Malik. Cortes normalizados y segmentación de imágenes. IEEE Trans. on Pattern Analysis and Machine Intelligence, 22(8):888-905, 2000. [23] A. Strehl and J. Ghosh.
IEEE Trans. on Pattern Analysis and Machine Intelligence, 22(8):888-905, 2000. [23] A. Strehl y J. Ghosh. Conjuntos de agrupamientos: un marco de reutilización de conocimiento para combinar múltiples particiones. Revista de Investigación de Aprendizaje Automático, 3:583-617, 2002. [24] V. N. Vapnik. La naturaleza de la teoría del aprendizaje estadístico. Berlín: Springer-Verlag, 1995. [25] Wu, M. y Schölkopf, B. Un enfoque de aprendizaje local para el agrupamiento. En Avances en Sistemas de Procesamiento de Información Neural 18. 2006. [26] S. X. Yu, J. Shi. Agrupamiento espectral multiclase. En Actas de la Conferencia Internacional sobre Visión por Computadora, 2003. [27] W. Xu, X. Liu y Y. Gong. Agrupación de documentos basada en la factorización de matrices no negativas. En Actas de la Conferencia Internacional ACM SIGIR sobre Investigación y Desarrollo en Recuperación de Información, 2003. [28] H. Zha, X. Él, C. Ding, M. Gu y H. Simon. Relajación espectral para el agrupamiento K-means. En NIPS 14. 2001. [29] T. Zhang y F. J. Oles. Categorización de texto basada en métodos de clasificación lineal regularizados. Revista de Recuperación de Información, 4:5-31, 2001. [30] L. Zelnik-Manor y P. Perona. Agrupamiento espectral autoajustable. En NIPS 17. 2005. [31] D. Zhou, O. Bousquet, T. N. Lal, J. Weston y B. Schölkopf. Aprendizaje con Consistencia Local y Global. NIPS 17, 2005. 

NIPS 17, 2005.