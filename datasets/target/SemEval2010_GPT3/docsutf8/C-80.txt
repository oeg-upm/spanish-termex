Conservación de la consistencia en el almacenamiento en caché de contenido dinámico de bases de datos∗ Niraj Tolia y M. Satyanarayanan Universidad Carnegie Mellon {ntolia,satya}@cs.cmu.edu RESUMEN Con el creciente uso de contenido web dinámico generado a partir de bases de datos relacionales, las soluciones de almacenamiento en caché tradicionales para mejorar el rendimiento y la latencia son ineficaces. Describimos una capa de middleware llamada Ganesh que reduce el volumen de datos transmitidos sin interpretación semántica de consultas o resultados. Se logra esta reducción mediante el uso de hash criptográficos para detectar similitudes con resultados anteriores. Estos beneficios no requieren ningún compromiso con la semántica de consistencia estricta proporcionada por la base de datos del servidor. Además, Ganesh no requiere modificaciones en aplicaciones, servidores web o servidores de bases de datos, y funciona con aplicaciones y bases de datos de código cerrado. Usando dos puntos de referencia representativos de sitios web dinámicos, las mediciones de nuestro prototipo muestran que puede aumentar el rendimiento de extremo a extremo hasta en un factor de dos para aplicaciones no intensivas en datos y hasta en un factor de diez para las intensivas en datos. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.2.4 [Gestión de Bases de Datos]: Términos Generales de Sistemas de Diseño, Rendimiento 1. INTRODUCCIÓN Una fracción creciente del contenido web se genera dinámicamente a partir de bases de datos relacionales en el backend. Incluso cuando el contenido de la base de datos permanece sin cambios, la localidad temporal de acceso no puede ser explotada porque el contenido dinámico no es almacenable en caché por los navegadores web o por servidores de almacenamiento en caché intermedios como los espejos de Akamai. En una arquitectura multinivel, cada solicitud web puede tensionar el enlace WAN entre el servidor web y la base de datos. Esto provoca que la experiencia del usuario sea altamente variable porque no hay almacenamiento en caché para aislar al cliente de cargas repentinas. Los intentos previos de almacenar en caché contenido dinámico de bases de datos generalmente han debilitado la semántica transaccional [3, 4] o han requerido modificaciones en la aplicación [15, 34]. Informamos sobre una nueva solución que toma la forma de una capa intermedia de middleware independiente de la base de datos llamada Ganesh. Ganesh no hace ningún esfuerzo por interpretar semánticamente el contenido de las consultas o sus resultados. En cambio, se basa exclusivamente en el hash criptográfico para detectar similitudes con resultados anteriores. La detección de similitud basada en hash ha sido cada vez más utilizada en sistemas de archivos distribuidos [26, 36, 37] para mejorar el rendimiento en redes de baja capacidad de ancho de banda. Sin embargo, estas técnicas no se han utilizado para bases de datos relacionales. A diferencia de enfoques anteriores que utilizan métodos genéricos para detectar similitud, Ganesh explota la estructura de los resultados de la base de datos relacional para lograr una mejora superior en el rendimiento. Uno se enfrenta al menos a tres desafíos al aplicar la detección de similitud basada en hash a las bases de datos de back-end. Primero, el trabajo previo en este ámbito ha considerado tradicionalmente el contenido de almacenamiento como bolsas de bits no interpretadas y sin estructura interna. Esto permite que las técnicas basadas en hash operen en largas y contiguas secuencias de datos para lograr la máxima efectividad. Por el contrario, las bases de datos relacionales tienen una estructura interna compleja que puede no ser tan propicia para la detección de similitudes basada en hash. Segundo, las bases de datos relacionales tienen restricciones de integridad y consistencia muy estrictas que no deben comprometerse por el uso de técnicas basadas en hash. Tercero, el código fuente de las bases de datos comerciales generalmente no está disponible. Esto contrasta con trabajos anteriores que presumían la disponibilidad del código fuente. Nuestros experimentos muestran que Ganesh, aunque conceptualmente simple, puede mejorar significativamente el rendimiento en anchos de banda representativos del Internet comercial actual. En los modelos de referencia de aplicaciones web multinivel, la mejora en el rendimiento fue de hasta diez veces para cargas de trabajo intensivas en datos. Para cargas de trabajo que no eran intensivas en datos, se observaron mejoras en el rendimiento de hasta el doble. Incluso cuando el ancho de banda no era una limitación, Ganesh tenía un bajo sobrecosto y no afectaba el rendimiento. Nuestros experimentos también confirman que aprovechar la estructura presente en los resultados de la base de datos es crucial para esta mejora en el rendimiento. Antecedentes 2.1 Generación de Contenido Dinámico A medida que la World Wide Web ha crecido, muchos sitios web han descentralizado sus datos y funcionalidades al llevarlos a los extremos de Internet. Hoy en día, los sistemas de comercio electrónico a menudo utilizan una arquitectura de tres niveles que consta de un servidor web de front-end, un servidor de aplicaciones y un servidor de base de datos de back-end. La Figura 1 ilustra esta arquitectura. Los dos primeros niveles se pueden replicar cerca de una concentración de clientes en el borde de Internet. Esto mejora la experiencia del usuario al reducir la latencia de extremo a extremo y disminuir la exposición al congestionamiento del tráfico de la columna vertebral. También puede aumentar la disponibilidad y escalabilidad de los servicios web. El contenido que se genera dinámicamente desde la base de datos del servidor no puede ser almacenado en caché en los dos primeros niveles. Si bien las bases de datos pueden replicarse fácilmente en una LAN, esto es inviable en una WAN debido a la difícil tarea de proporcionar simultáneamente una consistencia sólida, disponibilidad y tolerancia a particiones de red [7]. Como resultado, las bases de datos tienden a ser centralizadas para cumplir con los fuertes requisitos de consistencia de muchas aplicaciones de comercio electrónico como la banca, las finanzas y la venta al por menor en línea [38]. Por lo tanto, la base de datos del back-end suele estar ubicada lejos de muchos conjuntos de nodos de primer y segundo nivel [2]. En ausencia de almacenamiento en caché y replicación, el ancho de banda de la WAN puede convertirse fácilmente en un factor limitante en el rendimiento y la escalabilidad de aplicaciones intensivas en datos. El enfoque de Ganesh en los sistemas basados en hash es la transmisión eficiente de resultados al descubrir similitudes con los resultados de consultas anteriores. Dado que las consultas SQL pueden generar resultados grandes, las técnicas basadas en hash se prestan bien al problema de transferir eficientemente estos grandes resultados a través de enlaces con ancho de banda limitado. El uso de técnicas basadas en hash para reducir el volumen de datos transmitidos ha surgido como un tema común en muchos sistemas de almacenamiento recientes, como se discute en la Sección 8.2. Estas técnicas se basan en algunas suposiciones básicas. Se asume que las funciones hash criptográficas son resistentes a colisiones. En otras palabras, es computacionalmente intratable encontrar dos entradas que se hash a la misma salida. Las funciones también se asumen como unidireccionales; es decir, encontrar una entrada que resulte en una salida específica es computacionalmente inviable. Menezes et al. [23] proporcionan más detalles sobre estas suposiciones. Las suposiciones anteriores permiten a los sistemas basados en hash asumir que no se producen colisiones. Por lo tanto, pueden tratar el hash de un elemento de datos como su identificador único. Una colección de elementos de datos se convierte efectivamente en direccionable por contenido, permitiendo que un hash pequeño funcione como una palabra de código para un elemento de datos mucho más grande en almacenamiento permanente o transmisión en red. La suposición de que las colisiones son tan raras que prácticamente no existen ha sido cuestionada recientemente [17]. Sin embargo, como explicó Black [5], creemos que estos problemas no son una preocupación para Ganesh. Toda comunicación es entre partes confiables del sistema y un adversario no tiene forma de obligar a Ganesh a aceptar datos inválidos. Además, Ganesh no depende críticamente de ninguna función hash específica. Si bien actualmente usamos SHA-1, reemplazarlo con una función hash diferente sería sencillo. No habría impacto en el rendimiento con funciones hash más fuertes (por ejemplo, SHA256) solo añade unos pocos bytes adicionales y los hashes generados siguen siendo órdenes de magnitud más pequeños que los elementos de datos que representan. No es necesario volver a almacenar permanentemente ya que Ganesh solo utiliza el hash en datos volátiles. 3. DISEÑO E IMPLEMENTACIÓN Ganesh explota la redundancia en el flujo de resultados para evitar transmitir fragmentos de resultados que ya están presentes en el sitio de la consulta. La redundancia puede surgir de forma natural de muchas maneras diferentes. Por ejemplo, una consulta repetida después de un cierto intervalo puede devolver un resultado diferente debido a actualizaciones en la base de datos; sin embargo, puede haber una significativa similitud entre los dos resultados. Como otro ejemplo, un usuario que está refinando una búsqueda puede generar una secuencia de consultas con resultados superpuestos. Cuando Ganesh detecta redundancia, suprime la transmisión de los fragmentos de resultado correspondientes. En cambio, transmite un resumen mucho más pequeño de esos fragmentos y permite que el sitio de consulta reconstruya el resultado a través de la búsqueda de hash en una caché de resultados anteriores. De hecho, Ganesh utiliza la computación en los bordes para reducir la comunicación por Internet. Nuestra descripción de Ganesh se centra en cuatro aspectos. Primero explicamos nuestro enfoque para detectar similitud en los resultados de la consulta. A continuación, discutimos cómo la arquitectura Ganesh es completamente invisible para todos los componentes de un sistema de múltiples niveles. Luego describimos el enfoque basado en proxy de Ganesh y el flujo de datos para detectar similitudes. 3.1 Detectar similitud Una de las decisiones clave de diseño en Ganesh es cómo se detecta la similitud. Hay muchas formas potenciales de descomponer un resultado en fragmentos.  I the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the the thees I,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, Encontrar esta descomposición óptima es un problema difícil debido al amplio espacio de posibilidades y porque la elección óptima depende de muchos factores, como el contenido del resultado de las consultas, el historial de resultados recientes y el algoritmo de gestión de caché. Cuando un objeto es opaco, el uso de huellas digitales de Rabin [8, 30] para detectar datos comunes entre dos objetos ha sido demostrado con éxito en el pasado por sistemas como LBFS [26] y CASPER [37]. El fingerprinting de Rabin utiliza una ventana deslizante sobre los datos para calcular un hash rodante. Suponiendo que la función hash está distribuida uniformemente, un límite de fragmento se define cuando los bits de orden inferior del valor hash son iguales a algún valor predeterminado. El número de bits de orden inferior utilizados define el tamaño promedio del fragmento. Estos fragmentos subdivididos del objeto se convierten en la unidad de comparación para detectar similitudes entre diferentes objetos. Dado que las ubicaciones de los límites encontrados mediante el uso de las huellas de Rabin están determinadas de manera estocástica, generalmente no logran alinearse con ninguna propiedad estructural de los datos subyacentes. Por lo tanto, el algoritmo maneja bien las actualizaciones en su lugar, inserciones y eliminaciones. Sin embargo, tiene un rendimiento deficiente en presencia de cualquier reordenamiento de datos. La Figura 2 muestra un ejemplo donde dos resultados, A y B, que constan de tres filas, tienen los mismos datos pero diferentes atributos de ordenamiento. En el caso extremo, la huella digital de Rabin podría no ser capaz de encontrar datos similares debido a la forma en que detecta los límites de los fragmentos. Afortunadamente, Ganesh puede utilizar conocimientos específicos del dominio para una detección de límites más precisa. La información que explotamos es que el resultado de una consulta refleja la estructura de una base de datos relacional donde todos los datos están organizados en tablas y filas. Por lo tanto, es sencillo verificar la similitud con resultados anteriores en dos niveles de granularidad: primero el resultado completo y luego las filas individuales. El final de una fila en un resultado sirve como un límite natural de fragmento. Es importante tener en cuenta que el uso de la estructura tabular en los resultados solo implica una interpretación superficial de los datos. Ganesh no realiza ninguna interpretación semántica más profunda, como comprender tipos de datos, esquemas de resultados o restricciones de integridad. Ajustar la huella digital de Rabin para una carga de trabajo también puede ser difícil. Si el tamaño promedio de los fragmentos es demasiado grande, los fragmentos pueden abarcar varias filas de resultados. Sin embargo, seleccionar un tamaño de fragmento promedio más pequeño aumenta la cantidad de metadatos necesarios para describir los resultados. Esto, a su vez, disminuiría los ahorros obtenidos mediante su uso. El fingerprinting de Rabin también requiere dos pasadas computacionalmente costosas sobre los datos: una vez para determinar los límites de los fragmentos y otra vez para generar hashes criptográficos para los fragmentos. Ganesh solo necesita un único pase para la generación de hash, ya que los límites de los fragmentos son proporcionados por la estructura natural de los datos. La comparación de rendimiento en la Sección 6 muestra que el algoritmo basado en filas de Ganesh supera al fingerprinting de Rabin. Dado que trabajos anteriores ya han demostrado que la huella digital de Rabin funciona mejor que gzip [26], no comparamos a Ganesh con algoritmos de compresión en este artículo. 3.2 Transparencia El factor clave que influyó en nuestro diseño fue la necesidad de que Ganesh fuera completamente transparente para todos los componentes de un sistema típico de comercio electrónico: servidores web, servidores de aplicaciones y servidores de bases de datos. Sin esto, Ganesh tiene pocas posibilidades de tener un impacto significativo en el mundo real. Requerir modificaciones en cualquiera de los componentes mencionados aumentaría la barrera de entrada de Ganesh en un sistema existente, y por lo tanto reduciría sus posibilidades de adopción. Preservar la transparencia se simplifica por el hecho de que Ganesh es simplemente una mejora de rendimiento, no una mejora de funcionalidad o usabilidad. Elegimos la interposición de agentes como enfoque arquitectónico para lograr nuestro objetivo. Este enfoque se basa en la existencia de una interfaz de programación compacta que ya es ampliamente utilizada por el software objetivo. También se basa en un mecanismo para agregar fácilmente nuevo código sin interrumpir la estructura de módulos existente. Estas condiciones se cumplen fácilmente en nuestro contexto debido a la popularidad de Java como el lenguaje de programación para sistemas de comercio electrónico. La API de Conectividad de Base de Datos de Java (JDBC) [32] permite a las aplicaciones de Java acceder a una amplia variedad de bases de datos e incluso a otros repositorios de datos tabulares como archivos planos. El acceso a estas fuentes de datos es proporcionado por controladores JDBC que traducen entre la API JDBC y el mecanismo de comunicación de la base de datos. La figura 3(a) muestra cómo se utiliza típicamente JDBC en una aplicación. Dado que la interfaz JDBC está estandarizada, se puede sustituir un controlador JDBC por otro sin necesidad de de modificar la aplicación. El controlador JDBC se convierte así en el módulo natural para aprovechar la interposición de código. Como se muestra en la Figura 3(b), el controlador JDBC nativo es reemplazado por un controlador JDBC Ganesh que presenta la misma interfaz estandarizada. El controlador Ganesh mantiene una caché en memoria de fragmentos de resultados de consultas anteriores y realiza el reensamblaje de resultados. En la base de datos, agregamos un nuevo proceso llamado el proxy Ganesh. Este proxy, que puede ser compartido por múltiples nodos front-end, consta de dos partes: código para detectar similitud en fragmentos de resultados y el controlador JDBC nativo original que se comunica con la base de datos. El uso de un proxy en la base de datos hace que Ganesh sea independiente de la base de datos y simplifica la creación de prototipos y experimentación. Ganesh es capaz de trabajar con una amplia gama de bases de datos y aplicaciones, sin necesidad de realizar modificaciones en ninguna de ellas. 3.3 Caché basada en proxy El controlador JDBC nativo mostrado en la Figura 3(a) es un componente de código ligero suministrado por el proveedor de la base de datos. Su función principal es mediar la comunicación entre la aplicación y la base de datos remota. Reenvía consultas, almacena resultados completos y responde a solicitudes de la aplicación para ver partes de los resultados. El controlador JDBC de Ganesh mostrado en la Figura 3(b) presenta a la aplicación una interfaz idéntica a la proporcionada por el controlador nativo. Proporciona la capacidad de reconstruir resultados a partir de descripciones compactas basadas en hash enviadas por el proxy. Para realizar esta reconstrucción, el controlador mantiene una caché en memoria de los resultados recibidos recientemente. Esta caché solo se utiliza como fuente de fragmentos de resultados en la reconstrucción de resultados. El conductor Ganesh o el proxy no intentan rastrear las actualizaciones de la base de datos. La falta de consistencia en la caché no afecta a la corrección, ya que la descripción de los resultados siempre se obtiene del proxy; en el peor de los casos, no habrá beneficio de rendimiento al usar Ganesh. Los datos obsoletos simplemente se eliminarán de la caché con el tiempo. El proxy de Ganesh accede a la base de datos a través del controlador JDBC nativo, que permanece sin cambios entre las Figuras 3(a) y (b). La base de datos está completamente ajena a la existencia del proxy. El proxy no examina ninguna consulta recibida del controlador Ganesh, sino que las pasa al controlador nativo. En cambio, el proxy es responsable de inspeccionar la salida de la base de datos recibida del controlador nativo, detectar resultados similares y generar codificaciones basadas en hash de estos resultados siempre que se encuentre suficiente similitud. Si bien esta arquitectura no disminuye la carga en una base de datos, como se mencionó anteriormente en la Sección 2.1, es mucho más fácil replicar bases de datos para escalabilidad en una LAN que en una WAN. Para generar una codificación basada en hash, el proxy debe estar al tanto de qué fragmentos de resultados están disponibles en la caché de controladores de Ganesh. Un enfoque es ser optimista y asumir que todos los fragmentos de resultados están disponibles. Esto resultará en la transmisión inicial más pequeña posible de un resultado. Sin embargo, en casos donde hay poca superposición con resultados anteriores, el controlador Ganesh tendrá que realizar muchas llamadas al proxy durante la reconstrucción para recuperar fragmentos de resultados faltantes. Para evitar esta situación, el proxy sigue de manera flexible el estado de la caché de controladores de Ganesh. Dado que ambos componentes están bajo nuestro control, es relativamente sencillo hacer esto sin recurrir a técnicas de caja gris o comunicación explícita para mantener la coherencia de la caché. En cambio, el proxy simula el algoritmo de gestión de caché de controladores de Ganesh y lo utiliza para mantener una lista de hashes para los cuales es probable que el controlador de Ganesh posea los fragmentos de resultado. En caso de desviación de seguimiento, no habrá pérdida de corrección, pero habrá retrasos adicionales en el viaje de ida y vuelta para recuperar los fragmentos faltantes. Si el cliente detecta la pérdida de sincronización con el proxy, puede pedirle al proxy que restablezca el estado compartido entre ellos. También hay que tener en cuenta que el proxy no necesita guardar los fragmentos de resultado en sí, solo sus hashes. Esto permite que el proxy siga siendo escalable incluso cuando es compartido por muchos nodos front-end. El proxy Ganesh recibe la salida de la base de datos como objetos Java del controlador JDBC nativo. Examina esta salida para ver si está presente un objeto Java del tipo ResultSet. La interfaz JDBC utiliza este tipo de dato para almacenar los resultados de las consultas a la base de datos. Si se encuentra un objeto ResultSet, se reduce como se discute a continuación. Todos los demás objetos de Java se pasan sin modificar. Como se discute en la Sección 3.1, el proxy utiliza los límites de fila definidos en el ResultSet para dividirlo en fragmentos que consisten en filas de resultado individuales. Todos los objetos ResultSet se convierten en objetos de un nuevo tipo llamado RecipeResultSet. Utilizamos el término receta para esta descripción compacta de un resultado de base de datos debido a su similitud con una receta de archivo en el sistema de archivos CASPER [37]. La conversión reemplaza cada fragmento de resultado que probablemente esté presente en la caché de controladores de Ganesh por un hash SHA-1 de ese fragmento. Los fragmentos de resultados previamente no vistos se conservan textualmente. El proxy también retiene los hashes de los nuevos fragmentos de resultados, ya que estarán presentes en la caché de los controladores en el futuro. Ten en cuenta que el proxy solo almacena en caché los hashes de los fragmentos de resultados y no almacena en caché las recetas. El proxy construye un RecipeResultSet verificando la similitud en todo el resultado y luego a nivel de fila. Si se predice que todo el resultado estará presente en la caché de los controladores de Ganesh, el RecipeResultSet será simplemente un único hash de todo el resultado. De lo contrario, contiene hashes para aquellas filas que se predice que están presentes en esa caché; todas las demás filas se conservan textualmente. Si el proxy estima un ahorro de espacio general, transmitirá el RecipeResultSet. De lo contrario, se transmite el ResultSet original. Los objetos RecipeResultSet son transformados de vuelta en objetos ResultSet por el controlador Ganesh. La Figura 4 ilustra el manejo de ResultSet en ambos extremos. Cada hash SHA-1 encontrado en un RecipeResultSet se busca en la caché local de fragmentos de resultados. En caso de acierto, el hash es reemplazado por el fragmento correspondiente. En caso de error, el conductor contacta al proxy de Ganesh para recuperar el fragmento. Todos los fragmentos de resultados previamente no vistos que fueron retenidos textualmente por el proxy se hasheado y se han añadido a la caché de resultados. Debería haber muy pocos fallos si el proxy ha seguido con precisión el estado de la caché de controladores de Ganesh. Una optimización futura sería agrupar la obtención de fragmentos faltantes. Esto sería valioso cuando hay muchos pequeños fragmentos faltantes en una WAN de alta latencia. Una vez que la transformación esté completa, el objeto ResultSet completamente reconstruido se pasa a la aplicación. 4. VALIDACIÓN EXPERIMENTAL Tres preguntas surgen de los objetivos y diseño de Ganesh: • Primero, ¿se puede mejorar significativamente el rendimiento al explotar la similitud entre los resultados de la base de datos? Detalles del conjunto de datos de referencia 500,000 usuarios, 12,000 historias BBOARD 2.0 GB 3,298,000 comentarios SUBASTA 1.3 GB 1,000,000 usuarios, 34,000 elementos Tabla 1: Detalles del conjunto de datos de referencia • En segundo lugar, ¿qué tan importante es la detección de similitud estructural de Ganesh en comparación con la detección de similitud de la huella digital de Rabin? • En tercer lugar, ¿es aceptable la sobrecarga del diseño basado en proxy? Nuestra evaluación responde a estas preguntas a través de experimentos controlados con el prototipo Ganesh. Esta sección describe los puntos de referencia utilizados, nuestro procedimiento de evaluación y la configuración experimental. Los resultados de los experimentos se presentan en las Secciones 5, 6 y 7. 4.1 Puntos de referencia Nuestra evaluación se basa en dos puntos de referencia [18] que han sido ampliamente utilizados por otros investigadores para evaluar varios aspectos de arquitecturas multi-tier [27] y de comercio electrónico [9]. El primer punto de referencia, BBOARD, está modelado según Slashdot, un sitio de noticias orientado a la tecnología. El segundo punto de referencia, AUCTION, está modelado según eBay, un sitio de subastas en línea. En ambos puntos de referencia, la mayoría del contenido se genera dinámicamente a partir de la información almacenada en una base de datos. Los detalles de los conjuntos de datos utilizados se pueden encontrar en la Tabla 1. 4.1.1 El Benchmark BBOARD El benchmark BBOARD, también conocido como RUBBoS [18], modela Slashdot, un popular sitio web orientado a la tecnología. Slashdot recopila enlaces a noticias y otros temas de interés encontrados en otros lugares de la web. El sitio también funciona como un tablón de anuncios al permitir a los usuarios comentar en las historias publicadas en forma de conversación en hilos. No es raro que una historia recopile cientos de comentarios en cuestión de horas. El benchmark BBOARD es similar al sitio y modela las actividades de un usuario, incluyendo operaciones de solo lectura como navegar por las historias del día, explorar categorías de historias y ver comentarios, así como operaciones de escritura como registro de nuevos usuarios, agregar y moderar comentarios, y enviar historias. El benchmark consiste en tres fases diferentes: una fase de calentamiento corta, una fase de ejecución que representa el cuerpo principal de la carga de trabajo, y una fase de enfriamiento corta. En este documento solo informamos sobre los resultados de la fase de ejecución. La fase de calentamiento es importante para establecer el estado del sistema dinámico, pero las mediciones de esa fase no son significativas para nuestra evaluación. La fase de enfriamiento es únicamente para permitir que el punto de referencia se apague. Las fases de calentamiento, ejercicio y enfriamiento son de 2, 15 y 2 minutos respectivamente. El número de clientes simulados fue de 400, 800, 1200 y 1600. El punto de referencia está disponible en una versión de Java Servlets y PHP y tiene diferentes conjuntos de datos; evaluamos a Ganesh utilizando la versión de Java Servlets y el conjunto de datos Expandido. El benchmark BBOARD define dos cargas de trabajo diferentes. El primero, la mezcla de Autoría, consiste en un 70% de operaciones de solo lectura y un 30% de operaciones de lectura y escritura. El segundo, la mezcla de navegación, contiene solo operaciones de solo lectura y no actualiza la base de datos. 4.1.2 El Benchmark de SUBASTA El benchmark de SUBASTA, también conocido como RUBiS [18], modela eBay, el sitio de subastas en línea. El sitio web de eBay se utiliza para comprar y vender artículos a través de un formato de subasta. Las principales actividades de un usuario incluyen navegar, vender o pujar por artículos. Modelando las actividades en este sitio, este punto de referencia incluye actividades de solo lectura como navegar por artículos por categoría y por región, así como actividades de lectura-escritura como pujar por artículos, comprar y vender artículos, y dejar comentarios. Al igual que con BBOARD, el benchmark consiste en tres fases diferentes. Las fases de calentamiento, ejecución y enfriamiento para este experimento son de 1.5, 15 y 1 minutos respectivamente. Probamos Ganesh con cuatro configuraciones de clientes donde el número de clientes de prueba se estableció en 400, 800, 1200 y 1600. El punto de referencia está disponible en una versión de Enterprise Java Bean (EJB), Java Servlets y PHP y tiene diferentes conjuntos de datos; evaluamos Ganesh con la versión de Java Servlets y el conjunto de datos Expandido. El benchmark de SUBASTA define dos cargas de trabajo diferentes. El primero, la mezcla de Ofertas, consiste en un 70% de operaciones de solo lectura y un 30% de operaciones de lectura-escritura. El segundo, la mezcla de navegación, contiene solo operaciones de solo lectura y no actualiza la base de datos. 4.2 Procedimiento Experimental Ambos benchmarks involucran una carga de trabajo sintética de clientes accediendo a un servidor web. El número de clientes emulados es un parámetro experimental. Cada cliente emulado ejecuta una instancia del benchmark en su propio hilo, utilizando una matriz para hacer la transición entre diferentes estados del benchmark. La matriz define un modelo estocástico con probabilidades de transición entre los diferentes estados que representan las acciones típicas de los usuarios. Un ejemplo de transición es un usuario iniciando sesión en el sistema de SUBASTA y luego decidiendo si publicar un artículo en venta o pujar en subastas activas. Cada cliente también modela el tiempo de pensamiento del usuario entre las solicitudes. El tiempo de pensamiento se modela como una distribución exponencial con una media de 7 segundos. Evaluamos a Ganesh a lo largo de dos ejes: número de clientes y ancho de banda de la WAN. Las cargas más altas son especialmente útiles para comprender el rendimiento de Ganesh cuando la CPU o el disco del servidor de base de datos o del proxy son el factor limitante. Un estudio previo ha demostrado que aproximadamente el 50% de los cuellos de botella de Internet de gran área observados tenían un ancho de banda disponible inferior a 10 Mb/s [1]. Basándonos en este trabajo, enfocamos nuestra evaluación en el ancho de banda de la WAN de 5 Mb/s con una latencia de ida y vuelta de 66 ms, representativa de rutas de red severamente restringidas, y 20 Mb/s con una latencia de ida y vuelta de 33 ms, representativa de una ruta de red moderadamente restringida. También informamos sobre el rendimiento de Ganesh a 100 Mb/s sin agregar latencia de ida y vuelta. Este ancho de banda, representativo de una red sin restricciones, es especialmente útil para revelar cualquier sobrecarga potencial de Ganesh en situaciones donde el ancho de banda de la WAN no es el factor limitante. Para cada combinación de número de clientes y ancho de banda de WAN, medimos los resultados de las dos configuraciones enumeradas a continuación: • Nativa: Esta configuración corresponde a la Figura 3(a). El nativo evita la sobrecarga de Ganesh al usar un proxy y realizar la serialización de objetos Java. • Ganesh: Esta configuración corresponde a la Figura 3(b). Para un número dado de clientes y ancho de banda de WAN, comparar estos resultados con los resultados nativos correspondientes proporciona el beneficio de rendimiento debido al sistema de middleware Ganesh. La métrica utilizada para cuantificar la mejora en el rendimiento es el número de solicitudes de clientes que pueden ser atendidas por segundo. La métrica utilizada para cuantificar el rendimiento de Ganesh es el tiempo promedio de respuesta para una solicitud de cliente. Para todos los experimentos, el controlador Ganesh utilizado por el servidor de aplicaciones usó un tamaño de caché de 100,000 elementos. El proxy fue efectivo en rastrear el estado de la caché de los controladores Ganesh; para todos nuestros experimentos, la tasa de fallos en el controlador nunca superó el 0.7%. 4.3 Configuración Experimental La configuración experimental utilizada para las pruebas se puede ver en la Figura 5. Todas las máquinas eran Pentium 4 de 3.2 GHz (con HyperThreading habilitado). Con la excepción del servidor de base de datos, todas las máquinas tenían 2 GB de SDRAM y ejecutaban la distribución de Linux Fedora Core. El servidor de la base de datos tenía 4 GB de SDRAM. Utilizamos Apache Tomcat como tanto el servidor de aplicaciones que alojaba los Servlets de Java como el servidor web. Ambos benchmarks utilizaron Java Servlets para generar el contenido dinámico. El servidor de la base de datos utilizó la base de datos de código abierto MySQL. Para los controladores JDBC nativos, utilizamos los controladores Connector/J proporcionados por MySQL. El servidor de aplicaciones utilizaba la Máquina Virtual de Java de Sun como entorno de ejecución para los Servlets de Java. La herramienta sysstat se utilizó para monitorear la utilización de la CPU, red, disco y memoria en todas las máquinas. Las máquinas estaban conectadas por una red Ethernet gigabit conmutada. Como se muestra en la Figura 5, el servidor web y de aplicación de front-end fue separado del servidor de proxy y base de datos por un enrutador NetEm [16]. Este enrutador nos permitió controlar la configuración de ancho de banda y latencia en la red. El enrutador NetEm es un PC estándar con dos tarjetas de red que ejecuta el software de Control de Tráfico de Linux y Emulación de Red. Las restricciones de ancho de banda y latencia solo se aplicaron al enlace entre el servidor de aplicaciones y la base de datos para el caso nativo y entre el servidor de aplicaciones y el proxy para el caso de Ganesh. No hay comunicación entre el servidor de aplicaciones y la base de datos con Ganesh, ya que todos los datos fluyen a través del proxy. Como nuestro enfoque estaba en el enlace WAN entre el servidor de aplicaciones y la base de datos, no hubo restricciones en el enlace entre los clientes de prueba simulados y el servidor web. 5. DESEMPEÑO Y TIEMPO DE RESPUESTA En esta sección, abordamos la primera pregunta planteada en la Sección 4: ¿Se puede mejorar significativamente el rendimiento explotando la similitud entre los resultados de la base de datos? Para responder a esta pregunta, utilizamos los resultados de los benchmarks BBOARD y AUCTION. Utilizamos dos métricas para cuantificar la mejora en el rendimiento obtenible a través del uso de Ganesh: el throughput, desde la perspectiva del servidor web, y el tiempo de respuesta promedio, desde la perspectiva del cliente. El rendimiento se mide en términos del número de solicitudes de clientes que pueden ser atendidas por segundo. Los resultados y análisis de BBOARD 5.1 Figuras 6 (a) y (b) presentan el número promedio de solicitudes atendidas por segundo y el tiempo de respuesta promedio para estas solicitudes tal como lo perciben los clientes para la Mezcla de Autoría de BBOARD. Como muestra la Figura 6 (a), Native satura fácilmente el enlace de 5 Mb/s. Con 400 clientes, la solución nativa entrega 29 solicitudes/segundo con un tiempo de respuesta promedio de 8.3 segundos. La capacidad de procesamiento de los clientes disminuye con un aumento en los clientes de prueba, ya que los clientes se agotan debido a la congestión en el servidor de aplicaciones. Los estudios de usabilidad han demostrado que los tiempos de respuesta superiores a 10 segundos hacen que el usuario pase a 1. Dado que Java carece de un operador sizeof(), los cachés de Java limitan su tamaño en función del número de objetos. El tamaño de los volcados de caché tomados al final de los experimentos nunca superó los 212 MB. WWW 2007 / Pista: Rendimiento y Escalabilidad Sesión: Sistemas Escalables para Contenido Dinámico 315 0 50 100 150 200 250 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Solicitudes de Clientes de Prueba por Segundo Nativo Ganesh 0.001 0.01 0.1 1 10 100 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Tiempo Promedio de Respuesta de Clientes de Prueba Nativo Ganesh Nota Escala Logarítmica (a) Rendimiento: Mezcla de Autoría (b) Tiempo de Respuesta: Mezcla de Autoría 0 50 100 150 200 250 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Solicitudes de Clientes de Prueba por Segundo Nativo Ganesh 0.001 0.01 0.1 1 10 100 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Tiempo Promedio de Respuesta de Clientes de Prueba Nativo Ganesh Nota Escala Logarítmica (c) Rendimiento: Mezcla de Navegación (d) Tiempo de Respuesta: Mezcla de Navegación Promedio de tres pruebas. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue del 9.8% y 11.9% de la media correspondiente. Figura 6: BBOARD Benchmark - Rendimiento y Tiempo de Respuesta Promedio de otras tareas [24]. Basándose en estos números, aumentar el número de clientes de prueba hace que el sistema Nativo sea inutilizable. Ganesh a 5 Mb/s, sin embargo, ofrece una mejora doble con 400 clientes de prueba y una mejora quintuple con 1200 clientes. El rendimiento de Ganesh disminuye ligeramente a 1200 y 1600 clientes debido a que la red está saturada. En comparación con Native, la Figura 6 (b) muestra que los tiempos de respuesta de Ganesh son considerablemente más bajos con tiempos de respuesta de menos de un segundo con 400 clientes. La Figura 6 (a) también muestra que para 400 y 800 clientes de prueba, Ganesh a 5 Mb/s tiene el mismo rendimiento y tiempo de respuesta promedio que Native a 20 Mb/s. Solo con 1200 y 1600 clientes, Native a 20 Mb/s ofrece un rendimiento mayor que Ganesh a 5 Mb/s. Al comparar tanto a Ganesh como a Native a 20 Mb/s, vemos que Ganesh ya no está limitado por el ancho de banda y ofrece hasta una mejora del doble sobre Native con 1600 clientes de prueba. Como Ganesh no satura la red con configuraciones de cliente de prueba más altas, con 1600 clientes de prueba, su tiempo de respuesta promedio es de 0.1 segundos en lugar de los 7.7 segundos de Natives. Como era de esperar, no hay ganancias visibles de Ganesh en el ancho de banda más alto de 100 Mb/s donde la red ya no es el cuello de botella. Sin embargo, Ganesh sigue monitoreando a Native en cuanto a rendimiento. Las Figuras 6 (c) y (d) presentan el número promedio de solicitudes atendidas por segundo y el tiempo de respuesta promedio para estas solicitudes tal como lo perciben los clientes para la Mezcla de Navegación de BBOARDs. Independientemente de la configuración del cliente de prueba, la Figura 6 (c) muestra que el rendimiento de los Nativos a 5 Mb/s está limitado a 10 reqs/seg. Ganesh a 5 Mb/s con 400 clientes de prueba, ofrece un aumento de más de seis veces en el rendimiento. La mejora aumenta a más de once veces a 800 clientes de prueba antes de que Ganesh sature la red. Además, la Figura 6 (d) muestra que el tiempo de respuesta promedio de los Nativos de 35 segundos con 400 clientes de prueba hace que el sistema sea inutilizable. Estos altos tiempos de respuesta aumentan aún más con la adición de clientes de prueba. Incluso con la configuración del cliente de prueba de 1600, Ganesh ofrece un tiempo de respuesta promedio aceptable de 8.2 segundos. Debido a la naturaleza intensiva en datos de la mezcla de navegación, Ganesh a 5 Mb/s sorprendentemente tiene un rendimiento mucho mejor que Native a 20 Mb/s. Además, como se muestra en la Figura 6 (d), si bien el tiempo de respuesta promedio para Native a 20 Mb/s es aceptable con 400 clientes de prueba, resulta inutilizable con 800 clientes de prueba, con un tiempo de respuesta promedio de 15.8 segundos. Al igual que en el caso de 5 Mb/s, este tiempo de respuesta aumenta con la adición de clientes de prueba adicionales. Ganesh a 20 Mb/s y tanto Native como Ganesh a 100 Mb/s no tienen limitaciones de ancho de banda. Sin embargo, el rendimiento se estanca después de 1200 clientes de prueba debido a que la CPU de la base de datos está saturada. 5.1.3 Variante de filtro Nos sorprendió el rendimiento nativo del benchmark BBOARD. A una velocidad de banda ancha de 5 Mb/s, el rendimiento nativo fue más bajo de lo que esperábamos. Resultó que el código de referencia que muestra historias leía todos los comentarios asociados con la historia en particular de la base de datos y solo entonces realizaba un postprocesamiento para seleccionar los comentarios que se mostrarían. Si bien este es exactamente el comportamiento de SlashCode, la base de código detrás del sitio web de Slashdot, decidimos modificar la prueba de rendimiento para realizar cierto prefiltrado en la base de datos. Este benchmark modificado, llamado el Filtro de Variantes, modela a un desarrollador que aplica optimizaciones a nivel de SQL para transferir menos datos. En aras de la brevedad, solo resumimos brevemente los resultados de la mezcla de autores. Para la mezcla de Autoría, con 800 clientes de prueba a 5 Mb/s, la Figura 7 (a) muestra que el rendimiento de Natives aumenta un 85% en comparación con el punto de referencia original, mientras que la mejora de Ganesh es menor, del 15%. El rendimiento de los servidores disminuye por encima de los 800 clientes, ya que los clientes de prueba se agotan debido a los altos tiempos de respuesta. La ganancia más significativa para Native se observa a 20 Mb/s. En 1600 clientes de prueba, en comparación con el punto de referencia original, Native experimenta una mejora del 73% en el rendimiento y una reducción del 77% en el tiempo de respuesta promedio. Mientras WWW 2007 / Pista: Rendimiento y Escalabilidad Sesión: Sistemas Escalables para Contenido Dinámico 316 0 50 100 150 200 250 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Solicitudes/seg Nativo Ganesh 0.001 0.01 0.1 1 10 100 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Tiempo de Resp. Promedio (seg) Nativo Ganesh Nota Escala Logarítmica (a) Rendimiento: Mezcla de Autoría (b) Tiempo de Respuesta: Mezcla de Autoría Promedio de tres pruebas. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue del 7.2% y del 11.5% de la media correspondiente. Figura 7: BBOARD Benchmark - Variante de filtro - Rendimiento y Tiempo de Respuesta Promedio Ganesh no observa ninguna mejora en comparación con el original, aún procesa un 19% más de solicitudes/seg que Native. Por lo tanto, aunque las optimizaciones fueron más útiles para Native, Ganesh todavía ofrece una mejora en el rendimiento. 5.2 Resultados y Análisis de la SUBASTA 5.2.1 Figuras de la Mezcla de Ofertas Los gráficos 8 (a) y (b) presentan el número promedio de solicitudes atendidas por segundo y el tiempo de respuesta promedio para estas solicitudes tal como son percibidas por los clientes para la Mezcla de Ofertas de las SUBASTAS. Como se mencionó anteriormente, la mezcla de ofertas consiste en una combinación de operaciones de lectura y escritura. El benchmark AUCTION no es tan intensivo en datos como BBOARD. Por lo tanto, la mayoría de las ganancias se observan en el ancho de banda más bajo de 5 Mb/s. La figura 8 (a) muestra que el aumento en el rendimiento debido a Ganesh varía desde un 8% con 400 clientes de prueba hasta un 18% con 1600 clientes de prueba. Como se observa en la Figura 8 (b), los tiempos de respuesta promedio para Ganesh son significativamente más bajos que los de Native, con una disminución del 84% a 800 clientes de prueba y del 88% a 1600 clientes de prueba. La Figura 8 (a) también muestra que con un aumento cuádruple del ancho de banda de 5 Mb/s a 20 Mb/s, Native ya no está limitado por el ancho de banda y no hay diferencia de rendimiento entre Ganesh y Native. Con las configuraciones de cliente de prueba más altas, observamos que el ancho de banda utilizado por Ganesh era menor que el de Nativo. Ganesh podría seguir siendo útil en estos escenarios no restringidos si se compra ancho de banda de forma medible. Se observan resultados similares para el escenario de 100 Mb/s. 5.2.2 Mezcla de Navegación Para la Mezcla de Navegación de SUBASTAS, las Figuras 8 (c) y (d) presentan el número promedio de solicitudes atendidas por segundo y el tiempo promedio de respuesta para estas solicitudes tal como lo perciben los clientes. Una vez más, la mayoría de las ganancias se observan en anchos de banda más bajos. A 5 Mb/s, Native y Ganesh ofrecen un rendimiento y tiempos de respuesta similares con 400 clientes de prueba. Mientras que el rendimiento para ambos permanece igual en 800 clientes de prueba, la Figura 8 (d) muestra que el tiempo de respuesta promedio de Ganesh es un 62% menor que el de Native. El servidor satura el enlace con 800 clientes y agregar clientes de prueba adicionales solo aumenta el tiempo promedio de respuesta. Ganesh, independientemente de la configuración del cliente de prueba, no tiene restricciones de ancho de banda y mantiene el mismo tiempo de respuesta. A 1600 clientes de prueba, la Figura 8 (c) muestra que el rendimiento de Ganesh es casi el doble que el de Nativo. En los anchos de banda más altos de 20 y 100 Mb/s, ni Ganesh ni Native tienen limitaciones de ancho de banda y ofrecen un rendimiento y tiempos de respuesta equivalentes. Referencia original. Tamaño Ganesh Tamaño Rabin Tamaño SelectSort1 223.6 MB 5.4 MB 219.3 MB SelectSort2 223.6 MB 5.4 MB 223.6 MB Tabla 2: Microbenchmarks de similitud 6. SIMILITUD ESTRUCTURAL VS. SIMILITUD DE RABIN En esta sección, abordamos la segunda pregunta planteada en la Sección 4: ¿Qué tan importante es la detección de similitud estructural de Ganesh en comparación con la detección de similitud basada en la huella digital de Rabin? Para responder a esta pregunta, utilizamos microbenchmarks y los benchmarks BBOARD y AUCTION. Dado que Ganesh siempre tuvo un mejor rendimiento que Rabin en la huella dactilar, aquí presentamos solo un subconjunto de los resultados en aras de la brevedad. 6.1 Microbenchmarks Dos microbenchmarks muestran un ejemplo de los efectos de la reordenación de datos en el algoritmo de huella dactilar de Rabin. En el primer microbenchmark, SelectSort1, una consulta con un orden de clasificación especificado selecciona 223.6 MB de datos distribuidos en aproximadamente 280 K filas. La consulta se repite entonces con un atributo de ordenación diferente. Si bien se devuelve el mismo número de filas y los mismos datos, el orden de las filas es diferente. En un escenario así, se esperaría detectar una gran cantidad de similitud entre ambos resultados. Como muestra la Tabla 2, el algoritmo basado en filas de Ganesh logra una reducción del 97.6%, mientras que el algoritmo de huella digital de Rabin, con el parámetro de tamaño de fragmento promedio establecido en 4 KB, solo logra una reducción del 1%. La razón, como se muestra anteriormente en la Figura 2, es que con la huella digital de Rabin, los tramos de datos entre dos límites consecutivos suelen cruzar los límites de fila. Con el cambio en el orden de las filas en el segundo resultado y los fingerprints de Rabin ahora abarcando diferentes filas, el algoritmo no puede detectar similitud significativa. La pequeña ganancia observada se debe principalmente a aquellas filas individuales que son lo suficientemente grandes como para dividirse en múltiples fragmentos. SelectSort2, otro micro-benchmark ejecutó las mismas consultas pero aumentó el tamaño mínimo del fragmento del algoritmo de huella digital de Rabin. Como se puede ver en la Tabla 2, incluso la pequeña ganancia del microbenchmark anterior desaparece cuando el tamaño mínimo de fragmento fue mayor que el tamaño promedio de fila. Si bien se pueden abordar parcialmente estos problemas variando dinámicamente los parámetros del algoritmo de huella digital de Rabin, esto puede resultar computacionalmente costoso, especialmente en presencia de cargas de trabajo cambiantes. 6.2 Benchmarks de Aplicación Ejecutamos el benchmark BBOARD descrito en la Sección 4.1.1 en dos versiones de Ganesh: la primera con la huella digital de Rabin utilizada como WWW 2007 / Track: Sesión de Rendimiento y Escalabilidad: Sistemas Escalables para Contenido Dinámico 317 0 50 100 150 200 250 300 350 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Solicitudes/seg Ganesh Nativo 0.001 0.01 0.1 1 10 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Tiempo de Respuesta Promedio (seg) Ganesh Nativo Nota Escala Logarítmica (a) Rendimiento: Mezcla de Ofertas (b) Tiempo de Respuesta: Mezcla de Ofertas 0 50 100 150 200 250 300 350 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Solicitudes/seg Ganesh Nativo 0.001 0.01 0.1 1 10 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Tiempo de Respuesta Promedio (seg) Ganesh Nativo Nota Escala Logarítmica (c) Rendimiento: Mezcla de Navegación (d) Tiempo de Respuesta: Mezcla de Navegación Promedio de tres pruebas. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue del 2.2% y del 11.8% de la media correspondiente. Figura 8: Referencia de la subasta AUCTION - Rendimiento y Tiempo de Respuesta Promedio del algoritmo de fragmentación y el segundo con el algoritmo basado en filas de Ganesh. Los resultados de Rabins para la Mezcla de Navegación se normalizan con los resultados de Ganesh y se presentan en la Figura 9. Como muestra la Figura 9 (a), a 5 Mb/s, independientemente de la configuración del cliente de prueba, Rabin tiene un rendimiento significativamente inferior a Ganesh. Esto sucede debido a una combinación de dos razones. Primero, como se describe en la Sección 3.1, Rabin encuentra menos similitud ya que no explota la información estructural de los resultados. Segundo, este punto de referencia contenía algunas consultas que generaron resultados grandes. En este caso, Rabin, con un tamaño de fragmento promedio pequeño, generó una gran cantidad de objetos que desplazaron otros datos útiles de la caché. Por el contrario, Ganesh pudo detectar estas filas grandes y aumentar correspondientemente el tamaño de los bloques. Esto fue confirmado ya que las estadísticas de caché mostraron que la proporción de aciertos de Ganesh era aproximadamente tres veces mayor que la de Rabin. Las mediciones de rendimiento a 20 Mb/s fueron similares, con la excepción del rendimiento de Rabins con 400 clientes de prueba. En este caso, Ganesh no estaba limitado por la red y, de hecho, el rendimiento era el mismo que el de 400 clientes a 5 Mb/s. Rabin, sin embargo, aprovechó el aumento del ancho de banda de 5 a 20 Mb/s para ofrecer un rendimiento ligeramente mejor. A 100 Mb/s, el rendimiento de Rabin era casi similar al de Ganesh ya que el ancho de banda ya no era un cuello de botella. El tiempo de respuesta normalizado, presentado en la Figura 9 (b), muestra tendencias similares. A 5 y 20 Mb/s, la adición de clientes de prueba disminuye el tiempo de respuesta normalizado, ya que el tiempo de respuesta promedio de Ganesh aumenta más rápido que el de Rabin. Sin embargo, en ningún momento Rabin supera a Ganesh. Ten en cuenta que con 400 y 800 clientes a 100 Mb/s, Rabin tiene un mayor sobrecosto incluso cuando no está limitado por el ancho de banda. Como se menciona en la Sección 3.1, esto se debe a que Rabin tiene que hashear cada ResultSet dos veces. La sobrecarga desaparece con 1200 y 1600 clientes, ya que la CPU de la base de datos está saturada y limita el rendimiento tanto de Ganesh como de Rabin. 7. SUPERPOSICIÓN DE PROXY En esta sección, abordamos la tercera pregunta planteada en la Sección 4: ¿Es aceptable la superposición del diseño basado en proxy de Ganesh? Para responder a esta pregunta, nos concentramos en su rendimiento en las bandas de mayor ancho de banda. Nuestra evaluación en la Sección 5 mostró que Ganesh, en comparación con Native, puede ofrecer una mejora sustancial en el rendimiento a anchos de banda más bajos. Solo en anchos de banda más altos serían visibles los costos adicionales de latencia, medidos por el tiempo promedio de respuesta para una solicitud de cliente, y de rendimiento, medidos por la cantidad de solicitudes de cliente que pueden ser atendidas por segundo. Al observar la combinación de autoría del benchmark original de BBOARD, no se aprecian ganancias visibles de Ganesh a 100 Mb/s. Sin embargo, Ganesh sigue rastreando a Native en cuanto a rendimiento. Si bien el tiempo promedio de respuesta es mayor para Ganesh, la diferencia absoluta está entre 0.01 y 0.04 segundos y sería imperceptible para el usuario final. La mezcla de navegación muestra una diferencia aún menor en los tiempos de respuesta promedio. Los resultados de la variante del filtro de los benchmarks de BBOARD son similares. Incluso para el benchmark de SUBASTA, la diferencia entre el tiempo de respuesta de Nativo y Ganesh a 100 Mb/s nunca fue mayor a 0.02 segundos. La única excepción a los resultados anteriores se observó en la variante de filtro del benchmark BBOARD, donde Ganesh con 1600 clientes de prueba añadió 0.85 segundos al tiempo de respuesta promedio. Por lo tanto, incluso para redes mucho más rápidas donde el enlace WAN no es el cuello de botella, Ganesh siempre ofrece un rendimiento equivalente al Nativo. Si bien se agrega algo de latencia adicional debido al diseño basado en proxy, generalmente es imperceptible. TRABAJO RELACIONADO Hasta donde sabemos, Ganesh es el primer sistema que combina el uso de técnicas basadas en hash con el almacenamiento en caché de resultados de base de datos para mejorar el rendimiento y los tiempos de respuesta de aplicaciones con contenido dinámico. También creemos que es el primer sistema en demostrar los beneficios de utilizar información estructural para WWW 2007 / Track: Rendimiento y Escalabilidad Sesión: Sistemas Escalables para Contenido Dinámico 318 0.0 0.2 0.4 0.6 0.8 1.0 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Rendimiento Normalizado 31.8 3.8 2.8 2.3 23.8 32.8 5.8 3.6 1.8 2.1 1.1 1.0 0 5 10 15 20 25 30 35 400 800 1200 1600 400 800 1200 1600 400 800 1200 1600 5 Mb/s 20 Mb/s 100 Mb/s Clientes de Prueba Tiempo de Respuesta Normalizado (a) Rendimiento Normalizado: Mayor es mejor (b) Tiempo de Respuesta Normalizado: Mayor es peor Para el rendimiento, un resultado normalizado mayor que 1 implica que Rabin es mejor. Para el tiempo de respuesta, un resultado normalizado mayor que 1 implica que Ganesh es mejor. Media de tres pruebas. La desviación estándar máxima para el rendimiento y el tiempo de respuesta fue del 9.1% y del 13.9% de la media correspondiente. Figura 9: Comparación normalizada de Ganesh vs. Rabin - Mezcla de navegación BBOARD detectando similitud. En esta sección, primero discutimos enfoques alternativos para almacenar en caché contenido dinámico y luego examinamos otros usos de primitivas basadas en hash en sistemas distribuidos. 8.1 Almacenamiento en Caché de Contenido Dinámico En la capa de base de datos, varios sistemas han abogado por la caché de nivel intermedio donde partes de la base de datos se replican en el borde o servidor [3, 4, 20]. Estos sistemas almacenan en caché tablas completas en lo que es esencialmente una base de datos replicada o utilizan vistas materializadas de respuestas de consultas anteriores [19]. Requieren una integración estrecha con la base de datos del sistema para garantizar un límite de tiempo en la propagación de actualizaciones. Estos sistemas suelen estar dirigidos a cargas de trabajo que no requieren una consistencia estricta y pueden tolerar datos obsoletos. Además, a diferencia de Ganesh, algunas de estas soluciones de almacenamiento en caché de nivel medio [2, 3], sufren de la complejidad de tener que participar en la planificación de consultas y el procesamiento de consultas distribuidas. Gao et al. [15] proponen utilizar una arquitectura de replicación de objetos distribuidos donde los requisitos de consistencia de las tiendas de datos se adaptan según la aplicación. Estas soluciones requieren recursos sustanciales de desarrollo y un entendimiento detallado de la aplicación que se está modificando. Si bien existen sistemas que intentan automatizar la partición y replicación de la base de datos de una aplicación [34], no proporcionan semántica de transacciones completa. En comparación, Ganesh no debilita ninguna de las semánticas proporcionadas por la base de datos subyacente. El trabajo reciente en la evaluación de opciones de almacenamiento en caché de borde para sitios web dinámicos [38] ha sugerido que, sin una planificación cuidadosa, el empleo de estrategias complejas de descarga puede perjudicar el rendimiento. En cambio, el trabajo aboga por una arquitectura en la que todos los niveles, excepto la base de datos, deberían ser trasladados al borde. Nuestra evaluación de Ganesh ha demostrado que sería beneficioso para estos escenarios. Para mejorar la escalabilidad de la base de datos, C-JDBC [10], SSS [22] y Ganymed [28] también abogan por el uso de una arquitectura basada en interposición para clusterizar y replicar bases de datos de forma transparente a nivel de middleware. Los enfoques de estas arquitecturas y Ganesh son complementarios y se beneficiarían mutuamente. Avanzando hacia la capa de presentación, se ha producido una amplia adopción de la caché basada en fragmentos [14], la cual mejora la utilización de la caché al almacenar por separado diferentes partes de las páginas web generadas. Si bien el almacenamiento en caché basado en fragmentos funciona en el borde, una propuesta reciente ha propuesto trasladar el ensamblaje de páginas web a los clientes para optimizar la entrega de contenido [31]. Si bien Ganesh no se utiliza en la capa de presentación, los mismos principios se han aplicado en la Detección de Transferencias Duplicadas [25] para aumentar la eficiencia de la caché web, así como para el acceso web a través de enlaces con ancho de banda limitado [33]. 8.2 Sistemas basados en hash En los últimos años han surgido muchos sistemas que explotan técnicas basadas en hash. En el centro de todos estos sistemas se encuentra la idea de detectar similitudes en los datos sin necesidad de interpretar esos datos. Esta idea simple pero elegante se basa en el hash criptográfico, como se discutió anteriormente en la Sección 2. Las aplicaciones exitosas de esta idea abarcan una amplia gama de sistemas de almacenamiento. Los ejemplos incluyen la copia de seguridad entre pares de archivos informáticos personales [11], el archivado eficiente de datos [29] y la búsqueda de archivos similares [21]. Spring y Wetherall [35] aplican principios similares a nivel de red. Utilizando cachés sincronizadas en ambos extremos de un enlace de red, los datos duplicados son reemplazados por tokens más pequeños para su transmisión y luego restaurados en el extremo remoto. Este y otros sistemas basados en hash como los sistemas de archivos CASPER [37] y LBFS [26], y optimizadores de ancho de banda de Capa-2 como Riverbed y Peribit utilizan la huella digital de Rabin [30] para descubrir tramos de similitud en los datos. Este enfoque es especialmente útil cuando los elementos de datos son modificados en su lugar a través de inserciones, eliminaciones y actualizaciones. Sin embargo, como se muestra en la Sección 6, el rendimiento de esta técnica puede experimentar una caída dramática en presencia de reordenamiento de datos. Ganesh en cambio utiliza los límites de fila como divisores para detectar similitudes. El uso más agresivo de técnicas basadas en hash es por sistemas que utilizan hashes como identificadores principales para objetos en almacenamiento persistente. Los sistemas de almacenamiento como CFS [12] y PAST [13] que han sido construidos utilizando tablas hash distribuidas entran en esta categoría. Single Instance Storage [6] y Venti [29] son otros ejemplos de tales sistemas. Como se discute en la Sección 2.2, el uso de hashes criptográficos para abordar datos persistentes representa un nivel más profundo de confianza en su resistencia a colisiones que la asumida por Ganesh. Si el tiempo revela deficiencias en el algoritmo hash, el esfuerzo necesario para corregir la falla es mucho mayor. En Ganesh, simplemente se trata de reemplazar el algoritmo hash. 9. CONCLUSIÓN El creciente uso de contenido web dinámico generado a partir de bases de datos relacionales aumenta las demandas de ancho de banda de la WAN. Las soluciones de almacenamiento en caché tradicionales para reducir el ancho de banda y la latencia suelen ser ineficaces para este tipo de contenido. Este documento muestra que el impacto de los accesos a bases de datos a través de WAN puede reducirse sustancialmente mediante la arquitectura Ganesh sin comprometer la estricta semántica de consistencia de las bases de datos. La esencia de la arquitectura Ganesh es el uso de la computación en los bordes para reducir la comunicación a través de Internet. Ganesh es capaz de utilizar hashes criptográficos para detectar similitud con resultados anteriores y enviar recetas compactas de resultados en lugar de resultados completos en la sesión de Sistemas Escalables para Contenido Dinámico 319 de WWW 2007 / Track: Rendimiento y Escalabilidad. Nuestro diseño utiliza la interposición para lograr una transparencia completa: los clientes, los servidores de aplicaciones y los servidores de bases de datos no son conscientes de la presencia de Ganesh y no requieren ninguna modificación. Nuestra evaluación experimental confirma que Ganesh, aunque conceptualmente simple, puede ser altamente efectivo en mejorar el rendimiento y el tiempo de respuesta. Nuestros resultados también confirman que aprovechar la estructura presente en los resultados de la base de datos para detectar similitudes es crucial para esta mejora en el rendimiento. REFERENCIAS [1] AKELLA, A., SESHAN, S., Y SHAIKH, A. Una evaluación empírica de los cuellos de botella en Internet de área amplia. En Proc. 3ª Conferencia ACM SIGCOMM sobre Medición de Internet (Miami Beach, FL, EE. UU., Oct. 2003), pp. 101-114. [2] ALTINEL, M., BORNH ¨OVD, C., KRISHNAMURTHY, S., MOHAN, C., PIRAHESH, H., Y REINWALD, B. Tablas de caché: allanando el camino para una caché de base de datos adaptativa. En Proc. del 29º VLDB (Berlín, Alemania, 2003), pp. 718-729. [3] ALTINEL, M., LUO, Q., KRISHNAMURTHY, S., MOHAN, C., PIRAHESH, H., LINDSAY, B. G., WOO, H., Y BROWN, L. Dbcache: Caché de base de datos para servidores de aplicaciones web. En Proc. 2002 ACM SIGMOD (2002), pp. 612-612. [4] AMIRI, K., PARK, S., TEWARI, R., Y PADMANABHAN, S. Dbproxy: una caché de datos dinámica para aplicaciones web. En Proc. Conferencia Internacional de Ingeniería de Datos de IEEE (ICDE) (Mar. 2003). [5] BLACK, J. Compare-by-hash: Un análisis razonado. En Proc. Conferencia Técnica Anual USENIX 2006 (Boston, MA, mayo de 2006), pp. 85-90. [6] BOLOSKY, W. J., CORBIN, S., GOEBEL, D., y DOUCEUR, J. R. Almacenamiento de instancia única en Windows 2000. En Proc. 4to Simposio de Sistemas Windows de USENIX (Seattle, WA, ago. 2000), pp. 13-24. [7] BREWER, E. A. Lecciones de servicios a gran escala. IEEE Internet Computing 5, 4 (2001), 46-55. [8] BRODER, A., GLASSMAN, S., MANASSE, M., AND ZWEIG, G. Agrupamiento sintáctico de la web. En Proc. 6ta Conferencia Internacional WWW (1997). [9] CECCHET, E., CHANDA, A., ELNIKETY, S., MARGUERITE, J., Y ZWAENEPOEL, W. Comparación de rendimiento de arquitecturas de middleware para generar contenido web dinámico. En Proc. Cuarta Conferencia Internacional de Middleware ACM/IFIP/USENIX (Río de Janeiro, Brasil, junio de 2003). [10] CECCHET, E., MARGUERITE, J., Y ZWAENEPOEL, W. C-JDBC: Middleware flexible de agrupación de bases de datos. En Proc. Conferencia Técnica Anual USENIX 2004 (Boston, MA, junio de 2004). [11] COX, L. P., MURRAY, C. D., Y NOBLE, B. D. Pastiche: Haciendo que la copia de seguridad sea barata y fácil. En OSDI: Simposio sobre Diseño e Implementación de Sistemas Operativos (2002). [12] DABEK, F., KAASHOEK, M. F., KARGER, D., MORRIS, R., Y STOICA, I. Almacenamiento cooperativo de amplia área con CFS. En el 18º Simposio ACM sobre Principios de Sistemas Operativos (Banff, Canadá, octubre de 2001). [13] DRUSCHEL, P., Y ROWSTRON, A. PASADO: Una utilidad de almacenamiento entre pares a gran escala y persistente. En HotOS VIII (Schloss Elmau, Alemania, mayo de 2001), pp. 75-80. [14] Incluye el lado del borde. http://www.esi.org. [15] GAO, L., DAHLIN, M., NAYATE, A., ZHENG, J., Y IYENGAR, A. Replicación de datos específica de la aplicación para servicios en el borde. En WWW 03: Proc. Duodécima Conferencia Internacional sobre la World Wide Web (2003), pp. 449-460. [16] HEMMINGER, S. Netem - emulando redes reales en el laboratorio. En Proc. 2005 Linux Conference Australia (Canberra, Australia, Abr. 2005). [17] HENSON, V. Un análisis de compare-by-hash. En Proc. 9º Taller sobre Temas Candentes en Sistemas Operativos (HotOS IX) (mayo de 2003), pp. 13-18. [18] Benchmarks de Jmob. http://jmob.objectweb.org/. [19] LABRINIDIS, A., Y ROUSSOPOULOS, N. Equilibrando el rendimiento y la frescura de los datos en servidores de bases de datos web. En Proc. 29ª Conferencia VLDB (Sept. 2003). [20] LARSON, P.-A., GOLDSTEIN, J., Y ZHOU, J. Caché transparente de bases de datos en el nivel intermedio en SQL Server. En Proc. 2003 ACM SIGMOD (2003), pp. 661-661. [21] MANBER, U. Encontrar archivos similares en un sistema de archivos grande. En Proc. Conferencia Técnica de Invierno de USENIX 1994 (San Francisco, CA, 17-21 de 1994), pp. 1-10. [22] MANJHI, A., AILAMAKI, A., MAGGS, B. M., MOWRY, T. C., OLSTON, C., Y TOMASIC, A. Escalabilidad y seguridad simultáneas para aplicaciones web intensivas en datos. En Proc. 2006 ACM SIGMOD (junio de 2006), pp. 241-252. [23] MENEZES, A. J., VANSTONE, S. A., Y OORSCHOT, P. C. V. Manual de Criptografía Aplicada. CRC Press, 1996. [24] MILLER, R. B. 

CRC Press, 1996. [24] MILLER, R. B. Tiempo de respuesta en transacciones conversacionales entre humanos y computadoras. En Proc. Conferencia Conjunta de Computación de Otoño de AFIPS (1968), pp. 267-277. [25] MOGUL, J. C., CHAN, Y. M., Y KELLY, T. Diseño, implementación y evaluación de la detección de transferencias duplicadas en http. En Proc. Primer Simposio sobre Diseño e Implementación de Sistemas en Red (San Francisco, CA, Mar. 2004). [26] MUTHITACHAROEN, A., CHEN, B., Y MAZIERES, D. Un sistema de archivos en red de bajo ancho de banda. En Proc. 18º Simposio de la ACM sobre Principios de Sistemas Operativos (Banff, Canadá, Oct. 2001). [27] PFEIFER, D., Y JAKSCHITSCH, H. Caché basada en métodos en aplicaciones de servidores multinivel. En Proc. Quinto Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (Catania, Sicilia, Italia, noviembre de 2003). [28] PLATTNER, C., Y ALONSO, G. Ganymed: Replicación escalable para aplicaciones web transaccionales. En Proc. 5ta Conferencia Internacional de Middleware ACM/IFIP/USENIX (2004), pp. 155-174. [29] QUINLAN, S., Y DORWARD, S. Venti: Un nuevo enfoque para el almacenamiento de archivos. En Proc. Conferencia FAST 2002 sobre Tecnologías de Archivo y Almacenamiento (2002). [30] RABIN, M. Huellas dactilares mediante polinomios aleatorios. En el Informe Técnico TR-15-81 (1981) del Centro de Investigación en Tecnología Informática de la Universidad de Harvard. [31] RABINOVICH, M., XIAO, Z., DOUGLIS, F., Y KALMANEK, C. Mover los lados de los bordes incluye a los clientes reales en el borde. En Proc. 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (Seattle, WA, Mar. 2003). [32] REESE, G. Programación de bases de datos con JDBC y Java, 1ra ed. OReilly, junio de 1997. [33] RHEA, S., LIANG, K., Y BREWER, E. Caché web basada en valores. En Proc. Duodécima Conferencia Internacional de la World Wide Web (mayo de 2003). [34] SIVASUBRAMANIAN, S., ALONSO, G., PIERRE, G., Y VAN STEEN, M. Globedb: Replicación autónoma de datos para aplicaciones web. En WWW 05: Actas de la 14ª Conferencia Internacional de la World-Wide Web (mayo de 2005). [35] SPRING, N. T., Y WETHERALL, D. Una técnica independiente de protocolo para eliminar el tráfico de red redundante. En Proc. de ACM SIGCOMM (Ago. 2000). [36] TOLIA, N., HARKES, J., KOZUCH, M., Y SATYANARAYANAN, M. Integrando almacenamiento portátil y distribuido. En Proc. 3ra Conferencia USENIX sobre Tecnologías de Archivos y Almacenamiento (San Francisco, CA, Mar. 2004). [37] TOLIA, N., KOZUCH, M., SATYANARAYANAN, M., KARP, B., PERRIG, A., Y BRESSOUD, T. Uso oportunista del almacenamiento direccionable por contenido para sistemas de archivos distribuidos. En Proc. Conferencia Técnica Anual USENIX 2003 (San Antonio, TX, junio de 2003), pp. 127-140. [38] YUAN, C., CHEN, Y., Y ZHANG, Z. Evaluación de almacenamiento en caché/descarga en el borde para la entrega de contenido dinámico. En WWW 03: Proc. Duodécima Conferencia Internacional sobre la World Wide Web (2003), pp. 461-471. WWW 2007 / Pista: Rendimiento y Escalabilidad Sesión: Sistemas Escalables para Contenido Dinámico 320