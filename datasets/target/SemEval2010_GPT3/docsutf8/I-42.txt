Un Método Completo de Optimización de Restricciones Distribuidas para Arreglos de Pseudotree No Tradicionales∗ James Atlas Ciencias de la Computación e Informática Universidad de Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Ciencias de la Computación e Informática Universidad de Delaware Newark, DE 19716 decker@cis.udel.edu RESUMEN La Optimización de Restricciones Distribuidas (DCOP) es un marco general que puede modelar problemas complejos en sistemas multiagente. Varios algoritmos actuales que resuelven instancias generales de DCOP, incluyendo ADOPT y DPOP, organizan a los agentes en una estructura de pseudobosque tradicional. Introducimos una extensión al algoritmo DPOP que maneja un conjunto extendido de disposiciones de pseudobosque. Nuestro algoritmo resuelve correctamente instancias de DCOP para pseudobosques que incluyen aristas entre nodos en ramas separadas. El algoritmo también resuelve instancias con arreglos de pseudobosque tradicionales utilizando el mismo procedimiento que DPOP. Comparamos nuestro algoritmo con DPOP utilizando varios métricos, incluyendo el ancho inducido de los pseudobosques, la dimensionalidad máxima de los mensajes y la computación, y el costo máximo de la ruta secuencial a través del algoritmo. Demostramos que para algunas instancias del problema no es posible generar un pseudoárbol tradicional utilizando heurísticas de recorrido de aristas que supere a un pseudoárbol con aristas cruzadas. Utilizamos múltiples heurísticas para generar pseudoárboles y elegir el mejor pseudoárbol en complejidad espacio-temporal lineal. Para algunas instancias del problema observamos mejoras significativas en los tamaños de los mensajes y cálculos en comparación con DPOP. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente Términos Generales Algoritmos 1. INTRODUCCIÓN Muchos problemas históricos en la comunidad de IA pueden transformarse en Problemas de Satisfacción de Restricciones (CSP). Con la llegada de la inteligencia artificial distribuida, los sistemas multiagente se convirtieron en una forma popular de modelar las interacciones complejas y la coordinación necesaria para resolver problemas distribuidos. Los CSPs fueron originalmente extendidos a entornos de agentes distribuidos en [9]. Los primeros dominios para problemas de satisfacción de restricciones distribuidas (DisCSP) incluyeron la programación de talleres de trabajo [1] y la asignación de recursos [2]. Muchos dominios para sistemas de agentes, especialmente coordinación de trabajo en equipo, programación distribuida y redes de sensores, implican problemas excesivamente restringidos que son difíciles o imposibles de satisfacer para cada restricción. Los enfoques recientes para resolver problemas en estos dominios se basan en técnicas de optimización que mapean restricciones en funciones de utilidad multivaluadas. En lugar de encontrar una asignación que satisfaga todas las restricciones, estos enfoques encuentran una asignación que produce un alto nivel de utilidad global. Esta extensión al enfoque original de DisCSP se ha vuelto popular en sistemas multiagente, y ha sido etiquetada como Problema de Optimización de Restricciones Distribuidas (DCOP) [1]. Los algoritmos actuales que resuelven DCOPs completos utilizan dos enfoques principales: búsqueda y programación dinámica. Los algoritmos basados en búsqueda que se originaron a partir de DisCSP típicamente utilizan alguna forma de retroceso [10] o propagación de límites, como en ADOPT [3]. Los algoritmos basados en programación dinámica incluyen DPOP y sus extensiones [5, 6, 7]. Hasta la fecha, ambas categorías de algoritmos organizan agentes en un pseudoárbol tradicional para resolver el problema. Se ha demostrado en [6] que cualquier grafo de restricciones puede ser mapeado en un pseudoárbol tradicional. Sin embargo, también se demostró que encontrar el pseudoárbol óptimo era NP-Difícil. Comenzamos a investigar el rendimiento de los pseudobosques tradicionales generados por las heurísticas actuales de recorrido de aristas. Descubrimos que estas heurísticas a menudo generaban poco paralelismo, ya que los pseudárboles tendían a tener una gran profundidad y bajos factores de ramificación. Sospechábamos que podría haber otras formas de organizar los pseudobosques que proporcionarían un mayor paralelismo y tamaños de mensaje más pequeños. Después de explorar estos otros arreglos, descubrimos que los pseudobosques de bordes cruzados proporcionan profundidades más cortas y factores de ramificación más altos que los pseudobosques tradicionales. Nuestra hipótesis era que estos pseudorboles cruzados superarían a los pseudorboles tradicionales en algunos tipos de problemas. En este artículo presentamos una extensión al algoritmo DPOP que maneja un conjunto ampliado de disposiciones de pseudobosque que incluyen pseudobosques con aristas cruzadas. Comenzamos con una definición de 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, pseudobosques tradicionales y pseudobosques de bordes cruzados. Luego proporcionamos un resumen del algoritmo DPOP original e introducimos nuestro algoritmo DCPOP. Discutimos la complejidad de nuestro algoritmo, así como el impacto de las heurísticas de generación de pseudobosques. Luego demostramos que nuestro Procedimiento de Optimización de Pseudotree de Bordes Cruzados Distribuido (DCPOP) funciona significativamente mejor en la práctica que el algoritmo DPOP original para algunas instancias del problema. Concluimos con una selección de ideas para trabajos futuros y extensiones para DCPOP. 2. La DEFINICIÓN DEL PROBLEMA DCOP ha sido formalizada de maneras ligeramente diferentes en la literatura reciente, por lo que adoptaremos la definición presentada en [6]. Un Problema de Optimización de Restricciones Distribuidas con n nodos y m restricciones consiste en la tupla < X, D, U > donde: • X = {x1,..,xn} es un conjunto de variables, cada una asignada a un agente único • D = {d1,..,dn} es un conjunto de dominios finitos para cada variable • U = {u1,..,um} es un conjunto de funciones de utilidad tales que cada función involucra un subconjunto de variables en X y define una utilidad para cada combinación de valores entre estas variables. Una solución óptima para una instancia de DCOP consiste en una asignación de valores en D a X tal que la suma de las utilidades en U sea máxima. Los dominios de problemas que requieren un costo mínimo en lugar de una utilidad máxima pueden mapear los costos en utilidades negativas. Las funciones de utilidad representan restricciones suaves pero también pueden representar restricciones fuertes mediante el uso de valores negativos arbitrariamente grandes. Para este artículo solo consideramos funciones de utilidad binarias que involucran dos variables. Las funciones de utilidad de orden superior pueden ser modeladas con cambios menores en el algoritmo, pero también aumentan sustancialmente la complejidad. 2.1 Pseudárboles Tradicionales Los pseudárboles son una estructura común utilizada en procedimientos de búsqueda para permitir el procesamiento paralelo de ramas independientes. Como se define en [6], un pseudoárbol es un arreglo de un grafo G en un árbol raíz T de tal manera que los vértices en G que comparten una arista están en la misma rama en T. Una arista de retroceso es una arista entre un nodo X y cualquier nodo que se encuentre en el camino desde X hasta la raíz (excluyendo al padre de X). La Figura 1 muestra un pseudoárbol con cuatro nodos, tres aristas (A-B, B-C, BD) y una arista de retroceso (A-C). También se definen en [6] cuatro tipos de relaciones entre nodos que existen en un pseudoárbol: • P(X) - el padre de un nodo X: el único nodo más alto en el pseudoárbol que está conectado a X directamente a través de un borde de árbol • C(X) - los hijos de un nodo X: el conjunto de nodos más bajos en el pseudo Las líneas sólidas representan relaciones padre-hijo y la línea discontinua representa una relación pseudo-padre-pseudo-hijo. Figura 2: Un pseudoárbol de bordes cruzados. Las líneas sólidas representan relaciones padre-hijo, la línea discontinua representa una relación pseudo-padre-pseudo-hijo, y la línea punteada representa una relación rama-padre-rama-hijo. El nodo en negrita, B, es el punto de fusión para el nodo E. 2.2 Pseudárboles con aristas cruzadas Definimos una arista cruzada como una arista de un nodo X a un nodo Y que está por encima de X pero no en el camino desde X hasta la raíz. Un pseudoárbol de bordes cruzados es un pseudoárbol tradicional con la adición de bordes cruzados. La Figura 2 muestra un pseudoárbol con una arista cruzada (D-E). En un pseudoárbol de bordes cruzados designamos ciertos bordes como primarios. El conjunto de aristas primarias define un árbol de expansión de los nodos. Las relaciones de padre, hijo, pseudo-padre y pseudo-hijo del pseudotree tradicional ahora están definidas en el contexto de este árbol de expansión de borde primario. Esta definición también produce dos tipos adicionales de relaciones que pueden existir entre nodos: • BP(X) - los nodos padres de rama de un nodo X: el conjunto de nodos más altos en el pseudoárbol que están conectados a X pero no están en el camino principal desde X hasta la raíz (En la Figura 2, D = BP(E)) • BC(X) - los nodos hijos de rama de un nodo X: el conjunto de nodos más bajos en el pseudo La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Los algoritmos actuales suelen tener una fase de pre-ejecución para generar un pseudoárbol tradicional a partir de una instancia general de DCOP. Nuestro algoritmo DCPOP genera un pseudoárbol de bordes cruzados de la misma manera. Primero, la instancia DCOP < X, D, U > se traduce directamente en un grafo con X como el conjunto de vértices y una arista para cada par de variables representadas en U. A continuación, se utilizan varias heurísticas para organizar este grafo en un pseudoárbol. Un heurístico común es realizar una búsqueda en profundidad guiada (DFS, por sus siglas en inglés) ya que el recorrido resultante es un pseudoárbol, y un DFS se puede realizar fácilmente de manera distribuida. Definimos un método basado en el recorrido de aristas como cualquier método que produce un pseudoárbol en el que todos los pares padre/hijo comparten una arista en el grafo original. Esto incluye recorridos basados en DFS, búsqueda en anchura y búsqueda de mejor primero. Nuestras heurísticas que generan pseudobosques de bordes cruzados utilizan un recorrido de búsqueda mejor primero distribuido. 3. ALGORITMO DPOP El algoritmo DPOP original opera en tres fases principales. La primera fase genera un pseudoárbol tradicional a partir de la instancia de DCOP utilizando un algoritmo distribuido. La segunda fase une hipercubos de utilidad de los nodos hijos y el nodo local y los propaga hacia la raíz. La tercera fase elige una asignación para cada dominio de arriba hacia abajo, comenzando con el agente en el nodo raíz. La complejidad de DPOP depende del tamaño del cálculo más grande y del mensaje de utilidad durante la fase dos. Se ha demostrado que este tamaño corresponde directamente al ancho inducido del pseudoárbol generado en la fase uno [6]. DPOP utiliza heurísticas de tiempo polinómico para generar el pseudoárbol, ya que encontrar el pseudoárbol de ancho inducido mínimo es NP-duro. Se han desarrollado varias heurísticas de recorrido de borde distribuido para encontrar pseudobosques de ancho reducido [8]. Al final de la primera fase, cada agente conoce a su padre, hijos, pseudo-padres y pseudo-hijos. 3.1 Propagación de utilidad Los agentes ubicados en los nodos hoja del pseudoárbol comienzan el proceso calculando un hipercubo de utilidad local. Este hipercubo en el nodo X contiene las utilidades sumadas para cada combinación de valores en los dominios de P(X) y PP(X). Este hipercubo tiene un tamaño dimensional igual al número de pseudo-padres más uno. Un mensaje que contiene este hipercubo se envía a P(X). Los agentes ubicados en nodos no hoja esperan a que lleguen todos los mensajes de los nodos hijos. Una vez que el agente en el nodo Y tiene todos los mensajes de utilidad, calcula su hipercubo de utilidad local que incluye los dominios de P(Y), PP(Y) y Y. El hipercubo de utilidad local se une luego con todos los hipercubos de los mensajes hijos. En este punto, todas las utilidades que involucran al nodo Y son conocidas, y el dominio de Y puede ser eliminado de forma segura del hipercubo unido. Este proceso de eliminación elige la mejor utilidad sobre el dominio de Y para cada combinación de los dominios restantes. Un mensaje que contiene este hipercubo se envía ahora a P(Y). El tamaño dimensional de este hipercubo depende del número de dominios superpuestos en los mensajes recibidos y del hipercubo de utilidad local. Esta fase de propagación basada en programación dinámica continúa hasta que el agente en el nodo raíz del pseudoárbol haya recibido todos los mensajes de sus hijos. 3.2 Propagación de Valor La propagación de valor comienza cuando el agente en el nodo raíz Z ha recibido todos los mensajes de sus hijos. Dado que Z no tiene padres ni pseudo-padres, simplemente combina los hipercubos de utilidad recibidos de sus hijos. El hipercubo combinado contiene solo valores para el dominio de Z. En este punto, el agente en el nodo Z simplemente elige la asignación para su dominio que tiene la mejor utilidad. Un mensaje de propagación de valor con esta asignación se envía a cada nodo en C(Z). Cada nodo luego recibe un mensaje de propagación de valor de su padre y elige la asignación para su dominio que tenga la mejor utilidad dadas las asignaciones recibidas en el mensaje. El nodo agrega su asignación de dominio a las asignaciones que recibió y pasa el conjunto de asignaciones a sus hijos. El algoritmo está completo cuando todos los nodos han elegido una asignación para su dominio. ALGORITMO DCPOP Nuestra extensión al algoritmo DPOP original, mostrada en el Algoritmo 1, comparte las mismas tres fases. La primera fase genera el pseudoárbol de bordes cruzados para la instancia de DCOP. La segunda fase fusiona ramas y propaga los hipercubos de utilidad. La tercera fase elige asignaciones para dominios en los puntos de fusión de ramas y de arriba hacia abajo, comenzando con el agente en el nodo raíz. Para la primera fase generamos un pseudoárbol utilizando varios heurísticos distribuidos y seleccionamos el que tenga la menor complejidad general. La complejidad de la computación y el tamaño del mensaje de utilidad en DCPOP no corresponden directamente al ancho inducido del pseudoárbol de aristas cruzadas. En cambio, utilizamos un método de tiempo polinómico para calcular el tamaño máximo de computación y utilidad del mensaje para un pseudoárbol de bordes cruzados dado. Una descripción de este método y el proceso de selección de pseudodendrogramas aparece en la Sección 5. Al final de la primera fase, cada agente conoce a su padre, hijos, pseudo-padres, pseudo-hijos, padres de rama e hijos de rama. 4.1 Fusión de Ramas y Propagación de Utilidad En el algoritmo DPOP original, un nodo X solo tenía funciones de utilidad que involucraban a su padre y a sus pseudo-padres. En DCPOP, se permite que un nodo X tenga una función de utilidad que involucre a un padre de rama. El concepto de una rama se puede ver en la Figura 2 con el nodo E representando nuestro nodo X. Las dos rutas distintas desde el nodo E hasta el nodo B se llaman ramas de E. El único nodo donde se encuentran todas las ramas de E es el nodo B, que se llama punto de fusión de E. Los agentes con nodos que tienen padres de rama comienzan enviando un mensaje de propagación de utilidad a cada padre de rama. Este mensaje incluye un hipercubo de utilidad bidimensional con dominios para el nodo X y el nodo padre de la rama BP(X). También incluye una estructura de información de rama que contiene el nodo de origen de la rama, X, el número total de ramas que se originan en X y el número de ramas que se originan en X y se fusionan en una representación única por esta estructura de información de rama (este número comienza en 1). Intuitivamente, cuando el número de ramas fusionadas es igual al número total de ramas originales, el algoritmo ha alcanzado el punto de fusión para X. En la Figura 2, el nodo E envía un mensaje de propagación de utilidad a su nodo padre de rama, el nodo D. Este mensaje tiene dimensiones para los dominios de E y D, e incluye información de rama con un origen en E, 2 ramas totales y 1 rama fusionada. Como en la fase de propagación de utilidad de la utilidad DPOP original, un agente en el nodo hoja X envía un mensaje de propagación de utilidad a su padre. En DCPOP, este mensaje contiene dimensiones para los dominios de P(X) y PP(X). Si el nodo X también tiene padres de rama, entonces el mensaje de propagación de utilidad también contiene una dimensión para el dominio de X e incluirá una estructura de información de rama. En la Figura 2, el nodo E envía un mensaje de propagación de utilidad a su padre, el nodo C. Este mensaje tiene dimensiones para los dominios de E y C, e incluye información de rama con un origen en E, 2 ramas en total y 1 rama fusionada. Cuando un nodo Y recibe mensajes de propagación de utilidad de todos de The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), 743 sus hijos y sus hijos de rama, fusiona cualquier rama con el mismo nodo de origen X. La estructura de información de la rama fusionada acumula el número de ramas fusionadas para X. Si el número total acumulado de ramas fusionadas es igual al número total de ramas, entonces Y es el punto de fusión para X. Esto significa que los hipercubos de utilidad presentes en Y contienen toda la información sobre las valoraciones de las funciones de utilidad que involucran al nodo X. Además de la eliminación típica del dominio de Y de los hipercubos de utilidad, ahora podemos eliminar de forma segura el dominio de X de los hipercubos de utilidad. Para ilustrar este proceso, examinaremos lo que sucede en la segunda fase para el nodo B en la Figura 2. En la segunda fase, el Nodo B recibe dos mensajes de propagación de utilidad. El primero proviene del nodo C e incluye dimensiones para los dominios E, B y A. También tiene una estructura de información de ramas con origen en E, 2 ramas en total y 1 rama fusionada. El segundo proviene del nodo D e incluye dimensiones para los dominios E y B. También tiene una estructura de información de rama con origen en E, 2 ramas en total y 1 rama fusionada. El nodo B luego fusiona las estructuras de información de rama de ambos mensajes porque tienen la misma procedencia, el nodo E. Dado que el número de ramas fusionadas que provienen de E es ahora 2 y el total de ramas que provienen de E es 2, el nodo B elimina las dimensiones para el dominio E. El nodo B también elimina la dimensión para su propio dominio, dejando solo información sobre el dominio A. Luego, el nodo B envía un mensaje de propagación de utilidad al nodo A, que contiene solo una dimensión para el dominio de A. Aunque no sea posible en DPOP, este método de propagación de utilidad y eliminación de dimensiones puede producir hipercubos en el nodo Y que no comparten ningún dominio. En DCPOP no unimos hipercubos independientes de dominio, sino que en su lugar podemos enviar múltiples hipercubos en el mensaje de propagación de utilidad enviado al padre de Y. Este enfoque perezoso de las uniones ayuda a reducir el tamaño de los mensajes. 4.2 Propagación de valores Al igual que en DPOP, la propagación de valores comienza cuando el agente en el nodo raíz Z ha recibido todos los mensajes de sus hijos. En este punto, el agente en el nodo Z elige la asignación para su dominio que tiene la mejor utilidad. Si Z es el punto de fusión de las ramas de algún nodo X, Z también elegirá la asignación para el dominio de X. Por lo tanto, cualquier nodo que sea un punto de fusión elegirá asignaciones para un dominio que no sea el suyo propio. Estas tareas luego se pasan por la jerarquía de la cadena de mando principal. Si el nodo X en la jerarquía tiene padres de rama, entonces el mensaje de asignación de valor de P(X) contendrá una asignación para el dominio de X. Cada nodo en la jerarquía agrega cualquier tarea que haya elegido a las que recibió y pasa el conjunto de tareas a sus hijos. El algoritmo está completo cuando todos los nodos han elegido o recibido una asignación para su dominio. 4.3 Prueba de Corrección Demostraremos la corrección de DCPOP notando primero que DCPOP extiende completamente DPOP y luego examinando los dos casos para la asignación de valores en DCPOP. Dado un pseudoárbol tradicional como entrada, la ejecución del algoritmo DCPOP es idéntica a DPOP. Usando un arreglo de pseudodendrograma tradicional, ningún nodo tiene padres de rama o hijos de rama, ya que todas las aristas son aristas de retroceso o aristas de árbol. Por lo tanto, el algoritmo DCPOP utilizando un pseudoárbol tradicional envía solo mensajes de propagación de utilidad que contienen dominios pertenecientes al padre o pseudo-padres de un nodo. Dado que ningún nodo tiene ramas-padres, no existen ramas, y por lo tanto ningún nodo sirve como punto de fusión para ningún otro nodo. Por lo tanto, todas las asignaciones de propagación de valor se eligen en el nodo del dominio de la asignación. Para la ejecución de DCPOP con pseudárboles de bordes cruzados, algunos nodos actúan como puntos de fusión. Observamos que cualquier nodo X que no sea un punto de fusión asigna su valor exactamente como en DPOP. El hipercubo de utilidad local en X contiene dominios para X, P(X), PP(X) y BC(X). Como en DPOP, el mensaje de asignación de valores recibido en X incluye los valores asignados a P(X) y PP(X). Además, dado que X no es un punto de fusión, todas las asignaciones a BC(X) deben haber sido calculadas en puntos de fusión más altos en el árbol y están en el mensaje de asignación de valor de P(X). Por lo tanto, después de eliminar los dominios para los cuales se conocen las asignaciones, solo queda el dominio de X. El agente en el nodo X ahora puede elegir correctamente la asignación con la máxima utilidad para su propio dominio. Si el nodo X es un punto de fusión para alguna rama-hijo Y, sabemos que X debe ser un nodo a lo largo del camino desde Y hasta la raíz, y desde P(Y) y todos los BP(Y) hasta la raíz. A partir del algoritmo, sabemos que Y necesariamente tiene toda la información de C(Y), PC(Y) y BC(Y) ya que espera sus mensajes. El nodo X tiene información sobre todos los nodos debajo de él en el árbol, lo cual incluiría a Y, P(Y), BP(Y) y aquellos PP(Y) que están debajo de X en el árbol. Para cualquier PP(Y) por encima de X en el árbol, X recibe la asignación para el dominio de PP(Y) en el mensaje de asignación de valor de P(X). Por lo tanto, X tiene información de utilidad sobre todas las funciones de utilidad de las cuales Y forma parte. Al eliminar los dominios incluidos en el mensaje de asignación de valor, el nodo X se queda con un hipercubo de utilidad local con dominios para X e Y. El agente en el nodo X ahora puede elegir correctamente las asignaciones con la máxima utilidad para los dominios de X e Y. 4.4 Análisis de complejidad La primera fase de DCPOP envía un mensaje a cada P(X), PP(X) y BP(X). La segunda fase envía un mensaje de asignación de valor a cada C(X). Por lo tanto, DCPOP produce un número lineal de mensajes con respecto al número de aristas (funciones de utilidad) en el pseudoárbol de aristas cruzadas y la instancia original de DCOP. La complejidad real de DCPOP depende de dos medidas adicionales: el tamaño del mensaje y el tamaño de la computación. El tamaño del mensaje y el tamaño de la computación en DCPOP dependen del número de ramas superpuestas, así como del número de aristas de retroceso superpuestas. Se demostró en [6] que el número de aristas traslapadas es igual al ancho inducido del pseudoárbol. En un pseudoárbol de bordes cruzados mal construido, el número de ramas superpuestas en el nodo X puede ser tan grande como el número total de descendientes de X. Por lo tanto, el tamaño total del mensaje en DCPOP en una instancia mal construida puede ser exponencial en el espacio en el número total de nodos en el grafo. Sin embargo, en la práctica, un pseudoárbol bien construido con bordes cruzados puede lograr resultados mucho mejores. Más tarde abordaremos el tema de elegir pseudobosques cruzados bien construidos de un conjunto. Introducimos una medida adicional del costo máximo de la ruta secuencial a través del algoritmo. Esta medida se relaciona directamente con la cantidad máxima de paralelismo que puede lograr el algoritmo. Para tomar esta medida, primero almacenamos el tamaño total de cálculo para cada nodo durante las fases dos y tres. Este tamaño de cálculo representa el número de accesos individuales a un valor en un hipercubo en cada nodo. Por ejemplo, una unión entre dos dominios de tamaño 4 cuesta 4 ∗ 4 = 16. Dos grafos acíclicos dirigidos (DAG) pueden ser dibujados; uno con los mensajes de propagación de utilidad como aristas y los costos de la fase dos en los nodos, y el otro con los mensajes de asignación de valor y los costos de la fase tres en los nodos. El costo máximo del camino secuencial es igual a la suma del camino más largo en cada DAG desde la raíz hasta cualquier nodo hoja. HEURÍSTICAS En nuestra evaluación de la complejidad en DCPOP nos enfocamos en el peor caso posiblemente producido por el algoritmo. Reconocemos 744 La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Algoritmo 1 DCPOP Algoritmo 1: DCPOP(X; D; U) Cada agente Xi ejecuta: Fase 1: creación de pseudotree 2: elegir líder de todos los Xj ∈ X 3: líder elegido inicia la creación de pseudotree 4: después, Xi conoce P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) y PC(Xi) Fase 2: propagación de mensajes UTIL 5: si |BP(Xi)| > 0 entonces 6: BRANCHXi ← |BP(Xi)| + 1 7: para todos Xk ∈BP(Xi) hacer 8: UTILXi (Xk) ← Calcular utils(Xi, Xk) 9: Enviar mensaje(Xk,UTILXi (Xk),BRANCHXi ) 10: si |C(Xi)| = 0 (es decir, Si Xi es un nodo hoja, entonces 11: UTILXi (P(Xi)) ← Calcular utils(P(Xi),PP(Xi)) para todos los PP(Xi) 12: Enviar mensaje(P(Xi), UTILXi (P(Xi)), BRANCHXi ) 13: Enviar mensaje(PP(Xi), UTIL vacío, BRANCH vacío) a todos los PP(Xi) 14: Activar el manejador de mensajes UTIL() Fase 3: Propagación de mensajes de VALOR 15: Activar el manejador de mensajes de VALOR() FIN ALGORITMO Manejador de mensajes UTIL(Xk, UTILXk (Xi), BRANCHXk ) 16: Almacenar UTILXk (Xi), BRANCHXk (Xi) 17: Si han llegado mensajes UTIL de todos los hijos y los hijos de la rama, entonces 18: Para todos los Bj ∈ BRANCH(Xi) hacer 19: Si Bj está fusionado, entonces 20: Unir todos los hipercubos donde Bj ∈ UTIL(Xi) 21: Eliminar Bj del hipercubo unido 22: Si P(Xi) == nulo (eso significa que Xi es la raíz) entonces 23: v ∗ i ← Elegir óptimo(nulo) 24: Enviar VALOR(Xi, v ∗ i) a todos los C(Xi) 25: De lo contrario 26: UTILXi (P(Xi)) ← Calcular utils(P(Xi), PP(Xi)) 27: Enviar mensaje(P(Xi), UTILXi (P(Xi)), BRANCHXi (P(Xi))) Manejador de mensajes de VALOR(VALORXi , P(Xi)) 28: Agregar todos los Xk ← v ∗ k ∈ VALORXi , P(Xi) a la vista del agente 29: Xi ← v ∗ i = Elegir óptimo(vista del agente) 30: Enviar VALORXl , Xi a todos los Xl ∈ C(Xi) que en problemas del mundo real la generación del pseudoárbol tiene un impacto significativo en el rendimiento real. El problema de encontrar la mejor pseudotree para una instancia de DCOP dada es NP-Difícil. Por lo tanto, se utiliza una heurística para la generación, y el rendimiento del algoritmo depende del pseudoárbol encontrado por la heurística. Algunas investigaciones previas se centraron en encontrar heurísticas para generar buenas pseudorboles [8]. Si bien hemos desarrollado algunas heurísticas que generan buenos pseudoárboles cruzados para usar con DCPOP, nuestro enfoque ha sido utilizar múltiples heurísticas y luego seleccionar el mejor pseudo Consideramos solo heurísticas que se ejecuten en tiempo polinómico con respecto al número de nodos en la instancia original del DCOP. El algoritmo DCPOP actual tiene una complejidad exponencial en el peor de los casos, pero podemos calcular el tamaño máximo del mensaje, el tamaño de la computación y el costo de la ruta secuencial para un pseudoárbol de bordes cruzados dado en complejidad espacio-temporal lineal. Para hacer esto, simplemente ejecutamos el algoritmo sin intentar calcular ninguno de los hipercubos de utilidad local o asignaciones de valor óptimo. En cambio, los mensajes incluyen información dimensional y de ramificación pero no hipercubos de utilidad. Después de que cada heurística complete la generación de un pseudoárbol, ejecutamos el procedimiento de medición y propagamos la información de la medición hasta la raíz elegida en ese pseudo La raíz luego transmite la complejidad total de esa heurística a todos los nodos. Después de que todas las heurísticas hayan tenido la oportunidad de completarse, cada nodo sabe qué heurística produjo el mejor pseudoárbol. Cada nodo luego procede a comenzar el algoritmo DCPOP utilizando su conocimiento del pseudoárbol generado por la mejor heurística. Las heurísticas utilizadas para generar pseudárboles tradicionales realizan un recorrido DFS distribuido. El algoritmo distribuido general utiliza un mecanismo de paso de token y un número lineal de mensajes. Las heurísticas mejoradas basadas en DFS utilizan un procedimiento especial para elegir el nodo raíz, y también proporcionan una función de ordenación sobre los vecinos de un nodo para determinar el orden de la recursión de caminos. Las heurísticas basadas en DFS utilizadas en nuestros experimentos provienen del trabajo realizado en [4, 8]. 5.1 La heurística de pseudotree cruzado de mejor primer recorrido. Las heurísticas utilizadas para generar pseudárboles cruzados realizan un recorrido de mejor primer recorrido. Se presenta un algoritmo general distribuido de mejor primero para la expansión de nodos en el Algoritmo 2. Una función de evaluación en cada nodo proporciona los valores que se utilizan para determinar el siguiente mejor nodo a expandir. Ten en cuenta que en este algoritmo cada nodo solo intercambia su mejor valor con sus vecinos. En nuestros experimentos utilizamos varias funciones de evaluación que tomaban como argumentos una lista ordenada de ancestros y un nodo, que contiene una lista de vecinos (con la profundidad de colocación de cada vecino en el árbol). A partir de estos podemos calcular los padres de la rama, los hijos de la rama y las relaciones desconocidas para una posible ubicación del nodo. La mejor función general calculó el valor como ancestros - (padres de rama + hijos de rama) con el número de relaciones desconocidas como criterio de desempate. Después de completarse, cada nodo tiene conocimiento de su padre y ancestros, por lo que puede determinar fácilmente qué nodos conectados son pseudo-padres, padres de rama, pseudo-hijos e hijos de rama. La complejidad de la travesía de mejor primero depende de la complejidad de la función de evaluación. Suponiendo una complejidad de O(V) para la función de evaluación, que es el caso de nuestra mejor función general, el recorrido de mejor primero es O(V · E), lo que en el peor de los casos es O(n3). Para cada v ∈ V realizamos una operación de colocación y encontramos el siguiente nodo a colocar usando la operación getBestNeighbor. La complejidad de la operación del lugar es a lo sumo O(V) debido a los mensajes enviados. Encontrar el siguiente nodo utiliza recursión y recorre solo los ya colocados The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 745 Algoritmo 2 Algoritmo de Búsqueda Distribuida de Mejor Primero root ← líder elegido next(root, ∅) place(nodo, padre) nodo.padre ← padre nodo.ancestros ← padre.ancestros ∪ padre enviar mensaje de ubicación (nodo, nodo.ancestros) a todos los vecinos de nodo next(actual, anterior) si actual no está ubicado entonces place(actual, anterior) next(actual, ∅) else mejor ← obtenerMejorVecino(actual, anterior) si mejor = ∅ entonces si anterior = ∅ entonces terminar, todos los nodos están ubicados next(anterior, ∅) else next(mejor, actual) obtenerMejorVecino(actual, anterior) mejor ← ∅; puntaje ← 0 para todo n ∈ vecinos de actual hacer si n! = anterior entonces si n está ubicado entonces puntajeN ← obtenerMejorVecino(n, actual) else puntajeN ← evaluar(actual, n) si puntajeN > puntaje entonces puntaje ← puntajeN mejor ← n return mejor, puntaje nodos, por lo que tiene O(V) recursiones. Cada recursión realiza una operación recursiva getBestNeighbor que recorre todos los nodos colocados y sus vecinos. Esta operación es O(V · E), pero los resultados se pueden almacenar en caché utilizando solo O(V) espacio en cada nodo. Así que tenemos O(V ·(V +V +V ·E)) = O(V 2 ·E). Si somos inteligentes al evaluar los cambios locales cuando cada nodo recibe mensajes de ubicación de sus vecinos y almacenamos en caché los resultados, la operación getBestNeighbor es solo O(E). Esto aumenta la complejidad de la operación de ubicación, pero para todas las ubicaciones la complejidad total es solo O(V · E). Por lo tanto, tenemos una complejidad general de O(V ·E+V ·(V +E)) = O(V ·E). 6. COMPARACIÓN DE COMPLEJIDAD EN DPOP Y DCPOP Ya hemos demostrado que, dado el mismo input, DCPOP se desempeña igual que DPOP. También hemos demostrado que podemos predecir con precisión el rendimiento de un pseudoárbol dado en complejidad temporal lineal. Si usamos un número constante de heurísticas para generar el conjunto de pseudobosques, podemos elegir el mejor pseudobosque con complejidad lineal en espacio y tiempo. Ahora demostraremos que existe una instancia de DCOP para la cual un pseudoárbol de bordes cruzados supera a todos los posibles pseudoárboles tradicionales (basados en heurísticas de recorrido de bordes). En la Figura 3(a) tenemos una instancia de DCOP con seis nodos. Este es un grafo bipartito con cada partición completamente conectada a la otra (a) (b) (c) Figura 3: (a) La instancia de DCOP (b) Un arreglo de pseudobosque tradicional para la instancia de DCOP (c) Un arreglo de pseudobosque con aristas cruzadas para la partición de la instancia de DCOP. En la Figura 3(b) vemos un arreglo tradicional de pseudotree para esta instancia de DCOP. Es fácil ver que cualquier heurística basada en el recorrido de aristas no puede expandir dos nodos de la misma partición sucesivamente. También observamos que ningún nodo puede tener más de un hijo porque cualquier disposición de este tipo sería un pseudoárbol inválido. Por lo tanto, cualquier disposición tradicional de pseudodendrograma para esta instancia de DCOP debe tener la forma de la Figura 3(b). Podemos ver que las aristas de retroceso F-B y F-A se superponen al nodo C. El nodo C también tiene un padre E y una arista de retroceso con D. Utilizando el algoritmo DPOP original (o DCPOP ya que son idénticos en este caso), encontramos que el cálculo en el nodo C implica cinco dominios: A, B, C, D y E. En contraste, el arreglo de pseudonodos con aristas cruzadas en la Figura 3(c) requiere un máximo de cuatro dominios en cualquier cálculo durante DCPOP. Dado que el nodo A es el punto de fusión de las ramas tanto de B como de C, podemos ver que cada uno de los nodos D, E y F tiene dos ramas superpuestas. Además, cada uno de estos nodos tiene al nodo A como su padre. Usando el algoritmo DCPOP, encontramos que el cálculo en el nodo D (o E o F) implica cuatro dominios: A, B, C y D (o E o F). Dado que no se puede crear una disposición de pseudobosque tradicional mejor utilizando una heurística de recorrido de aristas, hemos demostrado que DCPOP puede superar a DPOP incluso si utilizamos el pseudobosque óptimo encontrado a través del recorrido de aristas. Reconocemos que los arreglos de pseudodistribución de árboles que permiten relaciones padre-hijo sin una restricción real pueden resolver el problema en la Figura 3(a) con un tamaño de cálculo máximo de cuatro dominios. Sin embargo, las heurísticas actuales utilizadas con DPOP no producen tales pseudobosques, y sería difícil distribuir una heurística así, ya que cada nodo requeriría información sobre nodos con los que no tiene restricciones. Además, aunque no lo demostramos aquí, los pseudobosques de bordes cruzados pueden producir tamaños de mensaje más pequeños que tales pseudobosques, incluso si el tamaño de la computación es similar. En la práctica, dado que encontrar la mejor disposición de pseudoramas es NP-Difícil, observamos que las heurísticas que producen pseudoramas con aristas cruzadas a menudo generan tamaños de cálculo y mensajes significativamente más pequeños. 7. RESULTADOS EXPERIMENTALES 746 El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Los métricos de rendimiento existentes para algoritmos DCOP incluyen el número total de mensajes, ciclos de reloj síncronos y tamaño de mensaje. Ya hemos demostrado que el número total de mensajes es lineal con respecto al número de restricciones en la instancia de DCOP. También introdujimos el costo de camino secuencial máximo (PC) como una medida de la máxima cantidad de paralelismo alcanzable por el algoritmo. El costo máximo de la ruta secuencial es igual a la suma de los cálculos realizados en la ruta más larga desde la raíz hasta cualquier nodo hoja. También incluimos como métricas el tamaño máximo de cálculo en número de dimensiones (CD) y el tamaño máximo de mensaje en número de dimensiones (MD). Para analizar la complejidad relativa de una instancia DCOP dada, encontramos el ancho inducido mínimo (IW) de cualquier pseudobosque tradicional producido por una heurística para el DPOP original. 7.1 Instancias genéricas de DCOP Para nuestras pruebas iniciales generamos aleatoriamente dos conjuntos de problemas con 3000 casos en cada uno. Cada problema fue generado asignando un número aleatorio (elegido de un rango) de restricciones a cada variable. El generador luego creó restricciones binarias hasta que cada variable alcanzó su número máximo de restricciones. El primer conjunto utiliza 20 variables, y el mejor DPOP IW varía de 1 a 16 con un promedio de 8.5. El segundo conjunto utiliza 100 variables, y el mejor DPOP IW osciló entre 2 y 68 con un promedio de 39.3. Dado que la mayoría de los problemas en el segundo conjunto eran demasiado complejos para calcular la solución, tomamos medidas de las métricas utilizando las técnicas descritas anteriormente en la Sección 5 sin resolver realmente el problema. Los resultados se muestran para el primer conjunto en la Tabla 1 y para el segundo conjunto en la Tabla 2. Para los dos conjuntos de problemas dividimos los casos en categorías de baja densidad y alta densidad. Los casos de baja densidad consisten en aquellos problemas que tienen un mejor DPOP IW menor o igual a la mitad del número total de nodos (por ejemplo, IW ≤ 10 para los problemas de 20 nodos e IW ≤ 50 para los problemas de 100 nodos. Los problemas de alta densidad consisten en el resto de los conjuntos de problemas. En ambas Tabla 1 y Tabla 2 hemos enumerado las métricas de rendimiento para el algoritmo DPOP original, el algoritmo DCPOP utilizando solo pseudobosques de bordes cruzados (DCPOP-CE), y el algoritmo DCPOP utilizando pseudobosques tradicionales y de bordes cruzados (DCPOP-All). Los pseudobosques utilizados para DPOP fueron generados utilizando 5 heurísticas: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB y DFS MCN BEC. Estas son todas las versiones del recorrido DFS guiado discutidas en la Sección 5. Los pseudobosques de bordes cruzados utilizados para DCPOP-CE fueron generados utilizando 5 heurísticas: MCN, LCN, MCN A-B, LCN A-B y LCSG A-B. Estas son todas las versiones del recorrido de mejor primero discutidas en la Sección 5. Para tanto DPOP como DCPOP-CE elegimos el mejor pseudoárbol producido por sus respectivas 5 heurísticas para cada problema en el conjunto. Para DCPOP-All elegimos la mejor pseudotree producida por las 10 heurísticas para cada problema en el conjunto. Para las métricas de CD y MD, el valor mostrado es el número promedio de dimensiones. Para la métrica de PC, el valor mostrado es el logaritmo natural del costo de ruta secuencial máximo (ya que el valor real crece exponencialmente con la complejidad del problema). La última fila en ambas tablas es una medida de mejora de DCPOP-All sobre DPOP. Para las métricas CD y MD, el valor mostrado es una reducción en el número de dimensiones. Para la métrica de PC, el valor mostrado es una reducción porcentual en el costo máximo de la ruta secuencial (% = DP OP −DCP OP DCP OP ∗ 100). Observa que DCPOP supera a DPOP en todas las métricas. Esto se sigue lógicamente de nuestra afirmación anterior de que, dada la misma entrada, DCPOP se comporta exactamente igual que DPOP. Así, dada la elección entre los pseudobosques producidos por las 10 heurísticas, DCPOP-All siempre superará a DCPOP-CE y DPOP. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 6: Mejora del Costo del Camino DCPOP Reunión Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Tabla 3: Problemas de Programación de Reuniones realizan DPOP. Otra tendencia que observamos es que la mejora es mayor para problemas de alta densidad que para problemas de baja densidad. Mostramos esta tendencia con mayor detalle en las Figuras 4, 5 y 6. Observa cómo la mejora aumenta a medida que aumenta la complejidad del problema. 7.2 Problema de Programación de Reuniones Además de nuestras pruebas genéricas iniciales de DCOP, realizamos una serie de pruebas en el Problema de Programación de Reuniones (MSP) como se describe en [6]. La configuración del problema incluye un número de personas agrupadas en departamentos. Cada persona debe asistir a un número específico de reuniones. Las reuniones pueden llevarse a cabo dentro de los departamentos o entre departamentos, y pueden asignarse a uno de los ocho horarios disponibles. El MSP se mapea a una instancia de DCOP donde cada variable representa el intervalo de tiempo en el que una persona específica asistirá a una reunión específica. Todas las variables que pertenecen a la misma persona tienen restricciones de exclusión mutua para que la persona no pueda asistir a más de una reunión durante el mismo intervalo de tiempo. Todas las variables que pertenecen a la misma reunión tienen restricciones de igualdad para que todos los participantes elijan el mismo horario. Se imponen restricciones unarias en cada variable para tener en cuenta la valoración de una persona de cada reunión y franja horaria. Para nuestros tests generamos 100 problemas de muestra para cada combinación de agentes y reuniones. Los resultados se muestran en la Tabla 3. Los valores en las primeras cinco columnas representan (en orden de izquierda a derecha), el número total de agentes, el número total de reuniones, el número total de variables, el promedio total de restricciones y el promedio mínimo de IW producido por un pseudoárbol tradicional. Las últimas tres columnas muestran las mismas métricas que utilizamos para las instancias genéricas de DCOP, excepto que esta vez solo mostramos las mejoras de DCPOP-All sobre DPOP. El rendimiento es mejor en promedio para todas las instancias de MSP, pero nuevamente vemos mejoras más grandes para instancias de problemas más complejos. 8. CONCLUSIONES Y TRABAJO FUTURO Presentamos un algoritmo completo y distribuido que resuelve instancias generales de DCOP utilizando arreglos de pseudoramas cruzados. Nuestro algoritmo extiende el algoritmo DPOP al agregar mensajes adicionales de propagación de utilidad e introducir el concepto de fusión de ramas durante la fase de propagación de utilidad. Nuestro algoritmo también permite que las asignaciones de valor ocurran en puntos de fusión de nivel superior para nodos de nivel inferior. Hemos demostrado que DCPOP extiende completamente DPOP al realizar las mismas operaciones dadas las mismas entradas. También hemos demostrado a través de algunos ejemplos y datos experimentales que DCPOP puede lograr un mejor rendimiento para algunas instancias del problema al extender el conjunto de entrada permitido para incluir pseudobosques cruzados. Damos especial énfasis al papel que desempeñan las heurísticas de recorrido de bordes en la generación de pseudobosques. Hemos demostrado que la penalización en el rendimiento es mínima para generar múltiples heurísticas, y que podemos elegir el mejor pseudoárbol generado en complejidad lineal de espacio-tiempo. Dada la importancia de un buen pseudoárbol para el rendimiento, el trabajo futuro incluirá nuevas heurísticas para encontrar mejores pseudo El trabajo futuro también incluirá adaptar las extensiones existentes de DPOP [5, 7] que soportan diferentes dominios de problemas para su uso con DCPOP. 9. REFERENCIAS [1] J. Liu y K. P. Sycara. Explotando la estructura del problema para la optimización distribuida de restricciones. En V. Lesser, editor, Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 246-254, San Francisco, CA, 1995. MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, y S. Kulkarni. Un enfoque dinámico distribuido de satisfacción de restricciones para la asignación de recursos. Notas de conferencia en Ciencias de la Computación, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe y M. Yokoo. Un método completo asíncrono para la optimización de restricciones distribuidas. En AAMAS 03, 2003. [4] A. Petcu. Frodo: Un marco para la optimización de restricciones abiertas/distribuidas. Informe técnico No. 2006/001, Instituto Federal Suizo de Tecnología (EPFL), Lausana (Suiza), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu y B. Faltings. A-dpop: Aproximaciones en optimización distribuida. En póster en CP 2005, páginas 802-806, Sitges, España, octubre de 2005. [6] A. Petcu y B. Faltings. Dpop: Un método escalable para la optimización de restricciones multiagente. En IJCAI 05, páginas 266-271, Edimburgo, Escocia, agosto de 2005. [7] A. Petcu, B. Faltings y D. Parkes. M-dpop: Implementación distribuida fiel de problemas eficientes de elección social. En AAMAS 06, páginas 1397-1404, Hakodate, Japón, mayo de 2006. [8] G. Ushakov. Resolviendo problemas de programación de reuniones utilizando un procedimiento de optimización distribuido de pseudobosque. Tesis de maestría, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida y K. Kuwabara. Satisfacción de restricciones distribuida para formalizar la resolución de problemas distribuidos. En la Conferencia Internacional sobre Sistemas de Computación Distribuida, páginas 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida y K. Kuwabara. El problema de satisfacción de restricciones distribuidas: Formalización y algoritmos. Ingeniería del Conocimiento y de Datos, 10(5):673-685, 1998. 748 La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)