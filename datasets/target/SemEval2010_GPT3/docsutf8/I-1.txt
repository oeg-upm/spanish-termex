Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra "tarea" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. CAN proporciona un constructo de objetivo explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo. Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2]. En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un constructo de objetivo. Esto se denota por Objetivo ` φs, P, φf ´, donde φs es la condición de éxito que determina cuándo se considera que el objetivo se ha logrado, φf es una condición de fracaso bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es un programa para lograr el objetivo, que se abortará una vez que φs o φf se vuelvan verdaderos. El comportamiento de un agente está especificado por una biblioteca de planes, denotada por Π, que consiste en una colección de cláusulas de planes de la forma e : c ← P, donde e es un evento, c es una condición de contexto (una fórmula lógica sobre las creencias de los agentes que debe ser verdadera para que el plan sea aplicable) y P es el cuerpo del plan. El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Objetivo ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 Un c omitido es equivalente a verdadero. Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figura 1: Reglas operativas de CAN. donde P1, . . . , Pn son ellos mismos programas, act es una acción primitiva que no está más especificada, y +b y −b son operaciones para añadir y eliminar creencias. La base de creencias contiene átomos de creencias fundamentales en forma de relaciones de primer orden, pero podría ser extendida ortogonalmente a otras lógicas. Se asume que se proporcionan operaciones bien definidas para verificar si una condición se sigue de un conjunto de creencias (B |= c), para agregar una creencia a un conjunto de creencias (B ∪ {b}), y para eliminar una creencia de un conjunto de creencias (B \ {b}). ?φ es una prueba para la condición φ, y !e5 es un evento6 que se publica desde dentro del programa. Los constructos compuestos son secuenciación (P1; P2), ejecución paralela (P1 P2) y metas (Meta ` φs, P, φf ´ ). Lo anterior define el idioma del usuario. Además, se utilizan un conjunto de formas compuestas auxiliares internamente al asignar semántica a los constructos. nil es el programa básico (terminante). Cuando un evento coincide con un conjunto de cláusulas de plan, estas se recopilan en un conjunto de alternativas protegidas (c1: P1, ..., cn: Pn). La otra forma compuesta auxiliar, , es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló. Un resumen de la semántica operacional para CAN de acuerdo con [23] y siguiendo algunas de las simplificaciones de [17] es el siguiente. Una configuración básica S = B, G, Γ consiste en la base de creencias actual B del agente, el conjunto actual de metas G que se persiguen (es decir, un conjunto de fórmulas) y el programa actual P que se está ejecutando (es decir, la intención actual). Una transición S0 −→ S1 especifica que ejecutar S0 durante un paso único produce la configuración S1. S0 −→∗ Sn es el cierre reflexivo transitivo usual de −→: Sn es el resultado de una o más transiciones de un solo paso. Una regla de derivación S −→ Sr S −→ Sr consiste en un conjunto (posiblemente vacío) de premisas, que son transiciones junto con algunas condiciones auxiliares (numerador), y una única transición conclusión derivable de estas premisas (denominador). La Figura 1 muestra algunas de las reglas operativas. La regla de Evento maneja eventos de tarea recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula de plan e : ψi ← Pi, si hay un unificador más general, θ = mgu(e, e) de e y el evento en 5 Donde es obvio que e es un evento, a veces excluiremos el signo de exclamación para mayor legibilidad. 6 Típicamente un objetivo de logro. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 11 B |= φs B, Objetivo ` φs, P, φf ´ −→ B, verdadero Gs B |= φf B, Objetivo ` φs, P, φf ´ −→ B, falla Gf P = Objetivo ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Objetivo ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Objetivo ` φs, P, φf ´ −→ B , Objetivo ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {verdadero, falla} B, Objetivo ` φs, P, φf ´ −→ B, Objetivo ` φs, P2 £ P2, φf ´ GR Figura 2: Reglas para objetivos en CAN. pregunta, entonces la regla construye una alternativa guardada ψiθ: Piθ. La regla Select selecciona un cuerpo de plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P Δ establece que el programa P debe intentarse primero, recurriendo a las alternativas restantes, Δ \ P, si es necesario. Esta regla y la regla de fallo se utilizan juntas para el manejo de fallos: si el programa actual Pi de una cláusula de plan para una tarea falla, primero se aplica la regla de fallo, y luego, si es posible, la regla Select elegirá otra alternativa aplicable para la tarea si existe alguna. Rule Sequence maneja la secuenciación de programas de la manera habitual. Las reglas Parallel1 y Parallel2 definen la posible intercalación al ejecutar dos programas en paralelo. La Figura 2 presenta reglas simplificadas para tratar con objetivos, en línea con las presentadas en [17]. La primera regla establece que un objetivo tiene éxito cuando φs se vuelve verdadero; la segunda regla establece que un objetivo falla cuando φf se vuelve verdadero. La tercera regla GI inicializa la ejecución de un programa de metas actualizando la base de metas y estableciendo el programa en la meta como P £ P; el primer P se ejecutará y el segundo P se utiliza para hacer un seguimiento del programa original para la meta. La cuarta regla GS ejecuta un solo paso del programa de objetivos. La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) cada vez que el programa actual ha terminado pero el objetivo deseado y aún posible no se ha logrado. 4.2 Abortando Intenciones y Manejando Fallas A continuación, introducimos la capacidad de especificar programas manejadores, en forma de métodos de falla y aborto, que se ocupan de la limpieza requerida cuando un programa dado falla o es abortado. No asociamos los métodos de falla y aborto con cláusulas de plan o con tareas (eventos), sino que introducimos una nueva construcción de programa que especifica los métodos de falla y aborto para un programa arbitrario. El constructo FAb(P, PF, PA) ejecuta el programa P. En caso de que P falle, ejecuta el programa de manejo de fallos PF; si P necesita ser abortado, ejecuta el programa de manejo de aborto PA. Por lo tanto, para agregar los métodos de falla y aborto PF y PA a una cláusula de plan e : c ← P, escribimos e : c ← FAb(P, PF, PA). Con la introducción de la capacidad de abortar programas, modificamos la construcción paralela para permitir que el fallo de una rama aborte la otra. Debemos tener en cuenta la posible existencia de métodos de aborto en la rama abortada. De manera similar, con el constructo de Objetivo ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa. Proporcionamos la semántica de un lenguaje de agente aumentado que contiene el constructo FAb al definir una transformación de origen, similar a la expansión de macros, que mapea una biblioteca de planes que contiene el constructo FAb(P, PF, PA) en CAN estándar (casi). La única extensión no estándar a CAN es un constructo de espera hasta que se cumpla una condición. Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del constructo de la Meta. Primero describimos la naturaleza general de la transformación de la fuente, que resulta ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAb, paralela y Goal. Un problema clave es que los constructos FAb pueden estar anidados, ya sea directa o indirectamente. Llamemos a cada instancia del constructo en tiempo de ejecución un posible punto de aborto (pap). Donde estos constructos están anidados, es importante que antes de que se ejecute el método de falla o aborto de un pap padre, se ejecuten primero los programas de métodos de falla o aborto de los paps hijos, como se describe anteriormente en la Sección 3. La necesidad de coordinar la ejecución de los métodos de aborto de paps anidados requiere que haya alguna forma de identificar los padres e hijos de un pap en particular. Logramos esto como parte de la transformación de origen al llevar un registro explícito del contexto de ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan. La transformación de origen reemplaza cada cláusula del plan de la forma e : c ← P con una cláusula del plan e(v) : c ← μv(P) donde v es una variable libre, no presente previamente en la cláusula del plan. Esta variable se utiliza para llevar un registro del contexto de ejecución. El valor de la variable de contexto es una lista de identificadores, donde cada nuevo párrafo está representado al anteponer un nuevo identificador al contexto. Por ejemplo, si los identificadores son enteros, el contexto de un documento puede ser representado por una lista [42, 1] y el contexto introducido por un nuevo documento puede ser representado por [52, 42, 1]. Nos referiremos a los paps por el contexto en lugar del nuevo identificador agregado, por ejemplo, por [51, 42, 1] y no solo por 51. Esto nos permite equiparar la relación de ancestro entre paps con la relación de sufijo de lista en los contextos relevantes, es decir, v es un ancestro de v si y solo si v es un sufijo de v. Para la mayoría de los constructos CAN, la variable de contexto no se utiliza o se pasa sin cambios: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) Queda por especificar la transformación μv(·) en tres casos: los constructos FAb, paralelo y Goal. Estos son más complejos en el sentido de que la fuente transformada necesita crear dinámicamente un nuevo identificador de pap, para usarlo como un nuevo contexto dentro de la construcción, y para llevar un registro de cuándo el pap está activo (es decir, actualmente en ejecución) añadiendo y eliminando creencias sobre el contexto. Introduzcamos la acción primitiva prependID(v, v) que crea un nuevo identificador pap y lo antepone a la lista v, dando como resultado la lista v. También introducimos los siguientes predicados: • a(v) - el pap v está actualmente activo. • abort(v) - el pap v debe ser abortado (después de abortar a todos sus descendientes). Una alternativa sería utilizar predicados a nivel meta que reflejen el estado actual de la estructura de intenciones. La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) • f(v) - el programa del pap v ha fallado. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))el pap v es un ancestro del pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v no tiene hijos activos. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - debemos abortar v, es decir, abort es verdadero para v o algún ancestro; sin embargo, debemos esperar hasta que no haya hijos activos de v. • san(v) ≡ sa(v) ∧ nac(v) - debemos abortar v ahora si debemos abortar v y v no tiene hijos activos. Primero consideremos el caso del constructo FAb. La idea es que, cada vez que ocurra un nuevo pap, se utiliza la acción prependID(v, v) para crear una nueva lista de identificadores de pap v a partir de la lista existente v. Luego agregamos la creencia de que v es el contexto activo, es decir, +a(v), y comenzamos a procesar el programa dentro del pap utilizando v en lugar de v como contexto. Necesitamos asegurarnos de retractar la creencia de que v está activo al final, es decir, −a(v). Utilizamos la construcción de Objetivo para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar. Mientras se ejecuta el programa P, sabemos que debemos descartar P e invocar su método de aborto si se le ha indicado a algún ancestro de P que aborte. Esto se representa por el predicado sa(v) siendo verdadero. Sin embargo, debemos asegurarnos de hacer esto solo después de que cada pap de niño haya tenido la oportunidad de invocar su método de aborto y todos estos métodos de aborto hayan sido completados: si abandonamos el programa demasiado pronto, entonces la ejecución de los métodos de aborto de los niños también será abandonada. Por lo tanto, la condición que realmente usamos en la construcción del Objetivo para probar cuándo detener el programa es san(v). Esta condición se basa en el hecho de que a medida que los niños completan sus papilas, eliminan los hechos relevantes. Nuestro uso del constructo Goal es por su capacidad de detener la ejecución de un programa cuando se cumplen ciertas condiciones. Para dejar de lado el aspecto de la repetición de la ejecución hasta que se cumpla una condición, debemos asegurarnos de que la condición de éxito o fracaso del constructo se cumpla una vez que la ejecución del programa tenga éxito o falle. Nos aseguramos de esto al retractar el hecho a(v) en caso de éxito y afirmar el hecho f(v) en caso de fracaso, y al tener las condiciones apropiadas de éxito y fracaso en el Objetivo. Por lo tanto, si falla la construcción del Objetivo, entonces el programa fue abortado o falló. Invocamos el método de fallo o aborto relevante, retiramos el hecho a(v) y luego fallamos. Al juntar todo esto, definimos formalmente μv(FAb(P, PA, PF )) de la siguiente manera, donde v es una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) En segundo lugar, debemos transformar el operador paralelo para asegurar que el fallo de una rama aborte de forma segura la otra. Aquí construimos dos nuevos contextos, v y v, a partir del contexto existente v. Si una rama falla, debe abortar la otra rama. Al final, si se abortó cualquiera de las ramas, entonces debemos fallar. Que v y v sean variables nuevas distintas de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(P1 P2) como: prependID(v, v); prependID(v, v); +a(v); +a(v); (Goal (¬a(v), (μv(P1); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v)) Goal (¬a(v), (μv(P2); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v))); ?¬abort(v) ∧ ¬abort(v) Finalmente, necesitamos modificar las ocurrencias del constructo Goal de dos maneras: primero, asegurarnos de que los métodos de manejo de aborto no se pasen por alto cuando se satisfacen las condiciones de éxito o fracaso, y segundo, activar la interrupción del programa contenido cuando se satisfacen las condiciones de éxito o fracaso. Para transformar el constructo Goal necesitamos extender el estándar CAN con un constructo de espera-hasta-condición. El constructo φ : P no ejecuta P hasta que φ se convierte en verdadero. Aumentamos el lenguaje CAN con las siguientes reglas para el operador de guardia :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false Para especificar μv(Goal ` φs, P, φf ´ ), generamos un nuevo pap y ejecutamos el programa dentro del constructo Goal en este nuevo contexto. Debemos asegurarnos de que la creencia a(v) sea eliminada, ya sea que el objetivo tenga éxito o fracase. Cambiamos la condición de éxito y fracaso del constructo Objetivo a una rama paralela utilizando el constructo de espera-hasta-condición, y modificamos el Objetivo para usar la condición de éxito debería abortar ahora san(v) como condición de éxito. La rama de espera desencadenará la interrupción del programa si se cumple tanto la condición de éxito como la de fracaso. Para evitar cualquier problema al terminar la condición de espera, también finalizamos la espera si el pap ya no está activo. Que v sea una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(Goal ` φs, P, φf ´ ) como: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) El programa P se ejecutará repetidamente hasta que san(v ) se convierta en verdadero. Hay dos formas en que esto puede ocurrir. Primero, si se cumple la condición de éxito φs o la condición de fracaso φf, entonces se ejecuta la segunda rama de la construcción en paralelo. Esto hace que abort(v) se convierta en verdadero, y, después de que se ejecuten los métodos de abortmethods descendientes, san(v) se convierte en verdadero. En este caso, P se elimina, se elimina el a(v), y todo el constructo tiene éxito o fracasa en función de φs. La segunda forma en que san(v) puede volverse verdadero es si v o uno de sus ancestros es abortado. En este caso, una vez que se ejecutan los métodos de aborto de los paps descendientes, san(v) se vuelve verdadero, P se elimina, se elimina la creencia a(v) (permitiendo que la segunda rama paralela se ejecute, instruyendo vacuamente a v a abortar), y la primera rama paralela falla (asumiendo que φs es falso). Ejemplo trabajado 4.3 Echemos un vistazo a la traducción del ejemplo de envío a IJCAI de la Sección 2. Expresaremos las tareas mediante eventos, por ejemplo, la tarea Asignar un Número de Papel la expresamos como el evento APN. Que la salida de la tarea Solicitar autorización sea Y o N, indicando la aprobación o no del gerente de Alicia, respectivamente. Entonces tenemos (al menos) las siguientes dos cláusulas de plan en CAN, para las tareas de Envío de Reunión de Apoyo y Solicitar Autorización de Despeje, respectivamente: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Tenga en cuenta que Envío de Reunión de Apoyo tiene un parámetro m, la reunión de interés (IJCAI, en nuestro ejemplo), mientras que Solicitar Autorización de Despeje no tiene parámetros. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 13. Veamos primero la traducción de la segunda cláusula del plan, para AFC, ya que es la más simple de las dos. Que v y v denoten nuevas variables. Entonces tenemos como cláusula del plan traducido: AFC(v): verdadero ← prependID(v, v); +a(v); Meta(¬a(v), (!SCR(v); !WFR(r, v); ?r = Y; −a(v) +f(v)), san(v) ∨ f(v)) (((?sa(v); !CCR(v)) nil); −a(v); ?falso) Podemos ver que se ha añadido un parámetro de contexto adicional a cada tarea y que el antiguo cuerpo del plan ahora aparece dentro de un constructo de Meta. Si el antiguo cuerpo del plan tiene éxito, la creencia a(v) se retira, lo que hace que el Objetivo tenga éxito. Si el cuerpo del plan antiguo falla, o si la tarea debe ser abortada, el constructo de Objetivo falla. Esto es seguido por la ejecución de CCR (en caso de un aborto), la retracción de a(v), y el fallo. La traducción de la primera cláusula del plan, para SMS, es más compleja, debido a la estructura paralela que introduce paps anidados: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Meta ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Meta ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Meta ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Aquí podemos ver que si la tarea !TWP(v ) falla, entonces se afirmará f(v ), lo que hará que falle la construcción de Meta que lo contiene, y llevará a que se afirme abort(v ). Si la tarea !WFR(r, v ) en la expansión de !AFC(v ) todavía se está ejecutando y no tiene paps hijos activos, entonces sa(v ) y sa(v ) serán verdaderos; sin embargo, solo san(v ) y no san(v ) serán verdaderos. Este conjunto de condiciones hará que el constructo Goal en la primera cláusula del plan falle, deteniendo la ejecución de !WFR(r, v). La tarea !CCR(v) será ejecutada. Una vez que esta tarea se complete, la creencia a(v) se retira, lo que hace que san(v) se convierta en verdadero, lo que lleva a que la primera construcción de objetivo de la segunda cláusula del plan falle. Si bien las cláusulas del plan traducido parecen complicadas, observe que la traducción de las cláusulas del plan inicial es completamente automatizada, de acuerdo con las reglas establecidas en la Sección 4.2. Las cláusulas del plan traducido, con la semántica de PUEDE aumentada por nuestra construcción de condición de esperar-hasta, especifican así la operación del agente para manejar tanto el fallo como la interrupción del ejemplo. 5. El fallo del plan se maneja en la versión extendida de AgentSpeak encontrada en el sistema Jason [6]. Los planes de limpieza de fallas se activan a partir de eventos de eliminación de objetivos −!g. Tales planes, similares a nuestros métodos de fracaso, están diseñados para que el agente efectúe cambios de estado (actúe para deshacer sus acciones anteriores) antes de posiblemente intentar otro plan para lograr el objetivo fallido g. Dados los constructos de Jason para abandonar un objetivo con una indicación de si intentar o no un plan alternativo para él, H¨ubner et al. [6] proporcionan una descripción informal de cómo un agente de Jason modifica su estructura de intenciones cuando ocurre un evento de fracaso del objetivo. En un plan de eliminación de objetivos, el programador puede especificar cualquier acción de deshacer y si intentar de nuevo el objetivo. Si no se proporciona un plan de eliminación de objetivos, el comportamiento predeterminado de Jason es no volver a intentar el objetivo. El manejo de fallos se aplica solo a los planes desencadenados por la adición de un logro o meta de prueba; en particular, los eventos de eliminación de metas no se publican por el fallo de un plan de eliminación de metas. Además, la semántica informal de [6] no considera submetas paralelas (es decir, el constructo CAN), ya que dicha ejecución no forma parte del lenguaje de Jason. La implementación de H¨ubner et al. [6] requiere acciones internas de Jason. Un requisito para implementar nuestro enfoque es una capacidad reflexiva en la implementación del agente BDI. Las implementaciones adecuadas del formalismo BDI son JACK [2], Jadex [14] y SPARK [9]. Los tres permiten métodos a nivel meta que son activados por eventos meta como la adopción de objetivos o el fracaso de un plan, y ofrecen capacidades introspectivas sobre los estados de objetivo e intención. Tales instalaciones de nivel meta también son requeridas por el enfoque de Unruh et al. [21], quienes definen la compensación semántica basada en objetivos para un agente. Los objetivos de manejo de fallos son invocados de acuerdo con las reglas de estrategia de manejo de fallos, por un agente dedicado Componente de Manejo de Fallos (FHC) que sigue la ejecución de la tarea. Estos objetivos son especificados por el programador del agente y se adjuntan a las tareas, de manera similar a cómo nuestro constructo FAb(P, PF, PA) asocia métodos de falla y aborto con un plan P. Sin embargo, cabe destacar que, a diferencia tanto de [6] como de nuestra semántica, [21] adjuntan el conocimiento de manejo de fallas a nivel de objetivo, no de plan. Sus objetivos de manejo de fallos pueden consistir en objetivos de estabilización que realicen una limpieza localizada e inmediata para restaurar el estado de los agentes a un estado conocido y estable, y objetivos de compensación que realicen acciones de deshacer. Los objetivos de compensación se activan al abortar un objetivo, y no necesariamente al fallar en el objetivo (es decir, si el FHC indica al agente que vuelva a intentar el objetivo fallido y el nuevo intento tiene éxito). El enfoque FHC se define a nivel de objetivo para facilitar la especificación abstracta del conocimiento de manejo de fallos; el FHC decide cuándo abordar un fallo y qué hacer (es decir, qué objetivos de manejo de fallos invocar), separando este conocimiento del cómo implementar acciones correctivas (es decir, qué plan ejecutar para cumplir con el objetivo de manejo de fallos adoptado). Esto contrasta con el manejo simplista de fallas a nivel de plan en el que el qué y el cómo se entrelazan en el conocimiento de la tarea del dominio. Si bien nuestro enfoque está definido a nivel de plan, nuestra semántica BDI extendida permite la separación de la ejecución y el manejo de fallos. Además, el FHC mantiene explícitamente estructuras de datos para rastrear la ejecución de agentes. Aprovechamos las estructuras de ejecución existentes y la capacidad autorreflexiva de un agente BDI para lograr tanto la interrupción como el manejo de fallos sin costos adicionales. Las reglas de estrategia de manejo de fallos de FHC (por ejemplo, si volver a intentar un objetivo fallido) son reemplazadas por instrucciones en nuestros planes de PF y PA, junto con manejadores de fallos predeterminados a nivel meta de acuerdo con la naturaleza de los agentes (por ejemplo, comprometidos ciegamente). El enfoque FHC es independiente de la arquitectura del agente en sí, a diferencia de nuestro trabajo que está dedicado al formalismo BDI (aunque no está ligado a ningún sistema de agente en particular). Por lo tanto, no se desarrollan semánticas formales en [21]; la operación de los FHCs se presenta como 14 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) un protocolo basado en estados. Este enfoque, junto con el punto de control estatal, se utiliza para sistemas multiagente en [22]. La arquitectura resultante incorpora su enfoque de manejo de fallos dentro de una arquitectura de procesamiento en pares para la recuperación de fallos de agentes. Otro trabajo sobre el manejo de excepciones multiagente incluye los agentes de manejo de excepciones distribuidos AOEXs [5], y los centinelas similares de [8]. En ambos casos, la lógica de manejo de fallos y el conocimiento están desacoplados de los agentes; en contraste, mientras se separa el manejo de excepciones del conocimiento específico del dominio, tanto el enfoque de Unruh et al. como nuestro enfoque retienen la lógica de manejo de fallos dentro de un agente. 6. CONCLUSIÓN Y TRABAJO FUTURO Las tareas y planes de un agente pueden no llegar a completarse con éxito, ya sea por la decisión del agente de abortarlos (quizás a petición de otro agente), o por factores imprevistos que llevan al fracaso. En este artículo hemos presentado un enfoque basado en procedimientos que incorpora la interrupción de tareas y planes en el ciclo de deliberación de un agente de estilo BDI, proporcionando así un enfoque unificado para el fracaso y la interrupción. Nuestra contribución principal es un análisis de los requisitos sobre la operación del agente para abortar tareas y planes, y una semántica operativa correspondiente para abortar en el lenguaje abstracto del agente CAN. Estamos planeando implementar una instancia de nuestro enfoque en el sistema de agentes SPARK [9]; en particular, el trabajo de este artículo será la base para el mecanismo de manejo de abortos de SPARK. También estamos desarrollando una herramienta de análisis para nuestra versión extendida de CAN como base para experimentación. Un agente inteligente no solo manejará con gracia tareas y planes fallidos, sino que también reflexionará sobre sus actitudes cognitivas para decidir su próximo curso de acción. Hemos asumido el comportamiento predeterminado de un agente de estilo BDI, de acuerdo con su naturaleza: por ejemplo, volver a intentar alternativas de un plan fallido hasta que uno tenga éxito o hasta que no queden planes alternativos (en cuyo caso fallar la tarea). El trabajo futuro consiste en poner nuestro enfoque al servicio de un razonamiento de agente más dinámico, como la introspección que un agente capaz de razonar sobre los efectos de la interacción de tareas y los requisitos de recursos puede lograr [19, 12]. Relacionado con esto está determinar el costo de abortar una tarea o un plan, y utilizarlo como un insumo en el proceso de deliberación. Esto influiría en particular en el compromiso que el agente tiene hacia una tarea específica: a mayor costo, mayor compromiso. Nuestra suposición de que los métodos de aborto no fallan, como se discutió anteriormente, es una suposición pragmática. Sin embargo, este es un tema que merece una mayor exploración, ya sea para desarrollar supuestos más débiles que también sean prácticos, o para analizar las condiciones bajo las cuales nuestra suposición es realista. Un elemento adicional de interés es extender nuestro enfoque al fracaso y la interrupción a los objetivos de mantenimiento [1]. Para tales objetivos, se necesita una semántica operativa diferente para la interrupción que para los objetivos de logro, para que coincida con la diferencia en la semántica de los propios objetivos. Agradecimientos Agradecemos a Lin Padgham y a los revisores anónimos por sus comentarios. El primer autor agradece el apoyo del Consejo de Investigación Australiano y del Software Orientado a Agentes bajo la subvención LP0453486. El trabajo de los dos autores en SRI International fue apoyado por la Agencia de Proyectos de Investigación Avanzada de Defensa (DARPA) bajo el Contrato No. NBCHD030010. Cualquier opinión, hallazgo, conclusión o recomendación expresada en este material son responsabilidad de los autores y no reflejan necesariamente la visión de DARPA o el Departamento del Interior-Centro Nacional de Negocios. 7. REFERENCIAS [1] L. Braubach, A. Pokahr, D. Moldt y W. Lamersdorf. Representación de objetivos para sistemas de agentes BDI. En Actas del Segundo Congreso Internacional. Taller sobre Programación de Sistemas Multiagente (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson y A. Lucas. Agentes inteligentes JACK: componentes para agentes inteligentes en Java. AgentLink News, Edición 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira y P. Henderson. Ampliando el concepto de compensación de transacciones. Revista de Sistemas de IBM, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk y J.-J. C. Meyer. Tipos de objetivos en la programación de agentes. En Proc. de AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy y E. Kendall. Aoex: Un marco de manejo de excepciones basado en agentes para construir sistemas de software confiables, distribuidos y abiertos. En Actas de la Séptima Conferencia Conjunta sobre Ingeniería de Software Basada en el Conocimiento, 2006. [6] J. F. H¨ubner, R. H. Bordini y M. Wooldridge. Programación de metas declarativas utilizando patrones de planificación. En Actas de la 4ta Conferencia Internacional. Taller sobre Lenguajes y Tecnologías Declarativos de Agentes, 2006. [7] D. Kinny. El cálculo Psi: un lenguaje algebraico de agentes. En Proc. de ATAL01, 2001. [8] M. Klein, J. A. Rodríguez-Aguilar y C. Dellarocas. Utilizando servicios de manejo de excepciones independientes del dominio para habilitar sistemas multiagente abiertos robustos: El caso de la muerte del agente. Agentes Autónomos y Sistemas Multiagente, 7(1-2):179-189, 2003. [9] D. Morley y K. Myers. El marco de agentes SPARK. En Proc. de AAMAS04, 2004. [10] D. Morley, K. L. Myers y N. Yorke-Smith. Refinamiento continuo de estimaciones de recursos del agente. En Proc. de AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack y M. Tambe. Un asistente personal inteligente para la gestión de tareas y tiempo. Revista de Inteligencia Artificial, 28, 2007. Aparecer. [12] K. L. Myers y N. Yorke-Smith. Un marco cognitivo para la delegación a un agente de usuario asistente. En Actas del Simposio de Otoño de AAAI 2005 sobre Asistentes de Resolución de Problemas de Iniciativa Mixta, 2005. [13] L. Padgham y M. Winikoff. Desarrollo de Sistemas de Agentes Inteligentes: Una Guía Práctica. John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, y W. Lamersdorf. Jadex: Un motor de razonamiento BDI. En R. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores, Programación Multiagente. Springer, 2005. [15] A. S. Rao. 

Springer, 2005. [15] A. S. Rao. AgentSpeak(L): Los agentes BDI se expresan en un lenguaje lógico computable. En Actas del Séptimo Taller Europeo sobre Modelado de Agentes Autónomos en un Mundo Multiagente, 1996. [16] A. S. Rao y M. P. Georgeff. Una arquitectura abstracta para agentes racionales. En Proc. de KR92, 1992. [17] S. Sardiña, L. de Silva y L. Padgham. Planificación jerárquica en lenguajes de programación de agentes BDI: un enfoque formal. En Proc. de AAMAS06, 2006. [18] S. Sardina y L. Padgham. Objetivos en el contexto del fracaso del plan BDI y la planificación. En Proc. de AAMAS07, 2007. [19] J. Thangarajah, L. Padgham y M. Winikoff. Detectar y aprovechar la interacción positiva de objetivos en agentes inteligentes. En Proc. de AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham y K. Fischer. Evitando conflictos de recursos en agentes inteligentes. En Proc. de ECAI-02, 2002. [21] A. Unruh, J. Bailey y K. Ramamohanarao. Un marco para la compensación semántica basada en objetivos en sistemas de agentes. En Actas de la Primera Conferencia Internacional. Taller sobre Seguridad en Sistemas Multiagente, 2004. [22] A. Unruh, H. Harjadi, J. Bailey y K. Ramamohanarao. Gestión de recuperación basada en compensación semántica en sistemas multiagente. En Proc. del Segundo Simposio IEEE sobre Seguridad y Supervivencia Multiagente (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Proc. de KR02, 2002. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 15