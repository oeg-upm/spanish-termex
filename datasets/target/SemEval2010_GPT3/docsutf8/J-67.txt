Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70