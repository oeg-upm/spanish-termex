Gestión de normas distribuidas en sistemas multiagentes regulados ∗ Dorian Gaertner Dept. del Departamento de Computación, Imperial College London, Londres SW7 2AZ, Reino Unido dg00@doc.ic.ac.uk Andrés García-Camino, Pablo Noriega, J.-A. Rodríguez-Aguilar IIIA-CSIC, 08193 Bellaterra, España {andres,pablo,jar}@iiia.csic.es Wamberto Vasconcelos Dept. of Computing Science, University of Aberdeen, Aberdeen AB24 3UE, Reino Unido wvasconcelos@acm.org RESUMEN Las normas son ampliamente reconocidas como un medio de coordinar sistemas multiagente. La gestión distribuida de normas es un tema desafiante y observamos una falta de realizaciones computacionales verdaderamente distribuidas de modelos normativos. Para regular el comportamiento de agentes autónomos que participan en múltiples actividades relacionadas, proponemos un modelo normativo, la Estructura Normativa (EN), un artefacto basado en la propagación de posiciones normativas (obligaciones, prohibiciones, permisos), como consecuencias de las acciones de los agentes. Dentro de un SN, los conflictos pueden surgir debido a la naturaleza dinámica del MAS y la concurrencia de las acciones de los agentes. Sin embargo, garantizar la libertad de conflicto de un NS en el momento del diseño es computacionalmente intratable. Mostramos esto formalizando la noción de conflicto, proporcionando un mapeo de NSs en Redes de Petri de Colores y tomando prestados resultados teóricos bien conocidos de ese campo. Dado que se requiere la resolución de conflictos en línea, presentamos un algoritmo manejable que se empleará de forma distribuida. Luego demostramos que este algoritmo es fundamental para la ejecución distribuida de una NS. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Lenguajes y estructuras Términos Generales Algoritmos, Diseño, Teoría 1. Una característica fundamental de los sistemas multiagentes abiertos y regulados en los que interactúan agentes autónomos es que los agentes participantes deben cumplir con las convenciones del sistema. Las normas pueden ser utilizadas para modelar tales convenciones y, por lo tanto, como un medio para regular el comportamiento observable de los agentes [6, 29]. Hay muchas contribuciones sobre el tema de las normas de sociólogos, filósofos y lógicos (por ejemplo, [15, 28]). Sin embargo, hay muy pocas propuestas de realizaciones computacionales de modelos normativos, es decir, la forma en que las normas pueden integrarse en el diseño y la ejecución de los Sistemas Multiagentes. Los pocos que existen (por ejemplo, [10, 13, 24]), operan de manera centralizada, lo que crea cuellos de botella y puntos únicos de fallo. Hasta donde sabemos, ninguna propuesta realmente respalda la ejecución distribuida de entornos normativos. En nuestro artículo abordamos ese problema y proponemos medios para manejar compromisos conflictivos en sistemas multiagentes abiertos, regulados, de manera distribuida. El tipo de MAS regulado que imaginamos consiste en múltiples actividades concurrentes y relacionadas en las que interactúan agentes. Cada agente puede participar simultáneamente en varias actividades y cambiar de una actividad a otra. Las acciones de un agente dentro de una actividad pueden tener consecuencias en forma de posiciones normativas (es decir, obligaciones, permisos y prohibiciones) [26] que pueden limitar su comportamiento futuro. Por ejemplo, un agente comprador que se quede sin crédito puede ser prohibido de hacer más ofertas, o un agente vendedor está obligado a entregar después de cerrar un trato. Suponemos que los agentes pueden optar por no cumplir con todas sus obligaciones y, por lo tanto, pueden ser sancionados por la MAS. Ten en cuenta que, cuando las actividades están distribuidas, las posiciones normativas deben fluir desde las actividades en las que se generan hacia aquellas en las que tienen efecto. Por ejemplo, la obligación del vendedor mencionada anteriormente debe fluir (o propagarse) desde una actividad de negociación hasta una actividad de entrega. Dado que en un MAS abierto y regulado no se pueden incorporar aspectos normativos en el diseño de los agentes, adoptamos la perspectiva de que el MAS debería complementarse con un conjunto separado de normas que regulen aún más el comportamiento de los agentes participantes. Para modelar la separación de preocupaciones entre el nivel de coordinación (interacciones de agentes) y el nivel normativo (propagación de posiciones normativas), proponemos un artefacto llamado Estructura Normativa (EN). Dentro de un sistema multiagente pueden surgir conflictos debido a la naturaleza dinámica del MAS y la concurrencia de las acciones de los agentes. Por ejemplo, un agente puede estar obligado y prohibido de realizar la misma acción en una actividad. Dado que la regulación de un MAS implica que los agentes participantes deben ser conscientes de la validez de las acciones que tienen lugar dentro de él, dichos conflictos deben ser identificados y posiblemente resueltos si se requiere una afirmación de validez para que un agente participe en una acción o sea sancionado. Sin embargo, garantizar la libertad de conflicto de un NS en el momento del diseño es computacionalmente intratable. Lo demostramos formalizando la noción de conflicto, proporcionando un mapeo de NSs en Redes de Petri Coloreadas (CPNs) y tomando prestados resultados teóricos bien conocidos del campo de las CPNs. Creemos que es necesario la detección y resolución de conflictos en línea. Por lo tanto, presentamos un algoritmo manejable para la resolución de conflictos. Este algoritmo es fundamental para la ejecución distribuida de un NS. El documento está organizado de la siguiente manera. En la Sección 2 detallamos un escenario que servirá como ejemplo a lo largo del documento. A continuación, en la Sección 3 definimos formalmente el artefacto de estructura normativa. Más adelante, en la Sección 4 formalizamos la noción de conflicto para posteriormente analizar la complejidad de la detección de conflictos en términos de CPNs en la Sección 5. La sección 6 describe la gestión computacional de las NSs al describir su puesta en práctica y presentar un algoritmo para la resolución de conflictos. Finalmente, comentamos sobre el trabajo relacionado, sacamos conclusiones e informamos sobre el trabajo futuro en la Sección 7.2. ESCENARIO Utilizamos un escenario de cadena de suministro en el que empresas e individuos se reúnen en un mercado en línea para realizar negocios. El procedimiento general de la transacción puede organizarse en seis actividades distribuidas, representadas como nodos en el diagrama de la Figura 1. Involucran a diferentes participantes cuyo comportamiento está coordinado a través de protocolos. En este escenario, los agentes pueden desempeñar uno de cuatro roles: contador de mercado (acc), cliente, proveedor (supp) y gerentes de almacén (wm). Las flechas que conectan las actividades representan cómo los agentes pueden moverse de una actividad a otra. Después de registrarse en el mercado, los clientes y proveedores se reúnen en una actividad donde negocian los términos de su transacción, es decir, precios, cantidades de productos a entregar, plazos y otros detalles. En la actividad contractual, se establece el pedido y se prepara una factura. El cliente participará luego en una actividad de pago, verificando su solvencia crediticia e instruyendo a su banco para transferir la cantidad correcta de dinero. El proveedor, mientras tanto, se encargará de que los bienes sean entregados (por ejemplo, a través de un gerente de almacén) en la actividad de entrega. Finalmente, los agentes pueden abandonar el mercado siguiendo un protocolo de salida predeterminado. El contador del mercado participa en la mayoría de las actividades como un proveedor de confianza de herramientas de auditoría. En el resto del documento construiremos sobre este escenario para ejemplificar la noción de estructura normativa e ilustrar nuestro enfoque para la detección y resolución de conflictos en un entorno distribuido. 3. ESTRUCTURA NORMATIVA En los MASs, los agentes interactúan de acuerdo con protocolos que naturalmente están distribuidos. Abogamos porque las acciones en un protocolo de este tipo pueden tener un efecto en la implementación de otros protocolos. Ciertas acciones pueden volverse prohibidas u obligatorias, por ejemplo. Tomamos las posiciones normativas como obligaciones, prohibiciones y permisos similares al trabajo descrito en [26]. La intención de agregar o eliminar una posición normativa la llamamos comando normativo. Las apariciones de posiciones normativas en un protocolo pueden tener consecuencias para otros protocolos. Para definir nuestro lenguaje normativo y especificar cómo se propagan las posiciones normativas, nos hemos inspirado en los sistemas de múltiples contextos [14]. Estos sistemas permiten la estructuración del conocimiento en teorías formales distintas y la definición de relaciones entre ellas. Las relaciones se expresan como reglas de puente: la deducibilidad de fórmulas en algunos contextos conduce a la deducción de otras fórmulas en otros contextos. Recientemente, estos sistemas han sido utilizados con éxito para definir arquitecturas de agentes [11, 23]. La metáfora se traduce a nuestro trabajo actual de la siguiente manera: la emisión de ilocuciones y/o la existencia de posiciones normativas en algunas escenas normativas conduce a la deducción de posiciones normativas en otras escenas normativas. Nos preocupamos por la propagación y distribución de posiciones normativas dentro de una red de escenas normativas distribuidas como consecuencia de las acciones de los agentes. Tomamos escenas normativas como conjuntos de posiciones normativas y enunciados que están asociados con un protocolo de interacción subyacente correspondiente a una actividad. En esta sección, primero presentamos un lenguaje simple que captura estos aspectos e introducimos formalmente las nociones de escena normativa, regla de transición normativa y estructura normativa. Damos la semántica prevista de estas reglas y mostramos cómo controlar un MAS a través de normas en un ejemplo. 3.1 Conceptos Básicos Los bloques de construcción de nuestro lenguaje son términos y fórmulas atómicas: Def. 1. Un término, denotado como t, es (i) cualquier constante expresada en minúsculas (con o sin subíndices), por ejemplo, a, b0, c o (ii) cualquier variable expresada en mayúsculas (con o sin subíndices), por ejemplo, X, Y, Zb o (iii) cualquier función f(t1, . . . , tn), donde f es un símbolo de función n-ario y t1, .., tn son términos. Algunos ejemplos de términos y funciones son Crédito, precio u oferta (biblia, 30) siendo respectivamente una variable, una constante y una función. Estaremos utilizando identificadores a lo largo del documento, los cuales son términos constantes y también necesitan la siguiente definición: Def. 2. Una fórmula atómica es cualquier construcción p(t1, . . . , tn), donde p es un símbolo de predicado n-ario y t1, . . . , tn son términos. El conjunto de todas las fórmulas atómicas se denota como Δ. Nos enfocamos en una clase expresiva de MASs en la que la interacción se lleva a cabo mediante actos de habla ilocucionarios intercambiados entre agentes participantes: Def. 3. Las ilocuciones I son fórmulas atómicas fundamentales que tienen la forma p(ag, r, ag, r, δ, t) donde p es un elemento de 1. Aquí, abstraemos de los protocolos y nos referimos a ellos genéricamente como actividades. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 637 un conjunto de partículas ilocucionarias (por ejemplo, informar, solicitar, ofrecer); ag, ag son identificadores de agentes; r, r son identificadores de roles; δ, un término de base arbitrario, es el contenido del mensaje, construido a partir de un lenguaje de contenido compartido; t ∈ N es una marca de tiempo. El significado intuitivo de p(ag, r, ag, r, m, t) es que el agente ag desempeñando el rol r envió el mensaje m al agente ag desempeñando el rol r en el tiempo t. Un ejemplo de una ilocución es informar(ag4, supp, ag3, cliente, oferta(wire, 12), 10). A veces es útil hacer referencia a las ilocuciones que no están completamente fundamentadas, es decir, aquellas que pueden contener variables no instanciadas (libres). En la descripción de un protocolo, por ejemplo, los valores precisos de los mensajes intercambiados pueden quedar sin especificar. Durante la promulgación del protocolo, los agentes producirán los valores reales que darán lugar a una ilocución de base. Por lo tanto, podemos definir los esquemas ilocutivos: Def. 4. Un esquema ilocutivo ¯I es cualquier fórmula atómica p(ag, r, ag, r, δ, t) en la que algunos de los términos pueden ser variables o pueden contener variables. 3.2 Definición formal de la noción de NS. Primero definimos las escenas normativas de la siguiente manera: Def. 5. Una escena normativa es una tupla s = ids, Δs donde ids es un identificador de escena y Δs es el conjunto de fórmulas atómicas δ (es decir, enunciados y posiciones normativas) que se cumplen en s. También nos referiremos a Δs como el estado de la escena normativa s. Por ejemplo, una instantánea del estado de la escena normativa de entrega de nuestro escenario podría representarse como: Δs = 8 < : utt(solicitud(sean, cliente, kev, wm, recibir(cable, 200), 20)), utt(aceptar(kev, wm, sean, cliente, recibir(cable, 200), 30)), obl(informar(kev, wm, sean, cliente, entregado(cable, 200), 30)) 9 = ; Es decir, el agente Sean asumiendo el rol de cliente ha solicitado al agente Kev (asumiendo el rol de gerente de almacén wm) recibir 200 kg de cable, y Kev está obligado a entregar 200 kg de cable a Sean ya que aceptó la solicitud. Ten en cuenta que el estado de una escena normativa Δs evoluciona con el tiempo. Estas escenas normativas están conectadas entre sí a través de transiciones normativas que especifican cómo las enunciaciones y posiciones normativas en una escena afectan a otras escenas normativas. Como se mencionó anteriormente, las actividades no son independientes ya que las ilocuciones pronunciadas en algunas de ellas pueden tener un efecto en las demás. Las reglas de transición normativas definen las condiciones bajo las cuales se genera un mandato normativo. Estas condiciones son ya sea enunciados o posiciones normativas asociadas con un protocolo dado (denotado por ejemplo actividad: enunciado) que generan un mandato normativo, es decir, la adición o eliminación de otra posición normativa, posiblemente relacionada con una actividad diferente. Nuestras reglas de transición están definidas de la siguiente manera: Def. 6. Una regla de transición normativa R tiene la forma: R ::= V C V ::= ids : D | V, V D ::= N | utt(¯I) N ::= per(¯I) | prh(¯I) | obl(¯I) C ::= add(ids : N) | remove(ids : N) donde ¯I es un esquema de ilocución, N es una posición normativa (es decir, permiso, prohibición u obligación), ids es un identificador para la actividad s y C es un comando normativo. Dotamos a nuestro lenguaje con la semántica habitual de los lenguajes basados en reglas [19]. Las reglas mapean una estructura normativa existente a una nueva estructura normativa donde solo cambia el estado de las escenas normativas. En las definiciones a continuación nos basamos en el concepto estándar de sustitución [9]. Definición 7. Una transición normativa es una tupla b = idb, rb donde idb es un identificador y rb es una regla de transición normativa. Estamos proponiendo extender la noción de MAS, regulada por protocolos, con una capa adicional que consiste en escenas normativas y transiciones normativas. Esta capa se representa como un grafo bipartito al que llamamos estructura normativa. Una estructura normativa relaciona escenas normativas y transiciones normativas especificando qué posiciones normativas deben generarse o eliminarse en qué escenas normativas. Definición 8. Una estructura normativa es un grafo bipartito etiquetado NS = Nodos, Bordes, Lin, Lout. Nodos es un conjunto S∪B donde S es un conjunto de escenas normativas y B es un conjunto de transiciones normativas. Los bordes es un conjunto Ain ∪ Aout donde Ain ⊆ S × B es un conjunto de arcos de entrada etiquetados con una fórmula atómica utilizando la función de etiquetado Lin : Ain → D; y Aout ⊆ B × S es un conjunto de arcos de salida etiquetados con una posición normativa utilizando la función de etiquetado Lout : Aout → N. Lo siguiente debe cumplirse: 1. Cada fórmula atómica que aparece en el LHS de una regla rb debe tener la forma (ids : D) donde s ∈ S y D ∈ Δ y ∃ain ∈ Ain tal que ain = (s, b) y Lin (ain) = D. 2. La fórmula atómica que aparece en el RHS de una regla rb debe tener la forma add(ids: N) o remove(ids: N) donde s ∈ S y ∃aout ∈ Aout tal que aout = (b, s) y Lout(aout) = N. 3. ∀a ∈ Ain tal que a = (s, b) y b = idb, rb y Lin(a) = D entonces (ids:D) debe ocurrir en el LHS de rb. 4. ∀a ∈ Aout tal que a = (b, s) y b = idb, rb y Lout(a) = N entonces add(ids: N) o remove(ids: N) debe ocurrir en el RHS de rb. Los dos primeros puntos aseguran que cada fórmula atómica en el LHS de una regla de transición normativa etiqueta un arco que entra en la transición normativa apropiada en la estructura normativa, y que la fórmula atómica en el RHS etiqueta el arco saliente correspondiente. Los puntos tres y cuatro aseguran que las etiquetas de todos los arcos entrantes se utilicen en el LHS de la regla de transición normativa en la que estos arcos entran, y que las etiquetas de todos los arcos salientes se utilicen en el RHS de la regla de transición normativa en la que estos arcos salen. 3.3 Semántica prevista La semántica formal se definirá mediante un mapeo a Redes de Petri de Colores en la Sección 5.1. Aquí comenzamos a definir la semántica prevista de las reglas de transición normativas describiendo cómo una regla cambia una escena normativa de una estructura normativa existente, dando como resultado una nueva estructura normativa. Cada regla se activa una vez por cada sustitución que unifica el lado izquierdo V de la regla con el estado de las escenas normativas correspondientes. Una fórmula atómica (es decir, una enunciación o una posición normativa) se cumple si es unificable con una enunciación o posición normativa que pertenece al estado de la escena normativa correspondiente. Cada vez que se activa una regla, se lleva a cabo el comando normativo especificado en el lado derecho de esa regla, con la intención de agregar o eliminar una posición normativa del estado de la escena normativa correspondiente. Sin embargo, la adición no es incondicional ya que pueden surgir conflictos. Este tema será tratado en las Secciones 4 y 6.1. 638 de la Sexta Conferencia Internacional. En nuestro ejemplo en curso tenemos la siguiente regla de transición normativa ejemplar: "pago: obl(informar(X, cliente, Y, cuenta, pagar(Z, P, Q), T)), pago: utt(informar(X, cliente, Y, cuenta, pagar(Z, P, Q), T)) « entrega: add(obl(informar(Y, wm, X, cliente, entregado(Z, Q), T)))". Es decir, durante la actividad de pago, una obligación en el cliente X de informar al contador Y sobre el pago P del artículo Z en el tiempo T y la correspondiente declaración que cumple con esta obligación permite el flujo de una norma hacia la actividad de entrega. La norma es una obligación para el agente Y (en este caso asumiendo el rol de gerente de almacén wm) de enviar un mensaje al cliente X informando que el artículo Z ha sido entregado. Mostramos en la Figura 2 una representación diagramática de cómo se relacionan las actividades y una estructura normativa: Nivel Normativo Contrato de Entrega de Pago Salida Registro Pago Entrega Negociación Nivel de Coordinación Contrato nt Figura 2: Actividades y Estructura Normativa A medida que se emiten enunciados ilocucionarios durante las actividades, surgen posiciones normativas. Las expresiones y posiciones normativas se combinan en reglas de transición, causando el flujo de posiciones normativas entre escenas normativas. La conexión entre los dos niveles se describe en la Sección 6.2.4. DEFINICIÓN DE CONFLICTO Los términos conflicto deóntico e inconsistencia deóntica se han utilizado indistintamente en la literatura. Sin embargo, en este documento adoptamos la perspectiva de [7] en la que los autores sugieren que surge una inconsistencia deontológica cuando una acción es simultáneamente permitida y prohibida, ya que una permisión puede no ser llevada a cabo, por lo que no se produce un conflicto real. Las situaciones en las que una acción está simultáneamente obligada y prohibida son, sin embargo, conflictos deontológicos, ya que tanto las obligaciones como las prohibiciones influyen en los comportamientos de manera conflictiva. El contenido de las posiciones normativas en este documento son actos ilocutivos. Por lo tanto, surge un conflicto normativo cuando una ilocución está simultáneamente obligada y prohibida. Proponemos utilizar la noción estándar de unificación [9] para detectar cuándo se superponen una prohibición y un permiso. Por ejemplo, una obligación obl(inform(A1, R1, A2, R2, p(c, X), T)) y una prohibición prh(inform(a1, r1, a2, r2, p(Y, d), T)) están en conflicto ya que se unifican bajo σ = {A1/a1, R1/r1, A2/a2, R2/r2, Y/c, X/d, T/T}. Capturamos formalmente esta noción: Def. 9. Un conflicto (deóntico) surge entre dos posiciones normativas N y N bajo una sustitución σ, denotado como conflict(N, N, σ), si y solo si N = prh(¯I), N = obl(¯I) y unificar(¯I, ¯I, σ). Es decir, una prohibición y una obligación están en conflicto si, y solo si, sus ilocuciones se unifican bajo σ. La sustitución σ, llamada aquí el conjunto de conflictos, unifica a los agentes, roles y fórmulas atómicas. Suponemos que unificar es una implementación adecuada de un algoritmo de unificación que i) siempre termina (posiblemente fallando, si no se puede encontrar un unificador); ii) es correcto; y iii) tiene complejidad computacional lineal. Las inconsistencias causadas por la misma ilocución siendo simultáneamente permitida y prohibida pueden ser formalizadas de manera similar. En este artículo nos enfocamos en conflictos de prohibición/obligación, pero la maquinaria computacional introducida en la Sección 6.1 también puede ser utilizada para detectar inconsistencias de prohibición/permiso, si sustituimos la modalidad obl por per. 5. FORMALIZANDO LA LIBERTAD DE CONFLICTOS En esta sección introducimos algunos conocimientos previos sobre las CPN asumiendo una comprensión básica de las Redes de Petri ordinarias. Para detalles técnicos remitimos al lector a [16]. Luego mapeamos los NSs a los CPNs y analizamos sus propiedades. Las CPNs combinan la potencia de las redes de Petri con la potencia de los lenguajes de programación funcional. Por un lado, las redes de Petri proporcionan los elementos básicos para la descripción de la sincronización de procesos concurrentes. Como se observó en [16], las CPNs tienen una semántica que se basa en la concurrencia verdadera en lugar de la interlección. En nuestra opinión, una semántica de verdadera concurrencia es más fácil de trabajar porque es la forma en que imaginamos que debe ser la conexión entre el nivel de coordinación y el nivel normativo de un sistema multiagente. Por otro lado, los lenguajes de programación funcional utilizados por las CPNs proporcionan los elementos básicos para la definición de tipos de datos y la manipulación de sus valores de datos. Por lo tanto, podemos traducir fácilmente expresiones de una estructura normativa. Por último, pero no menos importante, las CPN tienen una semántica bien definida que define de manera inequívoca el comportamiento de cada CPN. Además, las CPNs cuentan con una gran cantidad de métodos y herramientas de análisis formales mediante los cuales se pueden demostrar propiedades de las CPNs. En resumen, las CPNs nos proporcionan todas las características necesarias para razonar formalmente sobre estructuras normativas siempre que se proporcione un mapeo adecuado. De acuerdo con las redes de Petri, los estados de una CPN se representan mediante lugares. Pero a diferencia de las Redes de Petri, cada lugar tiene un tipo de dato asociado que determina el tipo de datos que el lugar puede contener. Un estado de una CPN se llama marcado. Consiste en una serie de fichas colocadas en los lugares individuales. Cada token lleva consigo un valor de datos que tiene el tipo del lugar correspondiente. En general, un lugar puede contener dos o más fichas con el mismo valor de datos. Por lo tanto, una marca de una CPN es una función que asigna a cada plaza un multiconjunto de fichas del tipo correcto. Uno a menudo se refiere a los valores de los tokens como colores de tokens y también se refiere a los tipos de datos como conjuntos de colores. Los tipos de una CPN pueden ser arbitrariamente complejos. Las acciones en una CPN se representan mediante transiciones. Un arco entrante en una transición desde un lugar indica que la transición puede eliminar fichas del lugar correspondiente, mientras que un arco saliente indica que la transición puede agregar fichas. El número exacto de tokens y sus valores de datos son determinados por las expresiones de arco, las cuales están codificadas utilizando el lenguaje de programación elegido para la CPN. Una transición está habilitada en una CPN si y solo si el multi-conjunto (o bolsa) 2 A es una extensión de la noción de conjunto, permitiendo la posibilidad de múltiples apariciones del mismo elemento. El Sexto Internacional. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), 639 variables en las expresiones de sus arcos entrantes están vinculadas a algún valor (cada uno de estos vínculos se denomina elemento de vinculación). Si es así, la transición puede ocurrir al eliminar fichas de sus lugares de entrada y agregar fichas a sus lugares de salida. Además de las expresiones de arco, es posible adjuntar una expresión de guardia booleana (con variables) a cada transición. Al juntar todos los elementos anteriores, obtenemos una definición formal de CPN que se empleará más adelante con fines de mapeo. Definición 10. Un CPN es una tupla Σ, P, T, A, N, C, G, E, I donde: (i) Σ es un conjunto finito de tipos no vacíos, también llamados conjuntos de colores; (ii) P es un conjunto finito de lugares; (iii) T es un conjunto finito de transiciones; (iv) A es un conjunto finito de arcos; (v) N es una función de nodo definida de A en P × T ∪ T × P; (vi) C es una función de color de P en Σ; (vii) G es una función de guarda de T en expresiones; (viii) E es una función de expresión de arco de A en expresiones; (ix) I es una función de inicialización de P en expresiones cerradas; Nótese que la explicación informal de las reglas de habilitación y ocurrencia proporcionadas anteriormente sienta las bases para comprender el comportamiento de un CPN. De acuerdo con las redes de Petri ordinarias, el comportamiento concurrente de una CPN se basa en la noción de paso. Formalmente, un paso es un multi-conjunto no vacío y finito sobre el conjunto de todos los elementos de enlace. Sea el paso S habilitado en una marcación M. Entonces, S puede ocurrir, cambiando la marcación M a M'. Además, decimos que la marca M es directamente alcanzable desde la marca M mediante la ocurrencia del paso S, y lo denotamos como M[S > M. Una secuencia de ocurrencias finitas es una secuencia finita de pasos y marcas: M1[S1 > M2... Mn[Sn > Mn+1 tal que n ∈ N y Mi[Si > Mi+1 ∀i ∈ {1, . . . , n}. 

(Note: The original sentence seems to have a typo or missing information, as it is not complete or clear in its meaning.) El conjunto de todas las marcas posibles alcanzables para una red Net desde una marca M se llama su conjunto de alcanzabilidad, y se denota como R(Net, M). 5.1 Mapeo a Redes de Petri Coloreadas. Nuestra estructura normativa es un grafo bipartito etiquetado. Lo mismo es cierto para una Red de Petri de Colores. Estamos presentando un mapeo f de uno a otro, con el fin de proporcionar semántica para la estructura normativa y demostrar propiedades sobre ella utilizando resultados teóricos bien conocidos del trabajo en CPNs. El mapeo f hace uso de correspondencias entre escenas normativas y lugares de CPN, transiciones normativas y transiciones de CPN y finalmente, entre etiquetas de arco y expresiones de arco de CPN. S → P B → T Lin ∪ Lout → E El conjunto de tipos es el conjunto unitario que contiene el color NP (es decir, Σ = {NP}). Este tipo complejo está estructurado de la siguiente manera (usamos la sintaxis CPN-ML [4]): color NPT = con Obl | Per | Prh | NoMod color IP = con informar | declarar | ofrecer color UTT = registro illp: IP ag1, rol1, ag2, rol2: cadena contenido: cadena tiempo: entero color NP = registro modo: NPT ilocución: UTT Modelar las ilocuciones como normas sin modalidad (NoMod) es un truco formal que utilizamos para asegurar que las subredes puedan combinarse como se explica a continuación. Los arcos son mapeados casi directamente. A es un conjunto finito de arcos y N es una función de nodo, tal que ∀a ∈ A ∃a ∈ Ain ∪Aout. N(a) = a. La función de inicialización I se define como I(p) = Δs (∀s ∈ S donde p se obtiene de s usando el mapeo; recuerda que s = ids, Δs). Finalmente, la función de color C asigna el color NP a cada lugar: C(p) = NP (∀p ∈ P). No estamos haciendo uso de la función de guardia G. En trabajos futuros, esta función puede ser utilizada para modelar restricciones cuando ampliemos la expresividad de nuestro lenguaje normativo. 5.2 Propiedades de Estructuras Normativas Habiendo definido la asignación de estructuras normativas a Redes de Petri de Colores, ahora examinamos propiedades de las RPC que nos ayudan a comprender la complejidad de la detección de conflictos. Una pregunta que nos gustaría responder es si, en un momento dado, una estructura normativa dada está libre de conflictos. Una instantánea de una estructura normativa corresponde a una marca en la CPN mapeada. Definición 11. Dada una marcación Mi, esta marcación es libre de conflictos si ¬∃p ∈ P. ∃np1, np2 ∈ Mi(p) tal que np1.modo = Obl y np2.modo = Prh y np1.illoc y np2.illoc unifican bajo una sustitución válida. Otra pregunta interesante sería si surgirá un conflicto a partir de tal instantánea del sistema al propagar las posiciones normativas. Para responder a esta pregunta, primero traducimos la instantánea de la estructura normativa al CPN correspondiente y luego ejecutamos la secuencia finita de ocurrencias de marcas y pasos, verificando la ausencia de conflictos en cada marca a medida que avanzamos. Definición 12. Dada una marca Mi, una secuencia finita de ocurrencias Si, Si+1, ..., Sn se llama libre de conflictos, si y solo si Mi[Si > Mi+1 . . . Mn[Sn > Mn+1 y Mk es libre de conflictos para todo k tal que i ≤ k ≤ n + 1. Sin embargo, la pregunta principal que nos gustaría investigar es si una estructura normativa dada es resistente al conflicto, es decir, si los agentes que implementan el MAS son capaces de generar conflictos a través de sus acciones. Tan pronto como se incluye la posibilidad de acciones (o enunciados) de agentes autónomos, se pierde el determinismo. Habiendo mapeado la estructura normativa a un CPN, ahora agregamos modelos de CPN de las interacciones de los agentes. Cada forma de interacción de agentes (es decir, cada actividad) puede ser modelada utilizando CPNs siguiendo la línea de Cost et al. [5]. Estas CPN no determinísticas alimentan tokens en la CPN que modela la estructura normativa. Esto conlleva a la introducción de no determinismo en la CPN combinada. La mitad inferior de la figura 3 muestra parte de un modelo CPN de un protocolo de agente donde el arco denotado con 1 representa alguna enunciación de una ilocución por un agente. La transición objetivo de este arco, no solo mueve un token al siguiente estado de esta CPN, sino que también coloca un token en el lugar correspondiente a la escena normativa apropiada en el modelo CPN de la estructura normativa (a través del arco 2). La transición 3 finalmente pudo propagar ese token en forma de obligación, por ejemplo. Por lo tanto, a partir de una marca dada, son posibles muchas secuencias de ocurrencia diferentes dependiendo de las acciones de los agentes. Hacemos uso del conjunto de alcanzabilidad R para definir una situación en la que los agentes no pueden causar conflictos. 640 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 3: Construyendo la CPN combinada Def. 13. Dado una red N, una marcación M es resistente a conflictos si y solo si todas las marcaciones en R(N,M) son libres de conflictos. Verificar la libertad de conflicto de una marca se puede hacer en tiempo polinómico al revisar todos los lugares de la CPN en busca de fichas en conflicto. La libertad de conflicto de una secuencia de ocurrencias en la CPN que representa la estructura normativa también se puede lograr en tiempo polinómico, ya que esta secuencia es determinista dado un instante. Ya sea que una estructura normativa esté diseñada de manera segura corresponde a verificar la resistencia al conflicto de la marca inicial M0. Ahora, verificar la resistencia al conflicto de una marca se convierte en una tarea muy difícil. Corresponde al problema de alcanzabilidad en una CPN: ¿se puede alcanzar un estado o lograr una marcación que contenga un conflicto? Este problema de alcanzabilidad se sabe que es NP-completo para las Redes de Petri ordinarias [22] y dado que las CPNs son funcionalmente idénticas, no podemos esperar verificar la resistencia al conflicto de una estructura normativa fuera de línea en una cantidad razonable de tiempo. Por lo tanto, se necesitan mecanismos distribuidos en tiempo de ejecución para garantizar que una estructura normativa mantenga la consistencia. Presentamos un mecanismo de este tipo en la siguiente sección. 6. Una vez que se ha detectado un conflicto (según se define en la Sección 4), proponemos emplear el unificador para resolver el conflicto. En nuestro ejemplo, si las variables en prh(inform(a1, r1, a2, r2, p(Y, d), T )) no obtienen los valores especificados en la sustitución σ, entonces no habrá un conflicto. Sin embargo, en lugar de calcular el conjunto complementario de una sustitución (que puede ser un conjunto infinito), proponemos anotar la prohibición con el unificador mismo y usarlo para determinar qué variables no pueden ser en futuras unificaciones para evitar un conflicto. Por lo tanto, designamos las prohibiciones anotadas como prh(¯I) Σ, donde Σ = {σ1, . . . , σn}, es un conjunto de unificadores. Las normas anotadas se interpretan como construcciones deónticas con influencias limitadas, es decir, su efecto (sobre agentes, roles e ilocuciones) ha sido restringido por el conjunto Σ de unificadores. Una prohibición puede estar en conflicto con varias obligaciones en una escena normativa dada s = id, Δ y necesitamos registrar (y posiblemente evitar) todos estos conflictos. A continuación definimos un algoritmo que garantiza que una posición normativa se agregará a una escena normativa de tal manera que no cause conflictos. Aunque proponemos reducir las prohibiciones, la misma maquinaria puede utilizarse para definir la reducción de obligaciones en su lugar. Estas políticas diferentes dependen de la semántica deontológica prevista y de los requisitos de los sistemas abordados. Por ejemplo, algunas MASs pueden requerir que sus agentes no actúen en presencia de conflictos, es decir, que la obligación debe ser limitada. 6.1 Resolución de Conflictos Proponemos una forma detallada de resolver conflictos normativos a través de la unificación. Detectamos la superposición de las influencias de las normas, es decir, cómo afectan el comportamiento de los agentes involucrados, y reducimos la influencia de la posición normativa, utilizando adecuadamente las anotaciones al verificar si la norma se aplica a las ilocuciones. El algoritmo mostrado en la Figura 4 representa cómo mantenemos un conjunto de normas libre de conflictos. Agrega una norma dada N a un estado normativo Δ existente y libre de conflictos, obteniendo un nuevo estado normativo resultante Δ que es libre de conflictos, es decir, sus prohibiciones están anotadas con un conjunto de conjuntos de conflictos que indican qué asignaciones para variables deben evitarse para que no ocurran conflictos. algoritmo addNorm(N, Δ) comienza 1 marca de tiempo(N) 2 caso N de 3 per(¯I): Δ := Δ ∪ {N} 4 prh(I): si N ∈ Δ tal que conflicto(N, N , σ) entonces Δ := Δ 5 de lo contrario Δ := Δ ∪ {N} 6 prh(¯I): 7 comienza 8 Σ := ∅ 9 para cada N ∈ Δ hacer 10 si conflicto(N, N , σ) entonces Σ := Σ ∪ {σ} 11 Δ := Δ ∪ {N Σ} 12 fin 13 obl(¯I): 14 comienza 15 Δ1 := ∅; Δ2 := ∅ 16 para cada (N Σ) ∈ Δ hacer 17 si N = prh(I) entonces 18 si conflicto(N , N, σ) entonces Δ1 := Δ1 ∪ {N Σ} 19 de lo contrario nulo 20 de lo contrario 21 si conflicto(N , N, σ) entonces 22 comienza 23 Δ1 := Δ1 ∪ {N Σ} 24 Δ2 := Δ2 ∪ {N (Σ ∪ {σ})} 25 fin 26 Δ := (Δ − Δ1) ∪ Δ2 ∪ {N} 27 fin 28 fin caso 29 devolver Δ fin Figura 4: Algoritmo para Preservar la Libertad de Conflictos El algoritmo utiliza una estructura de caso para diferenciar las diferentes posibilidades para una norma dada N. La línea 3 aborda el caso en el que la norma dada es un permiso: N simplemente se agrega a Δ. Las líneas 4-5 abordan el caso en el que intentamos agregar una prohibición de base a un estado normativo: si entra en conflicto con alguna obligación, entonces se descarta; de lo contrario, se agrega al estado normativo. Las líneas 6-12 describen la situación cuando la posición normativa a añadir es una prohibición no fundamentada. En este caso, el algoritmo inicializa Σ como un conjunto vacío y recorre en bucle (línea 9-10) las normas N en el estado normativo anterior Δ. Al encontrar uno que entre en conflicto con N, el algoritmo actualiza Σ agregando el conjunto de conflictos recién encontrado σ a él (línea 10). Al recorrer Δ en un bucle, podemos verificar cualquier conflicto entre la nueva prohibición y las obligaciones existentes, construyendo adecuadamente la anotación Σ que se utilizará al agregar N a Δ en la línea 11. Las líneas 13-27 describen cómo una nueva obligación se adapta a un estado normativo existente. Hacemos uso de dos conjuntos temporales inicialmente vacíos, Δ1, Δ2. El algoritmo recorre Δ (líneas 16-25) recogiendo aquellas prohibiciones anotadas N Σ que entran en conflicto con la nueva obligación. Sin embargo, hay dos casos con los que tratar: uno cuando un terreno La Sexta Internacional. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) se encuentra la prohibición 641 (línea 17) y su excepción, que abarca prohibiciones no fundamentadas (línea 20). En ambos casos, la antigua prohibición se almacena en Δ1 (líneas 18 y 23) para ser posteriormente eliminada de Δ (línea 26). Sin embargo, en el caso de una prohibición no basada en tierra, el algoritmo actualiza su anotación de conjuntos de conflictos (línea 24). El bucle garantiza que se realice una búsqueda exhaustiva (lineal) a través de un estado normativo, verificando si la nueva obligación entra en conflicto con alguna prohibición existente, posiblemente actualizando las anotaciones de estas prohibiciones conflictivas. En la línea 26, el algoritmo construye el nuevo Δ actualizado eliminando las antiguas prohibiciones almacenadas en Δ1 y agregando las prohibiciones actualizadas almacenadas en Δ2 (si las hay), así como la nueva obligación N. Nuestro algoritmo propuesto es correcto en el sentido de que, para una posición normativa N dada y un estado normativo Δ, proporciona un nuevo estado normativo Δ en el que todas las prohibiciones tienen anotaciones que registran cómo se unifican con las obligaciones existentes. Las anotaciones pueden estar vacías, sin embargo, este es el caso cuando tenemos una prohibición de base o una prohibición que no unifica/conflicta con ninguna obligación. Los permisos no afectan nuestro algoritmo y se manejan adecuadamente (línea 3). Cualquier intento de insertar una prohibición de base que entre en conflicto, produce el mismo estado normativo (línea 4). Cuando se agrega una nueva obligación, el algoritmo garantiza que se consideren todas las prohibiciones (líneas 14-27), lo que lleva a la eliminación de prohibiciones fundamentales conflictivas o la actualización de anotaciones de prohibiciones no fundamentales. El algoritmo siempre termina: los bucles están sobre un conjunto finito Δ y las verificaciones de conflictos y operaciones de conjunto siempre terminan. La complejidad del algoritmo es lineal: el conjunto Δ solo se examina una vez para cada posible caso de norma que se agregue. Al gestionar estados normativos, también puede ser necesario eliminar posiciones normativas. Esto es sencillo: los permisos se pueden eliminar sin problemas; las prohibiciones anotadas también se pueden eliminar sin más consideraciones; sin embargo, las obligaciones requieren cierto mantenimiento. Cuando una obligación debe ser eliminada, debemos verificarla con todas las prohibiciones anotadas para actualizar sus anotaciones. Aplicamos la verificación de conflictos y obtenemos un unificador, luego eliminamos este unificador de la anotación de prohibiciones. Invocamos el algoritmo de eliminación como removeNorm(N, Δ): devuelve un nuevo estado normativo Δ en el que se ha eliminado N, con posibles alteraciones en otras posiciones normativas como se explica. 6.2 Promulgación de una Estructura Normativa La promulgación de una estructura normativa implica la ejecución paralela y distribuida de escenas normativas y transiciones normativas. Con fines ilustrativos, a continuación describiremos la interacción entre las escenas normativas de pago y entrega y la transición normativa nt que las vincula en la mitad superior de la figura 2. Con este objetivo, considere por ejemplo que obl(inform(jules, cliente, rod, acc, pagar(cobre, 400, 350), T) ∈ Δpago y que Δentrega sostiene prh(inform(rod, wm, jules, cliente, entregado(Z, Q), T)). Tales estados indican que el cliente Jules está obligado a pagar £400 por 350 kg de cobre al contador Rod de acuerdo con la escena normativa de pago, mientras que Rod, asumiendo el papel de gerente de almacén en esta ocasión, tiene prohibido entregar cualquier cosa al cliente Jules de acuerdo con la escena normativa de entrega. Para cada escena normativa, el proceso de promulgación es el siguiente. En primer lugar, procesa su cola de mensajes entrantes que contiene tres tipos de mensajes: enunciados de la actividad a la que está vinculado; y comandos normativos para agregar o eliminar posiciones normativas. Por ejemplo, en nuestro ejemplo, la escena normativa de pago recopila la ilocución I = utt((inform(jules, cliente, rod, acc, pagar(cobre, 400, 350), 35)) que representa al cliente Jules pendiente de pago por cobre (a través de la flecha A en la figura 2). Las expresiones son marcadas con la hora y luego se agregan al estado normativo. Tendríamos Δpago = Δpago ∪ {I}, en nuestro ejemplo. Al recibir comandos normativos para agregar o eliminar una posición normativa, la escena normativa invoca el algoritmo de adición o eliminación correspondiente descrito en la Sección 6.1. En segundo lugar, la escena normativa reconoce su cambio de estado al enviar un mensaje de activación a cada transición normativa saliente a la que está conectada. En nuestro ejemplo, la escena normativa de pago estaría señalando su cambio de estado a la transición normativa nt. Para las transiciones normativas, el proceso funciona de manera diferente. Debido a que cada transición normativa controla la operación de una regla única, al recibir un mensaje de activación, sondea cada escena normativa entrante en busca de sustituciones para los esquemas ilocucionales relevantes en el LHS de su regla. En nuestro ejemplo, nt (siendo responsable de la regla descrita en la Sección 3.4), sondearía la escena normativa de pagos (a través de la flecha B) en busca de sustituciones. Al recibir respuestas de ellos (en forma de conjuntos de sustituciones junto con marcas de tiempo), se deben unificar las sustituciones de cada una de estas escenas normativas. Para cada unificación que encuentra, la regla se activa, y por lo tanto se envía el comando normativo correspondiente a la escena normativa de salida. La transición normativa luego lleva un registro del mensaje de activación que envió y de los sellos de tiempo de las posiciones normativas que desencadenaron la activación. Esto se hace para asegurar que las mismas posiciones normativas en el LHS de una regla solo activen su disparo una vez. En nuestro ejemplo, nt estaría recibiendo σ = {X/jules, Y/rod, Z/copper, Q/350} de la escena normativa de pago. Dado que las sustituciones en σ unifican con la regla nts, la regla se activa y se envía el comando normativo adicionar(entrega : obl(rod, wm, jules, cliente, entregado(cobre, 350), T)) a la escena normativa de entrega para obligar a Rod a entregar al cliente Jules 350 kg de cobre. Después de eso, la escena normativa de entrega invocaría el algoritmo addNorm de la figura 4 con Δentrega y N = obl(rod, wm, jules, cliente, entregado(cobre, 350)) como argumentos. 7. TRABAJO RELACIONADO Y CONCLUSIONES Nuestras contribuciones en este artículo son triples. En primer lugar, presentamos un enfoque para la gestión y razonamiento sobre normas de manera distribuida. Hasta donde sabemos, hay poco trabajo publicado en esta dirección. En [8, 21], se presentan dos idiomas para la aplicación distribuida de normas en MAS. Sin embargo, en ambos trabajos, cada agente tiene una interfaz de mensajes local que reenvía mensajes legales de acuerdo con un conjunto de normas. Dado que estas interfaces son locales para cada agente, las normas solo pueden expresarse en términos de acciones de ese agente. Esta es una seria desventaja, por ejemplo, cuando se necesita activar una obligación hacia un agente debido a un mensaje de otro. La segunda contribución es la propuesta de una estructura normativa. La noción es fructífera porque permite la separación de preocupaciones normativas y procedimentales. La estructura normativa que proponemos pone de manifiesto la similitud entre la propagación de posiciones normativas y la propagación 642 de la Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) de tokens en Redes de Petri de Colores. Esa similitud sugiere fácilmente un mapeo entre ambos, y proporciona fundamentos para un tratamiento analítico conveniente de la estructura normativa, en general, y la complejidad de la detección de conflictos, en particular. La idea de modelar interacciones (en forma de conversaciones) a través de Redes de Petri ha sido investigada en [18], donde el medio de interacción y los agentes individuales son modelados como subredes de CPN que posteriormente se combinan para su análisis. En [5], las conversaciones se diseñan y analizan primero a nivel de CPNs y luego se traducen a protocolos. Lin et al. [20] mapean los esquemas de conversación a CPNs. Hasta donde sabemos, el uso de esta representación en el apoyo a la detección de conflictos en MAS regulados no ha sido reportado en otro lugar. Finalmente, presentamos un mecanismo distribuido para resolver conflictos normativos. Sartor [25] aborda los conflictos normativos desde el punto de vista de la teoría legal y sugiere una forma de ordenar las normas involucradas. Su idea se implementa en [12] pero requiere un recurso central para el mantenimiento de la norma. El enfoque para la detección y resolución de conflictos es una adaptación y extensión del trabajo sobre grafos de instanciación reportado en [17] y un algoritmo relacionado en [27]. El algoritmo presentado en el artículo actual se puede utilizar para gestionar estados normativos de forma distribuida: escenas normativas que ocurren en paralelo tienen un estado normativo asociado Δ al cual el algoritmo se aplica de forma independiente cada vez que se introduce una nueva norma. Estas tres contribuciones que presentamos en este artículo abren muchas posibilidades para trabajos futuros. Deberíamos mencionar primero que, como estrategia general, estamos trabajando en una generalización de la noción de estructura normativa para hacerla operar con diferentes modelos de coordinación, con un contenido deóntico más rico y sobre diferentes realizaciones computacionales de MAS regulados. Como primer paso en esta dirección, estamos aprovechando el desacoplamiento entre los protocolos de interacción y la orientación normativa declarativa que la estructura normativa pone a disposición, para proporcionar una capa normativa para las instituciones electrónicas (como se define en [1]). Esperamos que dicho acoplamiento dote a las instituciones electrónicas de un entorno normativo más flexible y expresivo. Además, queremos ampliar nuestro modelo en varias direcciones: (1) para manejar la negación y restricciones como parte del lenguaje normativo, y en particular la noción de tiempo; (2) para acomodar múltiples autoridades normativas jerárquicas basadas en roles, siguiendo las líneas de Cholvy y Cuppens [3] y las relaciones de poder sugeridas por Carabelea et al. [2]; (3) para capturar en el algoritmo de resolución de conflictos diferentes semánticas relacionadas con las nociones deónticas mediante el apoyo a diferentes axiomatizaciones (por ejemplo, la fuerza relativa de la prohibición versus la obligación, nociones deónticas por defecto, inconsistencias deónticas). En el lado teórico, pretendemos utilizar técnicas de análisis de CPNs para caracterizar clases de CPNs (por ejemplo, acíclicos, simétricos, etc.) correspondientes a familias de Estructuras Normativas que son susceptibles a la detección de conflictos offline manejables. La combinación de estas técnicas junto con nuestros mecanismos en línea de resolución de conflictos tiene como objetivo dotar a los diseñadores de MAS con la capacidad de incorporar normas en sus sistemas de manera fundamentada. REFERENCIAS [1] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Diseñando entornos abiertos de ingeniería con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [2] C. Carabelea, O. Boissier y C. Castelfranchi. Utilizando el poder social para permitir a los agentes razonar sobre ser parte de un grupo. En la 5ª Conferencia Internacional. Taller, ESAW 2004, páginas 166-177, 2004. [3] L. Cholvy y F. Cuppens. Resolviendo conflictos normativos mediante la fusión de roles. En la Quinta Conferencia Internacional sobre Inteligencia Artificial y Derecho, Washington, EE. UU., 1995. [4] S. Christensen y T. B. Haagh. Diseño de CPN - visión general de la sintaxis de CPN ML. Informe técnico, Universidad de Aarhus, 1996. [5] R. S. Cost, Y. Chen, T. W. Finin, Y. Labrou y Y. Peng. Utilizando redes de Petri coloreadas para modelar conversaciones. En "Problemas en la Comunicación de Agentes", páginas 178-192, Londres, Reino Unido, 2000. [6] F. Dignum. Agentes autónomos con normas. Inteligencia Artificial y Derecho, 7(1):69-79, 1999. [7] A. Elhag, J. Breuker y P. Brouwer. Sobre el Análisis Formal de Conflictos Normativos. Información y comunicaciones. Tecnología. Ley, 9(3):207-217, octubre de 2000. [8] M. Esteva, W. Vasconcelos, C. Sierra y J. A. Rodríguez-Aguilar. Coherencia normativa en instituciones electrónicas. Volumen 3171 (LNAI), páginas 494-505. Springer-Verlag, 2004. [9] M. Fitting. 

Springer-Verlag, 2004. [9] M. Fitting. Lógica de primer orden y demostración automatizada de teoremas. Springer-Verlag, Nueva York, EE. UU., 1990. [10] N. Fornara, F. Vigan`o y M. Colombetti. Un enfoque basado en eventos para las normas en instituciones artificiales. En el taller AAMAS05: Agentes, Normas e Instituciones para Sistemas Multiagentes Regulados (ANI@REM), Utrecht, 2005. [11] D. Gaertner, P. Noriega y C. Sierra. Extendiendo la arquitectura BDI con compromisos. En Actas de la 9ª Conferencia Internacional de la Asociación Catalana de Inteligencia Artificial, 2006. [12] A. García-Camino, P. Noriega y J.-A. Rodríguez-Aguilar. Un algoritmo para la resolución de conflictos en actividades compuestas reguladas. En el 7º Taller Internacional - ESAW 06, 2006. [13] A. García-Camino, J.-A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Una arquitectura distribuida para sociedades de agentes conscientes de las normas. En DALT III, volumen 3904 (LNAI), páginas 89-105. Springer, 2006. [14] F. Giunchiglia y L. Serafini. Lógicas jerárquicas multilingües o: Cómo podemos prescindir de las lógicas modales. Inteligencia Artificial, 65(1):29-70, 1994. [15] J. Habermas. La Teoría de la Acción Comunicativa, Volumen Uno, Razón y la Racionalización de la Sociedad. Beacon Press, 1984. [16] K. Jensen. 

Beacon Press, 1984. [16] K. Jensen. Redes de Petri coloreadas: Conceptos básicos, métodos de análisis y usos prácticos (Volumen 1). Springer, 1997. [17] M. Kollingbaum y T. Norman. Estrategias para resolver conflictos normativos en el razonamiento práctico. En el taller de ECAI Coordinación en Sociedades de Agentes Emergentes 2004, 2004. [18] J.-L. Koning, G. Francois y Y. Demazeau. Formalización y prevalidación de protocolos de interacción en sistemas multiagentes. En ECAI, páginas 298-307, 1998. [19] B. Kramer y J. Mylopoulos. Representación del conocimiento. En S. C. Shapiro, editor, Enciclopedia de Inteligencia Artificial, volumen 1, páginas 743-759. John Wiley & Sons, 1992. [20] F. Lin, D. H. Norrie, W. Shen y R. Kremer. Un enfoque basado en esquemas para especificar políticas de conversación. En "Problemas en la Comunicación de Agentes", páginas 193-204, 2000. [21] N. Minsky. Interacción Regida por Leyes (LGI): Un Mecanismo de Coordinación y Control Distribuido (Una Introducción y un Manual de Referencia). Informe técnico, Universidad de Rutgers, 2005. [22] T. Murata. Redes de Petri: Propiedades, análisis y aplicaciones. Actas del IEEE, 77(4):541-580, 1989. [23] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1998. [24] A. Ricci y M. Viroli. Artefactos de coordinación: una abstracción unificadora para la coordinación mediada por el entorno de ingeniería en Sistemas Multiagente. Informática, 29:433-443, 2005. [25] G. Sartor. Conflictos normativos en el razonamiento legal. Inteligencia Artificial y Derecho, 1(2-3):209-235, junio de 1992. [26] M. Sergot. Una teoría computacional de posiciones normativas. ACM Trans. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Lógica, 2(4):581-622, 2001. [27] W. W. Vasconcelos, M. Kollingbaum y T. Norman. Resolviendo conflictos e inconsistencias en organizaciones virtuales reguladas por normas. En Actas de AAMAS 07, Hawái, EE. UU., 2007. IFAAMAS. [28] G. H. von Wright. 

IFAAMAS. [28] G. H. von Wright. Norma y Acción: Una Investigación Lógica. Routledge y Kegan Paul, Londres, 1963. [29] M. Wooldridge. Una introducción a los sistemas multiagentes. John Wiley & Sons, Chichester, Reino Unido, febrero de 2002. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 643