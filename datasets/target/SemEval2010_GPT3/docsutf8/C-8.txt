Operación Contexto y Transformación Operativa Basada en Contexto David Sun División de Ciencias de la Computación, EECS Universidad de California Berkeley, CA davidsun@cs.berkeley.edu Chengzheng Sun Escuela de Ingeniería Informática Universidad Tecnológica de Nanyang Singapur CZSun@ntu.edu.sg RESUMEN La Transformación Operativa (OT) es una técnica para el mantenimiento de la consistencia y la reversión de grupo, y se está aplicando a un número creciente de aplicaciones colaborativas. La base teórica de la Terapia Ocupacional es crucial para determinar su capacidad para resolver problemas existentes y nuevos, así como la calidad de esas soluciones. La teoría de la causalidad ha sido la base de todos los sistemas OT anteriores, pero es insuficiente para capturar los requisitos esenciales de corrección. Investigaciones pasadas habían inventado varios parches para solucionar este problema, lo que resultó en algoritmos de OT cada vez más intrincados y complicados. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de optimización combinatoria, reflexionamos sobre lo aprendido y nos propusimos desarrollar un nuevo marco teórico para comprender y resolver mejor los problemas de optimización combinatoria, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El algoritmo COT es capaz de admitir tanto la realización como la reversión de cualquier operación en cualquier momento, sin necesidad de funciones de transformación para preservar la Propiedad de Reversibilidad, la Propiedad de Convergencia 2, y las Propiedades Inversas 2 y 3. El algoritmo COT no solo es más simple y eficiente que los algoritmos de control de OT anteriores, sino que también simplifica el diseño de las funciones de transformación. Hemos implementado el algoritmo COT en un motor de colaboración genérico y lo hemos utilizado para respaldar una variedad de nuevas aplicaciones colaborativas. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas; H.5.3 [Interfaces de Información y Presentación]: Interfaces de Grupo y Organización-Computación Colaborativa; Interacción Sincrónica Términos Generales Algoritmos, Diseño, Teoría 1. La Transformación Operacional (TO) fue originalmente inventada para el mantenimiento de la consistencia en editores de texto plano de grupo [4]. En más de 15 años, la tecnología de operaciones en tiempo real (OT) ha evolucionado para soportar un número creciente de aplicaciones, incluyendo deshacer en grupo [15, 19, 18, 21], conciencia de grupo [28], notificación y compresión de operaciones [20], aplicaciones centradas en hojas de cálculo y tablas [14, 27], edición de documentos HTML/XML y estructurados en árbol [3, 7], procesamiento de texto y creación de presentaciones [29, 25, 24], compartición transparente y heterogénea de aplicaciones [1, 10, 24], y sistemas de cómputo y bases de datos replicadas en dispositivos móviles [6, 16]. Para apoyar de manera efectiva y eficiente las aplicaciones existentes y nuevas, debemos seguir mejorando la capacidad y calidad de la tecnología operativa para resolver tanto problemas antiguos como nuevos. La solidez de la base teórica de la Terapia Ocupacional es crucial en este proceso. Uno de los fundamentos teóricos de todos los algoritmos de OT existentes es la causalidad/concurrencia [9, 17, 4, 22]: las operaciones causalmente relacionadas deben ejecutarse en su orden causal; las operaciones concurrentes deben transformarse antes de su ejecución. Sin embargo, la teoría de la causalidad es insuficiente para capturar las condiciones esenciales de la OT para una transformación correcta. La limitación de la teoría de la causalidad había causado problemas de corrección desde el principio de la OT. El algoritmo dOPT fue el primer algoritmo de OT y se basó únicamente en las relaciones de concurrencia entre operaciones [4]: un par de operaciones son transformables siempre y cuando sean concurrentes. Sin embargo, investigaciones posteriores descubrieron que la condición de concurrencia por sí sola no es suficiente para garantizar la corrección de la transformación. Otra condición es que las dos operaciones concurrentes deben estar definidas en el mismo estado del documento. De hecho, el incumplimiento de la segunda condición fue la raíz del rompecabezas dOPT [22]. Este rompecabezas fue resuelto de varias maneras, pero la teoría de la causalidad, así como sus limitaciones, fueron heredadas por todos los algoritmos de seguimiento de OT. La limitación de la teoría de causalidad se hizo aún más prominente cuando se aplicó la OT para resolver el problema de deshacer en editores de grupo. El concepto de causalidad no es adecuado para capturar las relaciones entre una operación inversa (como una interpretación de un comando de deshacer a nivel meta) y otras operaciones normales de edición. De hecho, la relación de causalidad no está definida para operaciones inversas (ver Sección 2). Se inventaron varios parches para solucionar este problema, lo que resultó en algoritmos OT más intrincados y complicados [18, 21]. Después de haber diseñado, implementado y experimentado con una serie de algoritmos de OT de creciente complejidad, reflexionamos sobre lo aprendido y nos propusimos desarrollar un marco teórico unificado para comprender y resolver mejor los problemas de OT, reduciendo su complejidad y apoyando su evolución continua. En este documento, informamos los principales resultados de este esfuerzo: la teoría del contexto de operación y el algoritmo COT (OT basado en contexto). El resto de este documento está organizado de la siguiente manera. Primero, definimos la causalidad-dependencia/independencia y describimos brevemente sus limitaciones en la Sección 2. A continuación, presentamos los elementos clave de la teoría del contexto de operación, incluyendo la definición de contexto de operación, relaciones de dependencia/independencia del contexto, condiciones basadas en el contexto y vectores de contexto en la Sección 3. En la Sección 4, presentamos el algoritmo COT básico para el mantenimiento de la consistencia (do) y el deshacer en grupo bajo la suposición de que las funciones de transformación subyacentes son capaces de preservar algunas propiedades importantes de transformación. Luego, se discuten estas propiedades de transformación y sus precondiciones en la Sección 5. Las soluciones de COT a estas propiedades de transformación se presentan en la Sección 6. La comparación del trabajo de COT con el trabajo previo de OT, los problemas de corrección de OT y el trabajo futuro se discuten en la Sección 7. Finalmente, las principales contribuciones de este trabajo se resumen en la Sección 8.2. LIMITACIONES DE LA CAUSALIDAD La teoría de la causalidad es fundamental para la computación distribuida y para el diseño de todos los algoritmos de OT existentes. Siguiendo a Lamport [9], las relaciones de causalidad-dependencia/independencia entre las operaciones de edición pueden definirse en términos de sus secuencias de generación y ejecución [4, 23]. Definición 1. Relación de dependencia causal → Dadas dos operaciones Oa y Ob, generadas en los sitios i y j, Ob es causalmente dependiente de Oa, denotado por Oa → Ob, si: (1) i = j y la generación de Oa ocurrió antes de la generación de Ob; o (2) i = j y la ejecución de Oa en el sitio j ocurrió antes de la generación de Ob; o (3) existe una operación Ox, tal que Oa → Ox y Ox → Ob. Definición 2. Relación de independencia causal: Dadas dos operaciones Oa y Ob, Oa y Ob son causalmente independientes o concurrentes, denotadas por Oa Ob, si ni Oa → Ob, ni Ob → Oa. Así como los Relojes Lógicos Vectoriales se utilizan para capturar la causalidad en sistemas distribuidos [17], los Vectores de Estado se han utilizado para capturar las relaciones causales entre operaciones y para representar estados de documentos en sistemas de OT [4, 19, 23]. Para ilustrar las relaciones causales entre operaciones, considere una sesión de edición en grupo en tiempo real con dos sitios en la Figura 1. Hay tres operaciones de edición en este escenario (se explicará más adelante el comando de deshacer Undo(O2) y su relación con otras operaciones): O1 generada en el sitio 0, y O2 y O3 generadas en el sitio 1. Según las Definiciones 1 y 2, tenemos O2 → O3 porque la generación de O2 ocurrió antes que la generación de O3; O1 O2 y O1 O3 porque para cada par, ninguna ejecución de operaciones ocurrió antes que la generación de las otras operaciones. En la siguiente discusión, utilizaremos el término ITtransform para referirnos al uso de la función IT (Transformación de Inclusión): IT(Oa, Ob), la cual transforma la operación Oa contra la operación Ob de tal manera que el impacto de Ob esté efectivamente incluido en Oa [23]. Este término se introduce para diferenciar esta función de transformación especial de otros pasos involucrados en un proceso de transformación. Figura 1: Un escenario de edición en grupo en tiempo real. El escenario en la Figura 1 (sin el comando de deshacer) se ha utilizado a menudo para ilustrar el rompecabezas dOPT. Bajo el algoritmo dOPT [4], cuando O2 llega al sitio 0, será transformado contra O1 ya que O2 O1; esto es correcto porque O2 y O1 están definidos en el mismo estado inicial del documento. Cuando O3 llega al sitio 0, también se transformará en IT contra O1 ya que O3 O1; pero esto es incorrecto porque O3 está definido en el estado del documento que contiene el efecto de O2, mientras que O1 está definido en el estado inicial del documento. En este caso, los parámetros de O3 y O1 no son comparables y, por lo tanto, es posible que no se transformen correctamente en TI. La solución a este rompecabezas es primero transformar IT O1 contra O2 para producir O1, que está definido en el estado del documento incluyendo el efecto de O2 (el mismo estado en el que se define O3), y luego transformar IT O3 contra O1 [22]. A partir de las Definiciones 1 y 2, es claro que la relación de causalidad solo está definida para operaciones originales (por ejemplo, O1, O2 y O3) generados directamente por los usuarios, pero no para operaciones transformadas (por ejemplo, I'm sorry, but the sentence "O1)." does not have a clear meaning in English. Could you please provide more context or a different sentence for translation? Además, la relación de concurrencia no captura la condición esencial para una correcta transformación de TI: las dos operaciones de entrada deben estar definidas en el mismo estado del documento [23]. Otra limitación importante de la causalidad es su inadecuación para capturar condiciones de OT para operaciones inversas. El comando Deshacer (O2) en la Figura 1 se interpreta como una operación inversa O2. El efecto correcto de deshacer para O2 es eliminar el efecto de O2 pero retener los efectos de otras operaciones (es decir, O1 y O3) [21]. Para lograr este efecto, O2 debe ser tratado como una operación definida en el estado del documento que incluye el efecto de O2 pero no de O1 y O3, de modo que O2 pueda ser transformado contra O1 y O3 antes de su ejecución. Sin embargo, según la relación de sucesos de Lamport [9], Deshacer(O2) depende causalmente de O1, O2 y O3. Si O2 heredara la relación causal de Deshacer(O2), entonces sería tratado efectivamente como una operación definida en el estado del documento con los efectos de todas las operaciones O1, O2 y O3, lo que prohibiría que O2 fuera transformado contra cualquier operación, fallando así en lograr el efecto de deshacer correcto. Además, después de ejecutar una operación inversa como O2, el estado del documento ya no puede ser representado adecuadamente por el vector de estado, que solo es capaz de representar operaciones de edición normales originales. 3. CONTEXTO DE OPERACIÓN 3.1 Concepto básico Conceptualmente, cada operación O está asociada con un contexto, denotado por C(O), que corresponde al estado del documento 280 en el que la operación está definida. El significado del contexto de la operación es doble: (1) una operación solo puede ejecutarse correctamente si su contexto y el estado actual del documento son iguales; y (2) una operación solo puede transformarse correctamente contra otra operación si los contextos de estas dos operaciones son iguales. En la Figura 1, tanto O1 como O2 están definidos en el mismo documento inicial, por lo que están asociados con el mismo contexto; O3 está definido en el estado del documento que incluye el efecto de O2, por lo que C(O3) es diferente de C(O1) o C(O2). Cuando O2 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O2) no coincide con el estado actual del documento en el sitio 0, que incluye el efecto de O1. O2 puede ser correctamente transformado en TI contra O1 ya que sus contextos corresponden al mismo estado inicial del documento. Cuando O3 llega al sitio 0, no se puede ejecutar tal como está, ya que C(O3) no coincide con el estado actual del documento en el sitio 0, que incluye los efectos tanto de O1 como de O2. O3 no puede ser correctamente transformado en IT contra O1 ya que sus contextos son diferentes, lo cual es la raíz del rompecabezas dOPT. Como se discute en la Sección 2, Undo(O2) debe interpretarse como un O2 inverso definido en el estado del documento con el efecto de solo O2. Representación de conjunto del contexto de operación Para facilitar la comparación y manipulación de contextos de operación para una ejecución y transformación correctas, es necesario representar explícitamente el contexto de operación. En los sistemas OT, existen dos tipos diferentes de operaciones: operaciones originales que son generadas por los usuarios, y operaciones transformadas que son el resultado de algunas transformaciones. Las operaciones originales se pueden dividir aún más en dos clases: operaciones normales que se generan para hacer algo, y operaciones inversas que se generan para deshacer algunas operaciones ejecutadas. Para cualquier operación O, su inversa se denota por O^(-1). Dado que cada operación transformada debe provenir de una operación original, usamos la notación org(O) para denotar la operación original de O. Si O es una operación original, entonces org(O) = O. Dado que el contexto de una operación corresponde al estado del documento en el que la operación está definida, el problema de la representación del contexto se puede reducir al problema de la representación del estado del documento. En un editor de grupo basado en OT, cada estado del documento puede ser representado de manera única por el conjunto de operaciones originales ejecutadas hasta el momento en el documento. Estas operaciones originales pueden ser ejecutadas en diferentes órdenes o en diferentes formas (originales o transformadas) en diferentes sitios, pero se debe lograr el mismo estado del documento (de acuerdo con el requisito de convergencia [23]). Utilizamos operaciones originales (normales e inversas), en lugar de sus versiones transformadas, para representar el estado de un documento. Definición 3. La representación del estado del documento Un estado de documento puede ser representado por DS de la siguiente manera: 1. El estado inicial del documento está representado por DS = {}. 2. Después de ejecutar una operación O de cualquier tipo en el estado del documento representado por DS, el nuevo estado del documento está representado por DS = DS ∪ {org(O)}. Esta presentación no especifica qué formas de ejecución deben tomar las operaciones originales en DS para llevar el documento al estado actual, pero captura información esencial y suficiente para detectar si dos estados de documentos son iguales y para derivar sus diferencias en términos de operaciones originales. Basándose en la representación del estado del documento, el contexto de una operación normal original debería ser el mismo que la representación del estado del documento del cual se generó esta operación. Para lograr el efecto de deshacer en [21], se debe definir una operación inversa original O en el estado del documento DS = C(O) ∪ {O}, que es el estado después de ejecutar la operación original O en el estado C(O). Según la definición de la función de TI [23], una operación transformada O, donde O = TI(O, Ox), debe definirse en el estado del documento DS = C(O)∪{org(Ox)}, que es el estado alcanzable al ejecutar Ox en el estado C(O). Más precisamente, el contexto de una operación se define a continuación. Definición 4. El contexto de una operación 1. Para una operación normal original O, C(O) = DS, donde DS es la representación del estado del documento del cual se generó O. 2. Para una operación inversa original O, C(O) = C(O) ∪ {O}, donde O es la operación a deshacer. Para una operación transformada O, C(O) = C(O) ∪ {org(Ox)}, donde O = IT(O, Ox). Según la definición anterior, el contexto de cualquier tipo de operación puede ser representado como un conjunto de operaciones originales. Para el escenario en la Figura 1, tenemos C(O1) = {}, C(O2) = {}, y C(O3) = {O2} según la Definición 4-Ítem 1. Según la Definición 4-Ítem 2, tenemos C(O2) = {O2}. A partir de O2 = IT(O2, O1), tenemos que C(O2) = {O1} según la Definición 4-Ítem 3. 3.3 Dependencia/Independencia de contexto Definimos la relación de dependencia/independencia de contexto entre operaciones en términos de si una operación original está incluida en el contexto de otra operación de cualquier tipo. Definición 5. Relación de dependencia de contexto c → Dada una operación original Oa y una operación Ob de cualquier tipo, Ob es dependiente del contexto en Oa, denotado por Oa c → Ob, si: (1) Oa ∈ C(Ob); o (2) existe una operación original Ox, tal que Oa ∈ C(Ox) y Ox ∈ C(Ob). Cabe destacar que la relación de dependencia de contexto está definida únicamente entre una operación original (ya sea normal o inversa) y otra operación de cualquier tipo (original o transformada). Esto se debe a que cualquier operación tiene un contexto, pero solo las operaciones originales pueden ser incluidas en un contexto. Definición 6. Relación de independencia de contexto c Dadas dos operaciones originales Oa y Ob, Oa y Ob son independientes del contexto, denotadas por Oa c Ob, si ni Oa c → Ob, ni Ob c → Oa. Se puede demostrar que si tanto Oa como Ob son operaciones normales originales, entonces Oa c → Ob es equivalente a Oa → Ob; y Oa c Ob es equivalente a Oa Ob. En otras palabras, la relación causal-dependencia/independencia es un caso especial de la relación dependencia/independencia del contexto. 3.4 Condiciones basadas en el contexto Las siguientes Condiciones basadas en el contexto (CC) capturan los requisitos esenciales para la ejecución y transformación de operaciones en sistemas OT: 281 CC1: C(O) ⊆ DS es una condición necesaria para que una operación original O sea transformada al estado del documento DS para su ejecución. CC1 asegura que O siempre se ejecute después de las operaciones dependientes del contexto incluidas en C(O). En otras palabras, para cualquier operación original Ox, si Ox c → O, entonces Ox debe ejecutarse antes que O. Cuando O es una operación normal original, todas las operaciones que ocurren causalmente antes de O deben estar incluidas en C(O) (según la Definición 1 y la Definición 5), por lo que CC1 preserva el orden causal entre las operaciones normales originales [4, 22]. Cuando O es una operación inversa original, C(O) debe incluir la operación que debe deshacerse por O (ver Definición 4-Elemento 2), por lo que CC1 preserva el orden de hacer-deshacer entre operaciones normales e inversas [21]. CC2: DS − C(O)1 es el conjunto de operaciones contra las cuales O debe ser transformado antes de que O se ejecute en el estado del documento DS. CC2 asegura que O se transforma contra todas las operaciones independientes del contexto en DS antes de su ejecución. Se puede demostrar que, para cualquier Ox en DS - C(O), debe ser que Ox c O. Cuando O es una operación normal original, DS − C(O) debe incluir todas las operaciones ejecutadas que son concurrentes con O, por lo que CC2 cubre la condición de que O debe ser transformado contra operaciones concurrentes [4, 22]. Cuando O es una operación inversa, CC2 cubre la condición de que O debe ser transformado contra todas las operaciones que se ejecutan después de la operación a deshacer por O [21]. CC3: C(O) = DS es una condición necesaria para que O se ejecute en el estado del documento DS. CC3 es necesario para ejecutar correctamente las operaciones. CC4: C(Oa) ⊆ C(Ob) es una condición necesaria para que Oa sea transformable a IT en el nuevo contexto dado por C(Ob). Se requiere CC4 porque si C(Oa) ⊆ C(Ob), entonces debe existir una operación Ox ∈ C(Oa) pero Ox ∈ C(Ob), lo que significa que Oa no puede ser transformado por TI al nuevo contexto C(Ob) ya que la transformación por TI no puede eliminar este Ox de C(Oa) (ver Definición 4-ítem3). CC5: C(Ob) − C(Oa) es el conjunto de operaciones contra las cuales Oa debe ser transformado antes de ser transformado contra IT-Ob. CC5 asegura que Oa se transforma contra operaciones independientes del contexto en C(Ob) antes de ser transformado contra Ob por IT. Se puede demostrar que, para cualquier Ox en C(Ob) - C(Oa), debe ser que Ox c Oa, CC6: C(Oa) = C(Ob) es una condición necesaria para que Oa sea transformado contra Ob. CC6 es necesario para aplicar correctamente las funciones de TI. En resumen, CC1 y CC4 son necesarios para garantizar el orden correcto de la ejecución/transformación de operaciones; CC2 y CC5 son necesarios para seleccionar las operaciones objetivo de transformación correctas; y CC3 y CC6 son necesarios para garantizar la correcta ejecución/transformación de operaciones. Estas condiciones basadas en el contexto forman la base para el algoritmo COT que se presentará en la Sección 4 y la Sección 6. 1 DS − C(O) es la diferencia de conjuntos entre DS y C(O). 3.5 Vector de contexto Un elemento importante de la teoría del contexto de operación es el vector de contexto, que representa el conjunto de operaciones de un contexto de manera eficiente. Para mayor conveniencia notacional, asumimos que una sesión de edición colaborativa consiste en N sitios colaboradores, identificados por 0, 1, . . . , N − 1. 3.5.1 Representación de operaciones normales originales Las operaciones normales originales generadas en cada sitio son estrictamente secuenciales, por lo que cada una de ellas puede ser identificada de manera única por un par de enteros (sid, ns), donde sid es el identificador del sitio y ns es el número de secuencia local de esta operación. Sea Oij una operación normal original generada en el sitio i con un número de secuencia j. Si Oij está incluido en un contexto C(O), entonces Oi1, Oi2, . . . , Oij−1 también deben estar incluidos en C(O) de acuerdo con la Definición 3 y la Definición 4. Por lo tanto, todas las operaciones normales generadas en el mismo sitio pueden ser suficientemente caracterizadas por el número de secuencia más grande de estas operaciones. Todas las operaciones normales originales en un contexto se pueden dividir en N grupos según sus sitios de generación, por lo que se necesitan N enteros para representar las operaciones normales originales en un contexto. 3.5.2 Representación de operaciones inversas originales Una operación inversa original puede generarse para deshacer una operación normal original, o para rehacer una operación deshecha. Cada operación inversa original corresponde directa o indirectamente a exactamente una operación normal original. Por ejemplo, la operación inversa O puede ser generada para deshacer O, y O puede ser generada para deshacer O. Tanto O como O corresponden a la misma operación normal O. Basándose en esta observación, todas las operaciones inversas originales en un contexto de operación pueden agruparse por sus operaciones normales originales correspondientes: un grupo inverso por cada operación normal original deshecha. Las operaciones inversas en el mismo grupo inverso pueden diferenciarse aún más por un número de secuencia basado en su orden de ejecución dentro de este grupo. Por ejemplo, O y O están en el mismo grupo inverso correspondiente a O, por lo que O tiene el número de secuencia 1, y O tiene el número de secuencia 2. En general, un inverso puede ser identificado por un triple (sid, ns, is), donde sid y ns son el identificador del sitio y el número de secuencia de la operación normal correspondiente, e is es el número de secuencia inverso dentro del grupo. Dado que las inversiones se ejecutan secuencialmente, el número de secuencia más grande en el grupo puede utilizarse para representar todas las inversiones en el grupo. Los grupos inversos pueden ser divididos en N clusters inversos adicionales de acuerdo a los identificadores de sitio de sus operaciones normales correspondientes. El clúster inverso en el sitio i - icican puede expresarse de la siguiente manera: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], donde cada par (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj operaciones inversas correspondientes a la operación normal original con número de secuencia nsj en el sitio i. Si ninguna operación normal en el sitio i ha sido deshecha, ici está vacío. 3.5.3 Representación de operaciones normales e inversas Para representar un contexto de operación con operaciones normales originales e inversas, se define a continuación un vector de contexto N-dimensional. Definición 7. Dado una operación O, su contexto C(O) puede ser representado por el siguiente vector de contexto CV(O): CV(O) = [(ns0, ic0), (ns1, ic1), . . . , (nsN−1, icN−1)], donde, para 0 ≤ i ≤ N − 1, 1. nsi representa todas las operaciones normales originales generadas en el sitio i, y 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)] representa todas las operaciones inversas para deshacer las operaciones normales generadas en el sitio i, donde (nsj, isj), 0 ≤ j < k, representa un grupo inverso con isj inversos relacionados con la operación normal con número de secuencia nsj. 2 En ausencia de operaciones inversas en el contexto de la operación, todos los ici, 0 ≤ i ≤ N − 1, estarían vacíos y un Vector de Contexto se reduciría a un Vector de Estado [4]. La representación vectorial del contexto de la operación también puede ser utilizada como la representación vectorial del estado del documento. Como ejemplo, considera el estado del documento después de interpretar el comando deshacer Undo(O2) en la Figura 1. Dado que Undo(O2) se interpreta como un O2 inverso (ver Sección 4.2), el estado del documento después de ejecutar (el transformado) O2 deberá ser DS = {O1, O2, O3, O2}. Este estado del documento no puede ser representado por un vector de estado, pero puede ser representado como un vector de contexto de la siguiente manera: CV (DS) = [(1, [ ]), (2, [(1, 1)]]. Basándose en la Definición 7, es sencillo derivar el esquema para mantener la representación vectorial del estado del documento después de ejecutar cada operación (según la Definición 3). Además, la representación vectorial del contexto de la operación también se puede utilizar para detectar de manera eficiente las relaciones de dependencia/independencia del contexto. Debido a limitaciones de espacio, estos detalles técnicos se omiten en este documento. 4. En el algoritmo COT básico, asumimos que cada sitio mantiene un estado de documento DS, que contiene el conjunto de operaciones originales ejecutadas hasta el momento. Esto es diferente de los esquemas de registro o de búfer de historial (HB) en algoritmos OT anteriores [4, 22, 23], que registran una lista de operaciones transformadas. Dejamos intencionalmente sin especificar la estructura de datos interna de DS para mantener el algoritmo COT independiente de la estrategia de almacenamiento en búfer de operaciones. En la descripción del algoritmo, utilizaremos la representación del conjunto de contexto C(O), en lugar de la representación del vector de contexto CV(O). Cuando una operación O se propaga desde el sitio local a sitios remotos, sin embargo, es el vector de contexto, no el conjunto de contexto, el que se adjunta realmente a O para la propagación. El conjunto de operaciones en C(O) puede ser fácilmente determinado a partir de DS basado en la información en CV(O). El algoritmo COT tiene dos partes: la parte COT-DO para mantener la consistencia (hacer) y la parte COT-UNDO para deshacer. Ambas partes comparten el mismo procedimiento de transformación basado en el contexto central. El contexto de la operación y las condiciones basadas en el contexto son fundamentales para todo el algoritmo COT. 4.1 COT-DO COT-DO toma dos parámetros: O - una operación original a ejecutar, y DS - la representación actual del estado del documento. COT-DO se invoca solo si C(O) ⊆ DS (CC1), lo que garantiza que todas las operaciones incluidas en el contexto de O ya han sido ejecutadas en DS. Algoritmo 1. COT-DO(O, DS) 1. transformar(O, DS − C(O)); 2. Ejecutar O; DS := DS ∪ {org(O)}. Procedimiento 1. transformar(O, CD) Repetir hasta que CD = { }: 1. Eliminar Ox de CD, donde C(Ox) ⊆ C(O); 2. transformar(Ox, C(O) − C(Ox)); 3. O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. 

O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. COT-DO primero invoca el procedimiento transform() para transformar O contra las operaciones en DS − C(O) (CC2). Esto es para mejorar el contexto de O a DS. En el Paso 2, debe ser que C(O) = DS (CC3), por lo que O se ejecuta tal cual, y el original de O se agrega a DS (según la Definición 3-Ítem 2). El corazón de COT-DO es transform(O, CD), cuya tarea es transformar O contra las operaciones en CD, que representa la diferencia de contexto entre C(O) y un nuevo contexto en el que se define O. Este procedimiento repite los siguientes tres pasos hasta que el CD quede vacío: 1. Eliminar una operación Ox de CD, donde C(Ox) ⊆ C(O) (CC4). Una operación Ox que cumpla con esta condición puede ser determinada si todas las operaciones en CD están ordenadas en el orden de su ejecución y se recuperan secuencialmente. 2. El procedimiento transform() es invocado de forma recursiva para transformar Ox contra las operaciones en C(O)−C(Ox) (CC5). Esto es para actualizar Ox al contexto de O, para que puedan ser utilizados para la transformación de IT en el siguiente paso. 3. Después de la llamada recursiva a transform(), debe ser que C(O) = C(Ox) (CC6), por lo que O se transforma en IT contra Ox, y el contexto de O se actualiza agregando el original de Ox (según la Definición 4-Ítem 3). Para mostrar cómo funciona COT-DO, examinamos cómo resuelve el rompecabezas dOPT en la Figura 1. Considera las ejecuciones de operaciones en el sitio 0, con el estado inicial del documento DS0 = { }. 1. Después de la generación de O1, dado que C(O1) = DS0, O1 se ejecuta tal cual y DS0 se actualiza a DS1 = {O1}. 2. Cuando O2 llega con C(O2) = {}, se llama a transform(O2, DS1− C(O2)), donde DS1 − C(O2) = {O1}. Dentro de transform(O2, {O1}), dado que C(O1) = C(O2), tenemos O2 := IT(O2, O1), y C(O2) = {O1}. Al regresar de transformar(O2, {O1}), tenemos que C(O2) = DS1, por lo que se ejecuta O2 y DS1 se actualiza a DS2 = {O1, O2}, donde O2 = org(O2). Cuando O3 llega con C(O3) = {O2}, se llama a transform(O3, DS2− C(O3)), donde DS2 − C(O3) = {O1}. Dentro de transform(O3, {O1}), se llama recursivamente a transform(O1, C(O3)−C(O1)), con C(O3) − C(O1) = {O2}, que es el paso clave para detectar el rompecabezas dOPT. En la transformación recursiva (O1, {O2}), dado que C(O2) = C(O1), tenemos O1 := IT(O1, O2), y C(O1) = {O2}. Al regresar de la recursión, tenemos C(O1) = C(O3), por lo que C(O3) := IT(O3, O1) (el rompecabezas dOPT resuelto aquí), y C(O3) = {O1, O2}, donde O1 = org(O1). Después de regresar de transformar(O3, {O1}), C(O3) = DS2; por lo tanto, se ejecuta O3 y DS2 se actualiza a DS3 = {O1, O2, O3}, donde O3 = org(O3). 283 4.2 COT-DESHACER Para deshacer una operación O, un comando de deshacer a nivel meta Undo(O) debe ser emitido por un usuario. Cómo generar el comando de deshacer para seleccionar cualquier operación a deshacer es parte de la política de deshacer [21]. Este documento se limita a la discusión del mecanismo de deshacer, que determina cómo deshacer la operación seleccionada en un contexto dado. En COT-UNDO, Undo(O) se interpreta como un O inverso, que depende del contexto de las operaciones en C(O) y O mismo. COT-UNDO toma dos parámetros de entrada: O es la operación seleccionada para deshacer, que puede ser cualquier operación realizada hasta ahora, y DS es la representación actual del estado del documento. Algoritmo 2. COT-DESHACER(O, DS) 1. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 2. COT-DO(O, DS). 

COT-DO(O, DS). COT-UNDO funciona primero creando una O inversa invocando makeInverse(O)2, con su contexto C(O) := C(O) ∪ {O} (según la Definición 4-Elemento 2), y luego invocando COTDO para manejar O. Por ejemplo, para interpretar Undo(O2) en la Figura 1, se invoca a COTUNDO con los parámetros O2 y DS = {O1, O2, O3}. Primero, se crean O2 y C(O2) = {O2}. Entonces, se invoca a COT-DO con los parámetros O2 y DS. Dentro de COT-DO, se invocará transform(O2, DS − C(O2)), y O2 será transformado correctamente contra O1 y O3 ya que CD = DS − C(O2) = {O1, O3}. Este ejemplo muestra que una operación inversa puede ser manejada por COT-DO de la misma manera que otras operaciones normales. Esto se debe a que las condiciones basadas en el contexto CC1 - CC6 son uniformemente aplicables tanto a las operaciones normales como a las inversas. El algoritmo básico de COT es simple pero poderoso, capaz de realizar y deshacer cualquier operación en cualquier momento. Entre todos los sistemas OT anteriores, solo la combinación de GOTO y ANYUNDO (referida como GOTO-ANYUNDO) tiene capacidades similares [22, 21]. 5. Las propiedades de transformación de COT son un algoritmo de control de alto nivel responsable de determinar qué operación debe ser transformada frente a otras operaciones y en qué orden según condiciones basadas en el contexto. Otro componente importante de un sistema de OT son las funciones de transformación de bajo nivel responsables de transformar las operaciones según sus tipos y parámetros. Investigaciones previas han identificado una serie de propiedades/condiciones de transformación que deben mantenerse para garantizar la corrección de un sistema de OT. Los diferentes sistemas de OT pueden tener diferentes algoritmos de control, diferentes funciones de transformación y diferentes divisiones de responsabilidades entre estos componentes. A diferencia de GOTO-ANYUNDO, el algoritmo básico COT no utiliza funciones de ET (Transformación de Exclusión) [21], evitando así el requisito de la Propiedad de Reversibilidad (RP) entre las funciones de IT y ET [21]. Similar al algoritmo GOTO-ANYUNDO, el algoritmo básico COT asume que las funciones de transformación subyacentes son capaces de preservar las siguientes propiedades [4, 15, 19, 23, 21]: 2 Se remite al lector a [25] para definiciones precisas de las tres operaciones primitivas Insertar, Eliminar y Actualizar y sus inversas correspondientes. El procedimiento makeInverse(O) sigue directamente estas definiciones. 1. Propiedad de Convergencia 1 (PC1). Dado un estado de documento DS y operaciones Oa, Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: DS ◦ [Oa, Ob] = DS ◦ [Ob, Oa], lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en el estado del documento DS. 2. Propiedad de Convergencia 2 (PC2). Dadas tres operaciones O, Oa y Ob, si Oa = IT(Oa, Ob) y Ob = IT(Ob, Oa), entonces debe ser: IT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa), lo que significa que [Oa, Ob] y [Ob, Oa] son equivalentes con respecto al efecto en la transformación. 3. Propiedad Inversa 2 (PI2)4. Dada cualquier operación Ox y un par de operaciones [O, O], debe ser: IT(IT(Ox, O), O) = IT(Ox, I) = Ox, lo que significa que [O, O] e I son equivalentes con respecto al efecto en la transformación. 4. Propiedad Inversa 3 (PI3). Dadas dos operaciones Oa y Ob, si Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), y Oa := IT(Oa, Ob), entonces debe ser: Oa = Oa, lo que significa que la operación inversa transformada Oa es igual a la inversa de la operación transformada Oa. Las propiedades de transformación anteriores son descubrimientos importantes de investigaciones pasadas, pero no son requeridas incondicionalmente. Las condiciones previas para requerirlas, sin embargo, nunca fueron explícitamente establecidas en sus especificaciones, lo que desafortunadamente ha causado algunas concepciones erróneas en la literatura de OT. Para explorar soluciones alternativas a estas propiedades, declaramos explícitamente las Precondiciones (PC) para CP1, CP2, IP2 e IP3 de la siguiente manera: 1. PC-CP1: CP1 es necesario solo si el sistema OT permite que el mismo grupo de operaciones independientes del contexto se ejecuten en diferentes órdenes. 2. PC-CP2: CP2 es necesario solo si el sistema OT permite que una operación sea transformada contra el mismo grupo de operaciones independientes del contexto en diferentes órdenes. 3. PC-IP2: IP2 es necesario solo si el sistema OT permite que una operación Ox se transforme contra un par de operaciones de hacer y deshacer (O y O) una por una. 4. PC-IP3: IP3 solo es necesario si el sistema OT permite que una operación inversa Oa sea transformada contra otra operación Ob que es independiente del contexto de Oa. Las Propiedades de Convergencia 1 y 2 en este documento (y en [21]) son iguales a las Propiedades de Transformación 1 y 2 en [19]. Hay otra Propiedad Inversa 1 (IP1) que se requiere en un sistema OT para lograr el efecto de deshacer correcto [21], pero IP1 no está relacionada con las funciones de TI. En general, hay dos formas de lograr la corrección de OT con respecto a estas propiedades de transformación: una es diseñar funciones de transformación capaces de preservar estas propiedades; la otra es diseñar algoritmos de control capaces de romper las precondiciones para requerir estas propiedades. Investigaciones previas han demostrado que es relativamente fácil diseñar funciones de transformación capaces de preservar CP1, pero no trivial diseñar y demostrar formalmente funciones de transformación capaces de preservar CP2, IP2 e IP3. Contraejemplos que ilustran la violación de estas propiedades en algunas funciones de transformación publicadas anteriormente se pueden encontrar en [23, 21, 8, 11]. Las funciones de TI capaces de preservar IP2 e IP3 habían sido ideadas en el contexto de ANYUNDO [21], pero nuestra experiencia en la implementación de estas funciones reveló que esas soluciones son bastante intrincadas y poco eficientes (se puede encontrar un análisis más detallado en la Sección 7). Claramente, resolver CP2, IP2 e IP3 a nivel del algoritmo de control tiene el beneficio de simplificar el diseño de las funciones de transformación y el sistema OT en su totalidad. En la siguiente sección, ampliamos el algoritmo COT básico para proporcionar soluciones simples y eficientes a CP2, IP2 e IP3 a nivel del algoritmo de control. 6. Una característica distintiva de COT es que en cada proceso de transformación (es decir, una invocación de transform(O, CD)), todo el conjunto de operaciones objetivo de transformación se determina de antemano y está disponible en el parámetro de diferencia de contexto CD (calculado utilizando las condiciones basadas en el contexto CC2 y CC5). Con el conocimiento de todas las operaciones involucradas en el proceso de transformación, somos capaces de organizar adecuadamente estas operaciones para romper las precondiciones de CP2, IP2 e IP3. 6.1 Procedimiento de transformación extendido Extendemos el procedimiento central transform(O, CD) para aprovechar el conocimiento global de las operaciones en el parámetro de diferencia de contexto CD para romper PC-CP2, PC-IP2 y PC-IP3. La transformación extendida(), como se muestra en el Procedimiento 2, conserva la estructura y los elementos principales del Procedimiento 1, pero agrega soluciones a CP2, IP2 e IP3 en el Paso 1 (asegurar TPsafety()) y en el Paso 2-(c) (la parte del si-entonces). Procedimiento 2. transformar(O, CD) 1. Si CD = { }, asegúrate de TPsafety(O, CD); 2. Repetir hasta que CD = { }: (a) Eliminar la primera operación Ox de CD; (b) transformar(Ox, C(O) − C(Ox)); (c) Si Ox es un par de hacer-deshacer, entonces C(O) := C(O) ∪ {org(Ox), org(Ox)}; de lo contrario O := IT(O, Ox); C(O) := C(O) ∪ {org(Ox)}. Procedimiento 3. asegurar la seguridad de TP (O, CD) 1. Asegurar la seguridad de CP2: ordenar las operaciones en CD en un orden total que respete su orden de dependencia de contexto. 2. Asegurar la seguridad de IP2: para cualquier Ox ∈ CD, si Ox ∈ CD, entonces marcar Ox como un par de hacer-deshacer, y eliminar Ox de CD. 3. Asegurar la seguridad de IP3: si O es inverso, invocar para hacer IP3seguro Inverso(O, CD). Procedimiento 4. hacer IP3safe Inverso(O, CD) 1. O := hacerInversa(O); C(O) := C(O) − {O}; 2. NCD := {Ox | Ox ∈ CD y Ox ⊂ O}; 3. transformar(O, NCD); 4. O := hacerInversa(O); C(O) := C(O) ∪ {O}; 5. CD := CD − NCD. 6.2 Rompiendo la precondición para CP2 La solución COT para CP2 es ordenar todas las operaciones en CD en un orden total que respete su orden de dependencia de contexto (en el Paso 1 de garantizar TPsafety()). Si una operación O es transformada contra el mismo grupo de operaciones independientes del contexto en múltiples invocaciones para transformar(O, CD), este grupo de operaciones debe estar incluido en CD y ordenado en el mismo orden total. Por lo tanto, O nunca puede ser transformado en contra del mismo grupo de operaciones en diferentes órdenes, rompiendo así PC-CP2. Cabe destacar que CD se convierte en un conjunto ordenado después de la clasificación. El primer Ox en CD debe cumplir la condición C(Ox) ⊆ C(O) en el Paso 2(a) de transform(O, CD) (Procedimiento 1), por lo que esta condición ya no se especifica explícitamente en el Procedimiento 2. Un orden total correcto para romper PCCP2 puede determinarse convenientemente utilizando las relaciones de dependencia de contexto entre todas las operaciones, además de los identificadores de sitio de las operaciones independientes del contexto. Ha habido varios sistemas OT anteriores capaces de romper PC-CP2, incluido el sistema GOT (mediante un esquema de deshacer/rehacer basado en el orden total) [23], el sistema SOCT4 (mediante una estrategia de control basada en secuenciación global) [26], el sistema NICE (mediante un notificador central basado en transformación) [20], y el sistema TIBOT (mediante un protocolo de sincronización distribuido basado en tiempo interno) [12]. La solución COT para CP2 es única y evita el uso de cualquier operación de deshacer/rehacer o secuenciación/sincronización global. 6.3 Rompiendo la precondición para IP2 La idea básica de la solución COT para IP2 es asegurarse de que una operación nunca se transforme contra un par de operaciones de hacer y deshacer una por una, rompiendo así PCIP2. Esta solución consta de dos partes: (1) El Paso 2 de asegurar la seguridad de TP(CD) acopla las operaciones con sus inversas correspondientes si todas están incluidas en la diferencia de contexto CD, y elimina estas inversas de CD; (2) En el Paso 2-(c) de transform(), si se encuentra que Ox es un par de hacer-deshacer, la transformación IT de O contra Ox se omite (tratando efectivamente este par como una operación de identidad) y el contexto de O se actualiza añadiendo dos operaciones: {org(Ox), org(Ox)}. 6.4 Rompiendo la precondición para IP3 La solución COT para IP3 está encapsulada en el procedimiento hacer IP3seguro Inverso(O, CD), que convierte a O en un inverso seguro para IP3 con respecto a la diferencia de contexto CD. Un O inverso es seguro con respecto a IP3 con respecto a CD si está hecho a partir de una versión transformada de O, que ha incluido todas las operaciones en CD que son independientes del contexto de O. Bajo el control de COT, el inverso seguro de IP3 nunca debe ser transformado en contra de operaciones que son independientes del contexto de O, rompiendo así PC-IP3. El procedimiento inverso IP3safe de la marca funciona de la siguiente manera: (1) crear la operación O (la inversa de O) y C(O) = C(O) - 285 {O}; (2) seleccionar todas las operaciones de CD que son independientes del contexto de O y crear una nueva diferencia de contexto NCD; (3) transformar O contra las operaciones en NCD (invocando recursivamente a transform()); (4) crear una nueva inversa a partir de la O transformada; y (5) crear un nuevo CD restando NCD del CD antiguo (el nuevo CD debe mantener el orden total requerido para resolver CP2). Este nuevo inverso O debe ser seguro para IP3 porque se crea a partir de una operación transformada cuyo contexto ha incluido todas las operaciones en NCD. El inverso seguro de IP3 nunca debe ser transformado en contra de las operaciones en NCD ya que estas operaciones han sido eliminadas del nuevo CD en el Paso (5). 7. DISCUSIONES 7.1 La teoría del contexto de operación La noción de contexto de operación fue propuesta por primera vez en el algoritmo GOT [23] y utilizada en conjunto con la teoría de causalidad en los algoritmos de seguimiento GOTO y ANYUNDO [22, 21]. En trabajos anteriores, el contexto de una operación O se definió como una secuencia de operaciones transformadas que pueden ejecutarse para llevar el documento desde su estado inicial al estado en el que O está definido. Esta definición está directamente vinculada a la estrategia de almacenamiento en búfer de historial secuencial, que guarda las operaciones ejecutadas en sus formas y órdenes de ejecución. No hubo una representación explícita de un contexto de operación. Las relaciones de contexto entre las operaciones se derivan de las relaciones de causalidad más las relaciones de posición en el búfer de historial entre las operaciones [23, 21]. En este documento, el concepto de contexto de operación se define como un conjunto de operaciones originales correspondientes al estado del documento en el que se define esta operación. Este nuevo concepto de contexto de operación es independiente de la estrategia de almacenamiento en búfer de operaciones subyacente y se representa explícitamente como un conjunto de operaciones. Basándose en la representación del conjunto del contexto de operación, las condiciones esenciales de la OT (CC1 - CC6) han sido capturadas de manera precisa y concisa. Además, el vector de contexto ha sido diseñado para representar de manera eficiente tanto operaciones normales como inversas en un contexto. El vector de contexto es más general que el vector de estado y potencialmente aplicable a otros sistemas de computación distribuida también. Basándose en la teoría de la causalidad, los algoritmos de OT previos han utilizado vectores de estado para capturar las relaciones de dependencia causal entre las operaciones normales originales y para representar los estados de los documentos en términos de operaciones normales originales. Sin embargo, las relaciones de causalidad-dependencia no están definidas para operaciones inversas o transformadas, y los vectores de estado no pueden representar estados de documentos con operaciones inversas originales. La teoría de la causalidad no puede capturar las condiciones esenciales de OT (CC1 - CC6) para todos los tipos de operaciones - originales y transformadas, operaciones normales e inversas. 7.2 COT versus GOTO-ANYUNDO Tanto COT como GOTO-ANYUNDO son capaces de realizar y deshacer cualquier operación en cualquier momento. La principal diferencia es que COT logra esta capacidad sin utilizar funciones de ET (eliminando así el requisito de RP para las funciones de TI), y sin requerir que las funciones de TI preserven CP2, IP2 e IP3. La evitación de RP, CP2, IP2 e IP3 ha simplificado significativamente el diseño de las funciones de transformación y el sistema OT en su totalidad. COT es más simple que GOTO-ANYUNDO (y los algoritmos OT anteriores basados en la teoría de la causalidad) debido al uso de una única teoría de contexto de operación para capturar todas las condiciones relacionadas con OT (CC1-CC6), la uniformidad de las condiciones basadas en contexto para tratar todos los tipos de operación, y la concisión de estas condiciones basadas en contexto. El sistema basado en COT es más eficiente que el sistema basado en GOTOANYUNDO en la resolución de IP2 e IP3. En GOTOANYUNDO, la parte de hacer (una operación normal) y la parte de deshacer (una operación inversa) deben estar acopladas con el propósito de preservar IP2 [21]. Se adoptó una estrategia de acoplamiento entusiasta: una operación inversa se acopla con su operación normal correspondiente inmediatamente después de su ejecución. Bajo este esquema, las operaciones inversas no están explícitamente representadas en el búfer de historial. Cuando se va a ejecutar una operación normal, sin embargo, puede ser necesario transformarla solo contra la parte de deshacer de un par de hacer-deshacer. Para hacer frente a este problema, se debe utilizar un esquema adicional DeCouple-GOTO-ReCouple para desacoplar un par de hacer-deshacer antes de invocar GOTO y luego volver a acoplarlos después [21]. Sin embargo, la implementación de este esquema de desacoplamiento y recoplamiento reveló que era bastante intrincado y causaba muchas transformaciones repetidas. En el algoritmo COT, COT-DO y COT-UNDO están integrados de forma transparente. Las operaciones inversas están representadas explícitamente en el contexto de la operación, y se adopta una estrategia de acoplamiento perezoso: el acoplamiento de un par de hacer-deshacer no ocurre inmediatamente después de ejecutar cada inversa, sino solo cuando tanto la parte de hacer como la parte de deshacer aparecen en el mismo proceso de transformación en una etapa posterior. Estas estrategias ayudan a evitar transformaciones innecesarias causadas por el esquema de acoplamiento prematuro y el esquema de desacoplamiento y recoplamiento. En el sistema basado en GOTO-ANYUNDO, la solución para IP3 está encapsulada en una función de TI que preserva IP3, llamada IP3P-IT [21]. Dentro de esta función, se debe utilizar una función ET extendida, que puede invocar el costoso algoritmo GOTO para garantizar la RP con la función IT correspondiente. Por el contrario, la solución COT al IP3 está encapsulada en el procedimiento de alto nivel hacer IP3safe Inverse(O, CD), que es más eficiente ya que (1) evita convertir O a O de ida y vuelta múltiples veces para cada Ox ∈ NCD (si en su lugar se usara IP3P-IT(O, Ox)); y (2) el procedimiento transform() es mucho más económico que GOTO. Estrategias de almacenamiento en búfer OT 7.3 Otra característica distintiva del algoritmo COT es la separación del algoritmo de la estrategia de almacenamiento en búfer subyacente. Esto no solo ha dado como resultado una estructura lógica más limpia y simple para el algoritmo en sí, sino que también ha permitido una variedad de optimizaciones de rendimiento a nivel de almacenamiento de operaciones. Hemos ideado e implementado una estructura de almacenamiento en la que no solo se pueden guardar las operaciones originales, sino también las versiones transformadas; y todas las operaciones transformadas de la misma operación original se organizan en el mismo grupo de versiones. Cuando se requiere una operación original a nivel del algoritmo COT, se busca en el grupo de versiones correspondiente una versión que cumpla con el requisito de contexto. Si tal versión ya existe, se utiliza para representar la operación original en el proceso de transformación, ahorrando así el costo adicional de transformar la operación original en esta versión. Bajo esta estructura de almacenamiento intermedio, se pueden utilizar varios heurísticos para guardar selectivamente versiones transformadas con el fin de maximizar su reutilización y minimizar su uso de espacio. Mediante experimentación, hemos identificado algunas heurísticas útiles que son efectivas en ahorrar transformaciones para una serie de patrones comunes de secuencia de operaciones. COT no es el primer algoritmo de OT que almacena en búfer y utiliza operaciones originales para la transformación. Varios algoritmos de OT anteriores, incluyendo CCU [2], adOPTed [19] y GOTOANYUNDO [21], también han almacenado en búfer las operaciones originales. COT es único en su forma de almacenar en búfer y utilizar operaciones originales, así como transformadas. 7.4 Corrección de OT La corrección de OT es un tema central de discusión en la investigación de OT. En esta sección, proporcionamos nuestras observaciones y opiniones sobre algunos problemas importantes de corrección de OT. OT es un sistema complejo con múltiples componentes interrelacionados. Se necesita un enfoque orientado al sistema para abordar los problemas de OT. Un método experimental, llamado detección-resolución de rompecabezas, ha sido comúnmente utilizado en la exploración y refinamiento de soluciones de OT. Los rompecabezas son escenarios sutiles pero representativos en los que ciertas propiedades/condiciones de la Teoría de la Optimización pueden ser violadas y el sistema puede producir resultados incorrectos. La capacidad de resolver todos los acertijos conocidos es una condición necesaria y un indicador importante de la solidez de un sistema de OT. En la literatura de investigación, a menudo se utilizan escenarios de rompecabezas simples para ilustrar las razones clave por las que un sistema de OT funciona o falla. En el diseño real de sistemas OT, sin embargo, una implementación real y casos de prueba exhaustivos basados en escenarios de rompecabezas complejos son cruciales para validar un diseño. Los métodos teóricos también se han utilizado para verificar formalmente la corrección de la OT con respecto a algunas propiedades/condiciones de transformación identificadas. La verificación formal puede ser efectiva si los problemas de corrección han sido bien comprendidos y los criterios de verificación y condiciones límite han sido bien definidos. En este sentido, métodos experimentales como la detección y resolución de acertijos pueden desempeñar un papel importante en obtener las ideas necesarias sobre los problemas reales de corrección, y establecer criterios y condiciones adecuadas para la verificación formal. Se necesita un enfoque sistemático para llevar a cabo tanto la investigación experimental como teórica en Terapia Ocupacional. Muchos componentes y problemas de la OT están íntimamente relacionados, y una solución a un problema, si se examina de forma aislada, es poco probable que sea correcta o completa. Por ejemplo, una solución que funciona bien para el mantenimiento de la consistencia (hacer), puede fallar cuando se consideran tanto problemas de hacer como deshacer; y una solución de deshacer (por ejemplo, preservar IP2) puede violar la solución para el mantenimiento de la consistencia [21]. Una solución completa de OT para tanto hacer como deshacer problemas es significativamente más difícil de diseñar que una solución parcial para solo uno de ellos. Por otro lado, un problema difícil en un componente de la terapia ocupacional puede resolverse fácilmente, o evitarse por completo, si este problema se aborda desde un componente diferente de la terapia ocupacional. Por ejemplo, se sabe que idear y demostrar funciones de transformación capaces de preservar las propiedades CP2, IP2 e IP3 son difíciles. Sin embargo, estas dificultades pueden evitarse mediante la creación de algoritmos de control (como COT) capaces de romper las precondiciones para requerir estas propiedades; también es más fácil demostrar que un algoritmo de control es capaz de romper las precondiciones para estas propiedades, que demostrar que las funciones de transformación son capaces de preservarlas. Los diferentes sistemas de OT pueden tener diferentes divisiones de responsabilidad entre sus componentes y, por lo tanto, diferentes requisitos de corrección para estos componentes. Se debe tener precaución al interpretar los resultados de corrección. Por ejemplo, se demostró que CP1 y CP2 son necesarios y suficientes para que los sistemas basados en adOPTed converjan [19, 13], pero este resultado no puede generalizarse a todos los sistemas de OT. De hecho, CP1 y CP2 no son ni suficientes ni necesarios para muchos sistemas de OT. Son insuficientes porque un sistema OT puede necesitar preservar propiedades o condiciones adicionales, como IP2, IP3 y aquellas resumidas en [21]. Son innecesarios si las condiciones previas que requieren su uso han sido incumplidas. Por ejemplo, ni CP1 ni CP2 son necesarios en el sistema REDUCE basado en el algoritmo GOT para garantizar la convergencia [23]. CP2 tampoco es requerido por sistemas OT basados en COT o algunos algoritmos OT previos [26, 20, 12]. Un problema de corrección de OT, que a menudo se discute en relación con el problema de violación de CP2, es el problema de empate falso: cuando dos (o más) operaciones de inserción con la misma posición se transforman entre sí con IT, el empate de posición puede ser falso si no era original sino causado por transformaciones previas. Un sistema de OT puede fallar en producir resultados correctos si se utiliza la regla normal de desempate (por ejemplo, basada en identificadores de sitio) para romper empates falsos. Este problema fue descubierto hace mucho tiempo en los primeros trabajos de OT y un escenario concreto relacionado con este problema fue ilustrado en la Figura 6 de [23]. Está fuera del alcance de este documento discutir soluciones a este problema, pero vale la pena señalar que el problema de empate falso es diferente del problema de violación de CP2: un empate falso puede ocurrir sin violar CP2. En nuestra opinión, el problema de la falsa atadura es un tema a nivel de la función de transformación y su solución podría y debería ser localizada también en este nivel. Para ver opiniones y enfoques alternativos sobre este problema, se remite al lector a [8, 11, 5]. El algoritmo COT ha sido implementado y validado por un completo conjunto de pruebas que cubre todos los escenarios de rompecabezas de OT conocidos. En este documento, se ha utilizado un análisis informal y escenarios de rompecabezas simples para demostrar la corrección de COT con respecto a varias propiedades/condiciones de transformación. La verificación formal de la corrección de COT con respecto a estas propiedades/condiciones, y el análisis cuantitativo de la complejidad temporal y espacial de COT, se informarán en una versión del artículo para una revista científica. 8. CONCLUSIONES Hemos contribuido a la teoría del contexto de operación y al algoritmo COT (OT basado en contexto). La teoría del contexto de operación es capaz de capturar relaciones y condiciones esenciales para todo tipo de operación en un sistema de OT; proporciona una nueva base para comprender y resolver mejor los problemas de OT. El algoritmo COT proporciona soluciones uniformes tanto para el mantenimiento de la consistencia como para los problemas de deshacer; es más simple y eficiente que los algoritmos de control de OT anteriores con capacidades similares; y simplifica significativamente el diseño de las funciones de transformación. El algoritmo COT ha sido implementado en un motor de colaboración genérico y utilizado para apoyar una variedad de nuevas aplicaciones colaborativas [24]. Las aplicaciones del mundo real ofrecen emocionantes oportunidades y desafíos para la investigación futura en Terapia Ocupacional. La teoría del contexto de operación y el algoritmo COT servirán como nuevas bases para abordar los desafíos técnicos en las aplicaciones de OT existentes y emergentes. Agradecimientos Los autores agradecen a Bo Begole y a los revisores anónimos por sus valiosos comentarios y sugerencias que han contribuido a mejorar la presentación del artículo.  REFERENCIAS [1] J. Begole, M. Rosson y C. Shaffer. Transparencia en la colaboración flexible: apoyando la independencia del trabajador en sistemas de compartición de aplicaciones replicadas. ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack.
Traducción: ACM Trans. on Computer-Human Interaction, 6(2):95-132, 1999. [2] G. Cormack. Un cálculo para actualización concurrente. En el Informe de Investigación CS-95-06, Departamento de Ciencias de la Computación, Universidad de Waterloo, Canadá, 1995. [3] A. Davis, C. Sun y J. Lu. Generalizando la transformación operacional al lenguaje de marcado general estándar. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 58 - 67, noviembre de 2002. [4] C. A. Ellis y S. J. Gibbs. Control de concurrencia en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Gestión de Datos, páginas 399-407, mayo de 1989. [5] N. Gu, J. Yang y Q. Zhang. Mantenimiento de la consistencia basado en la técnica de marca y retrace en sistemas de trabajo en grupo. En Proc. de la Conf. de ACM sobre Trabajo en Grupo, páginas 264-273, noviembre de 2005. [6] R. Guerraoui y Corine Hari. Sobre el problema de consistencia en la computación distribuida móvil. En Actas del Segundo Taller Internacional de ACM sobre Principios de Computación Móvil, páginas 51-57, Nueva York, octubre de 2002. ACM. [7] C. Ignat y M.C. Norrie. Editor colaborativo personalizable que se basa en el algoritmo treeOPT. En Actas de la Conferencia Europea de Trabajo Cooperativo con Soporte Informático, páginas 315-324, septiembre de 2003. [8] A. Imine, P. Molli, G. Oster y M. Rusinowitch. Demostrando la corrección de las funciones de transformación en groupware en tiempo real. En Actas de la Conferencia Europea sobre Trabajo Cooperativo con Computadoras, septiembre de 2003. [9] L. Lamport. Tiempo, relojes y el ordenamiento de eventos en un sistema distribuido. Comunicación de ACM, 21(7):558-565, 1978. [10] D. Li y R. Li. Compartición transparente e interoperabilidad de aplicaciones heterogéneas de un solo usuario. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 246-255, noviembre de 2002. [11] D. Li y R. Li. Preservando la relación de efectos de operación en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 457-466, noviembre de 2004. [12] R. Li, D. Li y C. Sun. Un algoritmo de control de consistencia basado en intervalos de tiempo para aplicaciones de groupware interactivas. En Actas de la Conferencia Internacional sobre Sistemas Paralelos y Distribuidos, páginas 429-436, julio de 2004. [13] B. Lushman y G. Cormack. Prueba de corrección del algoritmo adOPTado de Ressels. Cartas de Procesamiento de Información, (86):303-310, 2003. [14] C. Palmer y G. Cormack. Operación transforma para una hoja de cálculo compartida distribuida. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 69-78, noviembre de 1998. [15] A. Prakash y M. Knister. Un marco para deshacer acciones en sistemas colaborativos. ACM Trans. on Computer-Human Interaction, 4(1):295-330, Dic. 1994. [16] N. Preguica, M. Shapiro y J. Legatheaux Martins. Automatización de la reconciliación basada en semántica para bases de datos móviles. En Actas de la 3ra Conferencia Francesa sobre Sistemas de Explotación, Octubre 2003. [17] M. Raynal y M. Singhal. Tiempo lógico: capturando la causalidad en sistemas distribuidos. Revista IEEE Computer, 29(2):49-56, Feb. 1996. [18] M. Ressel y R. Gunzenhäuser. Reducir los problemas de deshacer en grupo. En Proc. de la Conf. de la ACM sobre Trabajo en Grupo, páginas 131-139, noviembre de 1999. [19] M. Ressel, D. Nitsche-Ruhland y R. Gunzenhäuser. Un enfoque integrador y orientado a la transformación para el control de concurrencia y deshacer en editores de grupo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 288-297, noviembre de 1996. [20] H.F. Shen y C. Sun. Un marco de notificación flexible para sistemas colaborativos. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 77-86, noviembre de 2002. [21] C. Sun. Deshacer como inversión concurrente en editores de grupo. ACM Trans. on Computer-Human Interaction, 9(4):309-361, diciembre de 2002. [22] C. Sun y C. A. Ellis. Transformación operacional en editores de grupo en tiempo real: problemas, algoritmos y logros. En Actas de la Conferencia ACM sobre Trabajo Cooperativo con Computadoras, páginas 59-68, noviembre de 1998. [23] C. Sun, X. Jia, Y. Zhang, Y. Yang y D. Chen. Logrando la convergencia, la preservación de la causalidad y la preservación de la intención en sistemas de edición cooperativa en tiempo real. ACM Trans. on Computer-Human Interaction, 5(1):63-108, marzo de 1998. [24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen y W. Cai. Adaptación transparente de aplicaciones de un solo usuario para colaboración en tiempo real de múltiples usuarios. ACM Trans. on Computer-Human Interaction, 2006. [25] D. Sun, S. Xia, C. Sun, y D. Chen. Transformación operativa para procesamiento de texto colaborativo. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 437-446, noviembre de 2004. [26] N. Vidot, M. Cart, J. Ferrié, y M. Suleiman. Convergencia de copias en un entorno colaborativo distribuido en tiempo real. En Proc. de la Conf. de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 171-180, Dic. 2000. [27] S. Xia, D. Sun, C. Sun y D. Chen. Una técnica de edición colaborativa de tablas basada en adaptación transparente. En Proc. de la Conferencia Internacional sobre Sistemas de Información Cooperativos, LNCS Vol. 3760, Springer Verlag, páginas 576-592, noviembre de 2005. [28] S. Xia, D. Sun, C. Sun y D. Chen. Telepuntero asociado a objetos para sistemas de edición de documentos colaborativos en tiempo real. En Proc. de la Conf. de IEEE sobre Computación Colaborativa: Redes, Aplicaciones y Compartir el Trabajo, Dic. 2005. [29] S. Xia, D. Sun, C. Sun, D. Chen y H.F. Shen. Aprovechando aplicaciones de un solo usuario para colaboración multiusuario: el enfoque CoWord. En Actas de la Conferencia de la ACM sobre Trabajo Cooperativo con Computadoras, páginas 162-171, noviembre de 2004. 288