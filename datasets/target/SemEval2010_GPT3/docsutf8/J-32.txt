Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una política de puntos de quiebre) que cubre cada posible w ∈ [0, 1]. Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1. En [9], se sugiere que podemos seleccionar la política de punto de quiebre de una manera particular. Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una política de puntos de ruptura para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt. La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1. Decimos que una política de punto de quiebre tiene t - 1 puntos de quiebre. El artículo luego afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1, . . . , Uk. La prueba procede ordenando los puntos de quiebre de los niños (es decir, los valores respectivos de v) de izquierda a derecha (se puede asumir sin pérdida de generalidad que todos estos puntos de quiebre son distintos) y considerándolos sucesivamente; cada punto vl ∈ {v1, . . . , vL} corresponde a una elección fija de estrategias para k − 1 niños y un intervalo de estrategias admisibles para un niño. Supongamos, para mayor comodidad, que este niño es U1 y su intervalo de estrategias admisibles en vl es [a, b]; supongamos también que para Uj, j = 2, . . . , k, sus respectivas políticas de puntos de quiebre les prescriben jugar uj en respuesta a vl. Sea P i (u, w), i = 0, 1, el pago esperado para V cuando V juega i, U1 juega u, cada Uj, j = 2, . . . , k, juega uj, y W juega w, y considera el conjunto Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] tal que P 0 (u, w) = P1 (u, w)}; nota que para cualquier w ∈ Wl tenemos vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figura 1: LKS: Recorte para encontrar políticas de puntos de quiebre. Los autores muestran que para cualquier punto de quiebre vl, el conjunto Wl está vacío, es un solo intervalo, o es una unión de dos intervalos no flotantes (un intervalo es no flotante si uno de sus extremos es 0 o 1); además, la unión de todos los conjuntos Wl, l = 1, . . . , L, cubre el intervalo [0, 1]. Se sigue fácilmente que se puede cubrir [0, 1] con a lo sumo L+2 intervalos, cada uno de los cuales es un subconjunto de algún Wl. Los autores afirman entonces que cualquier cobertura de este tipo puede ser transformada en una política de puntos de ruptura para V. Es decir, afirman que para cualquier par de intervalos Wl1 y Wl2 en la cobertura, cualquier superposición entre Wl1 y Wl2 puede asignarse arbitrariamente a la cobertura por Wl1 y Wl2 recortados en consecuencia (cf. [9], p. 5). Ellos ilustran su enfoque en una figura, la cual se reproduce como Figura 1 aquí. En la figura, las líneas horizontales discontinuas representan los puntos de quiebre v1, v2, . . . , v7 y los intervalos sólidos a lo largo de estos puntos de quiebre son los conjuntos W1, W2, . . . , W7. El camino grueso conectado es la política de punto de quiebre correspondiente. Se elige de la siguiente manera: comenzar en la izquierda y siempre saltar al intervalo que permita el mayor avance hacia la derecha. Para entender por qué este enfoque no funciona en general, considera un camino de longitud 4 que consiste en una raíz indiferente R, su hijo W, el hijo de W V y el hijo de V U. Supongamos que U recibe un pago de 1 si juega de manera diferente a V y 0 en caso contrario. Así, si v denota la estrategia mixta de V (es decir, V juega 1 con probabilidad v), entonces la ganancia esperada que U obtiene al jugar 0 se da por P0(U) = v y la ganancia esperada que U obtiene al jugar 1 se da por P1(U) = 1 − v. Supongamos que V no obtiene ganancia al jugar 1 (por lo que P1(V) = 0) y que su matriz de ganancias al jugar 0 es 1 −9 9 −1, entonces si u denota la estrategia mixta de U y w denota la estrategia mixta de W, la ganancia esperada que V obtiene al jugar 0 se da por P0(V) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las políticas de mejor respuesta para U y V (como en la Definición 1) están dadas por los gráficos en la Figura 2. La mejor política de respuesta para U es una política de punto de quiebre para U (como en la Definición 2) con puntos de quiebre V v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados u1 = 1 y u2 = 0. La mejor política de respuesta para V no es una política de punto de quiebre (debido a cómo la curva de w = 0 a w = 1 retrocede). El algoritmo LKS recortaría para obtener una política de puntos de quiebre como la que se muestra en la Figura 3. Se observa que esta política de punto de quiebre ˆB(W, V) es inválida en el sentido de que no satisface ˆB(W, V) ⊆ B(W, V). El punto es que la matriz de pagos de W ahora puede ser elegida para evitar que el algoritmo LKS encuentre un equilibrio de Nash. Por ejemplo, supongamos que las ganancias se dan de tal manera que P0 (W) = v y P1 (W) = (1−v)2. La mejor política de respuesta para W es una línea horizontal en w = 0.1 (Este es el valor de w que permite v = 2/3 - ver Figura 2, lo que hace que P0 (W) = P1 (W).) En el paso descendente, los valores elegidos son w = .1, luego, a partir del recorte, v = 0 y u = 1, lo cual no es un equilibrio de Nash ya que W prefiere la acción 1. El fallo del algoritmo no se debe al hecho de que la política de recorte llegue tan lejos a la derecha como sea posible. Cualquier otro recorte sería igual de malo. Por ejemplo, supongamos que la política de punto de quiebre para V tiene v = 0 hasta algún punto w∗ < .9 y luego salta a v = 1. El algoritmo es entonces derrotado por la matriz de pagos con P0(W) = 2v y P1(W) = (1 − v) en la que la política de mejor respuesta para W es una línea horizontal en w = .9. El algoritmo luego da w = .9, v = 1, y u = 0, lo cual no es un equilibrio de Nash ya que W prefiere la acción 0. Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash. En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash. Para el algoritmo modificado, debemos extender la definición de la política de punto de quiebre (ver Definición 3) para que incluya políticas de punto de quiebre como la política de mejor respuesta para V en la Figura 2. Desafortunadamente, una política de punto de interrupción de este tipo puede ser exponencial en tamaño (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinómico en todos los árboles. En la siguiente sección, mostramos que se ejecuta en tiempo polinómico en un camino. 4. ENCONTRANDO EQUILIBRIOS EN UN CAMINO En esta sección, nos enfocamos en el caso en el que el grafo subyacente es un camino, es decir, su conjunto de vértices es {V1, . . . , Vn}, y su conjunto de aristas es {(Vj , Vj+1) | j = 1, . . . , n − 1}. Mostramos que en este caso la mejor política de respuesta para cada vértice puede ser representada como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV × IU; puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto. TEOREMA 5. Para cualquier j = 1, . . . , n, el conjunto B(Vj , Vj−1) puede ser representado como una unión disjunta de a lo sumo (j + 4)2 rectángulos. Además, dado tal representación de B(Vj , Vj−1), se puede calcular una representación de B(Vj+1, Vj) en tiempo O(j2). PRUEBA. Para cualquier conjunto A ⊆ [0, 1]2 que esté representado como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de A si u = 0 o u = 1 o A contiene un rectángulo de la forma IV × IU y u es un extremo de IU; los puntos de evento V se definen de manera similar. Observa que para cualquier u ∈ [0, 1], el número de componentes conectadas de [0, 1]×{u} ∩ A es a lo sumo el número de puntos de V-evento de A. Utilizamos inducción en j para demostrar que para cada Vj se cumple la afirmación del teorema y, además, cada B(Vj, Vj−1) tiene como máximo 2j + 4 puntos de evento. Para simplificar el caso base, modificamos el juego gráfico agregando un vértice ficticio V0 al principio del camino: el único vecino de V0 es V1, las ganancias de V0 siempre son iguales a 0, y las ganancias de todos los demás vértices (incluido V1) son las mismas que en el juego original. Para j = 0, tenemos B(V1, V0) = [0, 1]2, por lo que la afirmación del teorema es trivialmente verdadera. Ahora, supongamos que j > 0, establezca V = Vj y permita que U = Vj−1 y W = Vj+1 sean los vértices que preceden y siguen a V, respectivamente. Los pagos para V están descritos por una matriz 2×2×2 P: Pxyz es el pago que V recibe cuando U juega x, V juega y, y W juega z, donde x, y, z ∈ {0, 1}. Supongamos que U juega 1 con probabilidad u y W juega 1 con probabilidad w. Entonces la ganancia esperada de V al jugar 0 es P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, mientras que su ganancia esperada al jugar 1 es P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. Si P0 > P1, V prefiere estrictamente jugar 0; si P0 < P1, V prefiere estrictamente jugar 1; y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta). Dado que P0 y P1 son lineales en w y u, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de u y w, de modo que P0 − P1 = w(B1u + B0) − (A1u + A0). Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos. • B1 = 0, B0 = 0. En este caso, P0 > P1 si y solo si A1u + A0 < 0. Si también A1 = 0, A0 = 0, claramente, B(W, V) = [0, 1]2, y la afirmación del teorema es trivialmente verdadera. De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si A1 = 0 y u = −A0/A1. Sea V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. Por la hipótesis inductiva, V consiste en a lo sumo 2(j − 1) + 4 segmentos y puntos aislados. Para cualquier v ∈ V, tenemos B(W, V)|V = v = [0, 1]: no importa lo que juegue W, siempre y cuando U esté jugando −A0/A1, V está contento de jugar v. Por otro lado, para cualquier v ∈ (0, 1) \ V tenemos B(W, V)|V = v = ∅: cuando V juega v, U solo puede responder con u = −A0/A1, en cuyo caso V puede beneficiarse cambiando a una de las estrategias puras. Para completar la descripción de B(W, V), queda por analizar los casos v = 0 y v = 1. El vértice V prefiere jugar 0 si A1 > 0 y u ≤ −A0/A1, o A1 < 0 y u ≥ −A0/A1, o 103 A1 = 0 y A0 < 0. Supongamos por ahora que A1 > 0; los otros dos casos pueden ser tratados de manera similar. En este caso, 0 ∈ pbrV (w) para algún w ∈ [0, 1] si y solo si existe un u ∈ pbrU (0) tal que u ≤ −A0/A1: si no existe tal u, cada vez que V juega 0, la respuesta de U no está en pbrU (0) o V puede mejorar su recompensa jugando 1. Por lo tanto, o bien B(W, V)|V=0 = [0, 1] o B(W, V)|V=0 = ∅. De manera similar, B(W, V)|V=1 es igual a [0, 1] o ∅, dependiendo de pbrU(1). Por lo tanto, el conjunto B(W, V) consiste en un máximo de 2j + 4 ≤ (j + 4)2 rectángulos: B(W, V) ∩ [0, 1]×(0, 1) = [0, 1]×V contribuye como máximo con 2j + 2 rectángulos, y cada uno de los conjuntos B(W, V)|V=0 y B(W, V)|V=1 contribuye como máximo con un rectángulo. De manera similar, su número total de puntos de evento es a lo sumo 2j + 4: los únicos puntos de evento W son 0 y 1, cada punto de evento V de B(W, V) es un punto de evento V de B(V, U), y hay a lo sumo 2j + 2 de ellos. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 para algún α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si w = α, o B1 = 0 y u = −B0/B1 = −A0/A1. De manera similar al caso anterior, podemos mostrar que B(W, V)∩[0, 1]×(0, 1) consiste en el rectángulo {α}×[0, 1] y como máximo 2j + 2 rectángulos de la forma [0, 1]×IV, donde cada IV corresponde a un componente conectado de B(V, U)|U=−B0/B1. Además, V prefiere jugar 0 si B1u + B0 > 0 y w ≥ α o B1u + B0 < 0 y w ≤ α. Por lo tanto, si B1u∗ + B0 > 0 para algún u∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [α, +∞) ∩ [0, 1] y si B1u∗∗ + B0 < 0 para algún u∗∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [−∞, α] ∩ [0, 1]; si ambos u∗ y u∗∗ existen, B(W, V )|V =0 = [0, 1]. El conjunto B(W, V)|V=1 se puede describir de manera similar. Por la hipótesis inductiva, B(V, U) tiene a lo sumo 2j + 2 puntos de evento; dado que al menos dos de estos son puntos de evento U, tiene a lo sumo 2j puntos de evento V. Dado que cada punto de evento V de B(W, V) es un punto de evento V de B(V, U) y B(W, V) tiene como máximo 3 puntos de evento W (0, 1 y α), su número total de puntos de evento es como máximo 2j + 3 < 2j + 4. Además, de manera similar al caso anterior, se sigue que B(W, V) consiste en un máximo de 2j + 4 < (j + 4)2 rectángulos. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. En este caso, se puede definir la función de indiferencia f(·) como f(u) = A(u) B(u) = A1u+A0 B1u+B0, donde A(u) y B(u) nunca se anulan simultáneamente. Observa que siempre que w = f(u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1. Para cualquier A ⊆ [0, 1]2, definimos una función ˆfV por ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; nota que ˆfV mapea subconjuntos de [0, 1]2 a subconjuntos de R×[0, 1]. A veces omitimos el subíndice V cuando es evidente por el contexto. LEMMA 1. 

LEMMA 1. Para cualquier (w, v) ∈ [0, 1]×(0, 1) tenemos que (w, v) ∈ B(W, V) si y solo si existe un u ∈ [0, 1] tal que (v, u) ∈ B(V, U) y w = f(u). PRUEBA. Fije un v arbitrario en (0, 1). Supongamos que U juega algún u ∈ pbrU (v), w = f(u) satisface w ∈ [0, 1], y W juega w. Existe un vector de estrategias v1, . . . , vj−1 = u, vj = v tal que para cada Vk, k < j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que w = f(u), V es indiferente entre jugar 0 y 1; en particular, puede jugar v. Por lo tanto, si definimos vj+1 = w, el vector de estrategias (v1, . . . , vj+1) cumplirá las condiciones en la definición de mejor respuesta potencial, es decir, tenemos v ∈ pbrV (w). Por el contrario, supongamos que v ∈ pbrV (w) para algún w ∈ [0, 1], v = 0, 1. Entonces existe un vector de estrategias v1, . . . , vj−1, vj = v, vj+1 = w tal que para cada Vk, k ≤ j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que v = 0, 1, V, de hecho, es indiferente entre jugar 0 y 1, lo cual solo es posible si w = f(vj−1). Elige u = vj−1; por construcción, u ∈ pbrU (v). El lema 1 describe las situaciones en las que V es indiferente entre jugar 0 y jugar 1. Sin embargo, para caracterizar completamente B(W, V), también necesitamos saber cuándo V prefiere una estrategia pura. Define ˆf(0) = ∪u∈pbrU (0)Ru, donde Ru = ´ [f(u), +∞)×{0} si B(u) > 0, (−∞, f(u)]×{0} si B(u) < 0. y ˆf(1) = ∪u∈pbrU (1)Ru, donde Ru = ´ [f(u), +∞)×{1} si B(u) < 0, (−∞, f(u)]×{1} si B(u) > 0. LEMMA 2. 

LEMMA 2. Para cualquier w ∈ [0, 1], tenemos que (w, 0) ∈ ˆf(0) si y solo si 0 ∈ pbrV (w) y (w, 1) ∈ ˆf(1) si y solo si 1 ∈ pbrV (w). PRUEBA. Considera un u0 arbitrario ∈ pbrU (0). Si B(u0) > 0, para u = u0 la desigualdad P0 ≥ P1 es equivalente a w ≥ f(u0). Por lo tanto, cuando U juega u0 y W juega w, w ≥ f(u0), V prefiere jugar 0; dado que u0 ∈ pbrU (u), se sigue que 0 ∈ pbrV (w). El argumento para el caso B(u0) < 0 es similar. Por el contrario, si 0 ∈ pbrV (w) para algún w ∈ [0, 1], existe un vector (v1, . . . , vj−1, vj = 0, vj+1 = w) tal que para cada Vk, k ≤ j, Vk juega vk, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de Vk. Ten en cuenta que para cualquier vector de este tipo tenemos vj−1 ∈ pbrU (0). Por contradicción, asumimos que (w, 0) ∈ Ë u∈pbrU (0) Ru. Entonces debe ser el caso que para cualquier u0 ∈ pbrU (0) ya sea que f(u0) < w y Ru0 = (−∞, f(u0)]×{0} o f(u0) > w y Ru0 = [f(u0), +∞)×{0}. En ambos casos, cuando V juega 0, U juega u0, y V juega w, la desigualdad entre f(u0) y w es equivalente a P0 < P1, es decir, V se beneficiaría al cambiar a 1. El argumento para ˆf(1) es similar. Juntas, el Lema 1 y el Lema 2 describen completamente el conjunto B(W, V): tenemos B(W, V) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2. Queda por demostrar que B(W, V) puede representarse como una unión de como máximo (j + 4)2 rectángulos, tiene como máximo 2j + 4 puntos de evento, y puede ser calculado en tiempo O(j2). Sea u∗ = −B0/B1. Considera un rectángulo arbitrario R = [v1, v2]×[u1, u2] ⊆ B(V, U). Si u∗ ∈ [u1, u2], la función f(·) es continua en [u1, u2] y por lo tanto ˆf(R) = [fmin, fmax]×[v1, v2], donde fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste en un solo rectángulo. Ahora, supongamos que R es intersectado por la línea [0, 1]×{u∗}; como se mencionó anteriormente, hay a lo sumo 2j+2 rectángulos de este tipo. Se supone que limu→u∗− f(u) = +∞; dado que f(·) es una función lineal fraccional, esto implica que limu→u∗+ f(u) = −∞ y también f(u1) > f(u2). Dado que f(·) es continua en [u1, u∗ ) y (u∗ , u2], es fácil ver que ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2]. El caso B1 = 0 no causa problemas especiales. Para completitud, establezca u∗ como cualquier valor fuera de [0, 1] en este caso. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figura 4: f es creciente en (−∞, u∗ ) y (u∗ , +∞). y ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste de a lo sumo dos rectángulos. El caso limu→u∗− f(u) = −∞ es similar. Dado que ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), se sigue que ˆf(B(V, U)) consiste en un máximo de (j + 3)2 + 2j + 2 rectángulos. Además, es fácil ver que tanto ˆf(0) como ˆf(1) consisten en un máximo de 2 segmentos de línea cada uno. Concluimos que B(W, V) puede ser representado como una unión de a lo sumo (j + 3)2 + 2j + 6 < (j + 4)2 rectángulos. Además, si v es un punto de evento V de B(W, V), entonces v es un punto de evento V de B(V, U) (esto incluye los casos v = 0 y v = 1, ya que 0 y 1 son puntos de evento V de B(V, U)) y si w es un punto de evento W de B(W, V), entonces o bien w = 0 o w = 1 o existe algún u ∈ [0, 1] tal que w = f(u) y u es un punto de evento U de B(V, U). Por lo tanto, B(W, V) tiene como máximo 2j + 4 puntos de evento. El límite O(j2) en el tiempo de ejecución en el Teorema 5 se deriva de nuestra descripción del algoritmo. El límite de O(n3) en el tiempo total de ejecución para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash) se sigue. 4.1 Encontrar un solo equilibrio de Nash en tiempo O(n2) El límite superior en el tiempo de ejecución de nuestro algoritmo es ajustado, al menos asumiendo la implementación directa, en la que cada B(Vj+1, Vj) se almacena como una unión de rectángulos: no es difícil construir un ejemplo en el que el tamaño de B(Vj+1, Vj) sea Ω(j2). Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash; más bien, el objetivo es encontrar un equilibrio arbitrario del juego. En esta sección, demostramos que este problema puede resolverse en tiempo cuadrático, obteniendo así una prueba del Teorema 1. Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las políticas de mejor respuesta en lugar de las políticas de mejor respuesta en sí mismas; siguiendo [9], nos referiremos a tales subconjuntos como políticas de punto de quiebre. Si bien no siempre es posible construir una política de puntos de interrupción según se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de puntos de interrupción; además, demostramos que para un grafo de camino, la política de puntos de interrupción de cualquier vértice puede ser almacenada en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice. Definición 3. Una política de puntos de quiebre ˆB(V, U) para un vértice U cuyo padre es V es una curva no auto-intersectante de la forma X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, donde Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] y ui, vi ∈ [0, 1] para i = 0, . . . , m. Decimos que una política de puntos de quiebre es válida si v0 = 0, vm = 1, y ˆB(V, U) ⊆ B(V, U). A veces abusaremos de la notación al referirnos a ˆB(V, U) como una colección de segmentos Xi, Yi en lugar de su unión. Se debe tener en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1; por lo tanto, en cualquier argumento que involucre políticas de puntos de quiebre, todos los segmentos deben tratarse como segmentos dirigidos. Observe que cualquier política de puntos de quiebre válida ˆB(V, U) puede ser vista como un mapeo continuo 1-1 γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2, donde γ(0) = (0, u1), γ(1) = (1, um) y existen algunos t0 = 0, t1, . . . , t2m−2 = 1 tales que {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. Como se explica en la Sección 3, podemos utilizar una política de punto de quiebre válida en lugar de la política de mejor respuesta durante el paso descendente, y aún así garantizar que al final, produciremos un equilibrio de Nash. El Teorema 6 muestra que se puede calcular de forma inductiva políticas de puntos de quiebre válidas para todos los vértices en el camino; la prueba de este teorema se puede encontrar en la versión completa de este artículo [6]. TEOREMA 6. Para cualquier V = Vj, se puede encontrar en tiempo polinómico una política de puntos de quiebre válida ˆB(W, V) que consiste en a lo sumo 2j + 1 segmentos. EQUILIBRIOS DE NASH EN GRÁFICOS CON GRADO MÁXIMO 2 En esta sección mostramos cómo el algoritmo para caminos puede aplicarse para resolver un juego en cualquier gráfico cuyos vértices tengan un grado de a lo sumo 2. Un grafo con grado máximo 2 es, por supuesto, una unión de caminos y ciclos. Dado que cada componente conectado puede ser manejado de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo tratar con los ciclos. Dado un ciclo con vértices V1, . . . , Vk (en orden cíclico), realizamos dos búsquedas separadas de un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de Nash completamente mixto, donde todos los vértices juegan estrategias mixtas. Para i ≤ k, dejemos que vi denote la probabilidad de que Vi juegue 1. La primera búsqueda se puede hacer de la siguiente manera. Para cada i ∈ {1, . . . , k} y cada b ∈ {0, 1}, haz lo siguiente. 1. Sea P el camino (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. El pago a Vi+1 se basa en poner vi = b (por lo que depende solo de vi+1 y vi+2). 3. Aplica el pase ascendente a P 4. Pon vi = b; aplica el pase aguas abajo. Para cada vértice, Vj, lleva un registro de todas las posibles estrategias mixtas vj 5. Verificar si Vi+1 tiene alguna respuesta consistente con vi = b; si es así, tenemos un equilibrio de Nash. (De lo contrario, no hay un equilibrio de Nash del tipo deseado). Para la segunda búsqueda, hay que tener en cuenta que si Vi juega una estrategia mixta, entonces vi+1 y vi−1 satisfacen una ecuación de la forma vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Componiendo las dos transformaciones lineales fraccionarias, obtenemos vi+3 = (A0 + A1 vi−1)/(B0 + B1 vi−1), para algunas nuevas constantes A0, A1, B0, B1. Elige cualquier vértice Vi. Podemos expresar vi en términos de vi+2, luego vi+4, vi+6, etc. y finalmente vi mismo para obtener una ecuación cuadrática (para vi) que es fácil de derivar a partir de los pagos en el juego. Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1). Para un ciclo de longitud impar, todos los demás vj son derivables a partir de esas soluciones, y si existe un equilibrio de Nash completamente mezclado, todos los vj deberían resultar ser números reales en el rango (0, 1). Para un ciclo de longitud par, obtenemos dos ecuaciones cuadráticas, una para vi y otra para 105 vi+1, y de la misma manera podemos probar si alguna solución a estas ecuaciones produce valores para los otros vj, todos los cuales se encuentran en el intervalo (0, 1). Si la ecuación cuadrática es trivial, potencialmente hay un continuo de equilibrios completamente mezclados. Los valores de vi que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores dependientes vj se encuentran en el intervalo (0, 1); esta última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo transformaciones lineales fraccionarias respectivas. 6. ENCONTRANDO EQUILIBRIOS EN UN ÁRBOL (ARBITRARIO) Para árboles arbitrarios, la estructura general del algoritmo permanece igual, es decir, se puede construir una política de mejor respuesta (o, alternativamente, una política de punto de quiebre) para cualquier vértice basada en las políticas de mejor respuesta de sus hijos. Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pagos para cada vértice es de tamaño O(2K). Consideremos un vértice V cuyos hijos son U1, . . . , Uk y cuyo padre es W; la política de mejor respuesta de cada Uj es B(V, Uj). De manera similar a la sección anterior, podemos calcular los pagos esperados V de jugar 0 o 1, respectivamente. Es decir, cuando cada uno de los Uj juega uj y W juega w, tenemos P0 = L0 (u1, . . . , uk, w), P1 = L1 (u1, . . . , uk, w), donde las funciones L0 (·, . . . , ·), L1 (·, . . . , ·) son lineales en todos sus argumentos. Por lo tanto, la desigualdad P0 > P1 se puede reescribir como wB(u1, . . . , uk) > A(u1, . . . , uk), donde tanto A(·, . . . , ·) como B(·, . . . , ·) son lineales en todos sus argumentos. Dado u = (u1, . . . , uk) y defina la función de indiferencia f : [0, 1]k → [0, 1] como f(u) = A(u)/B(u); claramente, si cada Uj juega uj, W juega w y w = f(u), V es indiferente entre jugar 0 y 1. Para cualquier X = X1 × · · · × Xk, donde Xi ⊆ [0, 1]2 se define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k}. Además, se establece ˆf(0) = {(w, 0) | ∃u tal que ui ∈ pbrUi (0) y wB(u) ≥ A(u)} y ˆf(1) = {(w, 1) | ∃u tal que ui ∈ pbrUi (1) y wB(u) ≤ A(u)}. Como en la sección anterior, podemos demostrar que B(W, V) es igual a ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2; además, cualquier camino de w = 0 a w = 1 que sea un subconjunto de B(W, V) constituye una política de puntos de quiebre válida. Política de Puntos de Quiebre de Tamaño Exponencial. Si bien el algoritmo de la Sección 4 se puede generalizar para árboles de grado acotado, su tiempo de ejecución ya no es polinomial. De hecho, la afirmación contraria es cierta: podemos construir una familia de árboles y matrices de pago para todos los jugadores de manera que las políticas de mejor respuesta para algunos de los jugadores consistan en un número exponencial de segmentos. Además, en nuestro ejemplo las políticas de puntos de quiebre coinciden con las políticas de mejor respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] llevará un tiempo exponencialmente largo. De hecho, una afirmación más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de políticas de mejor respuesta para este grafo, podemos elegir las recompensas de los vértices de manera que el paso posterior de este algoritmo falle. La figura 5: El árbol Tn que corresponde a la política de puntos de quiebre de tamaño exponencial. En el resto de esta subsección, describimos esta construcción. Considera el árbol Tn dado por la Figura 5; sea Vn la raíz de este árbol. Para cada k = 1, . . . , n, permita que las ganancias de Sk y Tk sean las mismas que las de U y V descritas en la Sección 3; recuerde que las políticas de puntos de quiebre para U y V se muestran en la Figura 2. No es difícil ver que la función de indiferencia para Tk está dada por f(s) = .8s + .1. El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 en caso contrario; la política de mejor respuesta de V0 está dada por la Figura 6. LEMMA 3. 

LEMMA 3. Dado k < n, y sean u, t, v y w las estrategias de Vk−1, Tk, Vk y Vk+1, respectivamente. Supongamos que Vk prefiere jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Entonces B(Vk+1, Vk) consta de al menos 3k segmentos. Además, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} y {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PRUEBA. La demostración procede por inducción en k. Para k = 0, la afirmación es obvia. Ahora, supongamos que es cierto para B(Vk, Vk−1). Se puede ver B(Vk+1, Vk) como una unión de siete componentes: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, y cinco componentes que corresponden a los segmentos de B(Vk, Tk). Examinémoslos uno por uno. Para describir ˆf(0)∩[0, 1]×{0}, observe que f(u, t) = .5t+.1u+.2 es monótona en t y u y cumple con f(0, 0) = .2. Además, tenemos pbrVk−1 (0) = {0} y pbrTk (0) = {0}. Para cualquier w ∈ [0, 1] tenemos f(0, 0) ≥ w si y solo si w ∈ [0, .2]. Concluimos que ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. De manera similar, se sigue que ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; estos conjuntos corresponden a segmentos horizontales de B(Vk, Tk). Es fácil ver que S1, S2, S3 ⊂ B(Vk+1, Vk). Dado que f es una función continua, el número de segmentos en cada Si es al menos el número de segmentos en B(Vk, Vk−1)∩[.1, .9]×[0, 1], que es al menos 3k−1 por hipótesis de inducción. Además, dado que f es monótona en u y f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), todos los Si, i = 1, 2, 3, son disjuntos. Finalmente, el conjunto B(Vk+1, Vk) contiene dos segmentos que corresponden a los segmentos verticales de B(Vk, Tk), es decir, S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} y S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se intersectan entre sí. Concluimos que B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figura 6: Políticas de puntos de quiebre para V0 y V1, es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema. Para completar la construcción, necesitamos demostrar que podemos diseñar la matriz de pagos para Vk de manera que prefiera jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Con este fin, demostramos una afirmación más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de las estrategias de sus descendientes. Decimos que una función de k variables es multilineal si puede ser representada como una suma de monomios y cada uno de estos monomios es lineal en todas sus variables. Ten en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomios tengan el mismo grado. Recuerde que las ganancias de un vértice con k + 1 vecinos están descritas por las matrices P0 y P1, donde Pj i0i1...ik es la ganancia que V obtiene cuando juega j, y sus vecinos juegan i0, . . . , ik, y j, i0, . . . , ik ∈ {0, 1}. Sea P[j] = P[j](w, u1, . . . , uk) la ganancia esperada obtenida por este vértice cuando juega j y las estrategias (mixtas) de sus vecinos están dadas por un vector (w, u1, . . . , uk), es decir, P[j] = E[P j i0i1...ik ] donde i0, . . . , ik son variables aleatorias de Bernoulli independientes, cada una de las cuales es 1 con las respectivas probabilidades w, u1, . . . , uk. LEMMA 4. 

LEMMA 4. Dado un vértice del árbol V cuyo padre es W y cuyos hijos son U1, . . . , Uk, para cualquier función f = f(u1, . . . , uk) que pueda representarse como una razón de dos funciones multilineales f1, f2, es decir, f = f1(u1,...,uk) f2(u1,...,uk), existen matrices de pago P0 y P1 para V tales que P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). La prueba de este lema se basa en el hecho de que cada monomio de la forma as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, puede ser representado como t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk para algunos Ct, t ∈ {0, 1}k+1. Los detalles se pueden encontrar en la versión completa de este documento [6]. 6.2 Irreducibilidad de la Política de Mejor Respuesta para Tn Si bien la política de mejor respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que sea necesario hacer un seguimiento de todos sus segmentos de línea en lugar de centrarse en un pequeño subconjunto de estos segmentos. Sin embargo, resulta que para algoritmos de dos pasadas como el algoritmo de [8], la política de mejor respuesta no se puede simplificar. Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasadas si 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de quiebre para V2. • A consta de un paso ascendente y un paso descendente. • Durante el paso ascendente, para cada vértice V con padre W, A construye un conjunto BB(W, V) ⊆ B(W, V). Este conjunto se produce a partir de los conjuntos {BB(V, U) | U es un hijo de V} aplicando el procedimiento desde el principio de la Sección 6 (sustituyendo BB(V, Uj) por B(V, Uj) para todos los hijos Uj de V), y luego posiblemente omitiendo algunos de los puntos del conjunto resultante (que luego se almacena explícitamente). El paso aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB(W, V) en lugar de en los conjuntos B(W, V). El Teorema 7 demuestra que cualquier algoritmo de dos pasadas fallará durante la pasada aguas abajo en Tn si existe un índice j tal que el conjunto BB(Vj+1, Vj) omite algún punto interior de cualquiera de los (al menos 3j) segmentos de B(Vj+1, Vj). Esto implica el Teorema 3. TEOREMA 7. Para cualquier algoritmo de dos pasos A para el cual exista un índice j, j ∈ [1, n/4], un segmento S de B(Vj, Vj−1), y un punto interior (x, y) de S tal que BB(Vj, Vj−1) no contenga (x, y), podemos elegir matrices de pago de los vértices Vj, . . . , Vn para que el paso descendente de A falle, y, además, los pagos a V4j, . . . , Vn sean idénticamente 0. Esbozamos la demostración del Teorema 7; los detalles se pueden encontrar en la versión completa de este artículo [6]. Procedemos por inducción. Para j = 1, el argumento es similar al de la Sección 3. Para el paso inductivo, la idea principal es que podemos enfocarnos en cualquier parte de una política de mejor respuesta (¡incluyendo la parte que fue omitida!) utilizando una función de indiferencia apropiada; esto nos permite reducir el caso j = j0 a j = j0 − 1. En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico. A continuación mostramos que una propiedad de grafo similar a un camino más suave nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash. 7.1 Ancho de camino Una descomposición de camino de un grafo G = (V, E) es una secuencia de subconjuntos Si(V) ⊆ V tal que para cada arista (v, v') ∈ E, v, v' ∈ Si(V) para algún i, y además, para cada v ∈ V, si v ∈ Si(V) y v ∈ Sj(V) para j > i, entonces v ∈ Sk(V) para todo i ≤ k ≤ j. La descomposición del camino tiene ancho k si todos los conjuntos Si(V) tienen una cardinalidad de a lo sumo k + 1. El ancho de camino de G es el ancho mínimo de cualquier descomposición de camino de G. 107 El ancho de camino es una restricción del ancho de árbol (en el cual se buscaría un árbol cuyos vértices fueran los conjuntos Si(V), y los conjuntos que contienen algún vértice tendrían que formar un subárbol). Para cualquier constante k, se puede decidir en tiempo polinómico si un grafo tiene un ancho de camino (o ancho de árbol) k. Además, muchos problemas de teoría de grafos parecen más fáciles de resolver en tiempo polinómico cuando se restringen a grafos con un ancho de árbol o un ancho de camino fijo, consulte [1] para obtener una visión general. Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 Completitud de PPAD Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda. Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios de Nash del juego de entrada), donde la longitud de la descripción de cualquier solución debe estar acotada de forma polinómica en función de la longitud de la descripción de su entrada. En un problema de búsqueda total, hay una garantía de que al menos una solución existe para cualquier entrada. El teorema de Nash nos asegura que el problema de encontrar equilibrios de Nash es total. Una reducción del problema de búsqueda S al problema S es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinómico para S. Consiste en funciones f y g, computables en tiempo polinómico, donde f mapea entradas de S a entradas de S, y g mapea soluciones de S a soluciones de S, de tal manera que si IS es una entrada para S, y SS es una solución para f(IS), entonces g(SS) es una solución para IS. Observe que los problemas de búsqueda total no permiten las reducciones anteriores de problemas como CIRCUIT SAT (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido a que CIRCUIT SAT y otros problemas NP-completos tienen entradas con conjuntos de soluciones vacíos. En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema. Definición 4. FIN DE LA LÍNEA. Circuitos booleanos S y P, cada uno con n bits de entrada y n bits de salida, donde P(0n) = 0n y S(0n) = 0n. Solución: x ∈ {0, 1}n tal que S(x) = x, o alternativamente x ∈ {0, 1}n tal que P(S(x)) = x. S y P pueden ser consideradas como representando sucesor y predecesor. Observe que al calcular Si (0n) (para i = 0, 1, 2, ...) y comparar con P(Si+1 (0n)), eventualmente debemos encontrar una solución para EL FIN DE LA LÍNEA. END OF THE LINE caracteriza la clase de complejidad PPAD (que significa argumento de paridad en un grafo, versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda S es PPAD-completo si END OF THE LINE se reduce a S. Otros problemas PPAD-completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para descripciones más detalladas de estos problemas). 3-GRAPHICAL NASH es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo grafo tiene grado 3. Daskalakis et al. [4] muestran la completitud de PPAD de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera. Definición 5. BROUWER TRIDIMENSIONAL. Un circuito C que tiene 3n bits de entrada y 2 bits de salida. Los bits de entrada definen un cubilete del cubo unitario, compuesto por las 3 coordenadas de sus puntos, dadas con una precisión de n bits. La salida representa uno de los cuatro colores asignados por C a un cubito. C está restringido para asignar el color 1 a los cubitos adyacentes al plano (y, z), el color 2 a los cubitos restantes adyacentes al plano (x, z), el color 3 a los cubitos restantes en el plano (x, y), y el color 0 a todos los demás cubitos en la superficie del cubo unitario. Una solución es un vértice pancromático, un vértice adyacente a cubiletes que tienen 4 colores distintos. La razón por la que se garantiza la existencia de una solución es que se puede construir una función de Brouwer asociada φ, es decir, una función continua del cubo unitario a sí mismo, de modo que los vértices pancromáticos correspondan a los puntos fijos de φ. El Teorema del Punto Fijo de Brouwer promete la existencia de un punto fijo. La prueba del Teorema 4 utiliza una modificación de la reducción de [4] de 3-DIMENSIONAL BROUWER a 3-GRAPHICAL NASH. Para demostrar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera. Cada jugador tiene 2 acciones, denominadas 0 y 1. Para un jugador en el vértice V, dejemos que p[V] denote la probabilidad de que el jugador juegue 1. LEMMA 5. [7] Existe un juego gráfico Gshift de tamaño fijo con vértices V, V donde p[V] es la parte fraccionaria de 2p[V]. COROLARIO 1. Existe un juego gráfico Gn−shift de tamaño Θ(n) de ancho de camino constante, con vértices V, Vn donde p[Vn] es la parte fraccionaria de 2n .p[V]. PRUEBA. Crear una cadena de n copias de Gshift en el Lema 5. Cada subconjunto de vértices en la descomposición del camino son los vértices en una copia de Gshift. Que In(x) denote el n-ésimo bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso. Lo siguiente utiliza dispositivos de [7, 4]. COROLARIO 2. Existe un valor k tal que para todo n, y para todo n1, n2, n3 ≤ n, existe un juego gráfico de tamaño O(n) con ancho de camino k, teniendo vértices V1, V2, V3 donde p[V3] = p[V1] + 2−n3 (En1 p[V1] ∧ En2 p[V2]). PRUEBA DEL TEOREMA 4. Sea C el circuito booleano que describe una instancia de BROUWER TRIDIMENSIONAL. Sean g1, . . . , gp(n) las compuertas de C indexadas de tal manera que la(s) entrada(s) de cualquier compuerta son la(s) salida(s) de las compuertas de índice inferior. g1, . . . , g3n serán las 3n entradas de C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas como 0 y 1. La probabilidad de que V juegue 1 se denota como p[V]. G tiene 3 jugadores Vx, Vy y Vz para los cuales p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto en el cubo unitario. G está diseñado para incentivar a Vx, Vy y Vz a ajustar sus probabilidades en direcciones dadas por una función de Brouwer que está especificada por el circuito C. En un equilibrio de Nash, p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto fijo de una función que pertenece a la clase de funciones representadas por el BROUWER TRIDIMENSIONAL. Para 1 ≤ i ≤ p(n) introducimos un vértice V (i) C tal que para 1 ≤ j ≤ i, Ij(p[V (i) C ]) es la salida de la compuerta gj; para i < j ≤ p(n), Ij(p[V (i) C ]) es 0. Construye V (i) C a partir de V (i−1) C utilizando el Corolario 2. Sea G(i) el juego gráfico que hace esto. Sea S1(G(i)), . . . , Sn(G(i)) una descomposición de camino de longitud n de G(i), donde V(i−1) ⊂ S1(G(i)) y V(i) ⊂ Sn(G(i)). Luego, se obtiene una descomposición de camino de ∪1≤i≤p(n)G(i) tomando la unión de las descomposiciones de camino separadas, junto con Sn(G(i−1) ) ∪ S1(G(i) ) para 2 ≤ i ≤ p(n). Sea GC el juego gráfico anterior que simula C. GC tiene 3n entradas, que consisten en los primeros n bits de las expansiones binarias de p[Vx], p[Vy] y p[Vz]. De manera similar a [4], la salida de GC afecta a Vx, Vy y Vz de la siguiente manera. El color 0 incentiva a Vx, Vy y Vz 108 a ajustar sus probabilidades p[Vx], p[Vy] y p[Vz] en la dirección (−1, −1, −1); el color 2 los incentiva a moverse en la dirección (1, 0, 0); el color 2, dirección (0, 1, 0); el color 3, dirección (0, 0, 1). Necesitamos asegurarnos de que en los puntos en los límites de los cubitos adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes. De esta manera, los cuatro colores/direcciones deben estar cerca para que puedan anularse entre sí (y estemos en un vértice pancromático). Esto se logra utilizando el mismo truco que [4], en el cual hacemos un número constante M de copias de GC, que difieren en que cada copia agrega un vector de desplazamiento pequeño a sus copias de p[Vx], p[Vy] y p[Vz] (que se derivan del original utilizando el dispositivo de adición de [7]). Usando los dispositivos de suma y multiplicación de [7], promediamos las direcciones y sumamos un pequeño múltiplo de este promedio a (p[Vx], p[Vy], p[Vz]). En un equilibrio de Nash, las salidas de cada copia se cancelarán mutuamente. El ancho de camino del juego completo es a lo sumo M veces el ancho de camino GC. 8. PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un árbol de grado acotado en tiempo polinómico. Nuestra construcción muestra que cualquier algoritmo de dos pasadas que almacene explícitamente políticas de puntos de quiebre necesita tiempo y espacio exponenciales. Sin embargo, esto no excluye la existencia de un algoritmo que se base en una idea similar, pero en lugar de calcular la política de punto de ruptura completa para cada vértice, utiliza un pequeño número de pasadas adicionales a través del grafo para decidir qué partes (de tamaño polinómico) de cada política de punto de ruptura deben ser calculadas. En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de es elegido de forma adaptativa. Otra pregunta intrigante está relacionada con el hecho de que el grafo para el cual construimos una política de puntos de quiebre de tamaño exponencial tiene un ancho de camino de 2, mientras que nuestros resultados positivos son para un camino, es decir, un grafo de ancho de camino 1. No está claro si para cualquier grafo de grado acotado con ancho de camino 1, el tiempo de ejecución de nuestro algoritmo (versión basada en política de puntos de interrupción) será polinomial. En particular, resulta instructivo considerar un grafo oruga, es decir, el grafo que se puede obtener a partir de Tn al eliminar los vértices S1, . . . , Sn. Para este gráfico, la mejor política de respuesta de un vértice Vk en la columna vertebral de la oruga se obtiene combinando la mejor política de respuesta de su predecesor en la columna vertebral Vk−1 y su otro hijo Tk; dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1]2, [0, 1]×{0} o [0, 1]×{1}) o consiste en dos segmentos horizontales y un segmento vertical de la forma {α}×[0, 1] que los conecta. Suponiendo, para mayor comodidad, que B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, y f es la función de indiferencia para Vk, observamos que la política de mejor respuesta para Vk consta de 5 componentes: ˆf(0), ˆf(1), y tres componentes que corresponden a [0, α]×{0}, {α}×[0, 1], y [α, 1]×{1}. Por lo tanto, se puede pensar en la construcción de B(Vk+1, Vk) como el siguiente proceso: girar B(Vk, Vk−1) en π/2, cortarlo a lo largo de la línea (ahora horizontal) vk = α, aplicar una transformación lineal fraccional a la coordenada horizontal de ambas partes y volver a conectarlas usando la imagen del segmento {α}×[0, 1] bajo f. Esto implica que el problema de acotar el tamaño de la política de mejor respuesta (o, alternativamente, la política de punto de quiebre) se puede ver como una generalización del siguiente problema de geometría computacional, que creemos puede ser de interés independiente: PROBLEMA 1. Dada una colección de segmentos paralelos a los ejes en R2, considera la siguiente operación: elige una línea paralela a los ejes li (ya sea vertical u horizontal), corta el plano a lo largo de esta línea y desplaza una de las dos partes resultantes por una cantidad arbitraria δi; como resultado, algunos segmentos se dividirán en dos partes. Reconecte estas partes, es decir, para cada segmento de la forma [a, b] × {c} que fue transformado en [a, t] × {c + δi} y [t, b] × {c}, introduzca un segmento {t} × [c, c+δi]. ¿Es posible comenzar con el segmento [0, 1] y después de n operaciones obtener un conjunto que no pueda representarse como una unión de poli(n) segmentos de línea? ¿En caso afirmativo, puede ser que en este conjunto no haya un camino con un número polinomial de giros que conecte los extremos del segmento original? Resulta que en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en Θ(cn) segmentos para algún c > 0. Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande. Sin embargo, en nuestro ejemplo (que se omite en esta versión del documento debido a limitaciones de espacio), existe un camino de tamaño polinómico a través de la política de mejor respuesta, es decir, no demuestra que la política de punto de quiebre sea necesariamente exponencial en tamaño. Si se puede demostrar que esto siempre es cierto, puede ser posible adaptar esta prueba para mostrar que puede haber una brecha exponencial entre los tamaños de las políticas de mejor respuesta y las políticas de punto de quiebre. 9. REFERENCIAS [1] H. Bodlaender y T. Kloks. Algoritmos eficientes y constructivos para el ancho de camino y el ancho de árbol de grafos. Revista de Algoritmos, 21:358-402, 1996. [2] X. Chen y X. Deng. 3-NASH es PPAD-completo. Informe técnico TR-05-134, Coloquio Electrónico en Complejidad Computacional, 2005. [3] X. Chen y X. Deng. Resolviendo la complejidad del equilibrio de Nash de 2 jugadores. Informe técnico TR-05-140, Coloquio Electrónico en Complejidad Computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou. La complejidad de calcular un equilibrio de Nash. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [5] C. Daskalakis y C. Papadimitriou. Los juegos de tres jugadores son difíciles. Informe técnico TR-05-139, Coloquio Electrónico en Complejidad Computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg. Equilibrios de Nash en juegos gráficos en árboles revisados. Informe técnico TR-06-005, Coloquio Electrónico en Complejidad Computacional, 2006. [7] P. Goldberg y C. Papadimitriou. Reductibilidad entre problemas de equilibrio. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh. Un algoritmo exacto eficiente para juegos gráficos de conexión simple. En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns. Propagación de Nash para juegos gráficos con bucles. En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou. Sobre la complejidad del argumento de paridad y otras demostraciones ineficientes de existencia. J. Comput. This is not a complete sentence. Please provide more context or the full sentence you would like me to translate. Cienc., 48(3):498-532, 1994. 109