Asignación de tareas distribuida en redes sociales Mathijs de Weerdt Universidad Técnica de Delft Delft, Países Bajos M.M.deWeerdt@tudelft.nl Yingqian Zhang Universidad Técnica de Delft Delft, Países Bajos Yingqian.Zhang@tudelft.nl Tomas Klos Centro de Matemáticas e Informática (CWI) Ámsterdam, Países Bajos tomas.klos@cwi.nl RESUMEN Este artículo propone una nueva variante del problema de asignación de tareas, donde los agentes están conectados en una red social y las tareas llegan a los agentes distribuidas en la red. Mostramos que la complejidad de este problema sigue siendo NP-difícil. Además, no es aproximable dentro de algún factor. Desarrollamos un algoritmo basado en el protocolo de red de contratos. Nuestro algoritmo es completamente distribuido y asume que los agentes solo tienen conocimiento local sobre las tareas y recursos. Realizamos un conjunto de experimentos para evaluar el rendimiento y la escalabilidad del algoritmo propuesto en términos de calidad de la solución y tiempo de computación. Tres tipos diferentes de redes, a saber, redes de mundo pequeño, aleatorias y libres de escala, se utilizan para representar diversas relaciones sociales entre agentes en aplicaciones realistas. Los resultados demuestran que nuestro algoritmo funciona bien y que se adapta bien a aplicaciones a gran escala. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas Multiagente Términos Generales Algoritmos, Experimentación 1. En los últimos años se ha realizado mucho trabajo en métodos de asignación de tareas y recursos, los cuales pueden ser aplicados potencialmente a muchas aplicaciones del mundo real. Sin embargo, algunas aplicaciones interesantes donde las relaciones entre agentes juegan un papel requieren un modelo ligeramente más general. Tales situaciones aparecen con mucha frecuencia en escenarios del mundo real, y los recientes avances tecnológicos están acercando más de ellas al alcance de los métodos de asignación de tareas. Especialmente en aplicaciones empresariales, la selección preferencial de socios y la interacción son muy comunes, y este aspecto se vuelve más importante para la investigación de asignación de tareas, hasta el punto en que los desarrollos tecnológicos deben ser capaces de respaldarlo. Por ejemplo, el desarrollo de la web semántica y las tecnologías de grid conlleva a un aumento y renovado interés en el potencial de la web para apoyar los procesos empresariales [7, 15]. Como ejemplo, las organizaciones virtuales (VOs) están siendo reinventadas en el contexto de la red, donde están compuestas por un número de entidades autónomas (que representan a diferentes individuos, departamentos y organizaciones), cada una de las cuales tiene una variedad de capacidades para resolver problemas y recursos a su disposición [15, p. 237]. La pregunta es cómo se deben componer y recomponer dinámicamente los VOs a partir de agentes individuales, cuando se necesitan realizar diferentes tareas y subtareas. Esto se haría asignándolos a diferentes agentes, quienes pueden ser capaces de realizar diferentes subconjuntos de esas tareas. De igual manera, la formación de la cadena de suministro (SCF) se preocupa por la asignación, posiblemente ad hoc, de servicios a proveedores en la cadena de suministro, de tal manera que se optimice la ganancia general [6, 21]. Tradicionalmente, tales decisiones de asignación han sido analizadas utilizando la economía de los costos de transacción (TCE) [4], que toma la transacción entre etapas consecutivas de desarrollo como su unidad básica de análisis, y considera a la empresa y al mercado como formas estructurales alternativas para organizar transacciones. La economía de los costos de transacción se ha basado tradicionalmente en el análisis de estáticas comparativas: el problema central de la organización económica se considera la adaptación de las formas organizativas a las características de las transacciones. Más recientemente, el padre fundador de la TCE, Ronald Coase, reconoció que este es un enfoque demasiado simplista: El análisis no puede limitarse a lo que sucede dentro de una sola empresa. (. . . ) Con lo que estamos tratando es una estructura compleja interrelacionada. En este artículo, estudiamos el problema de asignación de tareas desde la perspectiva de una estructura interrelacionada tan compleja. En particular, el mercado no puede ser considerado como una forma organizativa sin tener en cuenta los socios específicos con los que interactuar en el mercado [11]. Específicamente, por lo tanto, consideramos que los agentes están conectados entre sí en una red social. Además, esta red no está completamente conectada: según la literatura empresarial, las empresas suelen tener relaciones laborales establecidas con un número limitado de socios preferidos; estos son los que consideran cuando llegan nuevas tareas y tienen que formar cadenas de suministro para asignar esas tareas. Además de modelar la estructura interrelacionada 500 978-81-904262-7-5 (RPS) c 2007 IFAAMAS entre socios comerciales, la red social introducida en este documento también puede ser utilizada para representar otros tipos de conexiones o restricciones entre entidades autónomas que surgen de otros dominios de aplicación. La siguiente sección proporciona una descripción formal del problema de asignación de tareas en redes sociales. En la Sección 3, demostramos que la complejidad de este problema sigue siendo NP-duro. Luego procedemos a desarrollar un algoritmo distribuido en la Sección 4, y realizamos una serie de experimentos con este algoritmo, como se describe en la Sección 5. La sección 6 discute el trabajo relacionado, y la sección 7 concluye. DESCRIPCIÓN DEL PROBLEMA Formulamos el problema de asignación de tareas sociales en esta sección. Hay un conjunto A de agentes: A = {a1, . . . , am}. Los agentes necesitan recursos para completar tareas. Que R = {r1, . . . , rk} denote la colección de los tipos de recursos disponibles para los agentes A. Cada agente a ∈ A controla una cantidad fija de recursos para cada tipo de recurso en R, que está definida por una función de recurso: rsc : A × R → N. Además, asumimos que los agentes están conectados por una red social. Definición 1 (Red social). Una red social de agentes SN = (A, AE) es un grafo no dirigido, donde los vértices A son agentes, y cada arista (ai, aj) ∈ AE indica la existencia de una conexión social entre los agentes ai y aj. Supongamos que un conjunto de tareas T = {t1, t2, . . . , tn} llega a una red social de agentes. Cada tarea t ∈ T está definida por una tupla u(t), rsc(t), loc(t), donde u(t) es la utilidad obtenida si la tarea t se completa, y la función de recursos rsc : T ×R → N especifica la cantidad de recursos necesarios para la realización de la tarea t. Además, una función de ubicación loc : T → A define las ubicaciones (es decir, agentes) en las que las tareas llegan a la red social. Un agente a que es la ubicación de una tarea t, es decir, loc(t) = a, se llama el encargado de esta tarea. Cada tarea t ∈ T necesita algunos recursos específicos de los agentes para completar la tarea. La asignación exacta de tareas a agentes está definida por una asignación de tareas. Definición 2 (Asignación de tareas). Dado un conjunto de tareas T = {t1, . . . , tn} y un conjunto de agentes A = {a1, . . . , am} en una red social SN, una asignación de tareas es una correspondencia φ : T × A × R → N. Una asignación de tareas válida en SN debe cumplir con las siguientes restricciones: • Una asignación de tareas debe ser correcta. Cada agente a ∈ A no puede utilizar más recursos de los que tiene disponibles, es decir, para cada r ∈ R, P t∈T φ(t, a, r) ≤ rsc(a, r). • Una asignación de tareas debe ser completa. Para cada tarea t ∈ T, o todos los recursos asignados a los agentes son suficientes, es decir, para cada r ∈ R, P a∈A φ(t, a, r) ≥ rsc(t, r), o la tarea no está asignada, es decir, φ(t, ·, ·) = 0. • Una asignación de tareas debe obedecer las relaciones sociales. Cada tarea t ∈ T solo puede asignarse a agentes que sean vecinos (directos) del agente loc(t) en la red social SN. Cada agente que pueda contribuir a una tarea se llama contratista. Escribimos Tφ para representar las tareas que están completamente asignadas en φ. La utilidad de φ es entonces la suma de las utilidades de cada tarea en Tφ, es decir, Uφ = Σ t∈Tφ u(t). Usando esta notación, definimos la asignación eficiente de tareas a continuación. Definición 3 (Asignación eficiente de tareas). Decimos que una asignación de tareas φ es eficiente si es válida y Uφ está maximizado, es decir, Uφ = max( P t∈Tφ u(t)). Ahora estamos listos para definir el problema de asignación de tareas en la red social que estudiamos en este artículo. Definición 4 (Problema de asignación de tareas sociales). Dado un conjunto de agentes A conectados por una red social SN = (A, AE), y un conjunto finito de tareas T, el problema de asignación de tareas sociales (o STAP por sus siglas en inglés) es el problema de encontrar la asignación eficiente de tareas φ, tal que φ sea válida y el bienestar social Uφ esté maximizado. 3. RESULTADOS DE COMPLEJIDAD El problema tradicional de asignación de tareas, TAP (sin la condición de la red social SN), es NP-completo [18], y la complejidad proviene del hecho de que necesitamos evaluar el número exponencial de subconjuntos del conjunto de tareas. Aunque podemos considerar el TAP como un caso especial del STAP al suponer que los agentes están completamente conectados, no podemos utilizar directamente los resultados de complejidad del TAP, ya que estudiamos el STAP en una red social arbitraria, que, como argumentamos en la introducción, debería estar parcialmente conectada. Ahora demostramos que el TAP con una red social arbitraria también es NP-completo, incluso cuando la utilidad de cada tarea es 1 y la cantidad de todos los recursos requeridos y disponibles es 1. Teorema 1. Dado el problema de asignación de tareas sociales con una red social arbitraria, tal como se define en la Definición 4, el problema de decidir si existe una asignación de tareas φ con utilidad mayor que k es NP-completo. Prueba. Primero demostramos que el problema está en NP. Dado una instancia del problema y un entero k, podemos verificar en tiempo polinómico si una asignación φ es una asignación válida y si la utilidad de φ es mayor que k. Ahora demostramos que el STAP es NP-duro mostrando que el conjunto independiente máximo ≤P STAP. Dado un grafo no dirigido G = (V, E) y un entero k, construimos una red G = (V, E) que tiene una asignación eficiente de tareas con k tareas de utilidad 1 asignadas si y solo si G tiene un conjunto independiente (IS) de tamaño k. av1 av3 ae3 rsc(ae1) = {e1} rsc(ae4) = {e4} av4 ae2 av2 ae4 ae1 rsc(ae2) = {e2}{e3} rsc(av3) = {v3} rsc(av4) = {v4} t1 = {v1, e1, e3} t2 = {v2, e1, e2} rsc(ae3) = rsc(av1) = {v1} rsc(av2) = {v2} t3 = {v3, e3, e4} t4 = {v4, e2, e4} e1 e2 e4 e3 v1 v2 v4v3 Figura 1: El problema de MIS se puede reducir al STAP. La figura izquierda es un grafo no dirigido G, que tiene la solución óptima {v1, v4} o {v2, v3}; la figura derecha es la instancia construida del STAP, donde la asignación óptima es {t1, t4} o {t2, t3}. Una instancia de la siguiente construcción se muestra en la Figura 1. Para cada nodo v ∈ V y cada arista e ∈ E en el grafo G, creamos un agente de vértice av y un agente de arista ae en G. El Sexto Internacional. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 501, cuando v era incidente a e en G, añadimos correspondientemente un borde e en G entre av y ae. Asignamos a cada agente en G un recurso, que está relacionado con el nodo o el borde en el grafo G, es decir, para cada v ∈ V, rsc(av) = {v} (aquí escribimos rsc(a) y rsc(t) para representar el conjunto de recursos disponibles para/requeridos por a y t), y para cada e ∈ E, rsc(ae) = {e}. Cada agente de vértice avi en G tiene una tarea ti que requiere un conjunto de recursos vecinos ti = {vi} ∪ {e|e = (u, vi) ∈ E}. No hay tarea sobre los agentes de borde en G. Definimos la utilidad 1 para cada tarea, y la cantidad de todos los recursos requeridos y disponibles como 1. Dado un ejemplo del problema de IS, supongamos que hay una solución de tamaño k, es decir, un subconjunto N ⊆ V tal que ningún par de vértices en N están unidos por una arista en E y |N| = k. N especifica un conjunto de agentes de vértices AN en el grafo correspondiente G. Dado dos agentes a1, a2 ∈ AN, ahora sabemos que no hay un agente ae conectado a ambos a1 y a2. Por lo tanto, para cada agente a ∈ AN, a asigna su tarea a los agentes de borde que están conectados a a. Todos los demás agentes de vértices a /∈ AN no pueden asignar sus tareas, ya que los recursos requeridos de los agentes de borde ya están siendo utilizados por los agentes a ∈ AN. El conjunto de tareas de los agentes AN (|AN| = k) es, por lo tanto, el conjunto máximo de tareas que se pueden asignar. La utilidad de esta asignación es k. De manera similar, si hay una solución para el STAP con el valor de utilidad k, y el conjunto de tareas asignadas es N, entonces para el problema IS, existe un conjunto independiente máximo N de tamaño k en G. Un ejemplo se puede encontrar en la Figura 1. Acabamos de demostrar que el STAP es NP-duro para un grafo arbitrario. En nuestra prueba, la complejidad proviene de la introducción de una red social. Se puede esperar que la complejidad de este problema se pueda reducir para algunas redes donde el número de vecinos de los agentes está limitado por una constante fija. Ahora presentamos un resultado de complejidad sobre esta clase de redes de la siguiente manera. Teorema 2. Que el número de vecinos de cada agente en la red social SN esté limitado por Δ para Δ ≥ 3. Calcular la asignación eficiente de tareas dada una red así es un problema NP-completo. Además, no es aproximable dentro de Δε para algún ε > 0. Prueba. Se ha demostrado en [2] que el problema del conjunto independiente máximo en el caso del grado limitado por Δ para Δ ≥ 3 es NP-completo y no es aproximable dentro de Δε para algún ε > 0. Utilizando la reducción similar de la demostración del Teorema 1, este resultado también se cumple para el STAP. Dado que nuestro problema es tan difícil como MIS, como se muestra en el Teorema 1, no es posible dar un límite de peor caso mejor que Δε para ningún algoritmo de tiempo polinómico, a menos que P = NP. 4. Para abordar el problema de asignar tareas en una red social, presentamos un algoritmo distribuido. Introducimos este algoritmo describiendo el protocolo para los agentes. Después de eso, presentamos el algoritmo óptimo y centralizado, así como un algoritmo de límite superior, que utilizamos en la Sección 5 para evaluar la calidad de nuestro algoritmo distribuido. 4.1 Protocolo para la asignación de tareas distribuidas. Podemos resumir la descripción del problema de asignación de tareas en redes sociales de la Sección 2 de la siguiente manera. Nosotros presentamos el Protocolo de Asignación Distribuida Codicioso (GDAP) en el Algoritmo 1. Cada gerente calcula la eficiencia e(t) para cada una de sus tareas t ∈ Ta, y luego mientras Ta = ∅: 1. Cada gerente selecciona la tarea más eficiente t ∈ Ta de modo que para cada tarea t ∈ Ta: e(t) ≤ e(t). 2. Cada gerente a solicita ayuda para t de todos sus vecinos (de a) informándoles sobre la eficiencia e(t) y los recursos necesarios para t. 3. Los contratistas reciben y almacenan todas las solicitudes, y luego ofrecen todos los recursos relevantes al gerente para la tarea con la mayor eficiencia. 4. Los gerentes que han recibido ofertas suficientes asignan sus tareas e informan a cada contratista qué parte de la oferta es aceptada. Cuando se asigna una tarea, o cuando un gerente ha recibido ofertas de todos los vecinos, pero aún no puede satisfacer su tarea, la tarea se elimina de la lista de tareas Ta. 5. Los contratistas actualizan sus recursos utilizados. Tienen una red (social) de agentes. Cada agente tiene a su disposición un conjunto de recursos de diferentes tipos. También tenemos un conjunto de tareas. Cada tarea requiere algunos recursos, tiene un beneficio fijo y está ubicada en un agente específico. Este agente se llama gerente. Solo permitimos que los agentes vecinos ayuden con una tarea. Estos agentes son llamados contratistas. Los agentes pueden desempeñar el papel de gerente y también de contratista. El problema consiste en determinar qué tareas ejecutar y qué recursos de qué contratistas utilizar para estas tareas. La idea del protocolo es la siguiente. Todos los agentes gerentes a ∈ A intentan encontrar contratistas vecinos para ayudarles con su(s) tarea(s) Ta = {ti ∈ T | loc(ti) = a}. Comienzan ofreciendo la tarea que es más eficiente en términos de la relación entre beneficio y recursos requeridos. De todas las tareas ofrecidas, los contratistas seleccionan la tarea con la mayor eficiencia y envían una oferta al gerente correspondiente. Una oferta consiste en todos los recursos que el agente puede suministrar para esta tarea. Si se han ofrecido recursos suficientes, el gerente selecciona los recursos requeridos e informa a todos los contratistas de su elección. La eficiencia de una tarea se define de la siguiente manera: Definición 5. La eficiencia e de una tarea t ∈ T se define por la utilidad de esta tarea dividida por la suma de todos los recursos requeridos: e(t) = u(t)P r∈R rsc(t,r) . Una descripción más detallada de este protocolo se puede encontrar en el Algoritmo 1. Aquí también se define cómo determinar cuándo una tarea ya no debe ser ofrecida, porque es imposible de cumplir localmente. Obviamente, una tarea tampoco se ofrece más una vez que ha sido asignada. Este protocolo es tal que, cuando ninguna tarea tiene exactamente la misma eficiencia, en cada iteración al menos una tarea es eliminada de la lista de tareas. A partir de esto se sigue la propiedad de computación y comunicación del algoritmo. Proposición 1. Para un STAP con n tareas y m agentes, el tiempo de ejecución del algoritmo distribuido es O(nm), y el número de mensajes de comunicación es O(n2 m). Incluso cuando algunas tareas tienen la misma eficiencia, es sencillo hacer que este resultado funcione. Por ejemplo, la implementación puede asegurar que los contratistas elijan la tarea con el identificador de tarea más bajo. 502 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Algoritmo 2 Asignación óptima de tareas sociales (OPT). Repetir lo siguiente para cada combinación de tareas: 1. Si la recompensa total para esta combinación es mayor que cualquier combinación anterior, prueba si esta combinación es factible de la siguiente manera: 2. Cree un problema de flujo de red para cada tipo de recurso r ∈ R (por separado) de la siguiente manera: (a) Cree un origen s y un sumidero s. (b) Para cada agente a ∈ A, cree un nodo de agente y una arista desde s a este nodo con una capacidad igual a la cantidad de recursos de tipo r que el agente a tiene. (c) Para cada tarea t ∈ T, cree un nodo de tarea y una arista desde este nodo a s con una capacidad igual a la cantidad de recursos de tipo r que la tarea T requiere. (d) Para cada agente a, conecte el nodo de agente a todos los nodos de tarea de las tareas vecinas, es decir, t ∈ {t ∈ T | (a, loc(t)) ∈ AE}. Dale a esta conexión una capacidad ilimitada. Resuelve el problema del flujo máximo para las redes de flujo creadas. Si el flujo máximo en cada red es igual a los recursos totales requeridos de ese tipo, la combinación actual de tareas es factible. En ese caso, esta es la mejor combinación actual de tareas. Prueba. En el peor de los casos, en cada iteración exactamente una tarea se elimina de una lista de tareas, por lo que hay n iteraciones. En cada iteración en el peor de los casos (es decir, en una red completamente conectada), para cada uno de los O(n) gerentes, se envían O(m) mensajes. A continuación, cada contratista puede seleccionar la tarea con la mayor eficiencia en O(n). Asignar una asignación se puede hacer en O(m). Esto lleva a un total de O(n + m) operaciones para cada iteración, y por lo tanto O(n^2 + nm) operaciones en total. El número de mensajes enviados es O(n(nm + nm + nm)) = O(n2 m). Establecemos la calidad de este protocolo experimentalmente (en la Sección 5). Preferiblemente, comparamos los resultados con la solución óptima. 4.2 Asignación óptima de tareas sociales El algoritmo de asignación óptima de tareas debe lidiar con las restricciones impuestas por la red social. Para este problema NPcompleto utilizamos un algoritmo de fuerza bruta exponencial para considerar combinaciones relevantes de tareas a ejecutar. Para cada combinación utilizamos un algoritmo de flujo máximo para verificar si los recursos son suficientes para el subconjunto seleccionado de tareas. La red de flujo describe qué recursos se pueden utilizar para qué tareas, dependiendo de la red social. Si el flujo máximo es igual a la suma de todos los recursos requeridos por el subconjunto de tareas, sabemos que existe una solución factible (ver Algoritmo 2). Claramente, no podemos esperar que este algoritmo óptimo pueda encontrar soluciones para tamaños de problemas más grandes. Para establecer la calidad de nuestro protocolo para instancias grandes, utilizamos el siguiente método para determinar un límite superior. 4.3 Límite superior para la asignación de tareas sociales Dado un problema de asignación de tareas sociales, si el número de tipos de recursos para cada tarea t ∈ T está limitado por 1, se aplica el Algoritmo 3 Límite superior para la asignación de tareas sociales (UB). Cree un problema de flujo de red con costos de la siguiente manera: 1. Crear una fuente s y un sumidero s. 2. Para cada agente a ∈ A y cada tipo de recurso ri ∈ R, crear un nodo agente-recurso ai y una arista desde s hasta este nodo con una capacidad igual a la cantidad de recursos del tipo r que el agente a tiene disponible y con costos 0.3. Para cada tarea t ∈ T y cada tipo de recurso ri ∈ R, crear un nodo tarea-recurso ti y una arista desde este nodo a s con una capacidad igual a la cantidad de recursos del tipo r que la tarea t requiere y costos -e(t). 4. Para cada tipo de recurso ri ∈ R y para cada agente a, conecte el nodo agente-recurso ai a todos los nodos tarea-recurso ti para las tareas vecinas t ∈ {t ∈ T | (a, loc(t)) ∈ AE o a = loc(t)}. Dale a esta conexión capacidad ilimitada y costos cero. 5. Crear un borde directamente de s a s con capacidad ilimitada y costos cero. Resuelve el problema de flujo de costo mínimo para esta red. Los costos de la red resultante son un límite superior para el problema de asignación de tareas sociales. El problema es resoluble de forma polinómica al transformarlo en un problema de red de flujo. Nuestro método para calcular eficientemente un límite superior para STAP hace uso de este caso especial al convertir cualquier instancia dada de STAP P en un nuevo problema P donde cada tarea solo tiene un tipo de recurso. Más específicamente, para cada tarea t ∈ T con utilidad u(t), hacemos lo siguiente. Sea m el número de tipos de recursos {r1, . . . , rm} requeridos por t. Luego dividimos t en un conjunto de m tareas T = {t1, . . . , tm} donde cada tarea ti solo tiene un tipo de recurso único (de {r1, . . . , rm}) y cada tarea tiene una parte justa de la utilidad, es decir, la eficiencia de t de la Definición 5 multiplicada por la cantidad de este tipo de recurso rsc(ti, ri). Después de realizar esta conversión de forma polinómica para cada tarea en T, el problema original P se convierte en el caso especial P. Ten en cuenta que el conjunto de asignaciones válidas en P es solo un subconjunto del conjunto de asignaciones válidas en P, ya que ahora es posible asignar una tarea parcialmente. A partir de esto es fácil ver que la solución de P proporciona un límite superior de la solución del problema original P. Para calcular la solución óptima de P, lo transformamos en un problema de flujo de costo mínimo. Modelamos el costo en la red de flujo mediante la negación de la utilidad de las nuevas tareas. Se utiliza una implementación de tiempo polinómico de un algoritmo de flujo de costo mínimo escalable [9] para el cálculo. El flujo de costo mínimo resultante representa una asignación máxima de las tareas para P. El modelado detallado se describe en el Algoritmo 3. En la siguiente sección, utilizamos este límite superior para estimar la calidad del GDAP para instancias a gran escala. 5. EXPERIMENTOS Implementamos el protocolo de asignación distribuida codicioso (GDAP), el algoritmo de asignación óptima (OPT) y el algoritmo de límite superior (UB) en Java, y los probamos en una PC con Linux. El propósito de estos experimentos es estudiar el rendimiento del algoritmo distribuido en diferentes configuraciones de problemas utilizando diferentes redes sociales. El sexto Congreso Internacional. La calidad de la solución y el tiempo de computación son las medidas de rendimiento, donde la calidad de la solución (SQ) se calcula de la siguiente manera. Cuando el número de tareas es pequeño, comparamos la salida del algoritmo distribuido con la solución óptima, es decir, SQ = GDAP OP T, pero si no es factible calcular la solución óptima, utilizamos el valor devuelto por el algoritmo de cota superior para la evaluación, es decir, SQ = GDAP UB. Para ver si este último es una buena medida, también comparamos la calidad del límite superior con la solución óptima para problemas más pequeños. En lo siguiente, describimos la configuración de todos los experimentos y presentamos los resultados. 5.1 Configuración experimental Consideramos varios entornos experimentales. En todos los entornos, los agentes están conectados por una red social. En los experimentos, se utilizan tres redes diferentes para simular las relaciones sociales entre agentes en posibles problemas del mundo real. Las redes de mundo pequeño son redes donde la mayoría de los vecinos de un agente también están conectados entre sí. Para los experimentos utilizamos un método para generar redes de pequeño mundo aleatorias propuesto por Watts et al. [22], con una probabilidad de reconfiguración fija p = 0.05. Las redes libres de escala tienen la propiedad de que un par de nodos tienen muchas conexiones, y muchos nodos tienen solo un pequeño número de conexiones. Para generar estos, utilizamos la implementación en la biblioteca JUNG del generador propuesto por Barabási y Albert [3]. También generamos redes aleatorias de la siguiente manera. Primero conectamos cada agente con otro agente de manera que todos los agentes estén conectados. A continuación, añadimos conexiones de forma aleatoria hasta alcanzar el grado promedio deseado. Ahora describimos los diferentes ajustes utilizados en nuestros experimentos con problemas de pequeña y gran escala. Configuración 1. El número de agentes es 40, y el número de tareas es 20. El número de tipos de recursos diferentes está limitado a 5, y el número promedio de recursos requeridos por una tarea es de 30. Por consiguiente, el número total de recursos requeridos por las tareas está fijo. Sin embargo, los recursos disponibles para los agentes son variados. Definimos la proporción de recursos para referirnos a la relación entre el número total de recursos disponibles y el número total de recursos requeridos. Los recursos se asignan de manera uniforme a los agentes. Los grados promedio de las redes también pueden cambiar. En este entorno, los beneficios de la tarea se distribuyen de forma normal alrededor del número de recursos requeridos. Configuración 2. Esta configuración es similar a la Configuración 1, pero aquí permitimos que los beneficios de las tareas varíen drásticamente: el 40% de las tareas tienen alrededor de 10 veces más beneficios que el otro 60% de las tareas. Configuración 3. Esta configuración es para problemas a gran escala. La proporción entre el número de agentes y el número de tareas se establece en 5/3, y el número de agentes varía de 100 a 2000. También fijamos la proporción de recursos en 1.2 y el grado promedio en 6. El número de tipos de recursos diferentes es 20, y el requisito promedio de recursos de una tarea es 100. Los beneficios de la tarea están distribuidos normalmente. 5.2 Resultados experimentales Los experimentos se realizan con los tres ajustes diferentes en las tres redes mencionadas anteriormente, donde cada dato registrado es el promedio de 20 instancias aleatorias. 5.2.1 Experimento 1 Se utiliza el ajuste experimental 1 para este conjunto de experimentos. Nos gustaría ver cómo se comporta el GDAP en las diferentes redes cuando el número de recursos disponibles para los agentes está cambiando. También estudiamos el comportamiento de nuestro algoritmo de límite superior. Para este experimento fijamos el número promedio de vecinos (grado) en cada tipo de red en seis. En la Figura 2 vemos cómo la calidad tanto del límite superior como del algoritmo GDAP depende de la proporción de recursos. Notablemente, para ratios de recursos más bajos nuestro GDAP está mucho más cerca de la asignación óptima que del límite superior. Cuando la proporción de recursos crece por encima de 1.5, los gráficos del límite superior y del GDAP convergen, lo que significa que ambos están muy cerca de la solución óptima. Esto se puede explicar por el hecho de que cuando hay muchos recursos disponibles, todas las tareas pueden asignarse sin conflictos. Sin embargo, cuando los recursos son muy escasos, el límite superior es demasiado optimista, ya que se basa en la asignación de sub tareas por tipo de recurso, y no considera cuántas de las tareas realmente se pueden asignar por completo. También observamos en el gráfico que la calidad de la solución del GDAP en las tres redes es bastante alta (más de 0.8) cuando el recurso disponible es muy limitado (0.3). Desciende por debajo de 0.8 con la proporción aumentada y vuelve a subir una vez que hay suficientes recursos disponibles (proporción de recursos 0.9). Claramente, si 504 The Sixth Intl. La calidad del GDAP y el límite superior dependen del grado de la red. Los recursos son realmente escasos, solo unas pocas tareas pueden asignarse con éxito incluso por el algoritmo óptimo. Por lo tanto, el GDAP es capaz de proporcionar una asignación bastante buena. Aunque las diferencias son mínimas, también se puede observar que los resultados para la red de mundo pequeño son consistentemente ligeramente mejores que los de las redes aleatorias, que a su vez superan a las redes libres de escala. Esto se puede entender al observar la distribución del grado de los agentes, como se muestra en la Figura 3. En este experimento, en la red de mundo pequeño casi todos los gerentes tienen un grado de seis. En redes aleatorias, el grado varía entre uno y aproximadamente diez. Sin embargo, en la red libre de escala, la mayoría de los nodos solo tienen tres o cuatro conexiones, y solo unos pocos tienen hasta veinte conexiones. Como veremos en el próximo experimento, tener más conexiones significa obtener mejores resultados. Para el próximo experimento fijamos la proporción de recursos en 1.0 y estudiamos la calidad tanto del límite superior como del algoritmo GDAP en relación con el grado de la red social. El resultado se puede encontrar en la Figura 4. En esta figura podemos ver que un alto grado promedio también conduce a la convergencia del límite superior y el GDAP. Obviamente, cuando los gerentes tienen muchas conexiones, se vuelve más fácil asignar tareas. Una excepción es, similar a lo que hemos visto en la Figura 2, que la solución del GDAP también es muy buena si las conexiones son extremadamente limitadas (grado 2), debido a que el número de tareas posiblemente asignadas es muy pequeño. Una vez más vemos que el límite superior no es tan bueno para problemas en los que los recursos son difíciles de alcanzar, es decir, en redes sociales con un bajo grado promedio. Dado que la calidad de la solución claramente depende de la proporción de recursos, así como del grado de la red social, estudiamos el efecto de cambiar ambos para ver si se influyen mutuamente. La Figura 5 muestra cómo la calidad de la solución depende tanto de la proporción de recursos como del grado de la red. Este gráfico confirma que el GDAP funciona mejor para problemas con un grado más alto y una proporción de recursos más alta. Sin embargo, ahora también está más claro que funciona mejor para grados muy bajos de disponibilidad de recursos. Para este experimento con 40 agentes y 20 tareas, el peor rendimiento se encuentra en instancias con grado seis y una proporción de recursos de 0.6 en comparación con instancias con grado doce y una proporción de recursos de 0.3. Pero incluso para esos casos, el rendimiento se sitúa por encima de 0.7. La desviación estándar consistente de alrededor del 15% en las 20 instancias del problema no se muestra como barras de error en estos primeros gráficos, porque oscurecería las correlaciones interesantes que ahora se pueden ver. 4 6 8 10 12 14 16 0.4 0.6 0.8 1 1.2 1.4 1.6 0.7 0.75 0.8 0.85 0.9 0.95 1 Recompensa relativa mundo pequeño Grado promedio Proporción de recursos Recompensa relativa Figura 5: La calidad del GDAP depende tanto de la proporción de recursos como del grado de la red. 5.2.2 Experimento 2 Para estudiar la robustez del GDAP frente a diferentes configuraciones del problema, generamos instancias donde la distribución de beneficios de la tarea es diferente: el 40% de las tareas obtiene un beneficio 10 veces mayor (como se describe en la Configuración 2). El efecto de esta distribución diferente se puede ver en la Figura 6. Estos dos gráficos muestran que los resultados para la distribución de beneficios sesgada son ligeramente mejores en promedio, tanto al variar la proporción de recursos como al variar el grado promedio de la red. Sostenemos que esto puede explicarse por la naturaleza codiciosa de GDAP, que hace que las tareas con alta eficiencia se asignen primero, y hace que el algoritmo funcione mejor en este entorno heterogéneo. 5.2.3 Experimento 3 El propósito de este experimento final es probar si el algoritmo puede escalarse a problemas grandes, como aplicaciones que se ejecutan en internet. Por lo tanto, generamos instancias donde el número de agentes varía de 100 a 2000, y simultáneamente aumentamos el número de tareas de 166 a 3333 (Configuración 3). La Figura 7 muestra el tiempo de ejecución para estas instancias en una máquina Linux con un procesador AMD Opteron de 2.4 GHz. Estos gráficos confirman el análisis teórico de la sección anterior, indicando que tanto el límite superior como el GDAP son polinomiales. De hecho, los gráficos muestran que el GDAP casi se comporta de manera lineal. Aquí vemos que la localidad del GDAP realmente ayuda a reducir el tiempo de cálculo. También hay que tener en cuenta que el GDAP requiere incluso menos tiempo de computación que el límite superior. La calidad del GDAP para estas grandes instancias no se puede comparar con la solución óptima. Por lo tanto, en la Figura 8 se utiliza el límite superior en su lugar. Este resultado muestra que el GDAP se comporta de manera estable y consistentemente bien con el aumento del tamaño del problema. También muestra una vez más que el GDAP funciona mejor en una red de mundo pequeño. 6. TRABAJO RELACIONADO La asignación de tareas en sistemas multiagentes ha sido investigada por muchos investigadores en los últimos años con diferentes suposiciones y énfasis. Sin embargo, la mayoría de las investigaciones realizadas hasta la fecha sobre la asignación de tareas no considera las conexiones sociales entre agentes, y estudia el problema de forma centralizada. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 505 0.65 0.7 0.75 0.8 0.85 0.9 0.95 1 0.4 0.6 0.8 1 1.2 1.4 1.6 Recompensa relativa al óptimo. Relación de recursos sesgada, pequeño mundo sesgado, aleatorio sesgado, libre de escala uniforme, pequeño mundo uniforme, aleatorio uniforme, libre de escala 0.7 0.75 0.8 0.85 0.9 0.95 1 2 4 6 8 10 12 14 16 Recompensa relativa al óptimo. Grado sesgado, pequeño mundo sesgado, aleatorio sesgado, libre de escala uniforme, pequeño mundo uniforme, aleatorio uniforme, libre de escala Figura 6: La calidad del algoritmo GDAP para una distribución de beneficios de tarea uniforme y sesgada relacionada con la proporción de recursos (el primer gráfico) y el grado de red (el segundo gráfico). configuración. Por ejemplo, Kraus et al. [12] desarrollan un protocolo de subasta que permite a los agentes formar coaliciones con restricciones de tiempo. Se asume que cada agente conoce las capacidades de todos los demás. El protocolo propuesto es centralizado, donde un gerente es responsable de asignar las tareas a todas las coaliciones. Manisterski et al. [14] discuten las posibilidades de lograr asignaciones eficientes tanto en entornos cooperativos como no cooperativos. Proponen un algoritmo centralizado para encontrar la solución óptima. A diferencia de este trabajo, también presentamos un protocolo completamente distribuido eficiente que tiene en cuenta la red social. La asignación de tareas también ha sido estudiada en entornos distribuidos, por ejemplo, por Shehory y Kraus [18] y por Lerman y Shehory [13]. Proponen algoritmos distribuidos con baja complejidad de comunicación para formar coaliciones en sistemas multiagente a gran escala. Sin embargo, no asumen la existencia de ninguna red de agentes. El trabajo de Sander et al. [16] introduce algoritmos basados en geometría computacional para la asignación de tareas distribuidas en dominios geográficos. Los agentes pueden moverse y buscar activamente tareas, y la capacidad de los agentes para realizar tareas es homogénea. Para aplicar su enfoque, los agentes necesitan tener cierto conocimiento sobre las posiciones geográficas de las tareas y algunos otros agentes. Otro trabajo [17] propone un mecanismo de ubicación para sistemas multiagentes abiertos que asigna tareas a agentes desconocidos. En este enfoque, cada agente almacena en caché una lista de agentes que conocen. El análisis de la complejidad de comunicación de este método se basa en grafos tipo retícula, mientras investigamos cómo resolver eficientemente la asignación de tareas en una red social, cuya topología puede ser arbitraria. Las redes han sido empleadas en el contexto de la asignación de tareas en algunos otros trabajos también, por ejemplo, para limitar las interacciones entre agentes y mediadores [1]. Los mediadores en este contexto son agentes que reciben la tarea y tienen conexiones con otros agentes. Dividen la tarea en subtareas y negocian con otros agentes para obtener compromisos de ejecutar estas subtareas. Su enfoque se centra en modelar el proceso de toma de decisiones de un único mediador. Otro enfoque es dividir la red en cliques de nodos, que representan coaliciones que los agentes involucrados pueden utilizar como mecanismo de coordinación [20]. El enfoque de ese trabajo es la formación de coaliciones distribuidas entre agentes, pero en nuestro enfoque, no necesitamos que los agentes formen grupos antes de asignar tareas. Easwaran y Pitt [6] estudian tareas complejas que requieren servicios para su realización. El problema se refiere a la asignación de subtareas a proveedores de servicios en una cadena de suministro. Otro estudio sobre la asignación de tareas en cadenas de suministro es [21], donde se argumenta que la característica definitoria de la Formación de Cadenas de Suministro es la descomposición jerárquica de sub tareas (HSD). HSD se implementa utilizando redes de dependencia de tareas (TDN), con agentes y bienes como nodos, y relaciones de entrada/salida entre ellos como aristas. Aquí, se presenta la red y el problema es seleccionar un subgrafo, para lo cual los autores proponen un algoritmo basado en el mercado, en particular, una serie de subastas. En comparación con estos trabajos, nuestro enfoque es más general en el sentido de que podemos modelar diferentes tipos de conexiones o restricciones entre agentes para diferentes dominios de problemas además de la formación de cadenas de suministro. Finalmente, las redes sociales han sido utilizadas en el contexto de la formación de equipos. Trabajos anteriores han demostrado cómo aprender qué relaciones son más beneficiosas a largo plazo [8], y adaptar la red social en consecuencia. Creemos que estos resultados pueden ser transferidos al ámbito de la asignación de tareas también, dejando esto como un tema para futuros estudios. 506 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 7. CONCLUSIONES En este artículo estudiamos el problema de asignación de tareas en una red social (STAP), que puede ser visto como una nueva y más general variante del TAP. Creemos que tiene un gran potencial para problemas realistas. Proporcionamos resultados de complejidad sobre el cálculo de la solución eficiente para el STAP, así como un límite en posibles algoritmos de aproximación. A continuación, presentamos un protocolo distribuido, relacionado con el protocolo contractnet. También introdujimos un algoritmo exponencial para calcular la solución óptima, así como un algoritmo de cota superior rápido. Finalmente, utilizamos la solución óptima y el límite superior (para instancias más grandes) para llevar a cabo un extenso conjunto de experimentos para evaluar la calidad de la solución y la eficiencia computacional del algoritmo distribuido propuesto en diferentes tipos de redes, a saber, redes de mundo pequeño, redes aleatorias y redes libres de escala. Los resultados presentados en este artículo muestran que el algoritmo distribuido funciona bien en redes de pequeño mundo, libres de escala y aleatorias, y para muchos ajustes diferentes. También se realizaron otros experimentos (por ejemplo, en redes de cuadrícula) y estos resultados se mantuvieron en una gama más amplia de escenarios. Además, demostramos que se adapta bien a redes grandes, tanto en términos de calidad como de tiempo de computación requerido. Los resultados también sugieren que las redes de mundo pequeño son ligeramente más adecuadas para la asignación de tareas locales, ya que no hay nodos con muy pocos vecinos. Hay muchas extensiones interesantes a nuestro trabajo actual. En este artículo, nos enfocamos en el aspecto computacional en el diseño del algoritmo distribuido. En nuestro trabajo futuro, también nos gustaría abordar algunos de los problemas relacionados con la teoría de juegos, como agentes estratégicos, y mostrar propiedades deseables de un protocolo distribuido en dicho contexto. En el algoritmo actual asumimos que los agentes solo pueden contactar a sus vecinos para solicitar recursos, lo cual puede explicar por qué nuestro algoritmo no funciona tan bien en las redes de escala libre como en las redes de mundo pequeño. Nuestro trabajo futuro puede permitir a los agentes reasignar (sub)tareas. Estamos interesados en ver cómo tales interacciones afectarán el rendimiento de la asignación de tareas en diferentes redes sociales. Un tercer tema interesante para futuros trabajos es la adición de información de reputación entre los agentes. Esto puede ayudar a modelar las relaciones comerciales cambiantes e incentivar a los agentes a seguir el protocolo. Finalmente, sería interesante estudiar instancias reales del problema de asignación de tareas sociales y ver cómo se relacionan con las redes generadas aleatoriamente de diferentes tipos estudiadas en este artículo. Agradecimientos. Este trabajo está respaldado por la Fundación de Tecnología STW, división de ciencias aplicadas de NWO, y el Ministerio de Asuntos Económicos. 8. REFERENCIAS [1] S. Abdallah y V. Lesser. Modelado de la asignación de tareas utilizando un modelo de teoría de decisiones. En Proc. AAMAS, páginas 719-726. ACM, 2005. [2] N. Alon, U. Feige, A. Wigderson y D. Zuckerman. Productos de grafos derandomizados. Complejidad computacional, 5(1):60-75, 1995. [3] A.-L. Barabási y R. Albert. Aparición de la escala en redes aleatorias. Ciencia, 286(5439):509-512, 1999. [4] R. H. Coase. La naturaleza de la empresa. Economica NS, 4(16):386-405, 1937. [5] R. H. Coase.
Economica NS, 4(16):386-405, 1937. [5] R. H. Coase. Mi evolución como economista. En W. Breit y R. W. Spencer, editores, Vidas de los Laureados, páginas 227-249. MIT Press, 1995. [6] A. M. Easwaran y J. Pitt. Formación de Cadena de Suministro en Sistemas Multiagentes Abiertos y Basados en el Mercado. Revista Internacional de Inteligencia Computacional y Aplicaciones, 2(3):349-363, 2002. [7] I. Foster, N. R. Jennings y C. Kesselman. Cerebro se encuentra con la fuerza bruta: por qué la red y los agentes se necesitan mutuamente. En Proc. AAMAS, páginas 8-15, Washington, DC, EE. UU., 2004. IEEE Computer Society. [8] M. E. Gaston y M. desJardins. Redes organizadas por agentes para la formación dinámica de equipos. En Proc. AAMAS, páginas 230-237, Nueva York, NY, EE. UU., 2005. ACM Press. [9] A. Goldberg. 

ACM Press. [9] A. Goldberg. Una implementación eficiente de un algoritmo de flujo de costo mínimo escalable. Revista de Algoritmos, 22:1-29, 1997. [10] R. Gulati. ¿La familiaridad engendra confianza? Las implicaciones de los lazos repetidos para la elección contractual en alianzas. Revista de la Academia de Gestión, 38(1):85-112, 1995. [11] T. Klos y B. Nooteboom. Economía Computacional de Costos de Transacción basada en Agentes. Dinámica y control económico, 25(3-4):503-526, 01. [12] S. Kraus, O. Shehory y G. Taase. Formación de coaliciones con información heterogénea incierta. En Proc. AAMAS, páginas 1-8. ACM, 2003. [13] K. Lerman y O. Shehory. Formación de coaliciones para mercados electrónicos a gran escala. En Proc. ICMAS, páginas 167-174. IEEE Computer Society, 2000. [14] E. Manisterski, E. David, S. Kraus y N. Jennings. Formación de grupos de agentes eficientes para completar tareas complejas. En Proc. AAMAS, páginas 257-264. ACM, 2006. [15] J. Patel y col. Organizaciones Virtuales Basadas en Agentes para la Red. Sistemas Multiagente y de Red, 1(4):237-249, 2005. [16] P. V. Sander, D. Peleshchuk y B. J. Grosz. Un algoritmo escalable y distribuido para una asignación eficiente de tareas. En Proc. AAMAS, páginas 1191-1198, Nueva York, NY, EE. UU., 2002. ACM Press. [17] O. Shehory. 

ACM Press. [17] O. Shehory. Un mecanismo de ubicación de agentes escalable. En Proc. ATAL, volumen 1757 de LNCS, páginas 162-172. Springer, 2000. [18] O. Shehory y S. Kraus. Métodos para la asignación de tareas a través de la formación de coaliciones de agentes. Inteligencia Artificial, 101(1-2):165-200, 1998. [19] R. M. Sreenath y M. P. Singh. Selección de servicios basada en agentes. Semántica Web, 1(3):261-279, 2004. [20] P. T. Toˇsi´c y G. A. Agha. Formación de coaliciones distribuidas basada en cliques máximos para la asignación de tareas en sistemas multiagente a gran escala. En Proc. MMAS, volumen 3446 de LNAI, páginas 104-120. Springer, 2005. [21] W. E. Walsh y M. P. Wellman. Modelado de la formación de cadenas de suministro en sistemas multiagentes. En Proc. AMEC II, volumen 1788 de LNAI, páginas 94-101. Springer, 2000. [22] D. J. Watts y S. H. Strogatz. Dinámicas colectivas de redes de mundo pequeño. Naturaleza, 393:440-442, 1998. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 507