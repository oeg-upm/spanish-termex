Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. 

LEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.
Revisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341