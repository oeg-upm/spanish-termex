Algoritmos de compensación para mercados de intercambio de trueque: Facilitando los intercambios de riñones a nivel nacional. David J. Abraham, Departamento de Ciencias de la Computación, Universidad Carnegie Mellon, dabraham@cs.cmu.edu. Avrim Blum, Departamento de Ciencias de la Computación, Universidad Carnegie Mellon, avrim@cs.cmu.edu. Tuomas Sandholm, Departamento de Ciencias de la Computación, Universidad Carnegie Mellon, sandholm@cs.cmu.edu. RESUMEN En los mercados de trueque, los agentes buscan intercambiar sus artículos entre sí, con el fin de mejorar sus propias utilidades. Estos intercambios consisten en ciclos de agentes, donde cada agente recibe el artículo del siguiente agente en el ciclo. Nos enfocamos principalmente en el próximo mercado nacional de intercambio de riñones, donde los pacientes con enfermedad renal pueden obtener donantes compatibles intercambiando sus propios donantes dispuestos pero incompatibles. Con más de 70,000 pacientes ya en espera de un riñón de cadáver en los Estados Unidos, este mercado es considerado como la única forma ética de reducir significativamente las 4,000 muertes al año atribuidas a enfermedades renales. El problema de compensación implica encontrar un intercambio que maximice el bienestar social cuando la longitud máxima de un ciclo está fija. Los ciclos largos están prohibidos, ya que, por razones de incentivo, todos los trasplantes en un ciclo deben realizarse simultáneamente. Además, en los intercambios de trueque en general, más agentes se ven afectados si uno abandona un ciclo más largo. Demostramos que el problema de despeje con esta restricción de longitud de ciclo es NP-duro. Resolverlo exactamente es uno de los principales desafíos en el establecimiento de un intercambio nacional de riñones. Presentamos el primer algoritmo capaz de liquidar estos mercados a nivel nacional. La clave es la formulación incremental del problema. Adaptamos dos paradigmas para la tarea: generación de restricciones y generación de columnas. Para cada uno, desarrollamos técnicas que mejoran drásticamente tanto el tiempo de ejecución como el uso de memoria. Concluimos que la generación de columnas escala considerablemente mejor que la generación de restricciones. Nuestro algoritmo también admite varias generalizaciones, como las exigidas por los intercambios reales de riñón. Nuestro algoritmo reemplazó a CPLEX como el algoritmo de compensación de la Alianza para la Donación Cruzada, uno de los principales intercambios de riñones. Las carreras de fósforos se realizan cada dos semanas y los trasplantes basados en nuestras optimizaciones ya han sido realizados. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas]: [General] Términos Generales Algoritmos, Economía 1. INTRODUCCIÓN El papel de los riñones es filtrar los desechos de la sangre. La insuficiencia renal resulta en la acumulación de estos desechos, lo cual conduce a la muerte en meses. Una opción de tratamiento es la diálisis, en la que el paciente va a un hospital para que su sangre sea filtrada por una máquina externa. Se requieren varias visitas por semana, y cada una lleva varias horas. La calidad de vida en diálisis puede ser extremadamente baja, de hecho, muchos pacientes optan por retirarse de la diálisis, lo que conduce a una muerte natural. Solo el 12% de los pacientes en diálisis sobreviven 10 años [23]. En cambio, el tratamiento preferido es un trasplante de riñón. Los trasplantes de riñón son, con mucho, los trasplantes más comunes. Desafortunadamente, la demanda de riñones supera con creces la oferta. En los Estados Unidos en 2005, 4,052 personas murieron esperando un trasplante de riñón que les salvara la vida. Durante este tiempo, casi 30,000 personas fueron añadidas a la lista nacional de espera, mientras que solo 9,913 personas salieron de la lista después de recibir un riñón de donante fallecido. La lista de espera actualmente tiene más de 70,000 personas, y el tiempo de espera mediano varía de 2 a 5 años, dependiendo del tipo de sangre. Para muchos pacientes con enfermedad renal, la mejor opción es encontrar un donante vivo, es decir, una persona sana dispuesta a donar uno de sus dos riñones. Aunque existen mercados para comprar y vender riñones de donantes vivos, la comercialización de órganos humanos es casi universalmente considerada como antiética, y la práctica suele ser explícitamente ilegal, como en los Estados Unidos. Sin embargo, en la mayoría de los países, la donación en vida es legal, siempre y cuando se realice como un regalo sin compensación financiera. En 2005, hubo 6,563 donaciones en vida en los Estados Unidos. El número de donaciones en vida habría sido mucho mayor si no fuera por el hecho de que, con frecuencia, un posible donante y su receptor previsto son incompatibles en tipo de sangre o tipo de tejido. En el pasado, el donante incompatible fue enviado a casa, dejando al paciente a la espera de un riñón de un donante fallecido. Sin embargo, ahora hay algunos intercambios renales regionales en los Estados Unidos, en los que los pacientes pueden intercambiar sus donantes incompatibles entre sí, para así obtener cada uno un donante compatible. Estos mercados son ejemplos de intercambios de trueque. En un mercado de intercambio por trueque, los agentes (pacientes) buscan intercambiar sus artículos (donantes incompatibles) entre sí. Estos intercambios consisten en ciclos de agentes, donde cada agente recibe el artículo del siguiente agente en el ciclo. Los intercambios de trueque son ubicuos: ejemplos incluyen Peerflix (DVDs) [11], Read It Swap It (libros) [12], e Intervac (casas de vacaciones) [9]. Durante muchos años, incluso ha habido un gran intercambio de zapatos en los Estados Unidos [10]. Las personas con pies de diferentes tamaños usan esto para evitar tener que comprar dos pares de zapatos. Los amputados de pierna tienen un intercambio separado para compartir el costo de comprar un par de zapatos. Podemos codificar un mercado de intercambio de trueque como un grafo dirigido G = (V, E) de la siguiente manera. Construye un vértice para cada agente. Agregar un borde ponderado e desde un agente vi hacia otro vj, si vi desea el artículo de vj. El peso que representamos de e es la utilidad para vi de obtener el artículo vjs. Un ciclo c en este grafo representa un intercambio posible, donde cada agente en el ciclo obtiene el artículo del siguiente agente. El peso wc de un ciclo c es la suma de los pesos de sus aristas. Un intercambio es una colección de ciclos disjuntos. El peso de un intercambio es la suma de los pesos de sus ciclos. Un intercambio que maximiza el bienestar social es aquel con un peso máximo. La Figura 1 ilustra un mercado de ejemplo con 5 agentes, {v1, v2, . . . , v5}, en el que todos los bordes tienen peso 1. El mercado tiene 4 ciclos, c1 = v1, v2, c2 = v2, v3, c3 = v3, v4 y c4 = v1, v2, v3, v4, v5, y dos intercambios maximales (de inclusión), a saber, M1 = {c4} y M2 = {c1, c3}. El intercambio M1 tiene tanto el peso máximo como la cardinalidad máxima (es decir, incluye la mayor cantidad de aristas/vértices). v1 v2 v3 v4 v5 e1 e3 e5 c1 c2 c3 e8 e7 e6e4e2 c4 Figura 1: Mercado de intercambio de trueque de ejemplo. El problema de compensación consiste en encontrar un intercambio de peso máximo que consista en ciclos con una longitud de a lo sumo una pequeña constante L. Esta restricción de longitud de ciclo surge naturalmente por varias razones. Por ejemplo, en un intercambio de riñón, todas las operaciones en un ciclo deben realizarse simultáneamente; de lo contrario, un donante podría retractarse después de que su pareja incompatible haya recibido un riñón. (No se puede redactar un contrato vinculante para donar un órgano). Esto da lugar a una restricción logística en el tamaño del ciclo: incluso si todos los donantes son operados primero y se utiliza el mismo personal e instalaciones para luego operar a los receptores, un ciclo k requiere entre 3k y 6k médicos, alrededor de 4k enfermeras y casi 2k salas de operaciones. Debido a tales limitaciones de recursos, es probable que el próximo mercado nacional de intercambio de riñones solo permita ciclos de longitud 2 y 3. Otra motivación para ciclos cortos es que si el ciclo falla en intercambiarse, menos agentes se ven afectados. Por ejemplo, las pruebas de último minuto en un intercambio de riñones a menudo revelan nuevas incompatibilidades que no fueron detectadas en las pruebas iniciales (en base a las cuales se construyó el grafo de compatibilidad). Más generalmente, un agente puede abandonar un ciclo si sus preferencias han cambiado, o simplemente no cumple con sus obligaciones (como enviar un libro a otro agente en el ciclo) debido a olvidos. En la Sección 3, demostramos que (la versión de decisión del) problema de despeje es NP-completo para L ≥ 3. Una posible estrategia sería buscar un buen heurístico o algoritmo de aproximación. Sin embargo, por dos razones, buscamos un algoritmo exacto basado en un programa lineal entero (PLE), que resolvemos utilizando una búsqueda especializada en árboles. • Primero, cualquier pérdida de optimalidad podría llevar a muertes de pacientes innecesarias. • Segundo, una característica atractiva de utilizar una formulación de PLE es que permite modelar fácilmente una serie de variaciones en el objetivo y agregar restricciones adicionales al problema. Por ejemplo, si se cree que los ciclos de 3 elementos tienen más probabilidades de fallar que los ciclos de 2 elementos, entonces simplemente se les puede asignar un peso que sea apropiadamente menor que 3/2 del peso de un ciclo de 2 elementos. O, si por diversas razones (por ejemplo, éticas) se requiere un intercambio de cardinalidad máxima, al menos se puede encontrar en una segunda pasada la solución (de entre todas las soluciones de cardinalidad máxima) que tenga el menor número de 3-ciclos. Otras variaciones que se pueden resolver incluyen encontrar diversas formas de colecciones de ciclos tolerantes a fallos (no disjuntas) en caso de que ciertos pares que se creían compatibles resulten ser incompatibles después de todo. En este documento, presentamos el primer algoritmo capaz de liquidar estos mercados a nivel nacional. Las codificaciones de ILP directas son demasiado grandes para siquiera construirse en el hardware actual, sin mencionar resolverlas. La clave entonces es la formulación incremental del problema. Adaptamos dos paradigmas para la tarea: generación de restricciones y generación de columnas. Para cada uno, desarrollamos una serie de técnicas (principalmente específicas del problema) que mejoran drásticamente tanto el tiempo de ejecución como el uso de memoria. 1.1 Trabajos Previos Varios artículos recientes han utilizado simulaciones y algoritmos de compensación de mercado para explorar el impacto de un intercambio nacional de riñones [13, 20, 6, 14, 15, 17]. Por ejemplo, utilizando el algoritmo de coincidencia máxima de Edmonds [4], [20] se muestra que un mercado nacional de intercambio por pares (utilizando solo ciclos de longitud 2) resultaría en más trasplantes, tiempos de espera reducidos y ahorros de $750 millones en costos de atención médica durante 5 años. Esos resultados son conservadores de dos maneras. En primer lugar, el mercado simulado contenía solo 4,000 pacientes iniciales, con 250 pacientes añadidos cada 3 meses. Se nos ha informado que el mercado podría ser casi el doble de este tamaño. En segundo lugar, los intercambios se restringieron a ciclos de longitud 2 (porque eso es todo lo que se puede modelar como coincidencia máxima y resolver utilizando el algoritmo de Edmonds). Permitir ciclos de longitud 3 conlleva a ganancias adicionales significativas. Esto se ha demostrado en mercados de intercambio de riñones con 100 pacientes utilizando CPLEX para resolver una codificación de programa entero del problema de compensación [15]. En este documento, presentamos un algoritmo alternativo para este programa entero que puede despejar mercados con más de 10,000 pacientes (y el mismo número de donantes dispuestos). Permitir ciclos de longitud mayor a 3 a menudo no conduce a ninguna mejora en el tamaño del intercambio [15]. (Además, en un modelo teórico simplificado, cualquier intercambio de riñón se puede convertir en uno con ciclos de longitud de a lo sumo 4 [15].) Si bien esto no se aplica a intercambios de trueque generales, ni siquiera a todos los mercados de intercambio de riñones, en la Sección 5.2.3 hacemos uso de la observación de que los ciclos cortos son suficientes para aumentar drásticamente la velocidad de nuestro algoritmo. A un nivel alto, el problema de compensación para intercambios de trueque es similar al problema de compensación (también conocido como problema de determinación de ganadores) en subastas combinatorias. En ambos contextos, la idea es recopilar toda la información pertinente sobre los agentes en un punto central de compensación y ejecutar un algoritmo centralizado de compensación para determinar la asignación. Ambos problemas son NP-duros. Ambos se resuelven mejor utilizando técnicas de búsqueda en árboles. Desde 1999, se ha realizado un trabajo significativo en informática y investigación de operaciones sobre algoritmos de búsqueda de árboles óptimos más rápidos para despejar subastas combinatorias. (Para una revisión reciente, consulte [18].) Sin embargo, el problema de compensación del intercambio de riñones (con un límite de 3 o más en el tamaño del ciclo) es diferente del problema de compensación de la subasta combinatoria de formas significativas. La diferencia más importante es que las formulaciones naturales del problema de subasta combinatoria tienden a ajustarse fácilmente en la memoria, por lo que el tiempo es el cuello de botella en la práctica. Por el contrario, las formulaciones naturales del problema de intercambio de riñones (con L = 3) ocupan al menos espacio cúbico en el número de pacientes para incluso modelar, y por lo tanto la memoria se convierte en un cuello de botella mucho antes que el tiempo al utilizar la búsqueda de árbol estándar, como branch-and-cut en CPLEX, para abordar el problema. (En una computadora de 1GB y un generador de instancias estándar realista, discutido más adelante, CPLEX 10.010 se queda sin memoria en cinco de las diez instancias de 900 pacientes y en las diez de las diez instancias de 1,000 pacientes que generamos). Por lo tanto, los enfoques que se han desarrollado para subastas combinatorias no pueden manejar el problema del intercambio de riñones. 1.2 Esquema del documento El resto del documento está organizado de la siguiente manera. La sección 2 discute el proceso mediante el cual generamos datos realistas del mercado de intercambio de riñones, con el fin de comparar los algoritmos de compensación. La sección 3 contiene una demostración de que el problema de decisión de compensación del mercado es NP-completo. Las secciones 4 y 5 contienen cada una una formulación ILP del problema de compensación. También detallamos en esas secciones nuestras técnicas utilizadas para resolver esos programas en instancias grandes. La sección 6 presenta experimentos sobre las diversas técnicas. La sección 7 discute la implementación reciente de nuestro algoritmo. Finalmente, presentamos nuestras conclusiones en la Sección 8 y sugerimos direcciones para investigaciones futuras. CARACTERÍSTICAS DEL MERCADO Y GENERADOR DE INSTANCIAS Probamos los algoritmos en mercados simulados de intercambio de riñones, los cuales son generados por un proceso descrito en Saidman et al. [17]. Este proceso se basa en los extensos datos a nivel nacional mantenidos por la Red Unida para el Comparto de Órganos (UNOS), por lo que genera una distribución realista de instancias. Varios artículos han utilizado variaciones de este proceso para demostrar la efectividad de un intercambio nacional de riñones (extrapolando de pequeñas instancias o restringiendo la compensación a ciclos de 2) [6, 20, 14, 13, 15, 17]. En resumen, el proceso implica generar pacientes con un tipo de sangre, sexo y probabilidad de ser incompatible en el tipo de tejido con un donante elegido al azar. Estas probabilidades se basan en datos reales de la población del mundo real. A cada paciente se le asigna un posible donante con un tipo de sangre aleatorio y una relación con el paciente. Si el paciente y el posible donante son incompatibles, ambos son ingresados en el mercado. La información del tipo de sangre y del tipo de tejido se utiliza luego para decidir qué pacientes y donantes son compatibles. Una complicación, manejada por el generador, es que si la paciente es mujer y ha tenido un hijo con su potencial donante, entonces la probabilidad de que los dos sean incompatibles aumenta. (Esto se debe a que la madre desarrolla anticuerpos contra su pareja durante el embarazo). Finalmente, aunque nuestros algoritmos pueden manejar funciones de peso más generales, los pacientes tienen una utilidad de 1 para donantes compatibles, ya que su probabilidad de supervivencia no se ve afectada por la elección del donante [3]. Esto significa que el intercambio de peso máximo tiene la máxima cardinalidad. La Tabla 1 proporciona límites inferiores y superiores sobre el tamaño de un intercambio de máxima cardinalidad en el mercado de intercambio de riñones. Los límites inferiores se encontraron al despejar el mercado solo con ciclos de longitud 2, mientras que los límites superiores no tenían restricción en la longitud del ciclo. Para cada tamaño de mercado, los límites fueron calculados sobre 10 mercados generados aleatoriamente. Ten en cuenta que puede haber una gran cantidad de variabilidad en los mercados: en un mercado de 5000 pacientes, menos de 1000 pacientes estaban en el intercambio de cardinalidad máxima. Tamaño máximo de intercambio Longitud-2 ciclos solamente Ciclos arbitrarios Pacientes Media Máximo Media Máximo 100 4.00e+1 4.60e+1 5.30e+1 6.10e+1 500 2.58e+2 2.80e+2 2.79e+2 2.97e+2 1000 5.35e+2 6.22e+2 5.61e+2 6.30e+2 2000 1.05e+3 1.13e+3 1.09e+3 1.16e+3 3000 1.63e+3 1.70e+3 1.68e+3 1.73e+3 4000 2.15e+3 2.22e+3 2.20e+3 2.27e+3 5000 2.53e+3 2.87e+3 2.59e+3 2.92e+3 6000 3.26e+3 3.32e+3 3.35e+3 3.39e+3 7000 3.80e+3 3.86e+3 3.89e+3 3.97e+3 8000 4.35e+3 4.45e+3 4.46e+3 4.55e+3 9000 4.90e+3 4.96e+3 5.01e+3 5.07e+3 10000 5.47e+3 5.61e+3 5.59e+3 5.73e+3 Tabla 1: Límites superiores e inferiores en el tamaño del intercambio. La Tabla 2 proporciona características adicionales del mercado de intercambio de riñones. Ten en cuenta que un mercado con 5000 pacientes puede tener más de 450 millones de ciclos de longitud 2 y 3. Longitud de los bordes 2 y 3 ciclos Pacientes Media Máx. Media Máx. 100 2.38e+3 2.79e+3 2.76e+3 5.90e+3 500 6.19e+4 6.68e+4 3.96e+5 5.27e+5 1000 2.44e+5 2.68e+5 3.31e+6 4.57e+6 2000 9.60e+5 1.02e+6 2.50e+7 3.26e+7 3000 2.19e+6 2.28e+6 8.70e+7 9.64e+7 4000 3.86e+6 3.97e+6 1.94e+8 2.14e+8 5000 5.67e+6 6.33e+6 3.60e+8 4.59e+8 6000 8.80e+6 8.95e+6 7000 1.19e+7 1.21e+7 8000 1.56e+7 1.59e+7 9000 1.98e+7 2.02e+7 10000 2.44e+7 2.51e+7 Tabla 2: Características del mercado. 297 COMPLEJIDAD DEL PROBLEMA En esta sección, demostramos que (la versión de decisión del) problema de compensación de mercado con ciclos cortos es NP-completo. Teorema 1. Dado un grafo G = (V, E) y un entero L ≥ 3, el problema de decidir si G admite una cubierta de ciclos perfecta que contenga ciclos de longitud como máximo L es NP-completo. Prueba. Es claro que este problema está en NP. Para la NP-dificultad, reducimos desde 3D-Matching, que es el problema de, dado conjuntos disjuntos X, Y y Z de tamaño q, y un conjunto de triples T ⊆ X × Y × Z, decidir si existe un subconjunto disjunto M de T con tamaño q. Una idea directa es construir un grafo tripartito con conjuntos de vértices X ∪ Y ∪ Z y aristas dirigidas (xa, yb), (yb, zc) y (zc, xa) para cada triple ti = {xa, yb, zc} ∈ T. Sin embargo, no es demasiado difícil ver que esta codificación falla porque una cobertura de ciclo perfecta puede incluir un ciclo sin un triple correspondiente. En cambio, utilizamos la siguiente reducción. Dado una instancia de 3D-Matching, construye un vértice para cada elemento en X, Y y Z. Para cada tripleta, ti = {xa, yb, zc}, construya el dispositivo en la Figura 2, que es similar a uno en Garey y Johnson [5, pp 68-69]. Ten en cuenta que los dispositivos se intersecan solo en los vértices de X ∪ Y ∪ Z. Es claro que esta construcción puede realizarse en tiempo polinómico. 1 ... 2 3 y_b ... 2 3 z_c y_b^i z_c^i L−1 L−1 L−1 x_a^i x_a ... 2 31 1 Figura 2: Dispositivo de NP-completitud para la tripleta ti y la longitud máxima del ciclo L. Sea M un emparejamiento 3D perfecto. Mostraremos que la construcción admite una cobertura perfecta de ciclos mediante ciclos cortos. Si ti = {xa, yb, zc} ∈ M, añade desde el gadget de ti los tres ciclos de longitud L que contienen a xa, yb y zc respectivamente. También añade el ciclo ª xi a, yi b, zi c «. De lo contrario, si ti ∉ M, añade los tres ciclos de longitud L que contienen xi a, yi b y zi c respectivamente. Es claro que todos los vértices están cubiertos, ya que M particiona X × Y × Z. Por el contrario, supongamos que tenemos una cobertura perfecta mediante ciclos cortos. Ten en cuenta que la construcción solo tiene ciclos cortos de longitudes 3 y L, y ningún ciclo corto involucra vértices distintos de dos gadgets diferentes. Es fácil ver entonces que en una cubierta perfecta, cada gadget ti contribuye ciclos de acuerdo a los casos anteriores: ti ∈ M, o ti /∈ M. Por lo tanto, existe un Emparejamiento 3D perfecto en la instancia original. 4. ENFOQUES DE SOLUCIÓN BASADOS EN UNA FORMULACIÓN DE ARISTAS En esta sección, consideramos una formulación del problema de compensación como un ILP con una variable para cada arista. Esta codificación se basa en el siguiente algoritmo clásico para resolver el problema de la cubierta de ciclos dirigidos sin restricciones de longitud de ciclo. Dado un mercado G = (V, E), construya un grafo bipartito con un vértice para cada agente y un vértice para cada artículo. Agregar un borde ev con peso 0 entre cada agente v y su propio artículo. En este punto, la codificación es una coincidencia perfecta. Ahora, para cada arista e = (vi, vj) en el mercado original, añade una arista e con peso we entre el agente vi y el artículo de vj. Los emparejamientos perfectos en esta codificación corresponden exactamente con las cubiertas de ciclos, ya que cada vez que se toma un artículo de un agente, debe recibir el artículo de otro agente. Se deduce que el problema de despeje sin restricciones puede resolverse en tiempo polinómico encontrando un emparejamiento perfecto de peso máximo. La Figura 3 contiene la representación en forma de grafo bipartito del mercado de ejemplo de la Figura 1. Las aristas de peso 0 están codificadas con líneas discontinuas, mientras que las aristas de mercado están en negrita. Elementos Agentes v1 v2 v3 v4 v5 e1 e3 e8 e2 v1 v2 v3 v4 v5 e7e6 e5 e4 Figura 3: Codificación de emparejamiento perfecto del mercado en la Figura 1. Alternativamente, podemos resolver el problema codificándolo como un ILP con una variable para cada arista en el grafo de mercado original G. Este ILP, que se muestra a continuación, tiene la ventaja de que puede ser extendido de manera natural para tratar con restricciones de longitud de ciclo. Por lo tanto, para el resto de esta sección, este será el enfoque que seguiremos. Se busca un max e∈E tal que para todo vi ∈ V, se cumplan las restricciones de conservación eout=(vi,vj ) eout − ein=(vj ,vi) ein = 0 y la restricción de capacidad eout=(vi,vj ) eout ≤ 1. Si se permite que los ciclos tengan una longitud de como máximo L, es fácil ver que solo necesitamos hacer los siguientes cambios en el ILP. Para cada camino de longitud L (a lo largo del documento, no incluimos ciclos en la definición de camino) p = ep1, ep2, ..., epL, agregar una restricción ep1 + ep2 + ... + epL ≤ L − 1, que excluye al camino p de cualquier solución factible. Desafortunadamente, en un mercado con solo 1000 pacientes, el número de caminos de longitud 3 supera los 400 millones, por lo que ni siquiera podemos construir este ILP sin quedarnos sin memoria. Por lo tanto, utilizamos una búsqueda en árbol con un enfoque de formulación incremental. Específicamente, utilizamos CPLEX, aunque añadimos restricciones como planos de corte durante el proceso de búsqueda en el árbol. Comenzamos con solo un pequeño subconjunto de las restricciones en el ILP. Dado que este ILP es pequeño, CPLEX puede resolver su relajación LP. Luego verificamos si alguna de las restricciones faltantes es violada por la solución fraccional. Si es así, generamos un conjunto de estas restricciones, las añadimos al ILP y repetimos. Incluso una vez que se satisfacen todas las restricciones, puede que no haya una solución entera que coincida con el límite superior fraccional, y aunque la hubiera, el solucionador de PL podría no encontrarla. En estos casos, CPLEX ramifica en una variable (utilizamos la estrategia de ramificación predeterminada de CPLEX) y genera un nuevo nodo de búsqueda correspondiente a cada uno de los hijos. En cada nodo del árbol de búsqueda que se visita, se repite este proceso de resolver el LP y agregar restricciones. Claramente, este enfoque produce una solución óptima una vez que la búsqueda en el árbol finaliza. Todavía necesitamos explicar los detalles del generador de restricciones (es decir, seleccionar qué restricciones comenzar) y la generación de restricciones (es decir, seleccionar qué restricciones violadas incluir). Describimos brevemente estos en las dos subsecciones siguientes, respectivamente. 4.1 Sembrador de Restricciones El principal sembrador de restricciones que desarrollamos prohíbe cualquier camino de longitud L − 1 que no tenga un borde cerrando el ciclo desde su inicio hasta su final. Si bien es costoso computacionalmente encontrar estas restricciones, su adición enfoca la búsqueda lejos de los caminos que no pueden estar en la solución final. También intentamos sembrar el LP con una colección aleatoria de restricciones del ILP. 4.2 Generación de Restricciones Experimentamos con varios generadores de restricciones. En cada caso, dada una solución fraccional, construimos el subgrafo de aristas con valor positivo. Este gráfico es mucho más pequeño que el gráfico original, por lo que podemos realizar los cálculos siguientes de manera eficiente. En nuestro primer generador de restricciones, simplemente buscamos caminos de longitud L con una suma de valores mayor que L − 1. Para cualquier camino de este tipo, restringimos su suma para que sea como máximo L − 1. Ten en cuenta que si hay un ciclo c con longitud |c| > L, podría contener hasta |c| caminos que violan. En nuestro segundo generador de restricciones, solo agregamos una restricción para tales ciclos: la suma de aristas en el ciclo puede ser a lo sumo |c|(L − 1)/L. Este generador hizo que el algoritmo fuera más lento, por lo que optamos por ir en la dirección opuesta en el desarrollo de nuestro generador final. Agrega una restricción por cada camino p que viola, y además, agrega una restricción para cada camino con los mismos vértices interiores (sin contar los extremos) que p. Esto mejoró la velocidad general. 4.3 Rendimiento experimental Resultó que incluso con estas mejoras, el enfoque de formulación de aristas no puede despejar un intercambio de riñón con 100 vértices en el tiempo en que la formulación de ciclos (descrita más adelante en la Sección 5) puede despejar uno con 10,000 vértices. En otras palabras, los enfoques basados en generación de columnas resultaron ser drásticamente mejores que los enfoques basados en generación de restricciones. Por lo tanto, en el resto del documento nos enfocaremos en la formulación del ciclo y en los enfoques basados en la generación de columnas. 5. Enfoques de solución basados en una formulación cíclica. En esta sección, consideramos una formulación del problema de compensación como un ILP con una variable para cada ciclo. Esta codificación se basa en el siguiente algoritmo clásico para resolver el problema de la cubierta de ciclos dirigidos cuando los ciclos tienen longitud 2. Dado un mercado G = (V, E), construya un nuevo grafo en V con un peso wc en cada arista de ciclo c de longitud 2. Es fácil ver que los emparejamientos en este nuevo grafo corresponden a coberturas de ciclos por ciclos de longitud 2 en el grafo original del mercado. Por lo tanto, el problema de equilibrio de mercado con L = 2 se puede resolver en tiempo polinómico encontrando un emparejamiento de peso máximo. Figura 4: Codificación del emparejamiento de peso máximo del mercado en la Figura 1. Podemos generalizar este codificado para L arbitrario. Sea C(L) el conjunto de todos los ciclos de G con longitud a lo sumo L. Entonces el siguiente ILP encuentra la cobertura de ciclos de máximo peso por ciclos de C(L): max c∈C(L) wcc sujeto a c:vi∈c c ≤ 1 ∀vi ∈ V con c ∈ {0, 1} ∀c ∈ C(L) 5.1 Formulación de Arista vs Ciclo En esta sección, consideramos los méritos de la formulación de arista y la formulación de ciclo. La formulación del problema del borde se puede resolver en tiempo polinómico cuando no hay restricciones en el tamaño del ciclo. La formulación del ciclo se puede resolver en tiempo polinómico cuando el tamaño del ciclo es a lo sumo 2. Ahora consideramos el caso de ciclos cortos de longitud como máximo L, donde L ≥ 3. Nuestros algoritmos de búsqueda de árboles utilizan la relajación LP de estas formulaciones para proporcionar cotas superiores de la solución óptima. Estos límites ayudan a podar subárboles y guiar la búsqueda de las formas habituales. Teorema 2. La relajación LP de la formulación del ciclo domina débilmente la relajación LP de la formulación del borde. Prueba. Considera una solución óptima para la relajación LP de la formulación del ciclo. Mostramos cómo construir una solución equivalente en la formulación de bordes. Para cada arista en el grafo, establezca su valor como la suma de los valores de todos los ciclos de los cuales es miembro. También, define el valor de un vértice de la misma manera. Debido a las restricciones del ciclo, las restricciones de conservación y capacidad de la codificación de los bordes se cumplen claramente. Queda por demostrar que ninguna de las restricciones de ruta se viola. Sea p cualquier camino de longitud L en el grafo. Dado que p tiene L−1 vértices interiores (sin contar los extremos), la suma de estos vértices interiores es como máximo L−1. Ahora, para cualquier ciclo c de longitud como máximo L, el número de aristas que tiene en p, que denotamos como ec(p), es como máximo el número de vértices interiores que tiene en p, que denotamos como vc(p). Por lo tanto, È e∈p e = È c∈C(L) c∗ec(p) ≤ È c∈C(L) c∗vc(p) = È v∈p v = L−1. 299 La afirmación contraria de este teorema no es verdadera. Considera un grafo que es simplemente un ciclo con n aristas. Claramente, la relajación LP de la formulación del ciclo tiene un valor óptimo de 0, ya que no hay ciclos de tamaño menor o igual a L. Sin embargo, la formulación de aristas tiene una solución de tamaño n/2, con cada arista teniendo un valor de 1/2. Por lo tanto, la formulación del ciclo es más ajustada que la formulación del borde. Además, para un grafo con m aristas, la formulación de aristas requiere O(m3) restricciones, mientras que la formulación de ciclos solo requiere O(m2). 5.2 Generación de columnas para la tabla de PL. La Tabla 2 muestra cómo el número de ciclos de longitud a lo sumo 3 crece con el tamaño del mercado. Con una variable por ciclo en la formulación del ciclo, CPLEX ni siquiera puede liquidar mercados con 1,000 pacientes sin quedarse sin memoria (ver Figura 6). Para abordar este problema, utilizamos un enfoque de formulación incremental. El primer paso en la búsqueda de árbol guiada por LP es resolver la relajación LP. Dado que la formulación del ciclo no cabe en la memoria, esta etapa de LP fallaría inmediatamente sin un enfoque de formulación incremental. Sin embargo, motivados por la observación de que una solución de intercambio puede incluir solo una pequeña fracción de los ciclos, exploramos el enfoque de utilizar la generación de columnas (es decir, ciclos). La idea de la generación de columnas es comenzar con un LP restringido que contenga solo un pequeño número de columnas (variables, es decir, ciclos), y luego agregar columnas repetidamente hasta que una solución óptima para este LP parcialmente formulado sea una solución óptima para el LP original (también conocido como maestro). Explicamos esto más a fondo mediante un ejemplo. Considera el mercado en la Figura 1 con L = 2. La Figura 5 muestra el LP maestro correspondiente, P, y su dual, D. El primal P maximiza 2c1 + 2c2 + 2c3 sujeto a c1 ≤ 1 (v1), c1 + c2 ≤ 1 (v2), c2 + c3 ≤ 1 (v3), c3 ≤ 1 (v4) con c1, c2, c3 ≥ 0. El dual D minimiza v1 + v2 + v3 + v4 sujeto a v1 + v2 ≥ 2 (c1), v2 + v3 ≥ 2 (c2), v3 + v4 ≥ 2 (c3) con v1, v2, v3, v4 ≥ 0. Figura 5: Formulación del ciclo. Sea P la restricción de P que contiene solo las columnas c1 y c3. Sea D el dual de P, es decir, D es simplemente D sin la restricción c2. Dado que P y D son pequeños, podemos resolverlos para obtener OPT(P) = OPT(D) = 4, con cOPT(P) = c1 = c3 = 1 y vOPT(D) = v1 = v2 = v3 = v4 = 1. Si cOP T (P ) debe ser una solución factible de P, resulta (afortunadamente) que vOP T (D ) es factible para D, de modo que OPT(D ) ≥ OPT(D). Podemos verificar esto comprobando que vOP T (D) cumple con las restricciones de D que aún no están en Di, es decir, la restricción c2. Se deduce que OPT(P) = OPT(D) ≥ OPT(D) = OPT(P), por lo que vOPT(P) es demostrablemente una solución óptima para P, a pesar de que P contiene solo un subconjunto estricto de las columnas de P. Por supuesto, puede resultar (desafortunadamente) que vOPT(D) no sea factible para D. Esto puede ocurrir como se muestra arriba si vOPT(D) = v1 = 2, v2 = 0, v3 = 0, v4 = 2. Aunque todavía podemos ver que OPT(D) = OPT(D), en general no podemos demostrarlo porque D y P son demasiado grandes para resolver. En cambio, dado que se viola la restricción c2, agregamos la columna c2 a P, actualizamos D y repetimos. El problema de encontrar una restricción violada se llama problema de fijación de precios. Aquí, el precio de una columna (ciclo en nuestra configuración) es la diferencia entre su peso y la suma de los valores duales de los vértices del ciclo. Si alguna columna de P tiene un precio positivo, su restricción correspondiente está violada y aún no hemos demostrado la optimalidad. En este caso, debemos seguir generando columnas para agregar a P. Problema de fijación de precios 5.2.1 Para instancias más pequeñas, podemos mantener una colección explícita de todos los ciclos factibles. Esto hace que el problema de fijación de precios sea fácil y eficiente de resolver: simplemente recorremos la colección de ciclos y buscamos ciclos con precio positivo. Incluso podemos encontrar ciclos con el precio más positivo, que son los más propensos a mejorar el valor objetivo de LP restringido [1]. Sin embargo, este enfoque no es escalable. Un mercado con 5000 pacientes puede tener hasta 400 millones de ciclos de longitud de máximo 3 (ver Tabla 2). Esto es demasiados ciclos para mantener en la memoria. Por lo tanto, para instancias más grandes, debemos generar ciclos factibles mientras buscamos uno con un precio positivo. Realizamos esto utilizando un algoritmo de búsqueda en profundidad en el grafo del mercado (ver Figura 1). Para hacer esta búsqueda más rápida, exploramos los vértices en orden de valores no decrecientes, ya que es más probable que estos vértices pertenezcan a ciclos con peso positivo. También utilizamos varias reglas de poda para determinar si la ruta de búsqueda actual puede llevar a un ciclo de peso positivo. Por ejemplo, en un vértice dado en la búsqueda, podemos podar basándonos en el hecho de que cada vértice que visitemos a partir de este punto tendrá un valor al menos tan grande como el vértice actual. Incluso con estas reglas de poda, la generación de columnas es un cuello de botella. Por lo tanto, también implementamos las siguientes optimizaciones. Cuando la búsqueda exhaustiva demuestra que un vértice no pertenece a ningún ciclo de precios positivos, marcamos el vértice y no lo utilizamos como raíz de una búsqueda en profundidad hasta que su valor dual disminuya. De esta manera, evitamos repetir innecesariamente nuestros esfuerzos computacionales de una iteración previa de generación de columnas. Finalmente, a veces puede ser beneficioso para la generación de columnas incluir varias columnas de precio positivo en una iteración, ya que puede ser más rápido generar una segunda columna una vez que se encuentra la primera. Sin embargo, evitamos esto por la siguiente razón. Si intentamos encontrar más columnas de precio positivo de las que se pueden encontrar, o si las columnas están muy separadas en el espacio de búsqueda, terminamos teniendo que generar y verificar una gran parte de la colección de ciclos factibles. En nuestros experimentos, hemos observado que esto ocurre en mercados con cientos de millones de ciclos, lo que resulta en costos de computación prohibitivamente caros. 5.2.2 Sembrado de Columnas Incluso si hay solo una pequeña brecha con la relajación principal del LP, la generación de columnas requiere muchas iteraciones para mejorar el valor objetivo del LP restringido. Cada una de estas 300 iteraciones es costosa, ya que debemos resolver el problema de fijación de precios y volver a resolver el LP restringido. Por lo tanto, aunque podríamos empezar sin columnas en el LP restringido, es mucho más rápido sembrar el LP con suficientes columnas para que el valor objetivo óptimo no esté muy lejos del LP principal. Por supuesto, no podemos incluir tantas columnas que nos quedemos sin memoria. Experimentamos con varios sembradores de columnas. En una clase de sembrador, utilizamos una heurística para encontrar un intercambio, y luego agregamos los ciclos de ese intercambio al LP restringido inicial. Implementamos dos heurísticas. El primero es un algoritmo voraz: para cada vértice en un orden aleatorio, si está sin cubrir, intentamos incluir un ciclo que lo contenga a él y a otros vértices sin cubrir. El otro heurístico utiliza un código especializado de emparejamiento de peso máximo [16] para encontrar una cobertura óptima mediante ciclos de longitud 2. Estas heurísticas funcionan extremadamente bien, especialmente teniendo en cuenta el hecho de que solo agregan un pequeño número de columnas. Por ejemplo, la Tabla 1 muestra que una cobertura óptima por ciclos de longitud 2 tiene casi el mismo peso que el intercambio con tamaño de ciclo no restringido. Sin embargo, tenemos suficiente memoria para incluir cientos de miles de columnas adicionales y así acercarnos aún más al límite superior. Nuestro mejor sembrador de columnas construye una colección aleatoria de ciclos factibles. Dado que un mercado con 5000 pacientes puede tener hasta 400 millones de ciclos factibles, lleva demasiado tiempo generar y recorrer todos los ciclos factibles, por lo que no incluimos una colección aleatoria uniforme. En cambio, realizamos un recorrido aleatorio en el grafo del mercado (ver, por ejemplo, Figura 1), en el cual, después de cada paso del recorrido, probamos si hay un borde de regreso a nuestro camino que forme un ciclo factible. Si encontramos un ciclo, este se incluye en el LP restringido y comenzamos una nueva caminata desde un vértice aleatorio. En nuestros experimentos (ver Sección 6), utilizamos este algoritmo para sembrar el LP con 400,000 ciclos. Este último enfoque supera a los sembradores heurísticos descritos anteriormente. Sin embargo, en nuestro algoritmo, utilizamos una combinación que toma la unión de todas las columnas de los tres sembradores. En la Figura 6, comparamos el rendimiento del sembrador combinado con el sembrador combinado sin el sembrador de recolección aleatoria. No trazamos el rendimiento del algoritmo sin ningún sembrador en absoluto, porque puede llevar horas despejar mercados que de otra manera podríamos despejar en unos pocos minutos. 5.2.3 Demostrando la optimalidad. Recordemos que nuestro objetivo es encontrar una solución óptima para la relajación principal del LP. Usando la generación de columnas, podemos demostrar que una solución primal restringida es óptima una vez que todas las columnas tienen precios no positivos. Desafortunadamente, nuestro problema de compensación tiene el llamado efecto de disminución gradual [1, Sección 6.3], en el cual, aunque el primal restringido es óptimo a posteriori, se requiere un gran número de iteraciones adicionales para demostrar la optimalidad (es decir, eliminar todas las columnas de precio positivo). No hay una buena solución general para el efecto de disminución. Sin embargo, para mitigar este efecto, aprovechamos la siguiente observación específica del problema. Recuerde de la Sección 1.1 que, casi siempre, un intercambio de peso máximo con ciclos de longitud a lo sumo 3 tiene el mismo peso que un intercambio de peso máximo sin restricciones. (Sin embargo, esto no significa que el solucionador para el caso sin restricciones encontrará una solución con ciclos cortos). Además, el problema de despeje no restringido se puede resolver en tiempo polinómico (ver Sección 4). Por lo tanto, podemos calcular eficientemente un límite superior en la relajación principal del LP, y, cada vez que el primal restringido alcanza este límite superior, ¡hemos demostrado la optimalidad sin necesidad de eliminar todas las columnas de precio positivo! Para que esto mejore el tiempo de ejecución del algoritmo en general, necesitamos poder despejar el mercado sin restricciones en menos tiempo del que le lleva a la generación de columnas eliminar todos los ciclos de precios positivos. Aunque el primer problema es soluble en tiempo polinómico, esto no es trivial para instancias grandes. Por ejemplo, para un mercado con 10,000 pacientes y 25 millones de conexiones, el código especializado de emparejamiento de peso máximo [16] era demasiado lento, y CPLEX se quedó sin memoria en la codificación de formulación de bordes de la Sección 4. Para hacer funcionar esta idea, utilizamos generación de columnas para resolver la formulación de bordes. Esto implica comenzar con un pequeño subconjunto aleatorio de los bordes, y luego agregar bordes con precio positivo uno por uno hasta que no quede ninguno. Realizamos esta generación de columnas secundarias no en el grafo de mercado original G, sino en el grafo bipartito de emparejamiento perfecto de la Figura 3. Hacemos esto para que solo necesitemos resolver el LP, no el ILP, ya que la brecha de integralidad en el grafo bipartito de emparejamiento perfecto es 1, es decir, siempre existe una solución integral que alcanza el límite superior fraccional. El aumento de velocidad resultante en el algoritmo general es dramático, como se puede ver en la Figura 6. 5.2.4 Gestión de Columnas Si el valor óptimo del LP restringido inicial P está lejos del LP maestro P, entonces se generan un gran número de columnas antes de que se cierre la brecha. Esto conduce a problemas de memoria en mercados con tan solo 4,000 pacientes. Además, incluso antes de que la memoria se convierta en un problema, las iteraciones de generación de columnas se vuelven lentas debido a la sobrecarga adicional de resolver un LP más grande. Para abordar estos problemas, implementamos un esquema de gestión de columnas para limitar el tamaño del LP restringido. Siempre que agregamos columnas al LP, verificamos si contiene más de un número umbral de columnas. Si este es el caso, eliminamos selectivamente columnas hasta que esté nuevamente por debajo del umbral2. Como discutimos anteriormente, solo una pequeña fracción de todos los ciclos terminará en la solución final. Es poco probable que eliminemos dicho ciclo, y aun si lo hacemos, siempre se puede generar de nuevo. Por supuesto, no debemos ser demasiado agresivos con el umbral, ya que hacerlo podría contrarrestar las ganancias de rendimiento por iteración al aumentar significativamente el número de iteraciones necesarias para obtener un conjunto de columnas adecuado en el LP al mismo tiempo. Hay algunas columnas que nunca eliminamos, por ejemplo aquellas en las que hemos realizado ramificaciones (ver Sección 5.3.2), o aquellas con un valor de LP distinto de cero. Entre el resto, eliminamos aquellos con el precio más bajo, ya que corresponden a las restricciones duales que están más satisfechas. Este esquema de gestión de columnas funciona bien y nos ha permitido despejar mercados con 10,000 pacientes, como se ve en la Figura 6. 5.3 Búsqueda de Ramificación y Precio para el ILP Dado un problema grande de despeje de mercado, podemos resolver con éxito su relajación LP hasta la optimalidad utilizando las mejoras de generación de columnas descritas anteriormente. Sin embargo, las soluciones que encontramos suelen ser fraccionarias. Por lo tanto, en el paso 2 siguiente, basándonos en el tamaño de la memoria, establecemos el umbral en 400,000. El paso 301 implica realizar una búsqueda de árbol de ramificación y precio [1] para encontrar una solución integral óptima. Breve, esta es la idea de ramificar y fijar precios. Siempre que establecemos una variable fraccional en 0 o 1 (rama), tanto el LP maestro como la restricción con la que estamos trabajando se modifican (se restringen). Por defecto, entonces, necesitamos realizar la generación de columnas (es decir, el esfuerzo de fijar precios) en cada nodo del árbol de búsqueda para demostrar que la restricción restringida es óptima para el LP maestro restringido. (Sin embargo, como se discute en la Sección 5.2.3, calculamos el límite superior integral para el nodo raíz basado en relajar completamente la restricción de longitud del ciclo, y cada vez que algún LP de los nodos en el árbol alcance ese valor, no necesitamos seguir fijando precios de columnas en ese nodo). Para el problema de despeje con ciclos de longitud a lo sumo 3, hemos encontrado que rara vez hay una brecha entre las soluciones integrales y fraccionarias óptimas. Esto significa que podemos evitar en gran medida el costoso paso de fijar precios por nodo: cuando el LP restringido restringido tiene el mismo valor óptimo que su padre en la búsqueda del árbol, podemos demostrar la optimalidad del LP, como se muestra en la Sección 5.2.3, sin tener que incluir columnas adicionales en el LP restringido. Aunque CPLEX puede resolver ILPs, no admite la técnica de branch-and-price (por ejemplo, debido a posibles complicaciones específicas del problema que involucran la interacción entre la regla de ramificación y el problema de fijación de precios). Por lo tanto, implementamos nuestro propio algoritmo de ramificación y precio, el cual explora el árbol de búsqueda en orden de profundidad primero. También experimentamos con el orden de selección de nodos A* [7, 2]. Sin embargo, esta estrategia de búsqueda requiere significativamente más memoria, la cual encontramos que se empleaba mejor para acelerar la fase de generación de columnas (ver Sección 5.2.2). Los componentes principales restantes del algoritmo se describen en las dos siguientes subsecciones. 5.3.1 Heurísticas Primal Antes de ramificar en una variable fraccional, utilizamos heurísticas primales para construir una solución integral factible. Estas soluciones son límites inferiores de las soluciones integrales óptimas finales. Por lo tanto, cuando una solución fraccional restringida no es mejor que la mejor solución integral encontrada hasta el momento, podamos el subárbol actual. Una heurística primal es efectiva si es eficiente y construye límites inferiores ajustados. Experimentamos con dos heurísticas primarias. El primero es un algoritmo de redondeo simple [8]: incluir todos los ciclos con un valor fraccional de al menos 0.5, y luego, asegurando la viabilidad, agregar de forma codiciosa los ciclos restantes. Si bien esta heurística es eficiente, encontramos que los límites inferiores que construye rara vez permiten realizar un gran número de podas. También intentamos usar CPLEX como una heurística primal. En cualquier nodo dado del árbol de búsqueda, podemos convertir la relajación LP restringida de nuevo a un ILP reintroduciendo las restricciones de integralidad. CPLEX tiene varias heurísticas primales integradas, las cuales podemos aplicar a este ILP. Además, podemos utilizar la búsqueda de árbol propia de CPLEX para encontrar una solución integral óptima. En general, esta búsqueda de árbol es mucho más rápida que la nuestra. Si CPLEX encuentra una solución integral que coincida con el límite superior fraccional en el nodo raíz, hemos terminado. De lo contrario, no existe tal solución integral, o aún no tenemos la combinación correcta de ciclos en el LP restringido. Para los mercados de intercambio de riñones, generalmente es la segunda razón la que se aplica (ver Secciones 5.2.2 y 5.2.4). Por lo tanto, en algún momento de la búsqueda en el árbol, una vez que se han generado más columnas como resultado de la ramificación, la heurística de CPLEX encontrará una solución integral óptima. Aunque la búsqueda de árbol de CPLEX es más rápida que la nuestra, no es tan rápida como para poder aplicarla a cada nodo en nuestro árbol de búsqueda. Por lo tanto, realizamos las siguientes optimizaciones. En primer lugar, agregamos una restricción que requiere que el valor objetivo del ILP sea tan grande como el objetivo fraccional. Si este no es el caso, queremos abortar y proceder a generar más columnas con nuestra búsqueda de ramificación y precio. En segundo lugar, limitamos el número de nodos en el árbol de búsqueda de CPLEX. Esto se debe a que hemos observado que no existe una solución integral, CPLEX puede tardar mucho tiempo en demostrarlo. Finalmente, solo aplicamos la heurística CPLEX en un nodo si tiene un conjunto de ciclos suficientemente diferente al de su padre. Utilizar CPLEX como heurística primal tiene un gran impacto porque reduce el tamaño del árbol de búsqueda, evitando así todo el trabajo de fijación computacionalmente costoso en los nodos que no se generan en este árbol más pequeño. 5.3.2 Ramificador de Ciclo. Experimentamos con dos estrategias de ramificación, ambas seleccionan una variable por nodo. La primera estrategia, ramificación por certeza, selecciona aleatoriamente una variable de aquellas cuyo valor LP está más cercano a 1. La segunda estrategia, ramificación por incertidumbre, selecciona aleatoriamente una variable cuyo valor LP esté más cercano a 0.5. En ambos casos, se generan dos hijos del nodo correspondientes a dos subárboles, uno en el que la variable se establece en 0 y otro en el que se establece en 1. Nuestro recorrido en profundidad siempre elige explorar primero el subárbol en el que el valor de la variable está más cerca de su valor fraccionario. Para nuestro problema de despeje con ciclos de longitud como máximo 3, encontramos que el ramificado por incertidumbre es superior, rara vez requiriendo retroceso alguno. 6. RESULTADOS EXPERIMENTALES Todos nuestros experimentos se realizaron en Linux (Red Hat 9.0), utilizando una PC Dell con un procesador Intel Pentium 4 de 3GHz y 1GB de RAM. Dondequiera que usamos CPLEX (por ejemplo, al resolver el LP y como heurística primal, como se discutió en las secciones anteriores), usamos CPLEX 10.010. La Figura 6 muestra el rendimiento en tiempo de ejecución de cuatro algoritmos de limpieza. Para cada tamaño de mercado listado, generamos aleatoriamente 10 mercados e intentamos liquidarlos utilizando cada uno de los algoritmos. El primer algoritmo es CPLEX en la formulación del ciclo completo. Este algoritmo no logra despejar ningún mercado con 1000 pacientes o más. Además, su tiempo de ejecución en mercados más pequeños que este es significativamente peor que el de los otros algoritmos. Los otros algoritmos son variaciones del enfoque de generación de columnas incremental descrito en la Sección 5. Comenzamos con la siguiente configuración (todas las optimizaciones están activadas): Categoría Configuración Columna Sembrador Combinación de heurísticas de intercambio voraz y emparejamiento de peso máximo, y sembrador de caminata aleatoria (400,000 ciclos). Generación de columnas una columna a la vez. Gestión de columnas activada, con límite de 400,000 columnas. Comprobador de Optimalidad Encendido. Redondeo heurístico primal y búsqueda en el árbol de CPLEX. Regla de ramificación de incertidumbre. La combinación de estas optimizaciones nos permite liquidar fácilmente mercados con más de 10,000 pacientes. En cada uno de los dos próximos algoritmos, desactivamos una de estas optimizaciones para resaltar su efectividad. Primero, restringimos el sembrador para que solo comience con 10,000 ciclos. Esta configuración es más rápida para instancias más pequeñas, ya que las relajaciones de LP son más pequeñas y se resuelven más rápido. Sin embargo, al llegar a 5000 vértices, este efecto comienza a ser contrarrestado por la generación adicional de columnas que se debe realizar. Para una instancia más grande, este sembrador restringido es claramente peor. Finalmente, restauramos el sembrador a su configuración optimizada, pero esta vez, eliminamos el verificador de optimalidad descrito en la Sección 5.2.3. Como en muchos problemas de generación de columnas, el efecto de disminución es significativo. Aprovechando las propiedades de nuestro problema, logramos despejar un mercado con 10,000 pacientes en aproximadamente el mismo tiempo que habría tomado despejar un mercado de 6000 pacientes. 7. IMPLEMENTANDO LA TECNOLOGÍA Nuestro algoritmo e implementación reemplazaron a CPLEX como algoritmo de compensación de la Alianza para la Donación Cruzada, uno de los principales intercambios de riñones, en diciembre de 2006. Realizamos una ejecución de prueba cada dos semanas, y los primeros trasplantes basados en nuestras soluciones ya han sido realizados. Aunque actualmente existen al menos cuatro intercambios de riñones en los Estados Unidos por razones políticas o interpersonales, todos comprenden que un intercambio nacional unificado y sin fragmentar salvaría más vidas. Estamos en conversaciones con intercambios de riñón adicionales que están interesados en adoptar nuestra tecnología. De esta manera, nuestra tecnología (y los procesos que la rodean) esperamos que sirvan como un sustrato que eventualmente ayudará a unificar los intercambios. Al menos la escalabilidad computacional ya no es un obstáculo. CONCLUSIÓN E INVESTIGACIONES FUTURAS En este trabajo hemos desarrollado los algoritmos exactos más escalables para intercambios de trueque hasta la fecha, con un enfoque especial en el próximo mercado nacional de intercambio de riñones en el que los pacientes con enfermedad renal serán emparejados con donantes compatibles intercambiando a sus propios donantes dispuestos pero incompatibles. Con más de 70,000 pacientes ya en espera de un riñón de cadáver en los Estados Unidos, este mercado es considerado como la única forma ética de reducir significativamente las 4,000 muertes al año atribuidas a la enfermedad renal. Nuestro trabajo presenta el primer algoritmo capaz de liquidar estos mercados a nivel nacional. Resuelve de manera óptima el problema de compensación de intercambio de riñones con 10,000 pares donante-receptor. Por lo tanto, no es necesario recurrir a soluciones aproximadas. La mejor tecnología previa (CPLEX básico) no puede manejar instancias de más de aproximadamente 900 pares de donantes-receptores porque se queda sin memoria. La clave de nuestra mejora es la formulación incremental de problemas. Adaptamos dos paradigmas para la tarea: generación de restricciones y generación de columnas. Para cada uno, desarrollamos una serie de técnicas que mejoran sustancialmente tanto el tiempo de ejecución como el uso de memoria. Algunas de las técnicas utilizan observaciones específicas del dominio, mientras que otras son independientes del dominio. Concluimos que la generación de columnas escala de manera significativamente mejor que la generación de restricciones. Para la generación de columnas en el LP, nuestras mejoras incluyen técnicas de fijación de precios, técnicas de siembra de columnas, técnicas para demostrar la optimalidad sin tener que traer todas las columnas con precio positivo (y utilizando otro proceso de generación de columnas en una formulación diferente para hacerlo), y técnicas de eliminación de columnas. Para la búsqueda de ramificación y precio en el programa entero que rodea al LP, nuestras mejoras incluyen heurísticas primales y también comparamos estrategias de ramificación. Sin duda, se podrían utilizar ajustes adicionales de parámetros y quizás técnicas adicionales de mejora de velocidad para hacer que el algoritmo sea aún más rápido. Nuestro algoritmo también admite varias generalizaciones, según lo deseado por los intercambios reales de riñones. Estos incluyen múltiples donantes alternativos por paciente, bordes ponderados en el grafo del mercado (para codificar diferencias en años de vida esperados añadidos basados en grados de compatibilidad, edad y peso del paciente, etc., así como la probabilidad de incompatibilidad de último minuto), cadenas desencadenadas por ángeles (cadenas de trasplantes desencadenadas por donantes altruistas que no tienen pacientes asociados con ellos, cada cadena termina con un riñón sobrante), y problemas adicionales (como diferentes puntajes para salvar a diferentes donantes altruistas o riñones sobrantes para futuras ejecuciones de emparejamiento basadas en tipo de sangre, tipo de tejido y probabilidad de que el órgano no desaparezca del mercado porque el donante tenga dudas). Debido a que utilizamos una metodología de PLI, también podemos soportar una variedad de restricciones laterales, las cuales a menudo desempeñan un papel importante en los mercados en la práctica [19]. También podemos respaldar la asignación forzosa de una parte, por ejemplo, este adolescente gravemente enfermo debe recibir un riñón si es posible. Nuestro trabajo ha tratado el intercambio de riñones como un problema por lotes con información completa (al menos a corto plazo, es probable que los intercambios de riñones sigan funcionando en modo por lotes de vez en cuando). Dos direcciones importantes para trabajos futuros son abordar explícitamente tanto los aspectos en línea como los de información limitada del problema. El aspecto en línea es que los beneficiarios y donantes irán llegando al sistema con el tiempo, y puede ser mejor no llevar a cabo el intercambio óptimo de forma miope ahora, sino reservar parte del mercado actual para futuras coincidencias. De hecho, se ha realizado cierto trabajo al respecto en ciertos entornos restringidos [22, 24]. El aspecto de información limitada es que incluso en modo por lotes, el grafo proporcionado como entrada no es completamente correcto: varios pares donante-receptor que se creían compatibles resultan ser incompatibles cuando se realizan pruebas de último minuto más costosas. Por lo tanto, sería deseable realizar una optimización teniendo esto en cuenta, como producir un subgrafo robusto de bajo grado para ser probado antes de que se genere la coincidencia final, o producir un plan de contingencia en caso de fallo. Actualmente estamos explorando varias preguntas en esta línea, pero ciertamente hay mucho más por hacer. Agradecimientos Agradecemos a los economistas Al Roth y Utku Unver, así como al cirujano de trasplantes de riñón Michael Rees, por alertarnos sobre el hecho de que la tecnología previa era insuficiente para el problema de compensación a escala nacional, proporcionar conjuntos de datos iniciales y discutir los detalles del proceso de intercambio de riñones. También agradecemos a Don Sheehy por habernos hecho notar la idea del intercambio de zapatos. Este trabajo fue apoyado en parte por la Fundación Nacional de Ciencias bajo los subsidios IIS-0427858 y CCF-0514922. REFERENCIAS [1] C. Barnhart, E. L. Johnson, G. L. Nemhauser, M. W. P. Savelsbergh y P. H. Vance. 303 0 500 1000 1500 2000 2500 3000 3500 4000 0 2000 4000 6000 8000 10000 Tiempo de limpieza (segundos) Número de pacientes Nuestro algoritmo Nuestro algoritmo con sembrador de columnas restringido Nuestro algoritmo sin demostrador de optimalidad Formulación de ciclo CPLEX Figura 6: Resultados experimentales: tiempo de ejecución promedio con barras de desviación estándar. Rama y precio: Generación de columnas para resolver programas enteros enormes. Investigación de Operaciones, 46:316-329, mayo-junio de 1998. [2] R. Dechter y J. Pearl. Estrategias generalizadas de búsqueda de mejor primero y la optimalidad de A*. Revista de la ACM, 32(3):505-536, 1985. [3] F. L. Delmonico. Intercambio de riñones - avances en el trasplante de donante vivo. Revista de Medicina de Nueva Inglaterra, 350:1812-1814, 2004. [4] J. Edmonds. Camino, árboles y flores. Revista Canadiense de Matemáticas, 17:449-467, 1965. [5] M. R. Garey y D. S. Johnson. Computadoras e Intractabilidad; Una Guía de la Teoría de NP-Completitud. 1990. [6] S. E. Gentry, D. L. Segev y R. A. Montgomery. Una comparación de las poblaciones atendidas por donación emparejada de riñón y donación emparejada de lista. Revista Americana de Trasplantes, 5(8):1914-1921, agosto de 2005. [7] P. Hart, N. Nilsson y B. Raphael. Una base formal para la determinación heurística de caminos de costo mínimo. IEEE Transactions on Systems Science and Cybernetics, 4(2):100-107, 1968. [8] K. Hoffman y M. Padberg. Resolviendo problemas de programación de tripulaciones aéreas mediante ramificación y corte. Ciencia de la Gestión, 39:657-682, 1993. [9] Intervac. http://intervac-online.com/. [10] Intercambio Nacional de Zapatos Impares. http://www.oddshoe.org/. [11] Peerflix. http://www.peerflix.com. [12] Léelo, cámbialo. http://www.readitswapit.co.uk/. [13] A. E. Roth, T. Sonmez y M. U. Unver. Intercambio de riñones. Revista Trimestral de Economía, 119(2):457-488, mayo de 2004. [14] A. E. Roth, T. Sonmez y M. U. Unver. Un centro de intercambio de riñones en Nueva Inglaterra. Revista Económica Americana, 95(2):376-380, mayo de 2005. [15] A. E. Roth, T. Sonmez y M. U. Unver. Intercambio eficiente de riñones: Coincidencia de deseos en un mercado con preferencias basadas en la compatibilidad. American Economic Review, próximo. [16] E. Rothberg. Algoritmo de emparejamiento de peso máximo de Gabow n3: una implementación. El Primer Desafío de Implementación DIMACS, 1990. [17] S. L. Saidman, A. E. Roth, T. Snmez, M. U. Unver y F. L. Delmonico. Aumentando la oportunidad de donación de riñón en vida mediante el emparejamiento para intercambios de dos y tres vías. Trasplante, 81(5):773-782, 2006. [18] T. Sandholm. Algoritmos óptimos de determinación de ganadores. En Subastas Combinatorias, Cramton, Shoham y Steinberg, eds. MIT Press, 2006. [19] T. Sandholm y S. Suri. Restricciones laterales y atributos no relacionados con el precio en los mercados. En el taller IJCAI-2001 sobre Razonamiento de Restricciones Distribuidas, páginas 55-61, Seattle, WA, 2001. Para aparecer en Games and Economic Behavior. [20] D. L. Segev, S. E. Gentry, D. S. Warren, B. Reeb y R. A. Montgomery. Donación emparejada de riñón y optimización del uso de órganos de donantes vivos. Revista de la Asociación Médica Estadounidense, 293(15):1883-1890, abril de 2005. [21] United Network for Organ Sharing (UNOS). http://www.unos.org/. [22] M. U. Unver. Intercambio dinámico de riñones. Documento de trabajo. [23] Sistema de Datos Renales de los Estados Unidos (USRDS). http://www.usrds.org/. [24] S. A. Zenios. Control óptimo de un programa de intercambio de riñones emparejados. Ciencias de la Gestión, 48(3):328-342, marzo de 2002. 304