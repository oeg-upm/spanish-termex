Indexación de bordes en una cuadrícula para entornos virtuales altamente dinámicos∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 RESUMEN Los sistemas de aplicaciones basados en juegos emergentes como Second Life1 proporcionan entornos virtuales en 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que es continuamente aumentado por los usuarios. Para hacer que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se construyen sobre una división de subespacios de cuadrícula basada en cliente-servidor, donde los mundos virtuales se dividen en submundos manejables. En cada submundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados de forma remota y los renderiza según su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de un usuario es uno de los factores principales que afectan la capacidad de procesamiento y escalabilidad del servidor. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y sub-millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial, por lo tanto, mapeamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar tanto como un objeto espacial como una consulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de nuevos entornos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimiza la aparición inesperada de objetos y que soporta una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos que nuestro enfoque siente las bases para marcos virtuales de próxima generación que puedan fusionarse con los servicios basados en la web existentes en un futuro cercano. Categorías y Descriptores de Asunto: C.2.4 [Computación - Redes de Comunicación]: Sistemas Distribuidos - Cliente/servidor, Aplicaciones Distribuidas, Bases de Datos Distribuidas; I.3.7 [Gráficos por Computadora]: Gráficos Tridimensionales y Realismo - Realidad Virtual Términos Generales: Algoritmos, Diseño, Rendimiento 1. INTRODUCCIÓN Recientemente, los Juegos en Línea Masivamente Multijugador (MMOGs) han sido estudiados como un marco para los entornos virtuales de próxima generación. Muchas aplicaciones de MMOG, sin embargo, todavía se limitan a un enfoque de diseño tradicional donde la complejidad de su escena 3D se controla cuidadosamente de antemano para cumplir con las restricciones de renderizado en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea fluido, infinito e ilimitado, Marshall et al. identificaron cuatro nuevos requisitos: extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución); escalabilidad (aunque aumente el número de usuarios concurrentes, el sistema sigue funcionando de manera efectiva); interactividad; e interoperabilidad. En este documento, nos enfocamos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite a los usuarios habituales de juegos desplegar su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por los usuarios tiende a generar desequilibrios entre la complejidad del escenario existente, causando problemas de rendimiento en todo el sistema. El soporte completo para la extensibilidad dinámica seguirá siendo uno de los mayores desafíos para los desarrolladores de videojuegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, por lo general no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples submundos o replicar mundos en ubicaciones geográficamente dispersas, se puede dar soporte a un gran número de usuarios concurrentes. Normalmente, el número máximo de usuarios en el mismo mundo gestionado por un único servidor o un grupo de servidores está limitado a varios miles, asumiendo un mundo bastante estático [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, se divide el espacio de manera similar a una cuadrícula. Originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales. 402 Avatar Object PoppingEntidades Autónomas (a) En el tiempo t (b) En el tiempo t+Δ Figura 1: El popping de objetos ocurrió mientras un usuario se mueve hacia adelante (capturas de pantalla de Second Life) donde Δ = 2 segundos. emplea un modelo de transmisión de objetos 3D basado en cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y brinda a los usuarios una libertad ilimitada para perseguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones de MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque tradicional de determinación de visibilidad tiene un problema de objetos que aparecen repentinamente. Por ejemplo, una casa fuera del rango visible de un usuario no se dibuja en el tiempo t, como se ilustra en la Figura 1(a). A medida que el usuario avanza, la casa aparecerá repentinamente en el tiempo (t + Δ) como se muestra en la Figura 1(b). Si Δ es pequeño, o la casa es lo suficientemente grande como para chocar con el usuario, interrumpirá la experiencia de navegación del usuario. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud menor que para los mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápido que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La sección 2 presenta el trabajo relacionado. La sección 3 describe nuestro nuevo método de visualización. En la Sección 4, presentamos suposiciones sobre nuestra aplicación objetivo e introducimos un nuevo método de indexación espacial diseñado para soportar cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta los resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las direcciones de investigación futuras en la Sección 7.2. El trabajo relacionado La determinación de la visibilidad ha sido ampliamente explorada en el campo de los gráficos 3D. Se han propuesto varios algoritmos locales de renderizado para eliminar objetos innecesarios antes del renderizado o en cualquier etapa del proceso de renderizado. La eliminación de frustum de vista, la eliminación de caras traseras y la eliminación de oclusión son algunas de las técnicas de eliminación de visibilidad conocidas [6]. Sin embargo, estos algoritmos asumen que todos los objetos visibles candidatos han sido almacenados localmente. Si los objetos objetivo están almacenados en servidores remotos, los clientes reciben los elementos de geometría necesarios para la representación de las bases de datos del servidor. Teller et al. describieron un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadros a lo largo del tiempo en recorridos remotos de escenas 3D complejas desde la ruta de navegación de los usuarios [5]. Funkhouser et al. demostraron que la representación multi-resolución, como los Niveles de Detalle (LOD), se puede utilizar para mejorar las tasas de cuadros de renderizado y la utilización de memoria durante la visualización interactiva. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente congestionados. Por otro lado, nuestro modelo de cálculo de visibilidad, representante de esta categoría, se basa en diferentes suposiciones sobre la representación de datos de entidades virtuales. En el área de gráficos, ha habido poco trabajo en el soporte de cálculos de visibilidad en tiempo real para un gran número de objetos y usuarios en movimiento. Aquí reconocemos que este tipo de problemas relacionados con gráficos tienen una similitud muy cercana con los problemas de bases de datos espaciales. Recientemente, varios artículos han abordado el problema de escalabilidad sobre cómo soportar grandes cantidades de objetos y consultas en entornos altamente dinámicos. Para apoyar actualizaciones frecuentes, se han estudiado en profundidad dos políticas de particionamiento: (1) indexación espacial basada en R-tree y (2) indexación espacial basada en cuadrícula. El R-tree es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por Rectángulos de Contención Mínima (MBR). El modelo de particionamiento basado en cuadrícula es un caso especial de particionamiento fijo. Recientemente, ha sido redescubierto ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el R-tree y sus variantes (R+ tree, R∗ -tree) sufren de una degradación de rendimiento inaceptable en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo de división [8, 9, 10, 11, 12]. Una estrategia de actualización de abajo hacia arriba propuesta para los R-trees [9] optimiza las operaciones de actualización del índice mientras mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de recorrer un árbol desde el nodo raíz para solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizar a través de una tabla hash de objetos. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición del espacio basada en cuadrículas para entornos emergentes de objetos en movimiento. A diferencia de los métodos tradicionales de indexación espacial que construyen un índice en los objetos en movimiento, este construye un índice en las consultas de rango continuo, asumiendo que las consultas se mueven raramente mientras que los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasiestacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un Quadtree y los objetos cuasiestacionarios se almacenan en un R∗ -tree. SINA [10] fue propuesto para proporcionar evaluaciones eficientes de consultas para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta de manera eficiente las actualizaciones de objetos recién descubiertos (positivas) o que ya no son relevantes (negativas). A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al. [12] propusieron un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de los objetos en movimiento. Mientras algún objeto resida en esta región, todos los resultados de consulta están garantizados de ser válidos en el sistema. Si los objetos se mueven fuera de su región, las solicitudes de actualización de ubicación deben ser enviadas al servidor de base de datos y las consultas afectadas son reevaluadas sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La diferencia principal es que nos enfocamos más en la determinación de visibilidad en tiempo real, mientras que otros asumen restricciones de tiempo más flexibles. 3. MODELO DE VISTA INICIADO POR OBJETO En esta sección ilustramos cómo el problema de los objetos emergentes puede asociarse con un modelo típico de decisión de vista. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos los términos comúnmente utilizados a lo largo de este documento. Las entidades en un espacio virtual se pueden categorizar en tres tipos 403 basados en su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil o estacionario común que puede ser visible para otras entidades. La entidad espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación puntual. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona de manera similar a un control de cámara en el campo de la gráfica 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa a un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos el término entidad objeto para referirnos a una entidad autónoma o un avatar, mientras que usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro de la cual cualquier otra entidad puede reconocer su existencia. Se basa en la suposición de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento dado y que todos los usuarios poseen una visibilidad igual. Por lo tanto, el usuario y el objeto solo pueden verse cuando su distancia actual es menor o igual a la óptima. Para especificar el rango visible, mucha literatura en el área de gráficos [5, 6] utiliza un Área de Interés Circular (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios de dirección rápidos sin interrupciones en la visualización en la periferia del área visible. Sin embargo, utilizamos un AOI de forma cuadrada a expensas de la precisión porque la extensión espacial cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en cuadrículas. El modelo de vista tradicional, al que llamamos modelo de vista iniciado por el usuario, asume que una entidad de usuario tiene un AOI mientras que una entidad de objeto no lo tiene. A medida que la usuaria navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su bajo sobrecosto de indexación, muchos Servicios Basados en la Localización (LBSs) y aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un grave problema de objetos que aparecen repentinamente durante la navegación. Recuerda, como se muestra en la Figura 1, que la casa que habrá aparecido en el tiempo t + Δ no aparece en el tiempo t porque el usuario no puede reconocer objetos que están fuera de su AOI en el tiempo t. De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el tiempo t. Por lo tanto, no hay otra opción más que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede provocar una degradación significativa del sistema. Para superar el problema de los objetos que aparecen repentinamente, proponemos un nuevo modelo de vista al que llamamos modelo de vista iniciado por objetos. Todas las entidades objeto tienen su propia Área de Interés (AOI) centrada en su ubicación actual, mientras que todas las entidades espectador no tienen AOI. Cada entidad de usuario reconoce los objetos cuyas AOIs cubren su ubicación puntual. Las principales fortalezas del nuevo modelo son que (1) no tiene problemas de objetos que aparezcan repentinamente siempre y cuando el sistema subyacente pueda gestionar el rango visible óptimo de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de varios cambios de comportamiento y temporales. Un objeto grande puede tener un rango visible más lejano que uno pequeño; un objeto tiene un rango visible más amplio durante el día que por la noche; incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado; si un objeto está ubicado dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los posibles argumentos en contra de la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctica, en comparación con la visión iniciada por el usuario. Estamos de acuerdo en que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una solución novedosa de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con un gran número de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D. Ten en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de toma de decisiones de visibilidad como el culling de visibilidad [6], sino de filtrar eficientemente las entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativas como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación. 4. DISEÑO DE LA INDEXACIÓN DE BORDES En la Sección 4.1 presentamos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación de celdas se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para el indexado de bordes se presentan en la Sección 4.5. 4.1 Aplicación Objetivo Nuestra aplicación objetivo asume tanto la transmisión de objetos en 3D como el alojamiento de submundos. El alojamiento de submundos es un entorno virtual colaborativo donde cada servidor aloja un submundo, construyendo así un único mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en submundos de tamaño igual. El submundo de muestra separado con líneas en negrita y discontinuas en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2); una entidad espectadora S; y un avatar A. Como se menciona en la Sección 3, todas las entidades objeto (E1, E2, A) tienen su propia AOI en forma de cuadrado. Dos entidades de usuario (S, A) están asociadas con máquinas cliente individuales (cliente S y cliente A en la figura). La condición espacial de que la ubicación del punto S se encuentre dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada submundo es gestionado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, entrega cualquier evento nuevo (es decir, un nuevo usuario entra en el submundo o un objeto se mueve de un lugar a otro) a los clientes y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de entidades en movimiento, un servidor divide aún más su submundo en particiones más pequeñas, llamadas celdas de rejilla. La Figura 2 muestra la cuadrícula de 4 × 4 delimitada por las líneas punteadas. En lugar de indexar las entidades del objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario dado incluye la búsqueda y de3 Un mejor método de indexación para un espacio 3D está en progreso. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) indexación de nodos (b) indexación de aristas (c) indexación de aristas con evaluación de celdas por filas Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos y aristas para el espacio de muestra en la Figura 2. Hay tres entidades de objeto, {E1, E2, A}, y dos entidades de usuario, {S, A}, en el mundo. Entrega de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación también se conoce como evaluación de usuario (o consulta) de forma intercambiable. Nuestra aplicación solo considera la indexación eficiente de entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por submundo se indexan y qué tan rápido se reconocen y recuperan las actualizaciones de índices. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento. 4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una celda dada. En nuestra aplicación, utilizamos tres tipos de tokens: el Token de Inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El Token de Apariencia (AT) indica que su entidad es un IT para la celda dada, pero no para la celda adyacente previamente. El Token de Desaparición (DT) es lo opuesto a AT, lo que significa que aunque su entidad no cumple con la relación IT con la celda dada, sí lo hace con la celda previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y una arista. Un nodo es una estructura de datos que almacena sus datos de una celda. Por lo tanto, el nodo para la celda i se define como un conjunto de entidades de IT y se expresa formalmente como Ni = {o|o.R∩i.R = ∅}, donde R es ya sea un AOI o una región de celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus ATs o DTs. Si el borde solo almacena las entidades AT, se le llama Borde de Aparición (AE); de lo contrario, si almacena DTs, se le llama Borde de Desaparición (DE). El AE para dos celdas adyacentes i y j se define como un conjunto de ATs y se expresa como E+(i, j) = Nj − (Ni ∩ Nj) (1) donde Ni y Nj son las estructuras de nodos para las celdas i y j. La DE para dos celdas adyacentes i, j se define como un conjunto de DT, que satisface: E−(i, j) = Ni − (Ni ∩ Nj) (2) En un mapa 2D, dependiendo de la relación de adyacencia entre dos celdas vecinas, los bordes se clasifican adicionalmente como bordes en fila, si dos vecinos son adyacentes horizontalmente (Er), o en columna, si son adyacentes verticalmente (Ec). En consecuencia, los bordes son de cuatro tipos diferentes, según su tipo de token y adyacencia: Er +(i, j), Er −(i, j), Ec +(i, j) y Ec −(i, j). 4.3 La indexación de nodos La partición de cuadrícula es un método popular de subdivisión del espacio que ha ganado popularidad recientemente para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia con nuestro método recién propuesto, denominamos a todos los métodos de indexación basados en la partición de cuadrículas existentes como indexación de nodos. La indexación de nodos divide el espacio en subespacios de tamaño equitativo (celdas de la cuadrícula), indexa entidades en cada celda y busca entidades que cumplan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodos por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodos de las celdas cuya región se intersecta con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para las entidades, esto permite actualizaciones de índices ligeras. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como un rectángulo, el indexado de nodos sufrirá una degradación significativa del sistema debido al costoso sobrecoste de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 celdas de la cuadrícula requiere 100 eliminaciones de fichas y 100 inserciones de fichas, en el peor de los casos. Uno de los métodos de indexación de nodos populares, la Indexación de Consultas, ha sido reportado de tener una degradación de rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio muestral mostrado en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3(a). Cada célula almacena entidades de TI que se intersectan con su región. El procesamiento de consultas para el espectador S implica buscar la estructura de nodos cuya región de celda se intersecta con S. En la Figura 3(a), E2 está indexado en la misma celda, por lo tanto, se entrega al cliente S después de la evaluación de la consulta. 4.4 Indexación de bordes Nuestro nuevo método de indexación, la indexación de bordes, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrada) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización periódica de entidades y evaluación de celdas. 4.4.1 Estructura de Borde de la Idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de utilizar estructuras de nodo. Con este enfoque, se eliminan los IT redundantes entre dos celdas adyacentes (Ni ∩Nj). En un mapa de cuadrícula 2D de M × M, cada celda i está rodeada por cuatro celdas vecinas (i− 1), (i+ 1), (i− M), (i+ M) (excepto las 405 celdas más externas) y ocho estructuras de borde diferentes. Si las dos primeras celdas vecinas están horizontalmente adyacentes a i y las dos últimas celdas (i−M), (i+M) están verticalmente cercanas, las ocho estructuras de borde son Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+1), Er −(i, i+1), Ec +(i, i+M) y Ec −(i, i+M). La Figura 3(b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las Ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de bordes deriva estructuras de nodos a partir de las estructuras de bordes. Si se conocen de antemano la estructura de cualquier nodo y todas las estructuras de los bordes, podemos derivar todas las estructuras de los nodos según lo definido por el Lema 1. La prueba del Lema 1 es trivial ya que se deduce fácilmente de las Ecuaciones 1 y 2. Lema 1. La estructura de vecindad de una celda j puede derivarse de la estructura de vecindad de su celda vecina i, Ni, y sus bordes E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j). Sin embargo, las estructuras de bordes por filas y por columnas capturan cierta información redundante. Por lo tanto, el indexado de bordes ingenuo almacena más tokens que el indexado de nodos: el número total de tokens de borde mostrados en la Figura 3(b) es 35 (17 ATs + 17 DTs + 1 IT); para el indexado de nodos en la Figura 3(a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo de dos pasos posterior al indexado original de bordes. Actualización periódica de entidades y evaluación de celdas. Muchos objetos se encuentran en constante movimiento, por lo que las estructuras de índice deben actualizarse regularmente. Generalmente, esto se hace a través de un algoritmo de dos pasos [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de las entidades recién movidas (el paso de actualización de entidades) y luego calcula las estructuras de nodos de cada celda (el paso de evaluación de celdas). Después de una evaluación de celda, se recuperan las entidades de usuario indexadas y se entrega la estructura de nodo calculada para cada cliente asociado con un usuario. Después de evaluar todas las celdas, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestro indexado de bordes actualizando las estructuras de bordes de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lema 1 durante las evaluaciones de celdas. Además de esta adaptabilidad, el Lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de las filas o los bordes de las columnas son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes por filas. Se asume que las estructuras de nodos más a la izquierda se obtienen previamente. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la derecha a partir de la estructura del nodo más a la izquierda y los bordes por fila. Repetimos este cálculo hasta llegar a la celda más a la derecha. Por lo tanto, sin bordes por columna podemos obtener con éxito todas las estructuras de nodos. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3(c) ilustra el concepto de nuestro método de indexación de bordes por filas. El número total de tokens se reduce a 17 (8 ATs + 8 DTs + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2. Otra Ejemplo La Figura 4 ilustra cómo construir estructuras de borde a partir de dos celdas cercanas. En la figura, dos celdas adyacentes en fila 3 y 4 tienen dos transiciones de borde en fila entre ellas, E+(3, 4), E−(3, 4); dos entidades de punto P1, P2; y dos entidades poligonales R1, R2. Como se muestra en la figura, N3 indexa {P2, R1, R2} y N4 mantiene los índices de {P1, R2}. E+(3, 4) se obtiene de la Ecuación 1: N4 − (N3 ∩ N4) = {P1}. De manera similar, E−(3, 4) = N3 − Celda 3 Celda 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figura 4: Ejemplo de indexación de borde de dos entidades de puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en filas. (N3 ∩ N4) = {P2, R1}. Si conocemos N3, E+(3, 4) y E−(3, 4), podemos calcular N4 de acuerdo con el Lema 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3 mientras que P1, R2 se superponen con la celda 4. Al transitar de la celda 3 a la 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece de nuevo mientras que la condición espacial de R2 permanece sin cambios. Por lo tanto, podemos insertar P2, R1 en el conjunto de bordes de desaparición e insertar P1 en el conjunto de bordes de aparición. Obviamente, el indexado de bordes es ineficiente para indexar una geometría de punto. La indexación de nodos tiene una entidad de tecnología de la información por punto y requiere la eliminación de un token y una inserción al mover cualquier ubicación. El indexado de bordes, sin embargo, requiere un AT y un DT por entidad de punto y dos eliminaciones de token y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos según la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3(c), nuestro método de indexación de bordes utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras que utiliza estructuras de nodo para la entidad de punto (S). 4.5 Problemas de Optimización En esta sección, describimos varias técnicas de optimización para la indexación de bordes, que reducen significativamente la complejidad del algoritmo. 4.5.1 Enfoque de Tabla Única: Actualización Normalmente, existen dos políticas prácticas para una actualización de región: la Actualización Completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar los tokens recién actualizados en áreas recién posicionadas. La Actualización Incremental solo elimina los tokens cuya relación espacial con las celdas cambió durante una actualización e inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales. Enfoque de dos tablas: Separar Entidades en Movimiento de Entidades Estacionarias. Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de aristas con una tabla hash. La inserción de un token se implementa insertándolo al principio del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación del token depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación de hash puede sufrir una penalización significativa en el sistema cuando se utiliza con un gran número de entidades pobladas. El indexado de bordes de dos tablas está diseñado para hacer que la sobrecarga de eliminación de tokens sea constante. Primero, dividimos una estructura de borde única que indexa entidades estacionarias y en movimiento en dos bordes separados. Tabla 1: Resumen de las notaciones para entidades virtuales y sus propiedades. Símbolo Significado U conjunto de entidades de objetos poblados O conjunto de entidades de objetos en movimiento, O ⊆ U Uq conjunto de entidades de usuarios poblados Q conjunto de entidades de usuarios en movimiento, Q ⊆ Uq A conjunto de avatares, A = {a|a ∈ U ∩ Uq} i.P ubicación de la entidad i donde i ∈ (U ∪ Uq) i.R AOI de la entidad i donde i ∈ (U ∪ Uq) mi longitud lateral de la entidad i donde i ∈ (U ∪ Uq). Está representado por el número de unidades de celda. m longitud promedio del lado del AOI de las entidades V ar(mi) varianza de la variable aleatoria mi v distancia máxima alcanzable. Se representa por el número de unidades celulares. estructuras. Si una entidad no se está moviendo, sus fichas serán colocadas en una estructura de borde estacionaria. De lo contrario, se colocará con un borde móvil. Segundo, todas las estructuras de borde en movimiento son reconstruidas periódicamente. Después de la reconstrucción, todas las celdas de la cuadrícula son evaluadas para calcular sus conjuntos visibles. Una vez que todas las celdas son evaluadas, los bordes móviles son destruidos y se sigue el paso de reconstrucción. Como resultado, las operaciones de búsqueda en las estructuras de borde móviles ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y velocidad de movimiento de las entidades. Se utiliza una implementación de lista enlazada simple para la estructura de borde móvil. 5. ANÁLISIS Analizamos cuantitativamente tres esquemas de indexación (indexación de nodos, indexación de aristas e indexación de aristas de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, asumimos que las estructuras de nodo y borde están implementadas con tablas hash. Para las manipulaciones de la tabla hash asumimos tres funciones de acceso a memoria: inserción de token, eliminación de token y escaneo de token. Sus costos de procesamiento se denotan como Ta, Td y Ts, respectivamente. Una operación de escaneo de token lee los tokens en un cubo hash de forma secuencial. Se utiliza ampliamente durante las evaluaciones celulares. Ts y Td son una función del número de tokens en el cubo mientras que Ta es constante. Con el propósito de análisis, definimos dos variables aleatorias. Una variable, denotada por mo, representa la longitud del lado del AOI de una entidad o. Las longitudes de los lados están distribuidas uniformemente en el rango de [mínimo, máximo]. El valor promedio de mo se denota por m. La segunda variable aleatoria v denota la distancia máxima en la dirección x o y de una entidad en movimiento durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también está distribuido uniformemente en el rango de [0, v]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades de células. La Tabla 1 resume las notaciones simbólicas y su significado. 5.1 Requisitos de memoria Deje que el tamaño del token esté representado por s. La indexación de nodos utiliza s · |Uq| unidades de memoria para entidades de usuario y s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| unidades para entidades de objeto. La indexación de bordes de una sola tabla consume s · |Uq| unidades de almacenamiento para las entidades de usuario y s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| para las entidades de objeto. La indexación de bordes de dos tablas ocupa s · |Uq| unidades para los usuarios y s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| unidades para los objetos. La Tabla 2 resume estos resultados. En nuestra aplicación objetivo, nuestros métodos de indexación de bordes consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. La partición de celdas de cuadrícula con diferentes métodos de borde resultará en diferentes requerimientos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula de M × M y una cuadrícula de 2M × 2M. El requisito de memoria para las entidades de usuario no cambia porque depende únicamente del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s(m + 1)|U| en el caso de una cuadrícula M × M y 2s(2m + 1)|U| para la cuadrícula (2M) × (2M). Por lo tanto, un tamaño de celda cuatro veces más grande llevará a un número de tokens aproximadamente dos veces más pequeño. 5.2 Costo de Procesamiento En esta sección, nos enfocamos en el análisis de costos de operaciones de actualización y evaluaciones de celdas. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad temporal de los objetos en movimiento y los usuarios en movimiento. 5.2.1 Costo de Actualización. Suponemos que se conocen de antemano un conjunto de objetos en movimiento O y un conjunto de usuarios en movimiento Q. Similar al indexado de bordes, el indexado de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en Q-Index [13] y SINA [10], elimina todos los tokens antiguos de las estructuras de nodos de celdas antiguas e inserta todos los tokens nuevos en los nuevos nodos de celdas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incremental. Para analizar el costo de actualización de la indexación de nodos, introducimos la distancia máxima alcanzable (v), donde la próxima ubicación de una entidad en movimiento, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre el espacio de celdas de la cuadrícula (±v, ±v) como se ilustra en la Figura 5. También asumimos que la distancia máxima alcanzable dada es menor que cualquier longitud de lado del Área de Interés (AOI) de los objetos en el sistema; es decir, v < mo donde o ∈ O. Como se observa en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve al área A, habrá (i + j)(mo + 1) − ij inserciones y eliminaciones de fichas, donde 1 ≤ i, j ≤ v. De lo contrario, habrá k(mo + 1) inserciones y eliminaciones de fichas, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimientos diferentes T nodo por actualización(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante T nodo por actualización = Èo∈O,v<mo T nodo por actualización(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización única donde v < mq, mo y q ∈ Q. consultas de método de indexación ×(Ta + Td) (segundos) objetos ×(Ta + Td) (segundos) indexación de nodos con actualización incremental |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 indexación de borde de tabla única con actualización completa |Q| |O| · 2(m + 1) indexación de borde de tabla única con actualización incremental |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 indexación de borde de dos tablas |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Distancia Máxima Alcanzable (v) (0,0) i j (i,j) A A AA B B B B Figura 5: Ilustración de la próxima ubicación de celda, celda(i, j), de una entidad en movimiento cuya ubicación inicial fue en la celda (0, 0). El tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización completa es: T edgefull por actualización = Èo∈O T edgefull por actualización (o) |O| = 2(m + 1)(Ta + Td) (5). El análisis del tiempo esperado de cualquier actualización de una sola entidad para el indexado de bordes con actualización incremental se vuelve complicado porque el costo temporal depende tanto de la longitud del lado de la entidad AOI como de la velocidad de movimiento. Hablando en términos generales, su costo de procesamiento en el peor de los casos es el mismo que el de Tedgefull por actualización. Debido a limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es menor que mo: Tedgeincremental por actualización = Èo∈O,v<mo Tedgeincremental por actualización (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que mientras el costo de actualización del peor caso del indexado de aristas (indexado de aristas de una sola tabla con política de actualización completa) depende solo de m, el del mejor caso del indexado de nodos (indexado de nodos con política de actualización incremental) sigue siendo proporcional a dos variables, v y m. Para un valor más pequeño de v (v = 1), el costo de actualización del indexado de nodos supera ligeramente al del indexado de aristas (es decir, 12m+89 vs. 2(m + 1)). Sin embargo, a medida que v aumenta, la ganancia de rendimiento se revierte inmediatamente (es decir, 60m+24 25 versus 2(m + 1), donde v = 2). Otro resultado interesante es que el indexado de bordes de dos tablas depende únicamente del costo de inserción de tokens, Ta. Normalmente, Td es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia Máxima Alcanzable (v) (%) #deTokensAfectados Indexación de Bordes de Dos Tablas Indexación de Bordes Incremental Indexación de Bordes Completa Indexación de Nodos Incremental Figura 6: Resultados de simulación de la complejidad de actualización de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones e inserciones de tokens por actualización de objeto, se representa como una función de la distancia máxima alcanzable (v). La longitud promedio del lado de los objetos AOI es el 10% de la longitud del lado de un mapa 2D dado, mayor que Ta porque Td requiere al menos una operación de búsqueda de token. Después de la búsqueda, Td ejecuta la operación inversa de Ta. Por lo tanto, Td bien puede expresarse como (Ta + Tlookup) y puede simplificarse como (Ta + |E| 2·b ·Ts) donde |E| es el tamaño de la estructura de borde y b es el número de sus cubetas hash. A partir de esta observación, podemos inferir que la actualización completa de un índice de borde de una sola tabla tarda al menos el doble que la actualización de un índice de borde de dos tablas. La Figura 6 muestra que la actualización completa del indexado de bordes cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil toma un tiempo constante para actualizar las estructuras de bordes correspondientes, lo cual depende principalmente de la longitud lateral del AOI dado. En esta figura asumimos que la longitud promedio de un lado del AOI es de 0.1 (o 10 %). El método de indexación de nodos, sin embargo, depende no solo de la longitud del lado sino también de la distancia alcanzable. Por lo tanto, la actualización de entidades en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de bordes. Como era de esperar, estos resultados de simulación validan la creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen notablemente la cantidad de inserciones y eliminaciones de tokens, mientras que en entornos extremadamente dinámicos, la proporción de reducción se vuelve insignificante. 5.2.2 Costo de Evaluación de Celda La indexación de nodos escanea todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo de celda. Por lo tanto, tomaría |Q|×Ts escanear todas las entidades de usuario. Si cada nodo almacena (m2 +2m+1+V ar(mo))|O| M2 entidades de objetos en promedio, el tiempo de finalización esperado de una evaluación de celda será entonces Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de celdas será |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. La complejidad de tiempo de ejecución de la evaluación de celda de tabla única puede simplificarse como Ts · |O| · 2(m + 1). En este análisis, no consideramos ningún sobrecosto de entrega de datos después de una evaluación de celda. Ten en cuenta que en la indexación de bordes de una sola tabla necesitamos escanear todos los tokens para las evaluaciones de celdas. La indexación de bordes de dos tablas se ejecuta en Td para eliminar los tokens evaluados después de una evaluación de celda. A diferencia de la operación Td, la operación Td es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados previamente calculados se reutilizan durante la siguiente ronda de evaluación, el tiempo transcurrido esperado de indexación de nodos estará limitado por el número total de evaluaciones de celdas (es decir, Ts(m2 + 2m + 1 + V ar(mo))|O|). Sin embargo, en el peor de los casos, la evaluación de celdas del indexado de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexado de aristas. 5.2.3 Poniéndolo todo junto: Costo de Monitoreo Periódico Como vimos en la Sección 5.2.1, los métodos de indexado de aristas superan al indexado de nodos en términos de actualizaciones y evaluaciones de celdas. En esta sección nos enfocamos en evaluar la diferencia de rendimiento entre la indexación de bordes de una sola tabla y la indexación de bordes de dos tablas. El tiempo total transcurrido de la indexación de bordes de una sola tabla basada en actualización completa para un conjunto dado de entidades en movimiento es la suma del tiempo transcurrido de las actualizaciones y evaluaciones de celdas: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7). De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8). A partir de las Ecuaciones 7 y 8, concluimos que la indexación de bordes de dos tablas, aunque representa una optimización menor de la indexación de bordes de una sola tabla al reemplazar el impredecible Td con el predecible Td, logra una mejora significativa en el rendimiento. En primer lugar, Td es muy predecible y un procedimiento más ligero que Td. Todos los costos adicionales de manipulación de la estructura de datos, como Ta, Ts y Td, pueden ser fácilmente perfilados y se vuelven constantes. Además, se garantiza que el índice de dos tablas superará al índice de borde de actualización completa de una sola tabla. Otra novedad del enfoque de las dos tablas es que es altamente resistente a la distribución de datos subyacente, ya sea altamente sesgada o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, Ta, Ts, Td, |Q|, |O| y m. Mientras que Ta, Ts y Td son parámetros específicos del sistema, |O|, |Q| y m son todos específicos de la aplicación. El último puede ser configurado por el primero y cualquier restricción de tiempo real T dada. Por lo tanto, el rendimiento del sistema - cuántos objetos en movimiento y usuarios son soportados por el sistema dado - se obtiene de la Ecuación 9. El rendimiento máximo del sistema = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9). Por ejemplo, si un submundo dado está lleno solo de avatares en movimiento, A = Q = O, cuya longitud lateral promedio es el 10% de la longitud lateral del mapa, entonces Ts + Td toma 0.42 microsegundos por evaluación de token, y Ta toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar libremente en el submundo y el mismo número de clientes conectados de forma remota reciben continuamente los eventos de actualización más recientes. 6. EVALUACIÓN Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La sección 6.1 examina si nuestro nuevo enfoque de visualización es superior a los modelos de visualización existentes, a pesar de su mayor complejidad de indexación. La sección 6.2 discute el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista. 6.1 Justificación del Modelo de Vista Iniciado por Objeto 6.1.1 Métricas de Evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, Precisión (P) y Recuperación (R), que estiman el grado de precisión y exhaustividad de un conjunto de resultados dado [15]. P es la proporción de elementos relevantes recuperados con respecto a todos los elementos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene un gran número de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor de P más alto significa una carga de tráfico de red más alta de la necesaria. R es la proporción de elementos relevantes recuperados respecto a todos los elementos relevantes. Un valor R más bajo significa que se ignoran más objetos que deberían ser reconocidos. A partir de la medida R, podemos estimar cuantitativamente la ocurrencia del popping de objetos. Además de las métricas P y R, utilizamos una métrica estandarizada de evaluación de consultas univaluada que combina P y R, llamada Emeasure [15]. La medida E se define como: E = 1 − (β2 + 1)PR β2P + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es menor que 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida E. Un valor más bajo de la medida E implica que el modelo de vista probado tiene una mayor calidad. El mejor valor de la medida E es cero, donde los mejores valores para P y R son ambos uno. Configuración de simulación 6.1.2 Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por un objeto: • Cálculo de visibilidad iniciado por el usuario - RQ-OP: Consulta de Región - Punto de Objeto • Cálculo de visibilidad orientado a objetos - PQ-OR: Consulta de Punto - Región de Objeto - RQ-OR: Consulta de Región - Región de Objeto - ACQ-OR: Consulta de Celda Aproximada - Región de Objeto RQ-OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de una AOI definida por el usuario. PQ-OR recopila un conjunto de objetos cuya AOI interseca con un punto de usuario dado, formalmente {o|q.P ∈ o.R}. RQ-OR, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se intersecta con el de un usuario, {o|o.R ∩ q.R = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición del espacio basada en cuadrículas, que es nuestra elección de metodología de evaluación de celdas para el indexado de bordes. Si un espacio virtual está dividido en celdas en mosaico y un punto de usuario pertenece a una de las celdas, el ACQ-OR busca los objetos cuya AOI 409 Tabla 5: cálculos de P y R de diferentes esquemas de determinación de visibilidad. El esquema P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 intersectaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares a RQ-OR mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-OR. Identifica cualquier objeto o que cumpla la condición c.R ∩ o.R = ∅ donde la celda c cumple q.P ∈ c.R también. Nuestro programa de simulación pobló 100 mil entidades de objetos y 10 mil entidades de usuarios en un espacio unitario 2D, [0, 1) × [0, 1). Las entidades pobladas están uniformemente ubicadas en el espacio unitario. La longitud del lado de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa el 5% al 14% de la longitud del lado del espacio unitario. El programa realiza pruebas de intersección entre todas las entidades de usuario y objeto exhaustivamente y calcula los valores de las medidas P, R y E (mostrados en la Tabla 5). 6.1.3 Resultados Experimentales Distribución de las medidas P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar un rango de AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero a una menor exhaustividad. Por ejemplo, el 5% de la longitud del lado de un AOI de usuario detecta todos los objetos cuya longitud del lado del AOI es al menos del 5%. Por lo tanto, cada objeto recuperado por RQ-OP está garantizado de ser completamente renderizado en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, por lo tanto sufre de demasiados objetos faltantes que deberían ser renderizados. De manera similar, el usuario cuya AOI es más amplia que cualquier otra AOI no puede perderse ningún objeto que deba ser renderizado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de objetos que aparezcan, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia visible máxima de cualquier objeto en el sistema, lo que puede provocar una degradación significativa del sistema. Distribución de la medida E: La Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-OR (rejilla de 100 × 100) y RQ-OR. Segundo, la curva de tendencia del gráfico de Precisión-a-E-medida de RQ-OR muestra similitud con la de ACQ-OR. Parece que las dos curvas yacen en la misma curva imaginaria, lo que indica que ACQ-OR hereda las propiedades de RQ-OR. Efecto del Tamaño de la Rejilla: La Figura 9 muestra la diferencia estadística de los valores de la medida E de siete esquemas de partición de rejilla diferentes (utilizando ACQ-OR) y un modelo RQ-OP. Utilizamos un diagrama de caja y bigotes para mostrar tanto los valores de la mediana como las varianzas de las distribuciones de la medida E y los valores atípicos de cada esquema. También trazamos el valor medio de las medidas RQ-OP E (línea verde) con fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medida E están fuertemente concentrados alrededor de los valores medianos, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida E más pequeño. El esquema RQ-OP mostró una mayor variabilidad en su calidad que otros esquemas, lo cual se debe en gran medida a las diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-OR mejora de manera más evidente que la de RQOP. A partir de la Figura 9, el esquema de cuadrícula de 20x20 tuvo una mejor medida E en la Tabla 6: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno de movimiento lento (v = 1). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.48 0.82 4.30 Tabla única incremental 2.08 0.80 2.88 Dos tablas 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100K objetos móviles y 10K usuarios móviles en un entorno altamente dinámico (v = 15). Tiempo de actualización de indexación Tiempo de evaluación Total Tabla única completa 3.65 0.77 4.42 Tabla única incremental 3.49 0.74 4.23 Dos tablas 1.75 0.93 2.68 valor en un entorno priorizado que en un entorno con igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula de 20x20 recupera una mayor calidad de conjuntos visibles que la RQ-OP. 6.2 Evaluación de la indexación de bordes En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de bordes. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido en actualizar todas las entidades en movimiento y calcular los conjuntos visibles para cada celda. También experimentamos con diferentes políticas de particionamiento de cuadrícula y las comparamos con soluciones de búsqueda exhaustiva. 6.2.1 Configuración de la simulación Implementamos algoritmos de indexación de bordes en C y ejecutamos los experimentos en un procesador Itanium de 64 bits a 900MHz con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizada para almacenar estructuras de nodos y aristas. 6.2.2 Resultados Experimentales Costo de Monitoreo Periódico: Las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de aristas al variar v. La velocidad de movimiento de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6), el método de indexación de aristas incremental supera al de actualización completa, debido a la reducción de actualizaciones de índices; el enfoque de dos tablas supera el rendimiento de los esquemas de una sola tabla, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de una sola tabla debido a la eliminación secuencial de tokens. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índices y evaluaciones de celdas en un entorno altamente dinámico donde coexisten objetos que se mueven lentamente y dinámicamente. En comparación con los resultados mostrados en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos de movimiento subyacentes. Sin embargo, la mejora en el rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la que se observa en un entorno de movimiento lento. Efecto del Tamaño de la Rejilla: Cuántas actualizaciones de objetos y evaluaciones de celdas se pueden admitir en un período de tiempo dado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos diferentes de cálculo de visibilidad: dos métodos de búsqueda exhaustiva impulsados por cálculo; y un método de indexación de bordes de dos tablas con diferentes tamaños de cuadrícula. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recuperación (R) Precisión (P) Consulta de rango del 5% Consulta de rango del 6% Consulta de rango del 7% Consulta de rango del 8% Consulta de rango del 9% Consulta de rango del 10% Consulta de rango del 11% Consulta de rango del 12% Consulta de rango del 13% Consulta de rango del 14% Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) Medida E Optimalidad RQ-OP RQ-OR ACQ-OR (celdas de cuadrícula de 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ-OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Medida E Esquema de Prueba de Visibilidad Mediana de RQ-OP Figura 7: Distribución de P y R medidos por RQ-OP. Figura 8: Valor de la medida E en función del valor de Precisión P cuando β = 1. Figura 9: Valor de la medida E en función del esquema de particionamiento de la cuadrícula ACQ-QR cuando β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # de Actualizaciones de Objetos (10K consultas) Tiempo Total Transcurrido (segundos) Tamaño de la Población = 100K, rango visible = 5−15%, movilidad = 1% Búsqueda Exhaustiva (Prueba de Intersección) Búsqueda Exhaustiva (Medida de Distancia Euclidiana) Indexación de Bordes de Dos Tablas 200x200 Indexación de Bordes de Dos Tablas 100x100 Indexación de Bordes de Dos Tablas 50x50 Figura 10: Tiempo total transcurrido de diferentes esquemas de indexación. Los métodos de búsqueda exhaustiva no mantienen ningún resultado intermedio. Simplemente calculan si un punto de usuario dado está dentro de un área de interés de objeto dada. Pueden tolerar el comportamiento impredecible del movimiento de los objetos. A pesar de su diseño simple y su capacidad de extensión, sufren de largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y evaluaciones de celdas es lineal con respecto a la longitud promedio de los lados del objeto AOI. Debido a que la longitud del lado está representada por unidades de celda, un aumento en el número de celdas aumenta las longitudes de los lados de manera proporcional. La Figura 10 ilustra que los resultados de la simulación medida coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis. 7. CONCLUSIÓN Y TRABAJOS FUTUROS Para apoyar la extensibilidad y escalabilidad dinámicas en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objeto, y su método de indexación eficiente, el indexado de bordes. Comparado con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de objetos que aparecen repentinamente que se puede observar fácilmente en los entornos virtuales existentes a costa de una mayor complejidad en la indexación. Nuestro modelo de indexación de bordes, sin embargo, puede superar dicha mayor complejidad de indexación indexando extensiones espaciales a nivel de borde y no a nivel de nodo en un submundo dividido en cuadrículas, y fue validado a través de análisis cuantitativos y simulaciones. Sin embargo, por ahora nuestro indexado de bordes todavía conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de bordes para hacer que la complejidad de indexación sea constante. Una vez que la complejidad de indexación se vuelva constante, planeamos indexar extensiones espaciales en 3D y datos de geometría de múltiples resoluciones. Esperamos que nuestro indexado de bordes pueda contribuir al despliegue exitoso de entornos de juego de próxima generación. REFERENCIAS [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Desafíos en el diseño de aplicaciones interactivas distribuidas modernas, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Col. Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis del tráfico de juegos: Una perspectiva de MMORPG, en NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Características del tráfico de un juego de rol multijugador masivo en línea y sus implicaciones, en NetGames 05, Octubre 2005. [4] Philip Rosedale y Cory Ondrejka, Habilitando mundos en línea creados por jugadores con computación en malla y streaming, Revista Gamastutra, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, Septiembre 2003. [5] Eyal Teler y Dani Lischinski, Streaming de escenas 3D complejas para recorridos remotos., Comput. Gráfico. Foro, vol. 20, no. 3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, Una arquitectura de red para renderizado remoto, en el Segundo Taller Internacional sobre Simulación Interactiva Distribuida y Aplicaciones en Tiempo Real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Algoritmo de visualización adaptativa para tasas de cuadros interactivas durante la visualización de entornos virtuales complejos, en SIGGRAPH 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki y James Kaufman, Indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, Soporte para actualizaciones frecuentes en árboles R: Un enfoque de abajo hacia arriba, en VLDB, páginas 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación en memoria principal de consultas de monitoreo sobre objetos en movimiento, Distrib. Bases de datos paralelas, vol. 15, núm. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, Un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia SIGMOD, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación con restricciones de velocidad: técnicas escalables para consultas continuas sobre objetos en movimiento, IEEE Transactions on Computers, vol. 51, núm. 10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+rtree: Indexación eficiente para bases de datos de objetos en movimiento, en DASFAA 03, Washington, DC, EE. UU., 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Recuperación de Información, 2da edición, Depto. de Ciencias de la Computación, Universidad de Glasgow, 1979. 411