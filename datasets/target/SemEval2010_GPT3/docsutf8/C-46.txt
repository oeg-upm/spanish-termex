TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. 

ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50