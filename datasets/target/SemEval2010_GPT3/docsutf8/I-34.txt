Resolviendo conflictos e inconsistencias en organizaciones virtuales reguladas por normas, Wamberto Vasconcelos Dept. Las organizaciones virtuales regidas por normas definen, regulan y facilitan el intercambio coordinado de recursos y la resolución de problemas en sociedades de agentes. Con una explicación detallada de las normas, la apertura en las organizaciones virtuales se puede lograr: los nuevos componentes, diseñados por diversas partes, pueden ser fácilmente incorporados. Nos enfocamos en organizaciones virtuales realizadas como sistemas multiagente, en las cuales agentes humanos y de software interactúan para lograr objetivos individuales y globales. Sin embargo, cualquier descripción realista de las normas debería abordar su naturaleza dinámica: las normas cambiarán a medida que los agentes interactúen entre sí y con su entorno. Debido a la naturaleza cambiante de las normas o a las normas derivadas de diferentes organizaciones virtuales, habrá situaciones en las que una acción sea simultáneamente permitida y prohibida, es decir, surge un conflicto. Asimismo, habrá situaciones en las que una acción esté tanto obligada como prohibida, es decir, surge una inconsistencia. Introducimos un enfoque, basado en unificación de primer orden, para detectar y resolver tales conflictos e inconsistencias. En nuestra solución propuesta, anotamos una norma con el conjunto de valores que sus variables no deben tener para evitar un conflicto o una inconsistencia con otra norma. Nuestro enfoque acomoda de manera ordenada las interrelaciones dependientes del dominio entre acciones y los conflictos/inconsistencias indirectos que estos pueden causar. Más generalmente, podemos capturar una noción útil de delegación de acciones y normas entre agentes (y roles) y utilizarla para abordar conflictos/inconsistencias causados por la delegación de acciones. Ilustramos nuestro enfoque con un ejemplo de e-Ciencia en el que agentes respaldan servicios de Grid. Categorías y Descriptores de Asignaturas I.2.4 [Inteligencia Artificial]: Aplicaciones y Sistemas Expertos en Derecho; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente Términos Generales Algoritmos, Teoría 1. Las organizaciones virtuales (VOs) facilitan el intercambio coordinado de recursos y la resolución de problemas que involucran a diversas partes geográficamente remotas [9]. Los VOs definen y regulan las interacciones (facilitando así la coordinación) entre agentes de software y/o humanos que se comunican para lograr objetivos individuales y globales [16]. Los VOs se realizan como sistemas multiagente y una característica muy deseable de tales sistemas es la apertura, mediante la cual los nuevos componentes diseñados por otras partes se integran sin problemas. El uso de normas, es decir, prohibiciones, permisos y obligaciones, en la especificación y operación de sistemas multiagente (MASs) es un enfoque prometedor para lograr la apertura [2, 4, 5, 6]. Las normas regulan el comportamiento observable de agentes de software auto-interesados y heterogéneos, diseñados por diversas partes que pueden no confiar del todo entre sí [3, 24]. Sin embargo, los VOs regulados por normas pueden experimentar problemas cuando las normas asignadas a sus agentes están en conflicto (es decir, una acción está simultáneamente prohibida y permitida) o son inconsistentes (es decir, una acción está simultáneamente prohibida y obligada). Proponemos un medio para detectar y resolver automáticamente conflictos e inconsistencias en los VO regulados por normas. Hacemos uso de la unificación de términos de primer orden [8] para averiguar si y cómo se superponen las normas en su influencia (es decir, los agentes y los valores de los parámetros en las acciones de los agentes que las normas pueden afectar). Esto permite una solución detallada en la que se reduce la influencia de normas conflictivas o inconsistentes para conjuntos particulares de valores. Por ejemplo, las normas en las que el agente x tiene permitido enviar la oferta (ag1, 20) y el agente ag2 tiene prohibido enviar la oferta (y, z) (donde x, y, z son variables y ag1, ag2, 20 son constantes) están en conflicto porque sus agentes, acciones y términos (dentro de las acciones) se unifican. Resolvemos el conflicto anotando normas con conjuntos de valores que sus variables no pueden tener, reduciendo así su influencia. En nuestro ejemplo, el conflicto se evita si requerimos que la variable y no puede ser ag1 y que z no puede ser 20. Este documento está organizado de la siguiente manera. En la siguiente sección proporcionamos una definición minimalista para los VOs regulados por normas. En la sección 3 definimos formalmente los conflictos de normas, y explicamos cómo se detectan y resuelven. En la sección 4 describimos cómo la maquinaria de la sección anterior puede adaptarse para detectar y resolver inconsistencias normativas. En la sección 5 describimos cómo se utilizan nuestras normas limitadas en sociedades de agentes conscientes de las normas. En la sección 6 explicamos cómo nuestra maquinaria puede ser utilizada para detectar y resolver conflictos/inconsistencias indirectos, es decir, aquellos causados a través de relaciones entre acciones; extendemos y adaptamos la maquinaria para dar cabida a la delegación de normas. En la sección 7 ilustramos nuestro enfoque con un ejemplo de agentes de software regulados por normas que sirven a la Red. En la sección 8 revisamos el trabajo relacionado y en la sección 9 discutimos nuestras contribuciones y damos direcciones para trabajos futuros. 644 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. Las organizaciones virtuales permiten que diversas partes se unan para compartir recursos y participar en la resolución de problemas. Este paradigma ha encontrado fuertes aplicaciones en la orquestación de servicios web [14], la e-Ciencia [16] y la Red [9]. Los VOs, en su formulación más genérica, pueden ser vistos como artefactos de coordinación, permitiendo que agentes de software y humanos participen en formas sofisticadas de interacción. Representamos formalmente nuestros VO como máquinas de estados finitos en las que las acciones de los agentes individuales etiquetan los bordes entre estados discretos. Esto nos proporciona un denominador común más bajo: hay formas mucho más sofisticadas, convenientes y expresivas de representar las interacciones entre agentes (por ejemplo, AUML [19] e instituciones electrónicas [20], por nombrar algunas), pero para generalizar nuestro enfoque, asumiremos que cualquier formalismo de nivel superior puede ser mapeado a una máquina de estados finitos (posiblemente con cierta pérdida de expresividad). Mostramos en la Figura 1 un simple VO representado gráficamente como una máquina de estados finitos. Las etiquetas en los bordes con//?>=<89:;0 p(X)  q(Y,Z) //?>=<89:;1 s(A,B) //?>=<89:;/.-,()*+2 Figura 1: Ejemplo de VO como una Máquina de Estados Finitos que conectan los estados son fórmulas atómicas de primer orden, denotadas genéricamente como ϕ; representan acciones realizadas por agentes individuales. Definimos nuestras organizaciones virtuales de la siguiente manera: DEF. 1. Una organización virtual I es el triple S, s0, E, T donde S = {s1, . . . , sn} es un conjunto finito y no vacío de estados, s0 ∈ S es el estado inicial, E es un conjunto finito de aristas (s, s , ϕ), s, s ∈ S conectando s con s con una fórmula atómica de primer orden ϕ como etiqueta, y T ⊆ S es el conjunto de estados terminales. Ten en cuenta que los bordes están dirigidos, por lo que (s, t, ϕ) = (t, s, ϕ). La muestra VO de la Figura 1 se representa formalmente como I = {0, 1, 2}, 0, {(0, 0, p(X)), (0, 1, q(Y, Z)), (1, 2, s(A, B)}, {2}. Suponemos una cuantificación existencial implícita en cualquier variable en ϕ, de modo que, por ejemplo, s(A, B) representa ∃A, B s(A, B). Los VO deben permitir dos tipos de no determinismo correspondientes a las elecciones que los agentes autónomos pueden hacer, a saber, i) el que surge cuando hay más de un borde que sale de un estado; y ii) el que surge de las variables en las fórmulas ϕ que etiquetan un borde, para las cuales el agente que realiza la acción instancia. Estos tipos de no determinismo son deseables ya que ayudan a definir mecanismos de coordinación genéricos y flexibles. Otro concepto importante que utilizamos son los roles de los agentes en las Organizaciones Virtuales (OV). Los roles, tal como se explotan en, por ejemplo, [18] y [20], nos ayudan a abstraernos de los agentes individuales y definir un patrón de comportamiento al cual cualquier agente que adopte un rol debería conformarse. Además, todos los agentes con el mismo rol tienen garantizados los mismos derechos, deberes y oportunidades. Haremos uso de dos conjuntos finitos y no vacíos, Agentes = {ag1, . . . , agn} y Roles = {r1, . . . , rm}, que representan, respectivamente, los conjuntos de identificadores de agentes y etiquetas de roles. Nos referimos genéricamente a los términos de primer orden, es decir, constantes, variables y funciones (anidadas) como τ. 2.1 Semántica de los VO La especificación de un VO como una máquina de estados finitos da lugar a un conjunto posiblemente infinito de historias de comportamientos computacionales, en las que se registran las acciones que etiquetan los caminos desde el estado inicial hasta un estado final. Aunque las acciones que conforman un VO se llevan a cabo de manera distribuida, proponemos un registro global explícito de todos los eventos. En la práctica, esto se puede lograr si requerimos que los agentes individuales declaren/informen las acciones que han llevado a cabo; esto asume agentes de confianza, naturalmente. Para registrar la autoría de la acción, anotamos las fórmulas con la identificación única de los agentes. Nuestra cuenta global explícita de todos los eventos es un conjunto de fórmulas atómicas fundamentales ϕ, es decir, solo permitimos que aparezcan constantes como términos de las fórmulas. Cada fórmula es un registro veraz de una acción especificada en el VO. Sin embargo, hay que tener en cuenta que en la especificación de VO no restringimos la sintaxis de las fórmulas: las variables pueden aparecer en ellas, y cuando un agente realiza una acción real, entonces cualquier variable de la acción especificada debe asignarse valores. Por lo tanto, definimos: DEF. 2. Un estado de ejecución global de un VO, denotado como Ξ, es un conjunto finito, posiblemente vacío, de tuplas a : r, ¯ϕ, t donde a ∈ Agentes es un identificador de agente, r ∈ Roles es una etiqueta de rol, ¯ϕ es una fórmula atómica de primer orden concreta, y t ∈ IN es una marca de tiempo. Por ejemplo, ag1:comprador, p(a, 34), 20 indica que el agente ag1 adoptando el rol de comprador realizó la acción p(a, 34) en el instante 20. Dado un VO I = S, s0, E, T, un estado de ejecución Ξ y un estado s ∈ S, podemos definir una función que obtiene un posible próximo estado de ejecución, es decir, h(I, Ξ, s) = Ξ ∪ { a:r, ¯ϕ, t }, para un (s, s , ϕ) ∈ E. Dicha función h debe abordar los dos tipos de no determinismo mencionados anteriormente, así como la elección de los agentes potenciales que pueden llevar a cabo la acción y sus roles adoptados. También definimos una función para calcular el conjunto de todos los posibles estados de ejecución, h∗ (I, Ξ, s) = {Ξ ∪ { a: r, ¯ϕ, t }|(s, s , ϕ) ∈ E}. 2.2 VOs Regulados por Normas Abogamos por una separación de preocupaciones en la que la organización virtual se complementa con un conjunto explícito y separado de normas que regulan aún más el comportamiento de los agentes mientras participan en la puesta en marcha de una organización. La libertad de elección dada a los agentes (capturada a través del no determinismo de los VO, explicado anteriormente) debe ser limitada en algunas circunstancias. Por ejemplo, podríamos necesitar describir que quien llevó a cabo ϕ está obligado a llevar a cabo ϕ, de modo que si hay un punto de elección en el que ϕ aparece como etiqueta de un borde, entonces ese borde debería ser seguido. En lugar de incorporar aspectos normativos en el diseño de los agentes (por ejemplo, codificando explícitamente aspectos normativos en el comportamiento de los agentes) o en el propio VO (por ejemplo, abordando excepciones y comportamientos desviados en el mecanismo en sí), adoptamos la perspectiva de que un VO debería complementarse con un conjunto separado de normas que regulen aún más el comportamiento de los agentes mientras participan en la puesta en marcha de la organización. Esta separación de preocupaciones debería facilitar el diseño de los Sistemas Multiagente (MAS); sin embargo, los diferentes componentes (VOs y normas) deben unirse en algún momento del proceso de diseño. Nuestras normas están definidas de la siguiente manera: DEF. 3. Una norma, genéricamente referida como ν, es cualquier construcción de la forma Oτ:τ ϕ, Pτ:τ ϕ, o Fτ:τ ϕ, donde τ, τ son variables o constantes y ϕ es una fórmula atómica de primer orden. Adoptamos la notación de [18]: Oτ:τ ϕ representa una obligación para el agente τ que asume el rol τ de llevar a cabo ϕ; recordamos que τ, τ son variables, constantes y funciones aplicadas a términos (anidados). Pτ:τ ϕ y Fτ:τ ϕ representan, respectivamente, un permiso y una prohibición para el agente τ, desempeñando el rol τ para lograr ϕ. Supondremos que los tipos se utilizan para manipular adecuadamente variables de identificadores de agentes y etiquetas de roles. Proponemos representar formalmente las posiciones normativas de todos los agentes que llevan a cabo un VO. Por posición normativa nos referimos a la carga social asociada a los individuos [12], es decir, sus obligaciones, permisos y prohibiciones: 2 Agentes no confiables pueden ser acomodados en esta propuesta, si asociamos a cada uno de ellos un agente gobernador que supervise las acciones del agente externo e informe sobre ellas. Este enfoque fue introducido en [12] y se explica en la sección 5. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 645 DEF. 4. Un estado normativo global Ω es un conjunto finito y posiblemente vacío de tuplas ω = ν, td, ta, te donde ν es una norma como se mencionó anteriormente y td, ta, te ∈ IN son, respectivamente, el momento en que ν fue declarada (introducida), cuando ν se vuelve activa y cuando ν expira, td ≤ ta < te. Vale la pena notar que no requerimos que las fórmulas atómicas de las normas sean concretas: podrían contener variables. Suponemos una cuantificación universal implícita en las variables A, R de las normas XA:Rϕ (para las modalidades deónticas X ∈ {O, P, F}), de modo que, por ejemplo, PA:Rp(X, b, c) significa ∀A ∈ Agentes.∀R ∈ Roles.∃X.PA:Rp(X, b, c). También nos referimos a las tuplas en Ω como normas. Los estados normativos globales complementan los estados de ejecución de los VO con información sobre las posiciones normativas de los agentes individuales. Podemos relacionarlos a través de una función para obtener un estado de ejecución siguiente de VOs regulado por una norma, es decir, g(I, Ξ, s, Ω, t) = Ξ, donde t representa el tiempo de la actualización. Por ejemplo, podríamos querer que todas las acciones prohibidas se excluyan del próximo estado de ejecución, es decir, g(I, Ξ, s, Ω, t) = Ξ ∪ { a :r, ¯ϕ, t }, (s, s , ϕ) ∈ E y Fa:rϕ, td, ta, te ∈ Ω, ta ≤ t ≤ te. Podríamos desear igualmente que solo se elijan acciones permitidas para el próximo estado de ejecución. No legislamos, ni recomendamos de hecho, ninguna forma particular de regular las ONG. Sin embargo, ofrecemos bases simples para permitir la implementación de políticas arbitrarias. Del mismo modo que un estado normativo es útil para obtener el siguiente estado de ejecución de un VO, podemos usar un estado de ejecución para actualizar un estado normativo. Por ejemplo, podríamos querer eliminar cualquier obligación específica de un agente y rol, que ha sido llevada a cabo por ese agente y rol específico, es decir, f(Ξ, Ω) = Ω − Obls, Obls = { Oa:rϕ, td, ta, te ∈ Ω| a:r, ¯ϕ, t ∈ Ξ}. La gestión (es decir, la creación y actualización) de estados normativos globales es un área de investigación interesante. Se reporta un enfoque simple pero útil en [11]: las reglas de producción representan genéricamente cómo se deben actualizar las normas para reflejar lo que los agentes han hecho y qué normas se mantienen actualmente. En este documento nuestro enfoque no es proponer cómo deberían ser gestionadas las Ωs; asumimos que existe algún mecanismo que se encarga de eso. 3. CONFLICTOS NORMATIVOS Ahora definimos medios para detectar y resolver conflictos e inconsistencias normativas. Hacemos uso del concepto de unificación [1, 8] de términos de primer orden τ, es decir, constantes, variables o funciones (anidadas) con términos como parámetros. Inicialmente definimos las sustituciones: DEF. 5. Una sustitución σ es un conjunto finito y posiblemente vacío de pares x/τ, donde x es una variable y τ es un término. Definimos la aplicación de una sustitución de la siguiente manera: 1. c · σ = c para una constante c 2. x · σ = τ · σ si x/τ ∈ σ; de lo contrario, x · σ = x 3. pn (τ0, . . . , τn) · σ = pn (τ0 · σ, . . . , τn · σ). 4. (Xτ1:τ2 ϕ) · σ = X(τ1·σ):(τ2·σ)(ϕ · σ) 5. ν, td, ta, te · σ = (ν · σ), td, ta, te Donde X se refiere genéricamente a cualquiera de las modalidades deónticas O, P, F. La unificación entre dos términos τ, τ consiste en encontrar una sustitución σ (también llamada, en este contexto, el unificador de τ y τ) tal que τ · σ = τ · σ. Se han propuesto muchos algoritmos para resolver el problema de unificación, un tema fundamental en la demostración automatizada de teoremas [8], y trabajos más recientes ofrecen formas muy eficientes de obtener unificadores. Haremos uso de la siguiente definición: DEF. 6. La relación unify(τ, τ , σ) se cumple si y solo si existe un σ posiblemente vacío tal que τ · σ = τ · σ. También definimos la unificación de fórmulas atómicas como unificar(pn (τ0, . . . , τn), pn (τ0, . . . , τn), σ) lo cual se cumple si y solo si τi · σ = τi · σ, 0 ≤ i ≤ n. La relación de unificación verifica si una sustitución σ es realmente un unificador para τ, τ pero también puede usarse para encontrar dicho σ. Suponemos que unificar es una implementación adecuada de un algoritmo de unificación que i) siempre termina (posiblemente fallando, si no se puede encontrar un unificador); ii) es correcto; y iii) tiene una complejidad computacional lineal. 3.1 Detección de Conflictos Un conflicto normativo surge cuando una fórmula atómica que etiqueta un borde en el VO, es decir, una acción, está simultáneamente permitida y prohibida [13]. En este caso, ambas normas están en conflicto con respecto a sus agentes, roles y parámetros (términos) de acciones específicas. Proponemos utilizar la unificación para detectar cuándo se superponen una prohibición y un permiso y emplear el unificador para resolver el conflicto. Por ejemplo, PA:Rp(c, X) y Fa:bp(Y, Z) están en conflicto ya que se unifican bajo σ = {A/a, R/b, Y/c, X/d}. Si, sin embargo, las variables en Fa:bp(Y, Z) no obtienen los valores en σ, entonces no habrá conflictos. Por lo tanto, proponemos anotar las prohibiciones en Ω con unificadores, llamados conjuntos de conflictos, y utilizar estas anotaciones para determinar qué variables no pueden ser los variables de la prohibición en futuras unificaciones con el fin de evitar un conflicto. Cada prohibición se considera a partir de ahora como teniendo tal anotación, denotada como (Fτ1:τ2 ϕ) Σc, td, ta, te. Inicialmente, esta anotación está vacía. Proponemos reducir la influencia de las prohibiciones, dando así a los agentes más opciones en las acciones que pueden realizar. Un enfoque similar podría ser adoptado mediante la restricción de permisos, limitando así las acciones disponibles para los agentes. Cada una de estas políticas es posible: no legislamos sobre ninguna de ellas ni damos preferencia sobre ninguna. En este documento estamos interesados en formalizar dichas políticas dentro de un marco matemático simple. Una prohibición puede estar en conflicto con varias autorizaciones en Ω. Por lo tanto, debemos encontrar el conjunto máximo de pares conflictivos de permisos y prohibiciones en Ω, realizando una inspección por pares. Esto requiere identificar la sustitución entre dos pares de normas que caracteriza un conflicto. Esto se captura formalmente mediante la siguiente definición: DEF. 7. Surge un conflicto entre dos tuplas ω, ω ∈ Ω bajo una sustitución σ, denotado como cflct(ω, ω , σ), si se cumplen las siguientes condiciones: 1. ω = (Fτ1:τ2 ϕ) Σc, td, ta, te , ω = Pτ1:τ2 ϕ , td, ta, te 2. unificar(τ1, τ1, σ), unificar(τ2, τ2, σ), y unificar(ϕ, ϕ , σ) 3. |te − te| ≤ |ta − ta| Es decir, un conflicto de prohibición y permiso (condición 1) si, y solo si, los agentes y roles a los que se aplican y sus acciones, respectivamente, se unifican bajo σ (condición 2) y sus períodos de activación se superponen (condición 3). La sustitución σ, el conjunto de conflictos, unifica a los agentes, roles y fórmulas atómicas de un permiso y una prohibición. La anotación Σc no juega ningún papel al detectar conflictos, pero, como mostramos a continuación, debemos actualizar la anotación para reflejar nuevas restricciones y resolver conflictos. Por ejemplo, cflct( (Fa:bp(Y, d)) ∅, 1, 3, 5 , PA:Rp(c, X), 2, 3, 4 , {A/a, R/b, Y/c, Z/X}) se cumple. Definimos a continuación cómo obtenemos el conjunto de normas en conflicto de un estado normativo Ω: DEF. 8. El conjunto finito, posiblemente vacío, de normas en conflicto de un estado normativo Ω, denotado como CFLS(Ω), se define como CFLS(Ω) = { ω, ω , σ |ω, ω ∈ Ω, cflct(ω, ω , σ)} 3.2 Resolución de Conflictos Una forma detallada de resolver conflictos puede hacerse a través de la unificación. Detectamos la superposición de las influencias normativas, es decir, cómo afectan los comportamientos de los agentes en la VO, y limitamos el 646 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) influencia de la prohibición. Ilustramos con diagramas de Venn en la Figura 2 la superposición de las influencias normativas (izquierda) que caracterizan un conflicto y la reducción necesaria para resolver el conflicto (derecha). La ilustración muestra el espacio de valores posibles para p(X, Y) y p(X, Y) PA:Rp(c, X) Fa:bp(Y, Z) p(X, Y) Fa:bp(Y, Z) PA:Rp(c, X) Figura 2: Superposición de Influencia (Izquierda) y Restricción (Derecha) dos porciones de este espacio que definen el alcance de influencia de las normas PA:Rp(c, X) y Fa:bp(Y, Z). El alcance de estas normas se superponen, ilustrado por la intersección de las casillas a la izquierda, en acciones con valores, por ejemplo, a, b, p(c, 2), . . . , a, b, p(c, n). La reducción de la prohibición elimina la intersección: traslada el alcance de la influencia de la norma fuera de la influencia del permiso. Si hubiera múltiples superposiciones entre una prohibición y varias autorizaciones, lo cual es probable que ocurra, entonces la prohibición será restringida múltiples veces para desplazar el alcance de la norma y evitar todas las intersecciones. El algoritmo mostrado en la Figura 3 describe cómo obtenemos un conjunto de normas sin conflictos. Mapea un conjunto existente Ω posiblemente con el algoritmo de resolución de conflictos conflictResolution(Ω, Ω) entrada Ω salida Ω comenzar Ω := Ω para cada ω ∈ Ω tal que ω = (Fa:r ¯ϕ) Σc, td, ta, te hacer si ω, ω, σ ∈ CFLS(Ω) entonces Ω := Ω − {ω} fin si fin para para cada ω ∈ Ω tal que ω = (Fτ1:τ2 ϕ) Σc, td, ta, te hacer ΣMAX c := [ ω,ω,σc ∈CFLS(Ω) {σc} Ω := (Ω − {ω}) ∪ { (Fτ1:τ2 ϕ) (Σc ∪ ΣMAX c), td, ta, te } fin para fin Figura 3: Algoritmo para Resolver Conflictos en un Conjunto de Normas mapeando normas a un nuevo conjunto Ω en el que los conflictos (si los hay) están resueltos. El algoritmo forma Ω como un conjunto que es libre de conflictos, lo que significa que las prohibiciones están anotadas con un conjunto de conflictos que indica qué asignaciones para variables deben evitarse. Inicialmente, Ω se establece como Ω. El algoritmo opera en dos etapas. En la primera etapa (primera para cada bucle), eliminamos todas las prohibiciones conflictivas ω = (Fa:r ¯ϕ) Σc, td, ta, te con pares de agente/rol y fórmulas concretas en conflicto a : r y ¯ϕ: la única forma de resolver conflictos derivados de tales prohibiciones es eliminarlas por completo, ya que no podemos restringir una norma completamente concreta. En la segunda etapa (segunda para cada bucle), se examinan las prohibiciones restantes en Ω: el conjunto CFLS(Ω) contiene todos los conflictos entre permisos y las prohibiciones restantes en Ω representadas como tuplas ω, ω, σc, con σc representando el conjunto de conflictos. Dado que una prohibición puede tener conflictos con varias autorizaciones, el conjunto CFLS(Ω) puede contener más de una tupla para cada prohibición. Para proporcionar un Ω que refleje todos estos conflictos para una prohibición específica, debemos formar ΣMAX c que contenga todos los conjuntos de conflictos σc para una prohibición dada ω. El conjunto maximal se utiliza para actualizar la anotación de la prohibición. Es importante explicar la necesidad de actualizar el conjunto de prohibiciones del conflicto. Los estados normativos cambian como resultado de las acciones de los agentes [11]: las permisiones, prohibiciones y obligaciones existentes son revocadas y/o se establecen nuevas como resultado de las interacciones de los agentes con el entorno y otros agentes. Cada vez que se añadan nuevas normas, debemos verificar nuevos conflictos e inconsistencias. Si solo aplicamos nuestro algoritmo a un par que consiste en una norma antigua y una nueva, entonces se puede ahorrar algo de reprocesamiento de pares de normas antiguas (que ya fueron tratadas anteriormente). La eliminación de normas del conjunto Ω se aborda de manera eficiente: cada permiso que se vaya a eliminar debe ser verificado primero en busca de conflictos con cualquier prohibición existente (se puede evitar el reprocesamiento si registramos el conflicto en lugar de detectarlo nuevamente). Si hay un conflicto, entonces el conjunto de conflictos habrá sido registrado en la anotación de prohibiciones; este conjunto de conflictos es eliminado de la anotación de prohibiciones. La eliminación de obligaciones sigue un proceso similar. Las prohibiciones se eliminan sin necesidad de considerar sus relaciones con otras normas. Nuestro algoritmo es correcto en el sentido de que proporciona, para un Ω dado, un nuevo Ω en el que i) se han eliminado todas las prohibiciones fundamentales que entran en conflicto con los permisos; y ii) todas las prohibiciones anotadas restantes (Fτ:τ ¯ϕ) Σc, td, ta, te no se unificarán con ninguno de los permisos en Ω, siempre que el unificador no aparezca en Σc. El primer requisito se aborda con el primer bucle for each, que hace precisamente esto: elimina todas las prohibiciones de base que se unifican con una obligación. El segundo requisito se aborda mediante el segundo bucle for each: cada prohibición tiene su anotación Σc agregada con ΣMAX c, acomodando así los unificadores de todas las autorizaciones que se unifican con la prohibición. Es fácil ver que el algoritmo siempre termina: cada uno de sus dos bucles recorre un conjunto finito, procesando un elemento a la vez. El conjunto CFLS(Ω) se calcula en un número finito de pasos, al igual que las operaciones de conjunto realizadas dentro de cada bucle. El algoritmo tiene, sin embargo, complejidad exponencial, ya que el cálculo de CFLS(Ω) requiere una comparación de pares de todos los elementos en Ω. Ilustramos nuestro algoritmo con el siguiente ejemplo. Que exista el siguiente estado normativo global Ω: j (FA:Rp(X, Y)) {}, 2, 2, 9, Pa:rp(a, b), 3, 4, 8, (Fa:rp(a, b)) {}, 2, 4, 12 Pa:rp(d, e), 3, 4, 9, ff. El primer bucle elimina la prohibición terrestre, obteniendo así el siguiente Ω: j (FA:Rp(X, Y)) {}, 2, 2, 9, Pa:bp(c, d), 3, 4, 8, Pe:fp(g, h), 3, 4, 9, ff. Luego tenemos el siguiente conjunto de normas en conflicto CFLS(Ω): 8 < : * (FA:Rp(X, Y)) {}, 2, 2, 9, Pa:bp(c, d), 3, 4, 8, {A/a, R/b, X/c, Y/d} +, * (FA:Rp(X, Y)) {}, 2, 2, 9, Pe:fp(g, h), 3, 4, 9, {A/e, R/f, X/g, Y/h} +9 =; Para cada prohibición ω ∈ Ω recuperamos todos los elementos de w, w, σ ∈ CFLS(Ω) y recopilamos sus σ en ΣMAX c. El Ω final es así: 8 < : (FA:Rp(X, Y )) j {A/a, R/b, X/c, Y/d} {A/e, R/f, X/g, Y/h} ff , 2, 2, 9 , Pa:rp(a, b), 3, 4, 8 , Pa:rp(d, e), 3, 4, 9 , 9 = ; El conjunto anotado de conjuntos de conflictos debe entenderse como un registro de unificaciones pasadas, que informa cómo deben utilizarse las prohibiciones en el futuro para evitar conflictos con permisos. Mostramos en la Sección 5.1 cómo los agentes conscientes de las normas utilizan las anotaciones. 4. INCONSISTENCIAS NORMATIVAS Si se puede encontrar una sustitución σ que unifique una obligación y una prohibición, entonces se produce una situación de inconsistencia normativa [13]. La obligación exige que un agente realice una acción que está prohibida. Podemos reutilizar la maquinaria, presentada anteriormente para resolver conflictos entre permisos y prohibiciones, con el fin de a) detectar y b) resolver tales inconsistencias. Con la Definición 7, nosotros 3 El esfuerzo combinatorio ya no es necesario si en su lugar mantenemos un conjunto de normas sin conflictos: cada vez que se introduce una nueva norma, la comparamos con las existentes, haciendo así que el proceso de mantenimiento sea de complejidad lineal. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 647 expresa la naturaleza de un conflicto entre una prohibición y un permiso. De igual manera, una situación de inconsistencia puede ser definida reutilizando esta definición y reemplazando la modalidad deontica P con O. Podemos reutilizar la maquinaria para la resolución de conflictos, desarrollada previamente, para resolver inconsistencias. El algoritmo de resolución de conflictos se puede aplicar sin cambios para acumular un conjunto de conflictos máximo ΣMAX c para cada prohibición en Ω que se unifica con las obligaciones. 5. Sociedades de agentes conscientes de normas. Ahora describimos cómo nuestros VO regulados por normas dan lugar a sociedades de agentes conscientes de normas. Abordamos Sistemas Multiagentes abiertos y heterogéneos: acomodamos agentes externos proporcionándoles a cada uno de ellos un agente gobernador correspondiente [12]. Este es un tipo de chaperón que interactúa con un agente externo, y observa e informa sobre su comportamiento. Mostramos nuestra arquitectura en la Figura 4 a continuación: un número de Agentes Gobernadores Externos Espacio de Tuplas de Agentes ag1 £ ¢ ¡ gov1 ⇐⇒ . . . . . . . . . . . . Yo, s, Ξ, Ω Yo, s, Ξ, Ω · · · agn £ ¢ ¡ govn ⇐⇒ Figura 4: Arquitectura para Sociedades de Agentes Conscientes de Normas de agentes externos interactúan (indicado por el ) con sus agentes gobernadores correspondientes. Los agentes del gobernador tienen acceso a la descripción del VO, el estado actual de la promulgación del VO, el estado de ejecución global Ξ y el estado normativo global Ω. Los agentes del gobernador pueden escribir y leer de (indicado por el ⇐⇒) un espacio de memoria compartida (por ejemplo, una solución tipo pizarra implementada como un espacio de tuplas), actualizando la configuración global (indicada por el ) para reflejar la dinámica de la ejecución del VO. Los agentes gubernamentales son necesarios porque no podemos anticipar ni legislar sobre el diseño o comportamiento de agentes externos. A continuación, representamos cómo los pares de gobernador/agentes externos trabajan juntos: cualquier elección no determinista en el VO es decidida por el agente externo; cualquier aspecto normativo es considerado por el agente gobernador. El agente gobernador representa el agente externo dentro del VO. Como tal, tiene el identificador único del agente externo. El agente gobernador lleva un registro de todos los roles que el agente externo está desempeñando actualmente: en nuestros VO, es posible que los agentes asuman más de un rol simultáneamente. Definimos en la Figura 5 cómo funcionan los agentes gobernadores: utilizamos un programa lógico con este propósito. Mostramos 1 main(Id, Roles) ← 2 obtener tupla( I, s, Ξ, Ω )∧ 3 terminar(Id, Roles, I, Ξ, Ω) 4 main(Id, Roles) ← 5 obtener tupla( I, s, Ξ, Ω )∧ 6 filtrar normas(Id, Roles, Ω, ΩId )∧ 7 discutir normas(Id, Roles, I, s, Ξ, ΩId , Acciones)∧ 8 actualizar tupla(Roles, Acciones, NuevosRoles)∧ 9 main(Id, NuevosRoles) Figura 5: Agente Gobernador como un Programa Lógico las líneas de nuestras cláusulas numeradas 1-9. La primera cláusula (líneas 1-3) describe la condición de terminación: get tuple/1 (línea 2) recupera I, s, Ξ, Ω del espacio de tuplas compartido y terminate/4 verifica si la ejecución actual de VO (registrada en Ξ) ha llegado a su fin. El equipo de agentes del gobernador sincroniza su acceso al espacio de tuplas [12], asegurando así que cada uno tenga la oportunidad de funcionar. La segunda cláusula (líneas 4-9) representa un bucle genérico cuando la condición de terminación de la primera cláusula no se cumple. En este caso, la tupla se recupera nuevamente (línea 5) y el agente gobernador procede (línea 6) a analizar el estado normativo global actual Ω con el objetivo de obtener el subconjunto ΩId ⊆ Ω de normas que hacen referencia al agente Id bajo los roles Roles. El predicado filter norms/4 recopila las normas que se aplican al agente Id (el agente externo del agente gobernador). En la línea 7, el agente gobernador, en posesión de las normas aplicables y otra información relevante, interactúa con el agente externo para decidir sobre un conjunto de Acciones que cumplen con las normas; estas acciones se utilizarán para actualizar (línea 8) el estado de ejecución global Ξ. En el proceso de actualizar el estado de ejecución, un nuevo conjunto de roles debe ser asignado al agente externo, representado como NewRoles. El agente gobernador sigue en bucle (línea 9) utilizando el identificador del agente externo y su nuevo conjunto de roles. 5.1 Uso de normas anotadas Ahora explicamos cómo los agentes conscientes de las normas utilizan normas anotadas. Lo hacemos a través de la definición de comprobación de predicado/2, que se cumple si su primer argumento, una acción candidata (en el formato de los elementos de Ξ de la Def. 2), está dentro de la influencia de una prohibición anotada ω, su segundo parámetro. La definición, como un programa lógico, se muestra en la Figura 6. Comprueba (línea 4) si el identificador del agente 1 check(Action, ω) ← 2 Action = a:r, ¯ϕ, t ∧ 3 ω = (Fτ1:τ2 ϕ) Σc, td, ta, te ∧ 4 unificar(a, τ1, σ) ∧ unificar(r, τ2, σ) ∧ unificar( ¯ϕ, ϕ, σ)∧ 5 para todo(σ , (σc ∈ Σc, unificar(σc, σ, σ )), MGUs)∧ 6 MGUs = ∅∧ 7 ta ≤ t ≤ te Figura 6: Comprobar si la Acción está dentro de la Influencia de la Norma Recortada y el rol de la acción se unifica con los términos apropiados τ1, τ2 de ω y que las acciones ¯ϕ, ϕ mismas se unifican, todo bajo el mismo unificador σ. Luego verifica (líneas 5-6) que σ no unifica con ninguno de los conjuntos de conflictos en Σc. Finalmente, en la línea 7 se comprueba si el tiempo de la acción está dentro de la influencia temporal normativa. La verificación de la no unificación de σ con ningún elemento de Σc merece una explicación. Los elementos de Σc son unificadores que indican qué valores no pueden tener las variables de la norma, es decir, representan vacíos en el alcance original de la influencia de las normas. El test equivale a preguntar si la acción está fuera de tales brechas, es decir, si la acción se encuentra dentro del alcance limitado de influencia de la norma. 6. En nuestra discusión anterior, se detectaron conflictos y inconsistencias normativas a través de una comparación directa de las fórmulas atómicas que representan la acción. Sin embargo, los conflictos e inconsistencias también pueden surgir indirectamente a través de las relaciones entre acciones. Por ejemplo, si p(X) equivale a q(X, X), entonces las normas PA:Rp(X) y FA:Rq(X, X) están en conflicto, ya que PA:Rp(X) se puede reescribir como PA:Rq(X, X) y, por lo tanto, tenemos tanto PA:Rq(X, X) como FA:Rq(X, X). En la discusión a continuación nos concentramos en el conflicto de normas, pero la inconsistencia normativa se puede abordar de manera similar, si cambiamos las modalidades deonticas de P por O. Las relaciones entre acciones dependen del dominio. Los diferentes dominios tienen formas distintas de relacionar sus acciones; los ingenieros construyen ontologías para representar dichas relaciones. Proponemos un medio simple para tener en cuenta tales relaciones y mostrar cómo estas pueden estar conectadas a los mecanismos introducidos anteriormente. En lugar de utilizar formalismos sofisticados para la construcción de ontologías, empleamos un conjunto de axiomas de dominio, definidos a continuación: DEF. 9. Los axiomas de dominio, denotados como Δ, son un conjunto finito y posiblemente vacío de fórmulas ϕ → (ϕ1 ∧ · · · ∧ ϕn) donde ϕ, ϕi, 1 ≤ i ≤ n, son fórmulas atómicas de primer orden. Nuestro ejemplo anterior puede ser capturado por Δ = {(p(X) → q(X, X)), (q(X, X) → p(X))}. Al representar y manipular explícitamente el conocimiento del dominio logramos generalidad: la misma maquinaria puede ser utilizada en diferentes dominios. Un conjunto de normas puede tener diferentes conflictos e inconsistencias, para distintos dominios de aplicación. 648 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 649 650 La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 651