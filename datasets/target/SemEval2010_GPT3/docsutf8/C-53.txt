Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir "DR)." ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer correcciones a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.

IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.
Traducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7