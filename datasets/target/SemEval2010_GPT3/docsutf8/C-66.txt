Programación basada en heurísticas de cargas de trabajo de servicios web compuestos Thomas Phan Wen-Syan Li Centro de Investigación IBM Almaden 650 Harry Rd. Los servicios web pueden ser agregados para crear flujos de trabajo compuestos que proporcionen funcionalidad simplificada para usuarios humanos u otros sistemas. Aunque los estándares de la industria y la investigación reciente han buscado definir las mejores prácticas y mejorar la composición del flujo de trabajo de extremo a extremo, un área que no ha sido completamente explorada es la programación de las solicitudes de servicios web de los flujos de trabajo para la provisión real de servicios en un entorno multinivel y multiorganizacional. Este problema es relevante para los escenarios empresariales modernos donde los procesos comerciales dentro de un flujo de trabajo deben completarse dentro de los límites definidos por la calidad de servicio (QoS). Debido a que estos procesos comerciales son consumidores de servicios web, las solicitudes de servicio deben ser mapeadas y programadas entre múltiples proveedores de servicios web, cada uno con su propio acuerdo de nivel de servicio negociado. En este documento proporcionamos heurísticas para programar solicitudes de servicio de múltiples flujos de trabajo de procesos comerciales a proveedores de servicios web de manera que se maximice una métrica de valor comercial en todos los flujos de trabajo. Mostramos que un algoritmo de búsqueda genética es apropiado para realizar esta programación, y a través de experimentación demostramos que nuestro algoritmo escala bien hasta mil flujos de trabajo y produce mejores asignaciones que enfoques tradicionales. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-aplicaciones distribuidas; D.2.8 [Ingeniería de Software]: Métricas-medidas de complejidad, medidas de rendimiento 1. INTRODUCCIÓN Los servicios web pueden ser compuestos en flujos de trabajo para proporcionar funcionalidad integrada de principio a fin para usuarios humanos u otros sistemas. Aunque los esfuerzos de investigación previos han examinado formas de automatizar de manera inteligente la composición de servicios web en flujos de trabajo (por ejemplo, [1, 9]), un problema importante que aún persiste es la asignación de solicitudes de servicios web a los proveedores de servicios web subyacentes en un escenario de tiempo de ejecución multinivel dentro de ciertas restricciones. En este documento abordamos este problema de programación y examinamos medios para gestionar un gran número de flujos de trabajo de procesos comerciales de manera escalable. El problema de programar solicitudes de servicios web a proveedores es relevante para los dominios comerciales modernos que dependen de la provisión de servicios de múltiples niveles. Considera el ejemplo mostrado en la Figura 1 que ilustra nuestro espacio de problemas. Los flujos de trabajo comprenden múltiples procesos comerciales relacionados que son consumidores de servicios web; aquí asumimos que los flujos de trabajo representan servicios solicitados por clientes o sistemas automatizados y que el flujo de trabajo ya ha sido compuesto con una herramienta de coreografía existente. Estos flujos de trabajo son luego enviados a un portal (no mostrado) que actúa como un agente de programación entre los consumidores del servicio web y los proveedores del servicio web. En este ejemplo, un flujo de trabajo podría representar las acciones necesarias para crear un itinerario de vacaciones, donde un proceso empresarial solicita la reserva de un boleto de avión, otro proceso empresarial solicita una habitación de hotel, y así sucesivamente. Cada una de estas solicitudes apunta a un tipo de servicio en particular (por ejemplo, reservas de aerolíneas, reservas de hoteles, reservas de autos, etc.), y para cada tipo de servicio, hay múltiples instancias de proveedores de servicios que publican una interfaz de servicio web. Un desafío importante es que los flujos de trabajo deben cumplir con alguna métrica de calidad de servicio (QoS), como el tiempo de finalización de extremo a extremo de todos sus procesos comerciales, y que cumplir o no con este objetivo resulta en la asignación de una métrica de valor comercial cuantitativo para el flujo de trabajo; intuitivamente, se desea que todos los flujos de trabajo cumplan con sus respectivos objetivos de QoS. Además, aprovechamos la idea de que los acuerdos de servicio de QoS suelen ser acordados entre los proveedores de servicios web y el agente de programación de tal manera que los proveedores anuncian un cierto nivel de QoS garantizado al programador en función de condiciones de tiempo de respuesta y concurrencia máxima disponible. El problema resultante es entonces programar y asignar las solicitudes de procesos comerciales para tipos de servicio a uno de los proveedores de servicios para ese tipo. La programación debe realizarse de tal manera que se maximice el valor comercial agregado en todos los flujos de trabajo. En la Sección 3 planteamos el escenario como un problema combinatorio y utilizamos un algoritmo de búsqueda genética [5] para encontrar la mejor asignación de solicitudes de servicios web a proveedores. Este enfoque converge hacia una asignación que maximiza el valor comercial general para todos los flujos de trabajo. En la Sección 4 mostramos a través de experimentación que esta heurística de búsqueda encuentra asignaciones mejores que otros algoritmos (codicioso, round-robin y proporcional). Además, este enfoque nos permite escalar el número de flujos de trabajo simultáneos (hasta mil flujos de trabajo en nuestros experimentos) y aún así encontrar horarios efectivos. 2. TRABAJO RELACIONADO En el contexto de asignación y programación de servicios, [11] mapea llamadas de servicios web a servidores potenciales utilizando programación lineal, pero su trabajo se centra en mapear solo flujos de trabajo individuales; nuestro enfoque principal está en programar de manera escalable múltiples flujos de trabajo (hasta 30 tipos de servicios SuperHotels.com Proceso de Negocio Proceso de Negocio Flujo de Trabajo ... Proceso de Negocio Proceso de Negocio ... HostileHostels.com IncredibleInns.com Proceso de Negocio Proceso de Negocio Proceso de Negocio ... Proceso de Negocio Proveedor de Servicios SkyHighAirlines.com SuperCrazyFlights.com Proceso de Negocio . . . . . . Acuerdo de Servicio de Calidad de Servicio (QoS) Publicitado CarRentalService.com Figura 1: Un escenario de ejemplo que muestra la interacción entre procesos comerciales en flujos de trabajo y proveedores de servicios web. Cada proceso empresarial accede a un tipo de servicio y luego se asigna a un proveedor de servicios para ese tipo, a uno mil como mostraremos más adelante, utilizando diferentes métricas empresariales y una heurística de búsqueda. [10] presenta un enfoque de aprovisionamiento dinámico que utiliza técnicas predictivas y reactivas para la entrega de aplicaciones de Internet multinivel. Sin embargo, las técnicas de aprovisionamiento no consideran los desafíos enfrentados cuando hay planes alternativos de ejecución de consultas y fuentes de datos replicadas. [8] presenta un mecanismo de programación basado en retroalimentación para sistemas multinivel con bases de datos de back-end, pero a diferencia de nuestro trabajo, asume un acoplamiento más estrecho entre los diversos componentes del sistema. Nuestro trabajo también se basa en investigaciones previas sobre programación. El problema clásico de programación de talleres, demostrado como NP-completo [4] [3], es similar al nuestro en el sentido de que las tareas dentro de un trabajo deben ser programadas en maquinaria (cf. nuestro escenario es que los procesos comerciales dentro de un flujo de trabajo deben ser programados en proveedores de servicios web). Las diferencias más destacadas son que las máquinas solo pueden procesar un trabajo a la vez (asumimos que los servidores pueden realizar múltiples tareas pero con un rendimiento degradado y un nivel máximo de concurrencia), las tareas dentro de un trabajo no pueden ejecutarse simultáneamente en diferentes máquinas (asumimos que los procesos comerciales pueden asignarse a cualquier servidor disponible), y la métrica principal de rendimiento es el makespan, que es el tiempo que tarda la última tarea de todos los trabajos en completarse (y como mostraremos más adelante, optimizar el makespan no es suficiente para programar los procesos comerciales, lo que requiere diferentes métricas). 3. En esta sección describimos nuestro modelo y discutimos cómo podemos encontrar asignaciones de programación utilizando un algoritmo de búsqueda genética. 3.1 Modelo Basamos nuestro modelo en el escenario simplificado mostrado en la Figura 1. Específicamente, asumimos que los usuarios o sistemas automatizados solicitan la ejecución de un flujo de trabajo. Los flujos de trabajo comprenden procesos comerciales, cada uno de los cuales realiza una invocación de servicio web a un tipo de servicio. Además, los procesos comerciales tienen un orden en el flujo de trabajo. La disposición y ejecución de los procesos comerciales y el flujo de datos entre ellos son gestionados por una herramienta de composición o coreografía (por ejemplo, [1, 9]). Aunque los lenguajes de composición pueden utilizar mecanismos sofisticados de control de flujo como ramas condicionales, para simplificar asumimos que los procesos se ejecutan secuencialmente en un orden dado. Este escenario puede ser extendido de forma natural a relaciones más complejas que pueden ser expresadas en BPEL [7], el cual define cómo interactúan los procesos de negocio, se intercambian mensajes, se ordenan actividades y se manejan excepciones. Debido a limitaciones de espacio, nos enfocamos en el espacio de problemas presentado aquí y extenderemos nuestro modelo a escenarios de implementación más avanzados en el futuro. Cada flujo de trabajo tiene un requisito de calidad de servicio (QoS) que debe completarse dentro de un número específico de unidades de tiempo (por ejemplo, del orden de segundos, como se detalla en la sección de Experimentos). Una vez completado (o fallido), se asigna un valor comercial al flujo de trabajo. Extendimos este enfoque aún más y consideramos diferentes tipos de finalización de flujo de trabajo para modelar niveles diferenciados de QoS que pueden ser aplicados por las empresas (por ejemplo, para proporcionar servicios al cliente escalonados). Decimos que un flujo de trabajo es exitoso si se completa dentro de su requisito de QoS, aceptable si se completa dentro de un factor constante κ 31 de su límite de QoS (en nuestros experimentos elegimos κ=3), o fallido si termina más allá de κ veces su límite de QoS. Para cada categoría, se asigna un puntaje de valor comercial al flujo de trabajo, siendo la categoría exitosa la que recibe la puntuación positiva más alta, seguida por la aceptable y luego la fallida. La distribución de puntos de valor empresarial no es uniforme en los flujos de trabajo, lo que modela casos en los que algunos flujos de trabajo tienen mayor prioridad que otros. Cada tipo de servicio es implementado por varios proveedores de servicios diferentes. Suponemos que los proveedores hacen acuerdos de nivel de servicio (SLAs) para garantizar un nivel de rendimiento definido por el tiempo de finalización de una invocación de servicio web. Aunque los Acuerdos de Nivel de Servicio (SLAs) pueden ser complejos, en este documento asumimos, para simplificar, que las garantías pueden adoptar la forma de una degradación lineal del rendimiento bajo carga. Esta garantía está definida por varios parámetros: α es el tiempo de finalización esperado (por ejemplo, del orden de segundos) si la carga de trabajo asignada de las solicitudes de servicio web es menor o igual a β, la concurrencia máxima, y si la carga de trabajo es mayor que β, la finalización esperada para una carga de trabajo de tamaño ω es α + γ(ω − β) donde γ es un coeficiente fraccional. En nuestros experimentos variamos α, β y γ con diferentes distribuciones. Idealmente, todos los flujos de trabajo podrían finalizar dentro de sus límites de calidad de servicio (QoS) y, por lo tanto, maximizar el valor empresarial agregado en todos los flujos de trabajo. Sin embargo, debido a que modelamos a los proveedores de servicios con un rendimiento degradante bajo carga, no todos los flujos de trabajo alcanzarán su límite de calidad de servicio (QoS): fácilmente puede darse el caso de que los procesos comerciales sean asignados a proveedores que están sobrecargados y no pueden completarse dentro del límite de calidad de servicio respectivo de los flujos de trabajo. El problema clave de investigación, entonces, es asignar los procesos comerciales a los proveedores de servicios web con el objetivo de optimizar el valor comercial agregado de todos los flujos de trabajo. Dado que el alcance de la optimización es el conjunto completo de flujos de trabajo, puede ser que las mejores asignaciones de programación resulten en que algunos flujos de trabajo tengan que fallar para que otros tengan éxito. Esta observación intuitiva sugiere que enfoques de programación tradicionales como el round-robin o asignaciones proporcionales no funcionarán bien, lo cual es lo que observamos y discutimos en la Sección 4. Por otro lado, una búsqueda exhaustiva de todas las posibles asignaciones encontrará el mejor horario, pero la complejidad computacional es prohibitivamente alta. Supongamos que hay W flujos de trabajo con un promedio de B procesos de negocio por flujo de trabajo. Además, en el peor de los casos, cada proceso empresarial solicita un tipo de servicio, para el cual hay P proveedores. Por lo tanto, hay W · PB combinaciones para explorar y encontrar las asignaciones óptimas de procesos comerciales a proveedores. Incluso para configuraciones pequeñas (por ejemplo, Dado que (W=10, B=5, P=10), el tiempo computacional para la búsqueda exhaustiva es significativo, y en nuestro trabajo buscamos ajustar estos parámetros. En la siguiente subsección, discuta cómo se puede utilizar un algoritmo de búsqueda genética para converger hacia las asignaciones de programación óptimas. 3.2 Algoritmo genético Dado un espacio de búsqueda exponencial de asignaciones de procesos comerciales a proveedores de servicios web, el problema es encontrar la asignación óptima que produzca el valor comercial agregado más alto en general en todos los flujos de trabajo. Para explorar el espacio de soluciones, utilizamos un algoritmo genético (GA) que simula la selección natural darwiniana al hacer que los miembros de una población compitan por sobrevivir para transmitir sus cromosomas genéticos a la siguiente generación; después de generaciones sucesivas, hay una tendencia a que los cromosomas converjan hacia la mejor combinación. Aunque existen otras heurísticas de búsqueda que pueden resolver problemas de optimización (por ejemplo, recocido simulado o escalada de colina más empinada), el problema de programación de procesos empresariales se adapta bien a un AG porque las soluciones potenciales pueden representarse en forma de matriz y nos permite utilizar investigaciones previas en la recombinación efectiva de cromosomas de AG para formar nuevos miembros de la población (por ejemplo, [2]). 0 1 2 3 4 0 1 2 0 2 1 1 0 1 0 1 0 2 1 2 0 0 1 Figura 2: Un ejemplo de cromosoma que representa una asignación de programación de (flujo de trabajo, tipo de servicio) → proveedor de servicios. Cada fila representa un flujo de trabajo, y cada columna representa un tipo de servicio. Por ejemplo, aquí hay 3 flujos de trabajo (0 a 2) y 5 tipos de servicio (0 a 4). En el flujo de trabajo 0, cualquier solicitud de tipo de servicio 3 se dirige al proveedor 2. Ten en cuenta que el identificador del proveedor de servicios se encuentra dentro de un rango limitado a su tipo de servicio (es decir, su columna), por lo que el 2 listado para el tipo de servicio 3 es un servidor diferente al servidor 2 en otras columnas. Representación cromosómica de una solución. En la Figura 2 mostramos un ejemplo de cromosoma que codifica una asignación de programación. La representación es una matriz bidimensional que mapea {flujo de trabajo, tipo de servicio} a un proveedor de servicios. Para un proceso de negocio en el flujo de trabajo i y utilizando el tipo de servicio j, la entrada (i, j)-ésima en la tabla es el identificador del proveedor de servicios al que se asigna el proceso de negocio. Ten en cuenta que el identificador del proveedor de servicios se encuentra dentro de un rango limitado a su tipo de servicio. Ejecución de GA. Un algoritmo genético procede de la siguiente manera. Inicialmente se crea un conjunto aleatorio de cromosomas para la población. Los cromosomas son evaluados (hasheados) según alguna métrica, y los mejores son elegidos para ser padres. En nuestro problema, la evaluación produce el valor neto del negocio en todos los flujos de trabajo después de ejecutar todos los procesos comerciales una vez que se asignan a sus respectivos proveedores de servicios de acuerdo con el mapeo en el cromosoma. Los padres se recombinan para producir hijos, simulando un cruce sexual, y ocasionalmente puede surgir una mutación que produce nuevas características que no estaban disponibles en ninguno de los padres. La idea principal es que nos gustaría que los niños fueran diferentes de los padres (para explorar más del espacio de soluciones) pero no demasiado diferentes (para contener las porciones del cromosoma que resultan en asignaciones de programación exitosas). Ten en cuenta que encontrar el óptimo global no está garantizado debido a que la recombinación y la mutación son estocásticas. Recombinación y mutación de ADN. Como se mencionó, los cromosomas son matrices bidimensionales que representan asignaciones de horarios. Para simular la recombinación sexual de dos cromosomas para producir un nuevo cromosoma hijo, aplicamos un esquema de cruce de un punto dos veces (una vez a lo largo de cada dimensión). El cruce se explica mejor por analogía al espacio cartesiano de la siguiente manera. Se elige un punto al azar en la matriz para que sea la coordenada (0, 0). Los elementos de la matriz de los cuadrantes II y IV del primer progenitor y los elementos de los cuadrantes I y III del segundo progenitor se utilizan para crear el nuevo hijo. Este enfoque sigue las mejores prácticas de los algoritmos genéticos al mantener juntos los segmentos cromosómicos contiguos a medida que se transmiten de padre a hijo. El esquema de mutación de uni-cromosoma cambia aleatoriamente una de las asignaciones de proveedor de servicios a otro proveedor dentro del rango disponible. Otros esquemas de recombinación y mutación son un área de investigación en la comunidad de AG, y buscamos explorar nuevos operadores en trabajos futuros. Función de evaluación de GA. Un componente importante de los algoritmos genéticos es la función de evaluación. Dada una cromosoma particular que representa un mapeo de programación, la función calcula de manera determinista el valor neto del negocio en todas las cargas de trabajo. Los procesos comerciales en cada carga de trabajo se asignan a proveedores de servicios, y el tiempo de finalización de cada proveedor se calcula en función de la garantía del acuerdo de servicio utilizando los parámetros mencionados en la Sección 3.1, a saber, el tiempo de finalización sin carga α, la máxima concurrencia β y un coeficiente γ que controla la degradación del rendimiento lineal bajo carga pesada. Ten en cuenta que la función de evaluación puede ser fácilmente reemplazada si se desea; por ejemplo, otras funciones de evaluación pueden modelar diferentes garantías de proveedores de servicios o flujos de trabajo paralelos. 4. EXPERIMENTOS Y RESULTADOS En esta sección mostramos el beneficio de utilizar nuestro planificador basado en algoritmos genéticos. Debido a que queríamos escalar los escenarios a un gran número de flujos de trabajo (hasta 1000 en nuestros experimentos), implementamos un programa de simulación que nos permitió variar parámetros y medir los resultados con diferentes métricas. El simulador fue escrito en C++ estándar y se ejecutó en un ordenador de escritorio Linux (Fedora Core) con una velocidad de 2.8 GHz y 1GB de RAM. Comparamos nuestro algoritmo con candidatos alternativos: • Un algoritmo de round-robin bien conocido que asigna cada proceso comercial de forma circular a los proveedores de servicios para un tipo de servicio en particular. Este enfoque proporciona el esquema más simple para el equilibrio de carga. • Un algoritmo aleatorio-proporcional que asigna proporcionalmente los procesos comerciales a los proveedores de servicios; es decir, para un tipo de servicio dado, los proveedores de servicios se clasifican según su tiempo de finalización garantizado, y los procesos comerciales se asignan proporcionalmente a los proveedores en función de su tiempo de finalización. (También probamos un esquema de proporcionalidad basado tanto en los tiempos de finalización como en la concurrencia máxima, pero obtuvimos los mismos resultados, por lo que solo se muestran los resultados de los esquemas anteriores aquí.) • Un algoritmo codicioso de hombre de paja que siempre asigna los procesos comerciales al proveedor de servicios que tiene el tiempo de finalización garantizado más rápido. Este algoritmo representa un enfoque ingenuo basado en observaciones avaras y locales de cada flujo de trabajo sin tener en cuenta todos los flujos de trabajo. En los experimentos que siguen, todos los resultados fueron promediados a lo largo de 20 pruebas, y para ayudar a normalizar los efectos de la aleatorización utilizada durante el AG, cada prueba comenzó leyendo datos preinicializados desde el disco. En la Tabla 1 enumeramos nuestros parámetros experimentales. En la Figura 3 mostramos los resultados de ejecutar nuestro AG contra las tres alternativas candidatas. El eje x muestra el número de flujos de trabajo escalado a 1000, y el eje y muestra el valor comercial agregado de todos los flujos de trabajo. Como se puede ver, el algoritmo genético produce consistentemente el mayor valor comercial incluso a medida que aumenta el número de flujos de trabajo; con 1000 flujos de trabajo, el algoritmo genético produce una mejora del 115% sobre la siguiente mejor alternativa. (Tenga en cuenta que aunque estamos optimizando en función de la métrica de valor comercial que definimos anteriormente, los algoritmos genéticos pueden converger hacia el valor óptimo de cualquier métrica, siempre y cuando la función de evaluación pueda medir de manera consistente el valor de un cromosoma con esa métrica). Como era de esperar, el algoritmo codicioso tiene un rendimiento muy pobre porque hace el peor trabajo en equilibrar la carga: todos los procesos comerciales de un tipo de servicio dado se asignan a un solo servidor (el que se anuncia como el que tiene el tiempo de finalización más rápido), y a medida que llegan más procesos comerciales, el rendimiento de los proveedores se degrada linealmente. El esquema de round-robin es inicialmente superado por el esquema proporcional aleatorio hasta alrededor de 120 flujos de trabajo (como se muestra en el gráfico ampliado de la Figura 4), pero a medida que aumenta el número de flujos de trabajo, el esquema de round-robin gana consistentemente sobre el proporcional aleatorio. La razón es que aunque el esquema aleatorio-proporcional asigna procesos comerciales a proveedores proporcionalmente según los tiempos de finalización anunciados (que es una medida del poder del proveedor de servicios), incluso los mejores proveedores eventualmente alcanzarán una concurrencia máxima del mundo real para la gran cantidad de flujos de trabajo que estamos considerando. Para un número muy grande de flujos de trabajo, el esquema de round-robin es capaz de equilibrar mejor la carga entre todos los proveedores de servicios. Para comprender mejor el comportamiento resultante de las asignaciones de programación, mostramos los resultados de finalización del flujo de trabajo en las Figuras 5, 6 y 7 para 100, 500 y 900 flujos de trabajo, respectivamente. Estas cifras muestran el porcentaje de flujos de trabajo que son exitosos (pueden completarse dentro de su límite de QoS), aceptables (pueden completarse dentro de κ=3 veces su límite de QoS) y fallidos (no pueden completarse dentro de κ=3 veces su límite de QoS). El GA produce consistentemente el mayor porcentaje de flujos de trabajo exitosos (lo que resulta en valores comerciales más altos para el conjunto agregado de flujos de trabajo). Además, el esquema de round-robin produce mejores resultados que el proporcional-aleatorio para un gran número de flujos de trabajo, pero no tiene un rendimiento tan bueno como el algoritmo genético. En la Figura 8 graficamos el makespan resultante de los mismos experimentos anteriores. Makespan es una métrica tradicional de la comunidad de programación de trabajos que mide el tiempo transcurrido para que se complete el último trabajo. Aunque útil, no captura la métrica de valor empresarial de alto nivel contra la que estamos optimizando. De hecho, el makespan no tiene en cuenta el hecho de que proporcionamos múltiples niveles de finalización (exitoso, aceptable y fallido) y asignamos puntajes de valor comercial en consecuencia. Para completar, señalamos que el algoritmo genético proporciona el makespan más rápido, pero es igualado por el algoritmo de round robin. El algoritmo genético produce mejores valores comerciales (como se muestra en la Figura 3) porque es capaz de explorar el espacio de soluciones para encontrar mejores asignaciones que generen flujos de trabajo más exitosos (como se muestra en las Figuras 5 a 7). También analizamos el efecto de los algoritmos de programación en el equilibrio de la carga. La Figura 9 muestra el porcentaje de proveedores de servicios que fueron accedidos mientras se ejecutaban los flujos de trabajo. Como era de esperar, el algoritmo codicioso siempre elige a un proveedor de servicios; por otro lado, el algoritmo de round-robin es el más rápido para distribuir el negocio. 33 Parámetro experimental Comentario Flujos de trabajo 5 a 1000 Procesos de negocio por flujo de trabajo aleatorio uniforme: 1 - 10 Tipos de servicio 10 Proveedores de servicios por tipo de servicio aleatorio uniforme: 1 - 10 Objetivo de QoS del flujo de trabajo aleatorio uniforme: 10-30 segundos Tiempo de finalización del proveedor de servicios (α) aleatorio uniforme: 1 - 12 segundos Máxima concurrencia del proveedor de servicios (β) aleatorio uniforme: 1 - 12 Coeficiente de degradación del proveedor de servicios (γ) aleatorio uniforme: 0.1 - 0.9 Valor de negocio para flujos de trabajo exitosos aleatorio uniforme: 10 - 50 puntos Valor de negocio para flujos de trabajo aceptables aleatorio uniforme: 0 - 10 puntos Valor de negocio para flujos de trabajo fallidos aleatorio uniforme: -10 - 0 puntos GA: número de padres 20 GA: número de hijos 80 GA: número de generaciones 1000 Tabla 1: Parámetros experimentales Fallido Aceptable (completado pero no dentro de QoS) Exitoso (completado dentro de QoS) 0% 20% 40% 60% 80% 100% RoundRobinRandProportionalGreedyGeneticAlg Porcentaje de todos los flujos de trabajo Comportamiento del flujo de trabajo, 100 flujos de trabajo Figura 5: Comportamiento del flujo de trabajo para 100 flujos de trabajo. Fracaso Aceptable (completado pero no dentro de QoS) Exitoso (completado dentro de QoS) 0% 20% 40% 60% 80% 100% RoundRobinRandProportionalGreedyGeneticAlg Porcentaje de todos los flujos de trabajo Comportamiento del flujo de trabajo, 500 flujos de trabajo Figura 6: Comportamiento del flujo de trabajo para 500 flujos de trabajo. Fracaso Aceptable (completado pero no dentro de QoS) Exitoso (completado dentro de QoS) 0% 20% 40% 60% 80% 100% RoundRobinRandProportionalGreedyGeneticAlg Porcentaje de todos los flujos de trabajo Comportamiento del flujo de trabajo, 500 flujos de trabajo Figura 7: Comportamiento del flujo de trabajo para 900 flujos de trabajo. 0 50 100 150 200 250 300 0 200 400 600 800 1000 Tiempo total [segundos] Número de flujos de trabajo Tiempo máximo de finalización para todos los flujos de trabajo Algoritmo genético Round robin Proporcional aleatorio Codicioso Figura 8: Tiempo máximo de finalización para todos los flujos de trabajo. Este valor es la métrica makespan utilizada en la investigación de programación tradicional. Aunque útil, el makespan no tiene en cuenta la puntuación del valor comercial en nuestro dominio de problemas. La Figura 10 muestra el porcentaje de proveedores de servicios accedidos (es decir, el porcentaje de proveedores de servicios representados en la Figura 9) que tenían más procesos comerciales asignados que su concurrencia máxima anunciada. Por ejemplo, en el algoritmo voraz solo se utiliza un proveedor de servicios, y este proveedor se satura rápidamente. Por otro lado, el algoritmo aleatorio-proporcional utiliza muchos proveedores de servicios, pero debido a que los procesos comerciales se asignan de manera proporcional con más asignaciones yendo a los mejores proveedores, hay una tendencia a que un menor porcentaje de proveedores se saturen. Para completitud, mostramos el rendimiento del algoritmo genético en sí mismo en la Figura 11. El algoritmo escala linealmente con un aumento en el número de flujos de trabajo. Observamos que los algoritmos round-robin, random-proportional y greedy terminaron en menos de 1 segundo incluso para la configuración de flujo de trabajo más grande. Sin embargo, consideramos que el beneficio de encontrar puntajes de valor empresarial mucho más altos justifica el tiempo de ejecución del algoritmo genético; además, esperaríamos que el tiempo de ejecución mejore tanto con la optimización del software como con un ordenador más rápido que nuestro PC estándar. CONCLUSIÓN Los procesos comerciales dentro de los flujos de trabajo pueden ser orquestados para acceder a servicios web. En este artículo estudiamos la provisión de servicios de múltiples niveles, donde las solicitudes de servicios web a tipos de servicios pueden ser asignadas a diferentes proveedores de servicios. El problema resultante es que para poder soportar un gran número de flujos de trabajo, la asignación de procesos de negocio a proveedores de servicios web debe ser inteligente. Utilizamos una métrica de valor empresarial para medir el 0.2 0.4 0.6 0.8 1 0 200 400 600 800 1000 Porcentaje de todos los proveedores de servicios Número de flujos de trabajo Proveedores de servicios utilizados Algoritmo genético Round robin Proporcional aleatorio Ávido Figura 9: El porcentaje de proveedores de servicios utilizados durante las ejecuciones de carga de trabajo. El algoritmo Greedy siempre elige al mismo proveedor de servicios, mientras que el algoritmo Round Robin distribuye las solicitudes de manera uniforme entre los proveedores. 0 0.2 0.4 0.6 0.8 1 0 200 400 600 800 1000 Porcentaje de todos los proveedores de servicios Número de flujos de trabajo Proveedores saturados Algoritmo genético Round robin Proporcional aleatorio Greedy Figura 10: El porcentaje de proveedores de servicios que están saturados entre aquellos proveedores que fueron utilizados (es decir, el porcentaje de proveedores de servicios representados en la Figura 9). Un proveedor de servicios saturado es aquel cuya carga de trabajo es mayor que su concurrencia máxima anunciada. Dado que el espacio de soluciones de los mapeos de programación es exponencial, utilizamos un algoritmo de búsqueda genética para explorar el espacio y converger hacia el mejor horario. Con una configuración predeterminada para todos los parámetros y utilizando nuestra puntuación de valor empresarial, el GA produjo hasta un 115% de mejora en el valor empresarial sobre el siguiente mejor algoritmo. Finalmente, debido a que un algoritmo genético convergerá hacia el valor óptimo utilizando cualquier métrica (incluso diferente a la métrica de valor empresarial que utilizamos), creemos que nuestro enfoque tiene un fuerte potencial para trabajos futuros. En trabajos futuros, buscamos adquirir trazas del mundo real de instancias de servicios web para obtener mejores estimaciones de las garantías de acuerdo de servicio, aunque esperamos que tales garantías entre los proveedores y sus consumidores no estén generalmente disponibles para el público. También analizaremos otras métricas de calidad de servicio (QoS) como el uso de CPU y E/S. Por ejemplo, podemos analizar los costos de transferencia con diferentes anchos de banda, latencia, tamaño de datos y distribución de datos. Además, esperamos mejorar nuestro algoritmo genético y compararlo con más alternativas de programación. Finalmente, dado que nuestro trabajo es complementario al trabajo existente en coreografía de servicios web (porque dependemos de flujos de trabajo preconfigurados), buscamos integrar nuestro enfoque con los sistemas de flujo de trabajo de servicios web disponibles expresados en BPEL. 6. REFERENCIAS [1] A. Ankolekar, et al. DAML-S: Marcado Semántico para Servicios Web, En Proc. del Simposio Internacional de Trabajo de la Web Semántica, 2001. [2] L. Davis. Programación de taller con algoritmos genéticos, En Proc. de la Conferencia Internacional sobre Algoritmos Genéticos, 1985. [3] H.-L. Fang, P. Ross y D. Corne. Un Enfoque Prometedor de Algoritmo Genético para Problemas de Programación de Taller de Trabajo, Re-programación y Programación de Taller Abierto, En Actas de la 5ta Conferencia Internacional sobre Algoritmos Genéticos, 1993. [4] M. Gary y D. Johnson. Computadoras e Intractabilidad: Una Guía de la Teoría de NP-Completitud, Freeman, 1979. [5] J. Holland. Adaptación en Sistemas Naturales y Artificiales: Un Análisis Introductorio con Aplicaciones a la Biología, Control e Inteligencia Artificial, MIT Press, 1992. [6] D. Goldberg. Algoritmos Genéticos en Búsqueda, Optimización y Aprendizaje Automático, Kluwer Academic Publishers, 1989. [7] Procesos de Negocio en un Mundo de Servicios Web, www-128.ibm.com/developerworks/webservices/library/ws-bpelwp/. [8] G. Soundararajan, K. Manassiev, J. Chen, A. Goel y C. Amza. Bases de datos de back-end en clústeres de servidores de contenido dinámico compartido, En Proc. de la Conferencia Internacional de Computación Autónoma de IEEE, 2005. [9] B. Srivastava y J. Koehler. Composición de Servicios Web: Soluciones Actuales y Problemas Abiertos, ICAP, 2003. [10] B. Urgaonkar, P. Shenoy, A. Chandra y P. Goyal. Provisión dinámica de aplicaciones de Internet de múltiples niveles, En Proc. de la Conferencia Internacional de IEEE sobre Computación Autónoma, 2005. [11] L. Zeng, B. Benatallah, M. Dumas, J. Kalagnanam y Q. Sheng. Composición de Servicios Web Impulsada por la Calidad, En Proc. de la Conferencia WWW, 2003. 35