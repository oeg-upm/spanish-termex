Semántica Operacional de Interacciones Multiagente
Juan M. Serrano
Universidad Rey Juan Carlos C/Tulipán S/N Madrid, España
juanmanuel.serrano@urjc.es
Sergio Saugar
Universidad Rey Juan Carlos C/Tulipán S/N Madrid, España
sergio.saugar@urjc.es
RESUMEN
La postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.
Por último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}
1
Nota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  
Interacciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.
Los componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción
Por lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.
Las variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.
y los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.
Recursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.
Los protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función "over" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. 
[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.
[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)