Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701