Implementación y Evaluación del Rendimiento de CONFLEX-G: Programa de Búsqueda de Espacio Conformacional Molecular Habilitado para Grid con OmniRPC. Hemos implementado CONFLEX-G utilizando un sistema de RPC en malla llamado OmniRPC. En este artículo, informamos sobre el rendimiento de CONFLEX-G en un banco de pruebas en red de varios clústeres de PC distribuidos geográficamente. Para explorar muchas conformaciones de grandes biomoléculas, CONFLEX-G genera estructuras de prueba de las moléculas y asigna trabajos para optimizar una estructura de prueba con un método confiable de mecánica molecular en la cuadrícula. OmniRPC proporciona un modelo de persistencia restringido para respaldar las aplicaciones de búsqueda paramétrica. En este modelo, cuando el procedimiento de inicialización está definido en el módulo RPC, el módulo se inicializa automáticamente en el momento de la invocación llamando al procedimiento de inicialización. Esto puede eliminar la comunicación y la inicialización innecesarias en cada llamada en CONFLEX-G. CONFLEXG puede lograr un rendimiento comparable al de CONFLEX MPI y puede aprovechar más recursos informáticos al permitir el uso de un clúster de múltiples clústeres en la cuadrícula. El resultado experimental muestra que CONFLEX-G logró una aceleración de 56.5 veces en el caso de la molécula 1BL1, donde la molécula consta de un gran número de átomos y cada optimización de la estructura de prueba requiere un tiempo significativo. El desequilibrio de carga en el tiempo de optimización de la estructura de prueba también puede causar degradación del rendimiento. Categorías y Descriptores de Asignaturas C.2.4 [Organización de Sistemas Informáticos]: RED DE COMUNICACIÓN DE COMPUTADORAS-Sistemas Distribuidos; J.2.4 [Aplicaciones Informáticas]: CIENCIAS FÍSICAS E INGENIERÍA Términos Generales Diseño, Rendimiento 1. INTRODUCCIÓN La elucidación de las conformaciones estables y el proceso de plegamiento de las proteínas es uno de los objetivos más fundamentales y desafiantes en las ciencias de la vida. Si bien algunas de las estructuras secundarias más comunes (por ejemplo, ciertos tipos de hélice, la lámina beta y la hélice) son bien conocidas, se requiere un análisis preciso de los miles de conformaciones químicamente importantes y un análisis de orden de pico-segundo de sus interconversiones conformacionales a través de los estados de transición en la superficie de energía potencial para la investigación de orden de microsegundo del proceso de plegamiento hacia la formación de la estructura terciaria. Recientemente, el concepto de la red computacional ha comenzado a atraer un interés significativo en el campo de la computación de alto rendimiento en red. Los rápidos avances en la tecnología e infraestructura de redes de área amplia han hecho posible construir entornos de computación distribuida a gran escala y alto rendimiento, o redes computacionales, que proporcionan acceso confiable, consistente y generalizado a enormes recursos computacionales. CONFLEX es uno de los programas de búsqueda de espacio conformacional más eficientes y confiables. Hemos aplicado este programa 154 a la paralelización utilizando computación global. El rendimiento del CONFLEX paralelizado permite explorar la región de energía más baja del espacio conformacional de péptidos pequeños en un tiempo transcurrido disponible utilizando un clúster de PC local. Dado que la optimización de la estructura de prueba en CONFLEX se calcula a través de la mecánica molecular, la búsqueda del espacio conformacional se puede realizar rápidamente en comparación con la que utiliza cálculos de orbitales moleculares. Aunque se utilizó la versión paralelizada de CONFLEX para calcular de forma paralela la optimización de la estructura, que representa más del 90% del procesamiento en la búsqueda de conformaciones moleculares, no se pudo lograr una mejora suficiente en la aceleración solo con este método. Por lo tanto, para polímeros de alto peso molecular de organismos vivos, como la proteasa del VIH, el uso de un solo clúster de PC es insuficiente debido a la necesidad de optimizar una gran cantidad de estructuras de prueba. Esto requiere los vastos recursos informáticos de un entorno de computación en malla. En este artículo, describimos CONFLEX-G, un programa de búsqueda conformacional molecular habilitado para grid, utilizando OmniRPC y reportamos su rendimiento en un grid de varios clusters de PC distribuidos geográficamente. El prototipo CONFLEX-G asigna la optimización de las estructuras de cálculo de prueba, que es una tarea muy consumidora de tiempo, a nodos trabajadores en el entorno de la red para obtener un alto rendimiento. Además, comparamos el rendimiento de CONFLEX-G en un clúster de PC local con el de un banco de pruebas en red. OmniRPC[2, 3, 4] es una implementación segura para hilos de Ninf RPC[5, 6], que es una facilidad de RPC de cuadrícula para la computación en entornos de cuadrícula. Varios sistemas adoptan el concepto de la RPC como el modelo básico para la computación en entornos de rejilla, incluyendo Ninf-G[7], NetSolve[8] y CORBA[9]. El sistema RPCstyle proporciona una interfaz de programación fácil de usar e intuitiva, que permite a los usuarios del sistema de cuadrícula crear fácilmente aplicaciones habilitadas para la cuadrícula. Para apoyar la programación paralela, un cliente de RPC puede emitir solicitudes de llamada asincrónicas a un ordenador remoto diferente para aprovechar el paralelismo en toda la red a través de OmniRPC. En este artículo, proponemos el modelo de persistencia OmniRPC para un sistema de RPC de Grid y demostramos su efectividad. Para apoyar una aplicación típica para un entorno de cuadrícula, como una aplicación de búsqueda paramétrica, en la que la misma función se ejecuta con diferentes parámetros de entrada en el mismo conjunto de datos. En el sistema GridRPC actual[10], el conjunto de datos establecido por la llamada anterior no puede ser utilizado por llamadas posteriores. En el sistema OmniRPC, una vez que se invoca un ejecutable remoto, el cliente intenta utilizar el ejecutable remoto invocado y su estado inicializado para llamadas posteriores a las mismas funciones remotas con el fin de eliminar el costo de invocación de cada llamada. Este documento demuestra que CONFLEX-G es capaz de aprovechar los enormes recursos informáticos de un entorno de grid y buscar conformadores moleculares a gran escala. Demostramos CONFLEX-G en nuestra plataforma de pruebas en red utilizando la proteína real como molécula de muestra. La facilidad OmniRPC del módulo inicializable automático (AIM) permite al sistema calcular eficientemente numerosos conformeros. Además, al utilizar OmniRPC, el usuario puede paralelizar en cuadrícula la aplicación existente y pasar del clúster al entorno de cuadrícula sin modificar el código del programa y compilar el programa. Además, el usuario puede construir fácilmente un entorno de red privada. El resto de este documento está organizado de la siguiente manera. Se presenta una visión general de la Base de Datos de Conformaciones de Estructuras Iniciales, la Perturbación Local, la Optimización de la Geometría, la Comparación y el Registro. Figura 1: Algoritmo de búsqueda de espacio conformacional en el CONFLEX original. El sistema CONFLEX se describe en la Sección 2, y la implementación y diseño de CONFLEX-G se detallan en la Sección 3. Informamos los resultados experimentales obtenidos utilizando CONFLEX-G y discutimos su rendimiento en la Sección 4. En la Sección 6, presentamos conclusiones y discutimos temas para estudios futuros. 2. CONFLEX es un programa eficiente de búsqueda de espacio conformacional, que puede buscar predominantemente y exhaustivamente los conformeros en la región de energía más baja. Las aplicaciones de CONFLEX incluyen la elucidación de la reactividad y selectividad de fármacos y posibles materiales medicinales con respecto a su flexibilidad conformacional. 2.1 Algoritmo de Búsqueda de Espacio Conformacional La estrategia básica de CONFLEX es una búsqueda exhaustiva solo de las regiones de baja energía. El CONFLEX original realiza los siguientes cuatro pasos principales: 1. Selección de una estructura inicial entre los conformeros únicos previamente descubiertos y ordenados en una base de datos conformacional. (Una estructura de entrada se utiliza como la primera estructura inicial al comienzo de una ejecución de búsqueda solamente.) 2. Generación de estructuras de prueba mediante perturbaciones locales a la estructura inicial seleccionada. 3. Optimización de geometría para las nuevas estructuras de prueba generadas. 4. Comparación de las estructuras optimizadas con éxito (ensayo) con los otros conformeros almacenados en una base de datos de conformaciones, y preservación de los conformeros únicos recién descubiertos en la base de datos. La Figura 1 muestra el esquema de CONFLEX, el algoritmo original de búsqueda de espacio conformacional. Estos procedimientos incorporan dos estrategias únicas. La Figura 2 muestra las estrategias para generar perturbaciones locales en CONFLEX. La primera estrategia implica tanto el aleteo de las esquinas como el volteo de los bordes para los átomos del anillo y la rotación paso a paso para las cadenas laterales o cadenas del esqueleto. Estos métodos proporcionan una forma altamente eficiente de producir varias estructuras de prueba buenas. Estas perturbaciones pueden considerarse como una imitación de 155 Rotación Escalonada de Esquina de Solapa de Borde de Giro Figura 2: Estrategias utilizadas para generar las perturbaciones locales, un paso de cruce de barrera en el proceso elemental de la interconversión conformacional térmica. De hecho, las perturbaciones de una estructura inicial corresponden al rendimiento preciso alrededor del espacio de la estructura inicial debido a la localización y debilidad de la perturbación. La regla de selección de la estructura inicial, la regla LowestConformer-First, es la segunda estrategia para dirigir la búsqueda de conformaciones ampliada a las regiones de baja energía. La estructura inicial se selecciona como el conjunto de conformaciones de menor energía almacenadas en la base de datos de conformaciones. Esta regla es efectiva para desplazarse hacia abajo en el espacio de búsqueda hacia regiones de menor energía, como el agua de un arroyo que fluye hacia un embalse vacío, llenando depresiones locales en el camino. Por lo tanto, estos procedimientos tácticos de la búsqueda CONFLEX se conocen como el Algoritmo de Llenado de Reservorio. Para permanecer en la región de baja energía y realizar una búsqueda exhaustiva, el límite de búsqueda (SEL), que determina la energía máxima de las estructuras iniciales, está predefinido. El aumento gradual de SEL permite buscar solo los conformeros de baja energía y evita desviarse hacia regiones de energía innecesariamente alta. 2.2 Paralelización de CONFLEX para clúster Para su aplicación en más de 100 átomos, CONFLEX fue mejorado utilizando técnicas de computación paralela de alto rendimiento. En el algoritmo de búsqueda CONFLEX, los procedimientos de optimización de geometría siempre ocupan el 95% del tiempo transcurrido durante la ejecución de la búsqueda. Por lo tanto, paralelizamos esta optimización utilizando la técnica de paralelización Maestro/Trabajador. Modificamos los procedimientos de búsqueda de la siguiente manera. Después de que se generan las estructuras de prueba (paso 2), se almacenan temporalmente en un grupo de tareas en el nodo maestro. Entonces, cada nodo trabajador recibe dinámicamente una estructura de prueba del nodo maestro. Después de que se complete una optimización en un nodo de trabajador, este recibe inmediatamente otra estructura de prueba. Cuando todas las estructuras de prueba relacionadas con una estructura inicial dada están optimizadas, solo se utiliza el procedimiento principal para la comparación. Al paralelizar CONFLEX, la aceleración de la búsqueda de conformadores moleculares obtenida es la reportada en[11]. 3. CONFLEX-G Originalmente, CONFLEX estaba destinado a ser utilizado para explorar los conformeros de las grandes biomoléculas, como la proteasa del VIH. En tales moléculas, el número de estructuras de prueba aumenta y el tiempo requerido para la optimización de la Selección de RPC de Estructuras Iniciales Conformaciones de la Base de Datos de Perturbación Local Comparación y Registro del Cliente Programa Cliente Grupo de Tareas de Optimización Geométrica RPC Entorno de Rejilla RPC Cluster B Cluster A Cluster C Estructura de prueba Estructura de prueba Estructura de prueba Estructura de prueba Figura 3: Procedimiento de CONFLEX-G. agente rexrex rex Cliente jones.tsukuba.ac.jp hpc-serv.hpcc.jp hpc1 hpc2 hpc3 Invocación del agente Comunicación de la red Figura 4: Visión general del sistema OmniRPC para el clúster remoto con una dirección IP privada. la estructura de prueba se vuelve inmensa. Implementamos la versión paralelizada de CONFLEX, la cual no puede tratar tales moléculas utilizando solo un clúster de PC local. Para aprovechar los vastos recursos informáticos de un entorno de grid, diseñamos e implementamos CONFLEX-G, que es una versión habilitada para grid de CONFLEX, con el sistema OmniRPC. CONFLEX-G asigna trabajos para optimizar una estructura de prueba a los nodos computacionales de cada clúster en el entorno de la red. La Figura 3 muestra el proceso de CONFLEX-G. Los programas de los trabajadores se inicializan mediante el método de inicialización, que es proporcionado por la instalación de OmniRPC AIM en la invocación del trabajador. En cada llamada RPC, el estado inicializado se reutiliza en el host remoto. En otras palabras, el programa cliente puede eliminar la inicialización para cada llamada RPC, y por lo tanto optimizar eficientemente las estructuras de prueba. 3.1 El sistema OmniRPC OmniRPC es un sistema de RPC en malla que permite una programación paralela sin problemas desde un clúster de PC hasta un entorno de malla. OmniRPC hereda su API y arquitectura básica de Ninf. Un cliente y los hosts computacionales remotos que ejecutan los procedimientos remotos pueden estar conectados a través de una red. Las bibliotecas remotas se implementan como un programa ejecutable que contiene una rutina de soporte de red como su rutina principal. Llamamos a este programa ejecutable un programa ejecutable remoto (rex). Cuando el programa cliente OmniRPC se inicia, la función de inicialización del sistema OmniRPC invoca el programa agente OmniRPC omrpc-agent en los hosts remotos listados en el archivo de hosts. Para invocar al agente, el usuario puede utilizar el comando de shell remoto rsh en una red de área local, la API de GRAM (Gestor de Asignación de Recursos Globus) del kit de herramientas Globus 156 en un entorno de grid, o el comando de shell remoto seguro ssh. El usuario puede cambiar las configuraciones solo modificando el archivo de host. OmniRpcCall es una interfaz de programación de cliente simple para llamar a funciones remotas. Cuando OmniRpcCall realiza una llamada a un procedimiento remoto, la llamada se asigna a un host remoto apropiado. Cuando el cliente emite la solicitud de RPC, solicita que el agente en el host seleccionado envíe el trabajo del ejecutable remoto con el programador de trabajos local especificado en el archivo del host. Si no se especifica el programador de tareas, el agente ejecuta el ejecutable remoto en el mismo nodo mediante la llamada al sistema fork. El cliente envía los datos de los argumentos de entrada al ejecutable remoto invocado, y recibe los resultados al regreso de la función remota. Una vez que se invoca un ejecutable remoto, el cliente intenta utilizar el ejecutable remoto invocado para llamadas RPC posteriores con el fin de eliminar el costo de invocar nuevamente el mismo ejecutable remoto. Cuando el agente y los ejecutables remotos son invocados, los programas remotos obtienen la dirección y el puerto del cliente de la lista de argumentos y se conectan de vuelta al cliente mediante TCP/IP directo o Globus-IO para la transmisión de datos. Debido a que el sistema OmniRPC no utiliza puertos de servicio fijos, el programa cliente asigna puertos no utilizados dinámicamente para esperar la conexión de los ejecutables remotos. Esto evita posibles problemas de seguridad y permite al usuario instalar el sistema OmniRPC sin necesidad de contar con una cuenta privilegiada. Aquí, un recurso de red típico se considera como un grupo de clústeres de PC distribuidos geográficamente. Para los clústeres de PC en una red privada, un proceso agente OmniRPC en el host del servidor funciona como un proxy para relé de comunicaciones entre el cliente y los ejecutables remotos mediante la multiplexación de las comunicaciones utilizando una única conexión. Esta característica, llamada multiplex IO (MXIO), permite a un único cliente utilizar hasta 1,000 hosts de computación remota. Cuando el clúster de PC está dentro de un firewall, el reenvío de puertos de SSH permite que el nodo se comunique con el exterior a través de MXIO. La Figura 4 muestra la descripción general del sistema OmniRPC para un clúster remoto con una dirección IP privada. Para la programación en paralelo, el programador puede utilizar llamadas a procedimientos remotos asíncronos, lo que permite al cliente emitir varias solicitudes mientras continúa con otras computaciones. Las solicitudes se envían a diferentes hosts remotos para ser ejecutadas en paralelo, y el cliente espera o consulta la solicitud completada. En un modelo de programación con llamadas a procedimientos remotos asíncronos, el programador debe manejar las solicitudes pendientes de forma explícita. Debido a que OmniRPC es un sistema seguro para hilos, puede haber varios llamados a procedimientos remotos pendientes en cualquier momento para programas multi-hilo escritos en OpenMP. Modelo de persistencia de OmniRPC 3.2: módulo inicializable automáticamente. OmniRPC soporta eficientemente aplicaciones paralelas típicas de Maestro/Trabajador como programas de ejecución paramétrica. Para aplicaciones de búsqueda paramétrica, que a menudo requieren una gran cantidad de datos idénticos para cada llamada, OmniRPC admite un modelo de persistencia limitado, que está implementado por el módulo inicializable automático. El usuario puede definir un procedimiento de inicialización en el ejecutable remoto para enviar y almacenar datos automáticamente antes de las llamadas reales al procedimiento remoto. Dado que el ejecutable remoto puede aceptar solicitudes para llamadas posteriores, el conjunto de datos que ha sido establecido por el procedimiento de inicialización puede ser reutilizado. Como resultado, el programa del trabajador puede ejecutarse de manera eficiente y reducir la cantidad de datos transmitidos para la inicialización. Una vez que se invoca un ejecutable remoto, el cliente intenta utilizar el ejecutable remoto invocado para llamadas RPC posteriores. Sin embargo, OmniRPC no garantiza la persistencia del ejecutable remoto, por lo que el conjunto de datos establecido por la llamada anterior no puede ser utilizado por llamadas posteriores. Esto se debe a que una llamada remota realizada por OmniRpcCall puede ser programada en cualquier host remoto de forma dinámica, y los ejecutables remotos pueden ser terminados accidentalmente debido a una reprogramación dinámica o fallos en el host. Sin embargo, la persistencia del ejecutable remoto puede ser explotada en ciertas aplicaciones. Un ejemplo es una aplicación de búsqueda paramétrica: en dicha aplicación, sería eficiente si un gran conjunto de datos pudiera cargarse previamente en la primera llamada, y las llamadas posteriores pudieran realizarse en los mismos datos, pero con diferentes parámetros. Este es el caso para CONFLEX. OmniRPC proporciona un modelo de persistencia restringido a través del módulo inicializable automático (AIM) para apoyar este tipo de aplicación. Si el procedimiento de inicialización está definido en el módulo, el módulo se inicializa automáticamente al invocarlo llamando al procedimiento de inicialización. Cuando el ejecutable remoto se reprograma en diferentes hosts, se llama a la inicialización para inicializar el módulo remoto recién asignado. Esto puede eliminar comunicaciones innecesarias cuando las llamadas RPC utilizan los mismos datos. Para revelar más sobre la diferencia en el progreso entre los casos con OmniRPC AIM y sin OmniRPC AIM, presentamos dos figuras. La Figura 5 ilustra el gráfico de tiempo del progreso de una aplicación típica de OmniRPC utilizando la facilidad OmniRPC AIM, y la Figura 6 ilustra el gráfico de tiempo de la misma aplicación sin la facilidad OmniRPC AIM. En ambas figuras, las líneas entre los diamantes representan los procesos de inicialización, y las líneas entre los puntos representan los cálculos. La línea en negrita indica el momento en que el programa cliente envía los datos al programa trabajador. Es necesario que la aplicación sin la funcionalidad OmniRPC AIM se inicialice en cada RPC. La aplicación que utiliza la funcionalidad OmniRPC AIM puede reutilizar los datos inicializados una vez que el conjunto de datos está inicializado. Esto puede reducir la inicialización en cada RPC. Los trabajadores de la aplicación con AIM pueden calcular de manera eficiente en comparación con la aplicación sin la facilidad de AIM de OmniRPC. 3.3 Implementación de CONFLEX-G utilizando OmniRPC. La Figura 3 muestra una visión general del proceso utilizado en CONFLEX-G. Usando RPCs, CONFLEX-G asigna los procesos de optimización de la estructura de prueba, que son realizados por los nodos de cálculo de un clúster de PC en la versión MPI de CONFLEX, a los nodos computacionales de cada clúster en un entorno de grid. Hay dos cálculos que realizan los programas de trabajador en CONFLEX-G. Uno es la inicialización de un programa de trabajador, y otro es el cálculo de la optimización de la estructura de prueba. Primero, la instalación OmniRPC del AIM se adapta para la inicialización de un programa trabajador. Esta instalación llama automáticamente a la función de inicialización, la cual está contenida en el programa de trabajador, una vez que el programa cliente invoca al programa de trabajador en un nodo remoto. Es necesario que el sistema RPC común, incluido GridRPC, inicialice un programa para cada llamada RPC, ya que la persistencia de datos de los programas trabajadores. Tabla 1: Configuraciones de máquinas en la plataforma de pruebas en red. El nombre del clúster del sitio Máquina Red de Autenticación # de Nodos # de CPUs Univ. de Tsukuba Dennis Dual Xeon 2.4GHz 1Gb Ethernet Globus, SSH 14 28 Alice Dual Athlon 1800+ 100Mb Ethernet Globus, SSH 18 36 TUT Toyo Dual Athlon 2600+ 100Mb Ethernet SSH 8 16 AIST Ume Dual Pentium3 1.4GHz 1Gb Ethernet Globus, SSH 32 64 no es compatible. En OmniRPC, sin embargo, cuando se define la función remota Inicializar en el programa del trabajador y se asigna un nuevo programa de trabajador, correspondiente al otro RPC, para ejecutar, se llama automáticamente a una función Inicializar. Por lo tanto, después de la llamada a la función Initialize para configurar los datos de inicialización comunes, un programa trabajador puede reutilizar estos datos y aumentar la eficiencia de sus procesos. Por lo tanto, cuanto mayor sea el costo de configuración, mayor será el beneficio potencial. Implementamos el programa de trabajador de CONFLEX-G para recibir datos, como parámetros de evaluación de energía, de un programa cliente y para ser inicializado por la función Inicializar. Organizamos el programa del cliente de CONFLEX-G para transferir el archivo de parámetros en el momento de la inicialización del trabajador. Esto permite que la ejecución se realice modificando solo la configuración del cliente si el usuario desea ejecutar CONFLEX-G con un conjunto de datos diferente. Segundo, para calcular la optimización de la estructura de prueba en un programa de trabajador, el programa de trabajador debe recibir los datos, como el arreglo de átomos de la estructura de prueba y el estado de energía interna. El resultado se devuelve al programa cliente después de que el trabajador haya optimizado la estructura de prueba. Dado que la parte de cálculo de la optimización de la estructura en este programa de trabajador puede ser calculada de forma independiente utilizando diferentes parámetros, paralelizamos esta parte utilizando RPC asincrónicos en el lado del cliente. Para llamar a la función de optimización de estructuras en un programa trabajador desde el programa cliente, utilizamos la API OmniRpcCallAsync, la cual está diseñada para RPC asincrónico. Además, la API OmniRpcCallWaitAll espera hasta que se utilicen todas las RPC asíncronas para realizar la sincronización una vez que todas las RPC asíncronas se hayan completado, con el fin de optimizar la estructura de la prueba. El programa cliente que asigna la optimización de la estructura de prueba al nodo de cálculo de un clúster de PC utilizando RPC se describe de la siguiente manera. OmniRpcInit() OmniRpcModuleInit(conflex_search,...); ... mientras( <nuevos conformeros> ) { para cada( <estructuras de prueba> ) OmniRpcCallAsync(conflex_search_worker, ...); OmniRpcWaitAll(); ... Ten en cuenta que la API OmniRpcModuleInit solo devuelve los argumentos necesarios para la inicialización y no ejecutará realmente la función de inicialización. Como se describe arriba, la inicialización real se realiza en la primera llamada remota. Dado que el sistema OmniRPC tiene un programador de round-robin sencillo, no es necesario escribir explícitamente el código para el equilibrio de carga. Por lo tanto, los RPC se asignan automáticamente a los trabajadores inactivos. Tabla 2: Rendimiento de la red entre el nodo maestro del clúster Dennis y el nodo maestro de cada clúster de PC. Rendimiento de ida y vuelta del clúster Tiempo (ms) (Mbps) Dennis 0.23 879.31 Alice 0.18 94.12 Toyo 11.27 1.53 Ume 1.07 373.33 RESULTADOS PRELIMINARES 4.1 Banco de pruebas de la red El banco de pruebas de la red fue construido utilizando recursos informáticos de la Universidad de Tsukuba, la Universidad de Tecnología de Toyohashi (TUT) y el Instituto Nacional de Ciencia y Tecnología Industrial Avanzada (AIST). La Tabla 1 muestra los recursos informáticos utilizados para la red del presente estudio. La Universidad de Tsukuba y AIST están conectadas por una red WAN de 1 Gbps en Tsukuba, y los otros clústeres de PC están conectados por SINET, que es una red de área amplia dedicada a la investigación académica en Japón. La Tabla 2 muestra el rendimiento de la red medida entre el nodo maestro del clúster Dennis y el nodo maestro de cada clúster de PC en el banco de pruebas de la red. El rendimiento de CONFLEX-G En todos los experimentos de CONFLEX-G, el programa cliente se ejecutó en el nodo maestro del clúster Dennis en la Universidad de Tsukuba. El planificador Round-Robin incorporado de OmniRPC se utilizó como planificador de tareas. Se utilizó SSH para un sistema de autenticación, el OminRPCs MXIO, que retransmite la comunicación de E/S entre el programa cliente y los programas trabajadores mediante el reenvío de puertos de SSH, no se utilizó. Se debe tener en cuenta que un programa de trabajador se asigna y se ejecuta en una CPU de un nodo de cálculo en un clúster de PC. Es decir, el número de trabajadores es igual al número de CPUs. Estos programas fueron compilados por el Intel Fortran Compiler 7.0 y gcc 2.95. Se utilizó MPICH, Versión 1.2.5, para comparar el rendimiento entre CONFLEX MPI y CONFLEX-G. Para demostrar la usabilidad de la instalación OmniRPC de AIM, implementamos otra versión de CONFLEX-G que no utilizaba la instalación OmniRPC. El programa del trabajador en esta versión de CONFLEXG debe inicializarse en cada RPC porque el trabajador no conserva el conjunto de datos anterior. Para examinar el rendimiento de CONFLEX-G, seleccionamos dos péptidos y dos proteínas pequeñas como moléculas de prueba: • N-acetil tetra-alanina metilester (AlaX04) • N-acetil hexadeca-alanina metilester (AlaX16) • Construcción de miniproteína TRP-cage TC5B (1L2Y) • Fragmento del extremo N del receptor de PTH (1BL1) La Tabla 3 enumera las características de estas moléculas de muestra. La estructura de prueba de columnas / bucles en esta tabla muestra la Figura 7: Rendimientos de CONFLEX-G, CONFLEX MPI y CONFLEX Original en el clúster Dennis. Figura 8: Proporción de aceleración, que se basa en el tiempo transcurrido de CONFLEX-G utilizando un trabajador en el clúster de Dennis. Figura 9: Rendimiento de CONFLEX-G con y sin la facilidad OmniRPC del módulo inicializable automático para AlaX16. Tabla 3: Características de las moléculas y transmisión de datos para optimizar las estructuras moleculares de prueba en cada código molecular. Tabla 4: Tiempo de búsqueda transcurrido para la conformación molecular de AlaX04. Tabla 6: Tiempo transcurrido de la búsqueda de la estructura de prueba de 1L2Y. Tabla 7: Tiempo transcurrido de la búsqueda de la estructura de prueba de 1BL1. Número total de estructuras del clúster Tiempo de optimización Transcurrido Velocidad transcurrida (# de trabajadores) trabajadores / trabajador / estructura (s) tiempo (s) tiempo (H) hasta Toyo MPI (1) 1 519.0 3,646 189,210 525.61 1.00 Toyo MPI (16) 16 32.4 3,646 120,028 33.34 15.76 Dennis (28) 28 18.5 3,154 61,803 17.16 30.61 Dennis (28) + Ume (56) 84 6.1 4,497 33,502 9.30 56.48 160 número de estructuras de prueba generadas en cada iteración, indicando el grado de paralelismo. La Figura 3 también resume la cantidad de transmisión de datos requerida para la inicialización de un programa de trabajador y para la optimización de cada estructura de prueba. Ten en cuenta que la cantidad de transmisión de datos necesaria para inicializar un programa de trabajador y optimizar una estructura de prueba en la versión MPI de CONFLEX es igual a la de CONFLEX-G. Utilizamos una versión mejorada del campo de fuerza MM2 para asignar una función de energía potencial a varias propiedades geométricas de un grupo de átomos. 4.2.1 Rendimiento en un clúster local. Primero comparamos el rendimiento de CONFLEX-G, la versión MPI de CONFLEX y la versión secuencial original de CONFLEX-G utilizando un clúster local. Investigamos el rendimiento variando el número de trabajadores utilizando el clúster Dennis. Elegimos AlaX04 como molécula de prueba para este experimento. La Figura 7 compara los resultados para el CONFLEX MPI y el CONFLEX-G en un clúster de PC local. El resultado de este experimento muestra que CONFLEX-G puede reducir el tiempo de ejecución a medida que aumenta el número de trabajadores, al igual que en la versión MPI de CONFLEX. Descubrimos que CONFLEX-G logró eficiencias comparables a la versión MPI. Con 28 trabajadores, CONFLEX-G logró una mejora de velocidad de 18.00 veces en comparación con la versión secuencial de CONFLEX. El rendimiento de CONFLEX-G sin la funcionalidad AIM de OmniRPC es peor que el de CONFLEX-G que utiliza la funcionalidad, basado en el aumento en el número de trabajadores. Esto indica que el OmniRPC AIM permite al trabajador calcular de manera eficiente sin necesidad de realizar otros cálculos, como la inicialización o la invocación de programas de trabajador. A medida que se aumenta el número de trabajadores, el rendimiento de CONFLEX-G es ligeramente inferior al de la versión MPI. Esta degradación del rendimiento es causada por diferencias en los procesos de inicialización de los trabajadores de CONFLEX-G y CONFLEX MPI. En el caso de CONFLEX MPI, todos los trabajadores se inicializan antes de la fase de optimización. En el caso de OminRPC, el trabajador es invocado bajo demanda cuando la llamada RPC es emitida realmente. Por lo tanto, la inicialización conlleva este sobrecosto. Dado que el objetivo de CONFLEX-G es explorar las conformaciones de grandes bio-moléculas, el número de estructuras de prueba y el tiempo para optimizar la estructura de prueba podrían ser grandes. En tales casos, el gasto general para invocar e inicializar el programa de trabajador puede ser pequeño en comparación con el tiempo total transcurrido. 4.2.2 Rendimiento para Péptidos en el Banco de Pruebas de la Red En primer lugar, las moléculas de muestra (AlaX04 y AlaX16) se utilizaron para examinar el rendimiento de CONFLEX-G en un entorno de red. La Figura 8 muestra la aceleración lograda al utilizar múltiples clústeres en comparación con el uso de un solo trabajador en el clúster de Dennis. Los resultados detallados se muestran en la Tabla 4 y la Tabla 5. En ambos casos, el mejor rendimiento se obtuvo utilizando 64 trabajadores de la combinación de los clústeres de Dennis y Alice. CONFLEX-G logró una aceleración máxima de 36.08 veces para AlaX04 y una aceleración máxima de 21.91 veces para AlaX16. En el caso de AlaX04, el rendimiento mejora solo cuando el rendimiento de la red entre clústeres es alto. Sin embargo, aunque se utilicen dos o más grupos en un entorno de red de área amplia, la mejora en el rendimiento fue leve debido a que el tiempo de optimización de una estructura de prueba generada a partir de AlaX04, una molécula pequeña, es corto. Además, los gastos generales necesarios para la invocación de un programa de trabajador y la transmisión de datos a través de la red consumen una gran parte del tiempo de procesamiento restante. En particular, la transmisión de datos necesaria para la inicialización de un programa de trabajador es de 2 MB. En el caso del clúster Toyo, donde el rendimiento de la red entre el programa cliente y los programas trabajadores es deficiente, el tiempo de transmisión de datos al programa trabajador requería aproximadamente 6.7 segundos. Dado que el tiempo de transmisión fue más largo que el tiempo de procesamiento de una optimización de estructura en CONFLEX-G, la mayor parte del tiempo se dedicó a esta transmisión de datos. Por lo tanto, incluso si CONFLEX-G utiliza un gran número de nodos de cálculo en un entorno de red de área amplia, no se obtiene el beneficio de utilizar un recurso de cuadrícula. En el caso de AlaX16, CONFLEX-G logró una aceleración al utilizar dos o más clústeres de PC en nuestro banco de pruebas en red. Esto se debió a que el tiempo de cálculo en el programa del trabajador era largo y los costos adicionales, como la latencia de red y la invocación de programas de trabajador, se volvieron relativamente pequeños y pudieron ocultarse. El mejor rendimiento se obtuvo utilizando 64 trabajadores en los clústeres de Dennis y Alice. En el caso de AaX16, el rendimiento logrado fue un aumento de velocidad de 36.08 veces. La Figura 9 revela el efecto de utilizar la facilidad del OmniRPC AIM en el rendimiento de CONFLEX-G. En la mayoría de los casos, CONFLEX-G con la instalación de OmniRPC AIM logró un mejor rendimiento que CONFLEX-G sin la instalación. En particular, la facilidad OmniRPC AIM fue ventajosa al usar dos clústeres conectados por una red de bajo rendimiento. Los resultados indican que la instalación OmniRPC AIM puede mejorar el rendimiento en el entorno de la red. 4.2.3 Rendimiento para proteínas pequeñas en el banco de pruebas de la red. Finalmente, exploramos la conformación molecular utilizando CONFLEX-G para moléculas grandes. En un entorno de cuadrícula, este experimento se llevó a cabo utilizando los clústeres Dennis y Ume. En este experimento, utilizamos dos proteínas, 1L2Y y 1BL1. La Tabla 6 y la Tabla 7 muestran el rendimiento de CONFLEX-G en el entorno de la red y el de CONFLEX MPI en el clúster de Toyo, respectivamente. Los incrementos de velocidad en estas tablas fueron calculados respectivamente basados en el rendimiento de un trabajador y 16 trabajadores del clúster Toyo utilizando CONFLEX MPI. CONFLEX-G con 84 trabajadores en los grupos de Dennis y Ume obtuvo aceleraciones máximas de 56.5 veces para 1L2Y y 34.5 veces para 1L2Y. Dado que el tiempo de cálculo para la optimización de la estructura requería una gran cantidad de tiempo, la proporción de gastos generales, incluidas tareas como la invocación de un programa de trabajador y la transmisión de datos para la inicialización, se volvió muy pequeña, por lo que el rendimiento de CONFLEX-G mejoró. Descubrimos que el desequilibrio de carga en el tiempo de procesamiento de la optimización para cada estructura de prueba causó una degradación del rendimiento. Cuando obtuvimos el mejor rendimiento para 1L2Y utilizando los cúmulos de Dennis y Ume, el tiempo para la optimización de cada estructura varió de 190 a 27,887 segundos, y la proporción entre los tiempos más largos y más cortos fue de 13.4. Para 1BL1, la proporción de tiempo mínimo sobre tiempo máximo fue de 190. Además, para que el programa del trabajador espere hasta que se complete la optimización de todas las estructuras de prueba, se descubrió que todos los programas de trabajador esperaban en un estado inactivo durante aproximadamente 6 horas. Esto ha causado la degradación del rendimiento de CONFLEX-G. 161 4.3 Discusión En esta subsección, discutimos la mejora del rendimiento reflejada en nuestros experimentos. Explotando el paralelismo - Para aprovechar más recursos computacionales, es necesario aumentar el grado de paralelismo. En este experimento, el grado de paralelismo no fue tan grande en el caso de las moléculas de muestra. Al utilizar un conjunto de más de 500 nodos informáticos para 1BL1, el número de estructuras de un solo ensayo asignadas a cada trabajador será solo de uno o dos. Si se asignan más de 100 estructuras de prueba a cada programa de trabajador, el cálculo se puede realizar de manera más eficiente debido a la reducción de la sobrecarga para la invocación y la inicialización de los trabajadores a través de la facilidad de OmniRPC AIM. Una idea para aumentar el paralelismo es superponer la ejecución de dos o más conjuntos de estructuras de prueba. En el algoritmo actual, se genera un conjunto de estructuras de prueba a partir de una estructura inicial y se calculan las optimizaciones para todas las estructuras de este conjunto. Además, esto ayudará a mejorar el desequilibrio de carga. Al hacer que otros conjuntos de estructuras de prueba se superpongan, incluso si algunas optimizaciones requieren mucho tiempo, la optimización de las estructuras en otros conjuntos se puede ejecutar para compensar a los trabajadores inactivos de otras optimizaciones. Sin embargo, no está claro cómo dicha modificación del algoritmo podría afectar la calidad de los resultados finales en términos de una búsqueda de conformación. Mejora en el desequilibrio de carga al optimizar cada estructura de prueba: la Tabla 8 enumera las estadísticas de los tiempos de optimización de las estructuras de prueba generadas para cada molécula de muestra medida utilizando 28 trabajadores en el clúster de Dennis. Cuando se utilizan dos o más conjuntos de grupos de PC, la mejora en el rendimiento se ve obstaculizada por el desequilibrio de carga en la optimización de las estructuras de prueba. El tiempo más largo para optimizar una estructura de prueba fue casi 24 veces más largo que el tiempo más corto. Además, los demás trabajadores deben esperar hasta que el trabajo más largo haya terminado, por lo que el tiempo total de ejecución no se puede reducir. Cuando CONFLEX-G buscó los conformeros de 1BL1 mediante el clúster de Dennis, el tiempo de cálculo más largo de la optimización de la estructura de prueba representó aproximadamente el 80% del tiempo transcurrido. Por lo tanto, hay dos posibles soluciones para el desequilibrio de carga. • Es necesario refinar el algoritmo utilizado para generar la estructura de prueba, que suprime la variación temporal para optimizar una estructura de prueba en CONFLEX. Esto permite que CONFLEX-G logre un alto rendimiento al utilizar muchos recursos informáticos. • Una de las soluciones es superponer las ejecuciones para dos o más conjuntos de estructuras de prueba. En los algoritmos actuales, se genera un conjunto de estructuras de prueba a partir de una estructura inicial y el cálculo continúa hasta que se calculen todas las estructuras de este conjunto. Al tener otros conjuntos de estructuras de prueba, incluso si una búsqueda de estructuras lleva mucho tiempo, un trabajo puede ejecutarse para compensar el desequilibrio de carga causado por otros trabajos. Sin embargo, no está claro cómo tal modificación de los algoritmos podría afectar la eficiencia. En este experimento, utilizamos un programador de round-robin incorporado simple de OmniRPC, que es necesario para aplicar el programador que asigna estructuras con largos tiempos de optimización a una tabla de alto rendimiento. Tabla 8: Estadísticas del tiempo transcurrido de la optimización de la estructura de prueba utilizando 28 trabajadores en el clúster Dennis. Código de Varianza Promedio Mínimo Máximo Molecular (s) (s) (s) AlaX04 2.0 11.3 5.3 3 AlaX16 47.6 920.0 154.2 5404 1L2Y 114.2 13331.4 803.2 636782 1BL1 121.0 29641.8 3153.5 2734811 nodos y estructuras con tiempos de optimización cortos a nodos de bajo rendimiento. En general, sin embargo, podría ser difícil predecir el tiempo necesario para la optimización de la estructura del ensayo. Paralelización del programa del trabajador para acelerar y optimizar una estructura de prueba - En la implementación actual, no paralelizamos el programa del trabajador. Para acelerar las estructuras de prueba, la programación híbrida utilizando OmniRPC y OpenMP en una máquina SMP (Symmetric Multiple Processor) puede ser uno de los métodos alternativos para mejorar el rendimiento general. TRABAJO RELACIONADO Recientemente, se ha desarrollado un algoritmo que resuelve los problemas de paralelización y comunicación en procesadores poco conectados para ser utilizados en simulaciones. El proyecto Folding@home simula escalas de tiempo miles a millones de veces más largas que las logradas previamente. Esto nos ha permitido simular el plegamiento por primera vez y examinar directamente enfermedades relacionadas con el plegamiento. SETI@home es un programa para buscar vida extraterrestre mediante el análisis de señales de radio telescopio utilizando datos de telescopios de diferentes sitios mediante la transformada de Fourier. SETI@home aborda problemas inmensamente paralelos, en los cuales los cálculos pueden dividirse fácilmente entre varios ordenadores. Los fragmentos de datos del radiotelescopio pueden asignarse fácilmente a diferentes computadoras. La mayoría de estos esfuerzos desarrollan explícitamente una aplicación de acoplamiento como una aplicación paralela utilizando un lenguaje de programación paralela de propósito especial y middleware, como MPI, lo cual requiere habilidades y esfuerzo de desarrollo. Sin embargo, las habilidades y esfuerzo necesarios para desarrollar una aplicación de cuadrícula pueden no ser necesarios para OmniRPC. Nimrod/G[15] es una herramienta para modelado paramétrico distribuido e implementa una granja de tareas paralelas para simulaciones que requieren varios parámetros de entrada variables. Nimrod incorpora un componente de programación distribuida que puede gestionar la programación de experimentos individuales en computadoras inactivas en una red de área local. Nimrod se ha aplicado en aplicaciones que incluyen bioinformática, investigación de operaciones y modelado molecular para el diseño de fármacos. NetSolve es una instalación de RPC similar a OmniRPC y Ninf, que proporciona una interfaz de programación similar y un mecanismo de equilibrio de carga automático. Ninf-G[7] es una implementación habilitada para grid de Ninf y proporciona un sistema GridRPC[10] que utiliza LDAP para gestionar la base de datos de ejecutables remotos, pero no admite clústeres que involucren direcciones IP privadas o direcciones dentro de un firewall. Matsuoka et al. [16] también han discutido varios problemas de diseño relacionados con los sistemas de RPC en malla. 162 6. CONCLUSIONES Y TRABAJO FUTURO Hemos diseñado e implementado CONFLEX-G utilizando OmniRPC. Informamos sobre su rendimiento en un banco de pruebas en red de varios clústeres de PC distribuidos geográficamente. Para explorar la conformación de grandes biomoléculas, se utilizó CONFLEXG para generar estructuras de prueba de las moléculas y asignar trabajos para optimizarlas mediante mecánica molecular en la cuadrícula. OmniRPC proporciona un modelo de persistencia restringido para que el módulo se inicialice automáticamente al invocarse llamando al procedimiento de inicialización. Esto puede eliminar la comunicación innecesaria y la inicialización en cada llamada en CONFLEX-G. CONFLEX-G puede lograr un rendimiento comparable al de CONFLEX MPI y aprovecha más recursos informáticos al permitir el uso de múltiples clústeres de PC en la red. El resultado experimental muestra que CONFLEX-G logró una aceleración de 56.5 veces para la molécula 1BL1, donde la molécula consta de un gran número de átomos y cada optimización de la estructura de prueba requiere mucho tiempo. El desequilibrio de carga de las optimizaciones de la estructura de prueba puede causar degradación del rendimiento. Necesitamos refinar el algoritmo utilizado para generar la estructura de prueba con el fin de mejorar la optimización del equilibrio de carga para las estructuras de prueba en CONFLEX. Los estudios futuros incluirán el desarrollo de herramientas de implementación y un examen de la tolerancia a fallos. En el OmniRPC actual, el registro de un programa de ejecución en hosts remotos y despliegues de programas de trabajadores se configuran manualmente. Se requerirán herramientas de implementación a medida que se incremente el número de hosts remotos. En entornos de cuadrícula en los que el entorno cambia dinámicamente, también es necesario contar con soporte para la tolerancia a fallos. Esta característica es especialmente importante en aplicaciones a gran escala que requieren cálculos prolongados en un entorno de cuadrícula. Planeamos refinar el algoritmo de optimización conformacional en CONFLEX para explorar el espacio de búsqueda de conformaciones de moléculas biológicas más grandes como la proteasa del VIH utilizando hasta 1000 trabajadores en un entorno de cuadrícula. AGRADECIMIENTOS Esta investigación fue apoyada en parte por una Subvención de la Secretaría de Educación, Cultura, Deportes, Ciencia y Tecnología de Japón, No. 14019011, 2002, y como parte del Programa de Investigación y Desarrollo para Aplicar la Ciencia y Tecnología Computacional Avanzada por la Corporación de Ciencia y Tecnología de Japón (Investigación en la plataforma de computación en red para el diseño de fármacos). Nos gustaría agradecer al centro de investigación de tecnología de red, AIST, Japón por proporcionar recursos informáticos para nuestro experimento. 8. REFERENCIAS [1] H. Goto y E. Osawa. Un algoritmo eficiente para buscar conformaciones de baja energía de moléculas cíclicas y acíclicas. J. Quím. Soc., Perkin Trans, 2:187-198, 1993. [2] M. Sato, T. Boku, y D. Takahashi. OmniRPC: un sistema de RPC en malla para programación paralela en entornos de clúster y malla. En Proc. de CCGrid2003, páginas 219-229, 2003. [3] M. Sato, M. Hirano, Y. Tanaka y S. Sekiguchi. OmniRPC: una instalación de RPC en Grid para la computación en clúster y global en OpenMP. En Proc. del Taller sobre Aplicaciones y Herramientas OpenMP 2001 (LNCS 2104), páginas 130-135, 2001. [4] Proyecto OmniRPC. http://www.omni.hpcc.jp/omnirpc/. [5] M. Sato, H. Nakada, S. Sekiguchi, S. Matsuoka, U. Nagashima y H. Takagi. Ninf: Una Biblioteca de Información Basada en Red para la Infraestructura de Computación Global en Todo el Mundo. En HPCN Europe, páginas 491-502, 1997. [6] Proyecto Ninf. http://ninf.apgrid.org/. [7] Y. Tanaka, H. Nakada, S. Sekiguchi, T. Suzumura y S. Matsuoka. Ninf-G: Una Implementación de Referencia de Middleware de Programación basado en RPC para la Computación en Grid. Revista de Computación en Red, 1(1):41-51, 2003. [8] D. Arnold, S. Agrawal, S. Blackford, J. Dongarra, M. Miller, K. Seymour, K. Sagi, Z. Shi y S. Vadhiyar. Guía del usuario de NetSolve V1.4.1. Departamento de Computación Innovador. Informe técnico ICL-UT-02-05, Universidad de Tennessee, Knoxville, TN, junio de 2002. [9] Grupo de gestión de objetos. http://www.omg.org/. [10] K. Seymour, H. Nakada, S. Matsuoka, J. Dongarra, C. Lee y H. Casanova. GridRPC: Una API de Llamada a Procedimientos Remotos para la Computación en Grid. [11] H. Goto, T. Takahashi, Y. Takata, K. Ohta y U. Nagashima. Conflex: Comportamientos conformacionales de polipéptidos según lo predicho por una búsqueda en el espacio conformacional. En Nanotech2003, volumen 1, páginas 32-35, 2003. [12] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. La Revista Internacional de Aplicaciones de Supercomputadoras y Computación de Alto Rendimiento, 11(2):115-128, Verano 1997. [13] Stefan M. Larson, Christopher D. Snow, Michael Shirts y Vijay S. Pande. Folding@home y genome@home: Utilizando computación distribuida para abordar problemas previamente intratables en biología computacional. Genómica Computacional, 2002. Proyecto seti@home. http://setiathome.ssl.berkeley.edu/. R. Buyya, K. Branson, J. Giddy y D. Abramson. El laboratorio virtual: un conjunto de herramientas para habilitar la modelización molecular distribuida para el diseño de fármacos en la red mundial. Concurrencia y Computación: Práctica y Experiencia, 15(1):1-25, enero de 2003. [16] S. Matsuoka, H. Nakada, M. Sato y S. Sekiguchi. Problemas de diseño de sistemas de servidores habilitados para redes para la red. En Proc. de GRID 2000 (LNCS 1971), páginas 4-17, 2000. 163