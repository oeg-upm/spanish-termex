Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En "Bajo revisión, 2003". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75