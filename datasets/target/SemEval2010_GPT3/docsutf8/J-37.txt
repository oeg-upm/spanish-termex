Encontrar equilibrios en juegos secuenciales grandes de información imperfecta∗ Andrew Gilpin Departamento de Ciencias de la Computación Universidad Carnegie Mellon Pittsburgh, PA, EE. UU. gilpin@cs.cmu.edu Tuomas Sandholm Departamento de Ciencias de la Computación Universidad Carnegie Mellon Pittsburgh, PA, EE. UU. sandholm@cs.cmu.edu RESUMEN Encontrar un equilibrio de un juego de forma extensiva de información imperfecta es un problema fundamental en la teoría computacional de juegos, pero las técnicas actuales no escalan a juegos grandes. Para abordar esto, introducimos el isomorfismo de juego ordenado y la transformación de abstracción isomórfica de juego ordenado relacionada. Para un juego secuencial de múltiples jugadores con información imperfecta, acciones observables y un espacio de señales ordenado, demostramos que cualquier equilibrio de Nash en un juego abstracto más pequeño, obtenido mediante una o más aplicaciones de la transformación, puede convertirse fácilmente en un equilibrio de Nash en el juego original. Presentamos un algoritmo, GameShrink, para abstraer el juego utilizando exhaustivamente nuestro isomorfismo. Su complejidad es ˜O(n2), donde n es el número de nodos en una estructura que llamamos el árbol de señales. No es más grande que el árbol de juego, y en juegos no triviales es drásticamente más pequeño, por lo que GameShrink tiene complejidad temporal y espacial sublineal en el tamaño del árbol de juego. Usando GameShrink, encontramos un equilibrio para un juego de póker con 3.1 mil millones de nodos, más de cuatro órdenes de magnitud que en el juego de póker más grande resuelto previamente. Discutimos varias aplicaciones de comercio electrónico para GameShrink. Para abordar juegos aún más grandes, introducimos métodos de aproximación que no preservan el equilibrio, pero que, no obstante, producen estrategias (ex post) cercanas a óptimas de manera demostrable. Categorías y Descriptores de Asignaturas: I.2 [Inteligencia Artificial], F. [Teoría de la Computación], J.4 [Ciencias Sociales y del Comportamiento]: Economía. Términos generales: Algoritmos, Economía, Teoría. 1. INTRODUCCIÓN En entornos con más de un agente, el resultado de un agente generalmente se ve afectado por las acciones del otro(s) agente(s). Por consiguiente, la acción óptima de un agente puede depender de los demás. La teoría de juegos proporciona un marco normativo para analizar tales situaciones estratégicas. En particular, proporciona conceptos de solución que definen qué es el comportamiento racional en tales contextos. El concepto de equilibrio de Nash [36] es el más famoso e importante en teoría de juegos. Es un perfil estratégico (una estrategia para cada agente) en el cual ningún agente tiene incentivo para desviarse hacia una estrategia diferente. Sin embargo, para que el concepto sea operativo, necesitamos técnicas algorítmicas para encontrar un equilibrio. Los juegos pueden clasificarse como juegos de información perfecta o información imperfecta. El ajedrez y el Go son ejemplos de lo primero, y, hasta hace poco, la mayoría del trabajo de juegos se ha centrado en juegos de este tipo. Para calcular una estrategia óptima en un juego de información perfecta, un agente recorre el árbol de juego y evalúa los nodos individuales. Si el agente es capaz de recorrer todo el árbol de juego, simplemente calcula una estrategia óptima de abajo hacia arriba, utilizando el principio de inducción hacia atrás. En términos de informática, esto se hace utilizando la búsqueda minimax (a menudo en conjunto con la poda αβ para reducir el tamaño del árbol de búsqueda y así mejorar la velocidad). La búsqueda Minimax se ejecuta en tiempo lineal en el tamaño del árbol de juego. La característica diferenciadora de los juegos de información imperfecta, como el póker, es que no son completamente observables: cuando es el turno de un agente de moverse, no tiene acceso a toda la información sobre el mundo. En tales juegos, la decisión de qué hacer en un momento dado generalmente no puede tomarse de manera óptima sin considerar las decisiones en todos los demás momentos (incluidas las de otros caminos de juego) porque esas otras decisiones afectan las probabilidades de encontrarse en diferentes estados en el momento actual. Por lo tanto, los algoritmos para juegos de información perfecta no resuelven juegos de información imperfecta. Para juegos secuenciales con información imperfecta, se podría intentar encontrar un equilibrio utilizando la forma normal (matricial), donde cada plan de contingencia del agente es una estrategia pura para el agente. Desafortunadamente (incluso si las estrategias equivalentes 1 en realidad producen una solución que satisface no solo el concepto de solución de equilibrio de Nash, sino un concepto de solución más fuerte llamado equilibrio de Nash perfecto en subjuegos [45]. 2 Este tipo de algoritmo aún no escala a árboles enormes (como en ajedrez o Go), pero se pueden desarrollar agentes de juego efectivos incluso entonces evaluando nodos intermedios utilizando una evaluación heurística y luego tratando esos nodos como hojas. 3 Un equilibrio en una forma normal de juego con cualquier 160 se reemplazan por una sola estrategia [27]), esta representación es generalmente exponencial en el tamaño del árbol de juego [52]. Al observar que solo es necesario considerar secuencias de movimientos en lugar de estrategias puras [41, 46, 22, 52], se llega a una representación más compacta, la forma de secuencia, que es lineal en el tamaño del árbol de juego. Para juegos de 2 jugadores, existe una formulación de programación lineal de tamaño polinómico (en el tamaño del árbol de juego) (complementariedad lineal en el caso no de suma cero) basada en la forma de secuencia, de modo que las estrategias para los jugadores 1 y 2 corresponden a variables primales y duales. Por lo tanto, los equilibrios de juegos de 2 jugadores de tamaño razonable pueden ser calculados utilizando este método. Sin embargo, este enfoque sigue generando problemas de optimización enormes (insolubles) para muchos juegos del mundo real, como el póker. En este artículo, adoptamos un enfoque diferente para abordar el difícil problema del cálculo de equilibrios. En lugar de desarrollar un método de encontrar equilibrios per se, en su lugar desarrollamos una metodología para abstraer automáticamente juegos de tal manera que cualquier equilibrio en el juego más pequeño (abstraído) corresponda directamente a un equilibrio en el juego original. Por lo tanto, al calcular un equilibrio en el juego más pequeño (utilizando cualquier algoritmo disponible para encontrar equilibrios), podemos construir un equilibrio en el juego original. La motivación es que un equilibrio para el juego más pequeño se puede calcular drásticamente más rápido que para el juego original. Con este fin, introducimos juegos con señales ordenadas (Sección 2), una amplia clase de juegos que tiene la suficiente estructura que podemos explotar con fines de abstracción. En lugar de operar directamente sobre el árbol de juego (algo que encontramos ser técnicamente desafiante), en su lugar introducimos el uso de filtros de información (Sección 2.1), que reducen la información que recibe cada jugador. Son utilizados en nuestro algoritmo de análisis y abstracción. Al operar únicamente en el espacio de los filtros, podemos mantener la estructura estratégica del juego intacta, al mismo tiempo que abstraemos los detalles del juego de una manera que no pierde información desde la perspectiva de encontrar el equilibrio. Introducimos el isomorfismo de juego ordenado para describir situaciones estratégicamente simétricas y la transformación de abstracción isomórfica de juego ordenado para aprovechar tales simetrías (Sección 3). Como nuestro resultado principal de equilibrio, tenemos lo siguiente: un número constante de agentes puede ser construido en tiempo cuasipolinómico [31], pero encontrar un equilibrio exacto es PPAD-completo incluso en un juego de 2 jugadores [8]. El algoritmo más prevalente para encontrar un equilibrio en un juego de 2 agentes es Lemke-Howson [30], pero en el peor de los casos requiere exponencialmente muchos pasos [44]. Para una encuesta sobre el cálculo del equilibrio en juegos de 2 jugadores, consulte [53]. Recientemente, se han demostrado eficientes algoritmos de búsqueda de equilibrio que enumeran soportes (es decir, conjuntos de estrategias puras que se juegan con probabilidad positiva) en muchos juegos [40], y se han desarrollado eficientes algoritmos de programación entera mixta que buscan en el espacio de soportes [43]. Para más de dos jugadores, se han propuesto muchos algoritmos, pero actualmente solo escalan a juegos muy pequeños [19, 34, 40]. También hubo técnicas tempranas que se aprovecharon de diferentes maneras del hecho de que en muchos juegos la gran mayoría de las estrategias puras no se juegan en equilibrio [54, 23]. Recientemente, este enfoque se extendió para manejar el cálculo de equilibrios secuenciales [26] también [35]. Teorema 2: Sea Γ un juego con señales ordenadas, y sea F un filtro de información para Γ. Sea F un filtro de información construido a partir de F mediante una aplicación de la transformación de abstracción isomórfica del juego ordenado, y sea σ un perfil de estrategia de equilibrio de Nash del juego inducido ΓF (es decir, el juego Γ utilizando el filtro F). Si σ se construye utilizando las estrategias correspondientes de σ, entonces σ es un equilibrio de Nash de ΓF. La prueba del teorema utiliza una caracterización equivalente de los equilibrios de Nash: σ es un equilibrio de Nash si y solo si existen creencias μ (creencias de los jugadores sobre información desconocida) en todos los puntos del juego alcanzables por σ, de modo que σ es secuencialmente racional (es decir, una mejor respuesta) dada μ, donde μ se actualiza utilizando la regla de Bayes. Podemos entonces usar el hecho de que σ es un equilibrio de Nash para demostrar que σ es un equilibrio de Nash considerando solo las propiedades locales del juego. También presentamos un algoritmo, GameShrink, para abstraer el juego utilizando exhaustivamente nuestro isomorfismo (Sección 4). Su complejidad es ˜O(n2), donde n es el número de nodos en una estructura que llamamos el árbol de señales. No es más grande que el árbol de juego, y en juegos no triviales es drásticamente más pequeño, por lo que GameShrink tiene complejidad temporal y espacial sublineal en el tamaño del árbol de juego. Presentamos varias mejoras de velocidad relacionadas con algoritmos y estructuras de datos (Sección 4.1), y demostramos cómo una modificación simple a nuestro algoritmo produce un algoritmo de aproximación (Sección 5). Aplicaciones de comercio electrónico Los juegos secuenciales de información imperfecta son ubicuos, por ejemplo, en negociaciones y subastas. A menudo, aspectos del conocimiento de un jugador no son pertinentes para decidir qué acción debe tomar el jugador en un punto dado del juego. En el extremo trivial, algunos aspectos del conocimiento de un jugador nunca son pertinentes (por ejemplo, si está lloviendo o no no tiene ninguna influencia en la estrategia de oferta en una subasta de arte), y dichos aspectos pueden ser completamente omitidos de la especificación del modelo. Sin embargo, algunos aspectos pueden ser pertinentes en ciertos estados del juego mientras que no son pertinentes en otros estados, y por lo tanto no pueden ser excluidos completamente del modelo. Además, puede resultar altamente no evidente qué aspectos son pertinentes en qué estados del juego. Nuestro algoritmo descubre automáticamente qué aspectos son irrelevantes en diferentes estados, y elimina esos aspectos del juego, lo que resulta en una representación del juego más compacta y equivalente. Una amplia área de aplicación que tiene esta propiedad es la negociación secuencial (potencialmente sobre múltiples temas). Otra área de aplicación amplia son las subastas secuenciales (potencialmente de múltiples bienes). Por ejemplo, en esos estados de una subasta de 1 objeto donde el postor A puede inferir que su valoración es mayor que la del postor B, el postor A puede ignorar toda su otra información sobre las señales de B, aunque esa información sería relevante para inferir la valoración exacta de B. Además, en algunos estados de la subasta, un postor podría no preocuparse por qué postores exactos tienen qué valoraciones, pero le importa qué valoraciones tienen los otros postores en conjunto (ignorando sus identidades). Muchos mecanismos de subasta secuencial de grito abierto y negociación entran dentro del modelo de juego estudiado en este documento (especificado en detalle más adelante), al igual que ciertos otros juegos en el comercio electrónico, como secuencias de ofertas de tómalo o déjalo [42]. Nuestras técnicas no están de ninguna manera específicas para una aplicación. El experimento principal que presentamos en este artículo es sobre un juego recreativo. Elegimos un juego de póker en particular como problema de referencia porque produce un árbol de juego extremadamente complicado y enorme, es un juego de información imperfecta, está completamente especificado como un juego (y los datos están disponibles), y ha sido propuesto como un problema desafiante por otros [47] (hasta donde sabemos, no se han propuesto instancias de problemas desafiantes para aplicaciones de comercio electrónico que requieran resolver juegos secuenciales). 1.3 Rhode Island Holdem poker Poker es un juego de cartas enormemente popular jugado en todo el mundo. La Serie Mundial de Póker de 2005 tuvo más de $103 millones de dólares en premios totales, incluyendo $56 millones para el evento principal. Cada vez más, los jugadores de póker compiten en casinos en línea, y las cadenas de televisión transmiten regularmente torneos de póker. El póker ha sido identificado como un área de investigación importante en IA debido a la incertidumbre derivada de las cartas de los oponentes, las acciones futuras de los oponentes y los movimientos de azar, entre otras razones [5]. Casi desde los inicios del campo, la teoría de juegos se ha utilizado para analizar diferentes aspectos del póker [28; 37; 3; 51, pp. 186-219]. Sin embargo, este trabajo se limitaba a juegos pequeños que podían resolverse a mano. Más recientemente, los investigadores de IA han estado aplicando la potencia computacional del hardware moderno para calcular estrategias basadas en la teoría de juegos para juegos más grandes. Koller y Pfeffer determinaron soluciones para juegos de póker con hasta 140,000 nodos utilizando la forma de secuencia y programación lineal [25]. Se han desarrollado aproximaciones a gran escala [4], pero esos métodos no ofrecen garantías sobre el rendimiento de las estrategias calculadas. Además, las aproximaciones fueron diseñadas manualmente por un experto humano. Nuestro enfoque produce un mecanismo de abstracción automatizado junto con garantías teóricas sobre el rendimiento de las estrategias. Rhode Island Holdem fue inventado como un banco de pruebas para el juego computacional [47]. Fue diseñado de manera que fuera similar en estilo a Texas Holdem, pero no tan grande que resultara imposible idear estrategias razonablemente inteligentes. (Las reglas de Rhode Island Holdem, así como una discusión sobre cómo Rhode Island Holdem puede ser modelado como un juego con señales ordenadas, es decir, encaja en nuestro modelo, están disponibles en una versión extendida de este artículo [13].) Aplicamos las técnicas desarrolladas en este artículo para encontrar una solución exacta (minimax) para Rhode Island Holdem, que tiene un árbol de juego que supera los 3.1 mil millones de nodos. Aplicar la forma de secuencia al Rhode Island Holdem directamente sin abstracción produce un programa lineal con 91,224,226 filas y el mismo número de columnas. Esto es demasiado grande para que los algoritmos de programación lineal actuales puedan manejar. Utilizamos nuestro algoritmo GameShrink para reducir esto con abstracción sin pérdida, y dio como resultado un programa lineal con 1,237,238 filas y columnas, con 50,428,638 coeficientes no nulos. Luego aplicamos la eliminación iterada de estrategias dominadas, lo que redujo aún más esto a 1,190,443 filas y 1,181,084 columnas. (Aplicar la eliminación iterada de estrategias dominadas sin GameShrink habría dado como resultado 89,471,986 filas y 89,121,538 columnas, lo cual seguiría siendo demasiado grande para resolverlo). GameShrink tardó menos de un segundo en realizar el encogimiento (es decir, en calcular todas las transformaciones de abstracción isomórfica de juego ordenadas). Usando un IBM eServer p5 570 de 1.65GHz con 64 gigabytes de RAM (el solucionador de programas lineales realmente necesitaba 25 gigabytes), lo resolvimos en 7 días y 17 horas utilizando el método de barrera de punto interior de CPLEX versión 9.1.2. Recientemente demostramos a nuestro jugador óptimo de póker Rhode Island Holdem en la conferencia AAAI-05 [14], y está disponible para jugar en línea en http://www.cs.cmu.edu/~gilpin/gsi.html. Si bien otros han trabajado en programas de computadora para jugar Rhode Island Holdem [47], no se ha encontrado una estrategia óptima antes. Este es el juego de póker más grande resuelto hasta la fecha por más de cuatro órdenes de magnitud. JUEGOS CON SEÑALES ORDENADAS Trabajamos con una clase ligeramente restringida de juegos, en comparación con la plena generalidad de la forma extensiva. Esta clase, que llamamos juegos con señales ordenadas, está altamente estructurada, pero lo suficientemente general como para capturar una amplia gama de situaciones estratégicas. Un juego con señales ordenadas consta de un número finito de rondas. Dentro de una ronda, los jugadores juegan un juego en un árbol dirigido (el árbol puede ser diferente en diferentes rondas). La única incertidumbre a la que se enfrentan los jugadores proviene de las señales privadas que los otros jugadores han recibido y de las señales futuras desconocidas. En otras palabras, los jugadores observan las acciones de los demás, pero potencialmente no las acciones de la naturaleza. En cada ronda, puede haber señales públicas (anunciadas a todos los jugadores) y señales privadas (comunicadas de forma confidencial a jugadores individuales). Para simplificar, asumimos, como es el caso en la mayoría de los juegos recreativos, que dentro de cada ronda, el número de señales privadas recibidas es el mismo entre los jugadores (esto podría ser bastante probablemente relajado). También asumimos que las acciones legales que un jugador tiene son independientes de las señales recibidas. Por ejemplo, en el póker, las acciones legales de apuestas son independientes de las cartas recibidas. Finalmente, la suposición más fuerte es que existe un orden parcial sobre conjuntos de señales, y las ganancias aumentan (no necesariamente de forma estricta) en estas señales. Por ejemplo, en el póker, este orden parcial corresponde exactamente a la clasificación de las manos de cartas. Definición 1. Un juego con señales ordenadas es una tupla Γ = I, G, L, Θ, κ, γ, p, , ω, u donde: 1. Yo = {1, . . . , n} es un conjunto finito de jugadores. 2. G = G1 , . . . , Gr , Gj = ` V j , Ej ´ , es una colección finita de árboles dirigidos finitos con nodos V j y aristas Ej. Que Zj denote los nodos hoja de Gj y que Nj (v) denote los vecinos salientes de v ∈ V j. Gj es el juego de etapa para la ronda j. 3. L = L1 , . . . , Lr , Lj : V j \ Zj → I indica qué jugador actúa (elige un borde saliente) en cada nodo interno en la ronda j. 4. Θ es un conjunto finito de señales. 5. κ = κ1 , . . . , κr y γ = γ1 , . . . , γr son vectores de enteros no negativos, donde κj y γj denotan el número de señales públicas y privadas (por jugador), respectivamente, reveladas en la ronda j. Cada señal θ ∈ Θ solo puede ser revelada una vez, y en cada ronda cada jugador recibe el mismo número de señales privadas, por lo que requerimos que Pr j=1 κj + nγj ≤ |Θ|. La información pública revelada en la ronda j es αj ∈ Θκj y la información pública revelada en todas las rondas hasta la ronda j es ˜αj = ` α1 , . . . , αj ´. La información privada revelada al jugador i ∈ I en la ronda j es βj i ∈ Θγj y la información privada revelada al jugador i ∈ I en todas las rondas hasta la ronda j es ˜βj i = ` β1 i , . . . , βj i ´. También escribimos ˜βj = ˜βj 1, . . . , ˜βj n para representar toda la información privada hasta la ronda j, y ˜β j i , ˜βj −i = ˜βj 1, . . . , ˜βj i−1, ˜β j i , ˜βj i+1, . . . , ˜βj n es ˜βj con ˜βj i reemplazado por ˜β j i. La información total revelada hasta la ronda j, ˜αj , ˜βj, se considera legal si no se repiten señales. 6. p es una distribución de probabilidad sobre Θ, con p(θ) > 0 para todo θ ∈ Θ. Las señales se extraen de Θ según p sin reemplazo, por lo que si X es el conjunto de señales ya reveladas, entonces p(x | X) = ( p(x)P y /∈X p(y) si x /∈ X 0 si x ∈ X. 7. es un orden parcial de subconjuntos de Θ y está definido al menos para aquellos pares requeridos por u. 8. ω : rS j=1 Zj → {over, continue} es una asignación de nodos terminales dentro de un juego de etapas a uno de dos valores: over, en cuyo caso el juego termina, o continue, en cuyo caso el juego continúa hasta la siguiente ronda. Claramente, necesitamos ω(z) = sobre para todo z ∈ Zr. Ten en cuenta que ω es independiente de las señales. Deje ωj sobre = {z ∈ Zj | ω(z) = sobre} y ωj cont = {z ∈ Zj | ω(z) = continuar}. 9. u = (u1 , . . . , ur ), uj : j−1 k=1 ωk cont × ωj sobre × j k=1 Θκk × n i=1 j k=1 Θγk → Rn es una función de utilidad tal que para cada j, 1 ≤ j ≤ r, para cada i ∈ I, y para cada ˜z ∈ j−1 k=1 ωk cont × ωj sobre, al menos una de las siguientes dos condiciones se cumple: (a) La utilidad es independiente de la señal: uj i (˜z, ϑ) = uj i (˜z, ϑ ) para todas las ϑ legales, ϑ ∈ j k=1 Θκk × n i=1 j k=1 Θγk . (b) está definida para todas las señales legales (˜αj , ˜βj i ), (˜αj , ˜β j i ) a través de la ronda j y la utilidad de un jugador aumenta en sus señales privadas, manteniendo todo lo demás igual: ˜αj , ˜βj i  ˜αj , ˜β j i =⇒ ui ˜z, ˜αj , ˜βj i , ˜βj −i ≥ ui ˜z, ˜αj , ˜β j i , ˜βj −i . Utilizaremos el término juego con señales ordenadas y el término juego ordenado de manera intercambiable. 2.1 Filtros de información En esta subsección, definimos un filtro de información para juegos ordenados. En lugar de revelar completamente una señal (ya sea pública o privada) a un jugador, la señal primero pasa a través de este filtro, que emite una señal simplificada al jugador. Al variar el filtro aplicado a un juego, podemos obtener una amplia variedad de juegos manteniendo intacto el espacio de acción subyacente del juego. Utilizaremos esto al diseñar nuestras técnicas de abstracción. Formalmente, un filtro de información es el siguiente. Definición 2. Que Γ = I, G, L, Θ, κ, γ, p, , ω, u sea un juego ordenado. Sea Sj ⊆ j k=1 Θκk × j k=1 Θγk el conjunto de señales legales (es decir, sin señales repetidas) para un jugador hasta la ronda j. Un filtro de información para Γ es una colección F = F1 , . . . , Fr donde cada Fj es una función Fj : Sj → 2Sj tal que se cumplen cada una de las siguientes condiciones: 1. (Veracidad) (˜αj , ˜βj i ) ∈ Fj (˜αj , ˜βj i ) para todos los (˜αj , ˜βj i ) legales. 2. (Independencia) El rango de Fj es una partición de Sj . 3. (Preservación de la información) Si dos valores de una señal son distinguibles en la ronda k, entonces son distinguibles para cada ronda j > k. Sea mj = Pj l=1 κl +γl. Requerimos que para todos los legales (θ1, . . . , θmk , . . . , θmj ) ⊆ Θ y (θ1, . . . , θmk , . . . , θmj ) ⊆ Θ: (θ1, . . . , θmk ) /∈ Fk (θ1, . . . , θmk ) =⇒ (θ1, . . . , θmk , . . . , θmj ) /∈ Fj (θ1, . . . , θmk , . . . , θmj ). Un juego con señales ordenadas Γ y un filtro de información F para Γ define un nuevo juego ΓF. Nos referimos a estos juegos como juegos ordenados filtrados. Nos queda el juego original si usamos el filtro de identidad Fj ˜αj , ˜βj i = n ˜αj , ˜βj i o. Tenemos el siguiente resultado simple (pero importante): Proposición 1. Un juego ordenado filtrado es un juego en forma extensiva que cumple con el perfecto recuerdo. Una prueba simple procede construyendo un juego en forma extensiva directamente a partir del juego ordenado, y mostrando que cumple con el recuerdo perfecto. Al determinar los pagos en un juego con señales filtradas, tomamos el promedio de todas las señales reales en la clase filtrada, ponderado por la probabilidad de que ocurra cada señal real. 2.2 Estrategias y equilibrio de Nash Estamos ahora listos para definir estrategias de comportamiento en el contexto de juegos ordenados filtrados. Definición 3. Una estrategia de comportamiento para el jugador i en la ronda j de Γ = I, G, L, Θ, κ, γ, p, , ω, u con filtro de información F es una distribución de probabilidad sobre acciones posibles, y está definida para cada jugador i, cada ronda j, y cada v ∈ V j \Zj para Lj (v) = i: σj i,v : j−1 k=1 ωk cont×Rango Fj → Δ n w ∈ V j | (v, w) ∈ Ej o. (Δ(X) es el conjunto de distribuciones de probabilidad sobre un conjunto finito X). Una estrategia de comportamiento para el jugador i en la ronda j es σj i = (σj i,v1 , . . . , σj i,vm ) para cada vk ∈ V j \ Zj donde Lj (vk) = i. Una estrategia de comportamiento para el jugador i en Γ es σi = ` σ1 i , . . . , σr i ´. Un perfil estratégico es σ = (σ1, . . . , σn). Un perfil estratégico con σi reemplazado por σi es (σi, σ−i) = (σ1, . . . , σi−1, σi, σi+1, . . . , σn). Por abuso de notación, diremos que el jugador i recibe un pago esperado de ui(σ) cuando todos los jugadores están jugando el perfil estratégico σ. La estrategia σi se dice que es la mejor respuesta del jugador i a σ−i si para todas las demás estrategias σi del jugador i tenemos ui(σi, σ−i) ≥ ui(σi, σ−i). σ es un equilibrio de Nash si, para cada jugador i, σi es la mejor respuesta para σ−i. Un equilibrio de Nash siempre existe en juegos de forma extensiva finitos [36], y existe en estrategias de comportamiento para juegos con memoria perfecta [29]. Usando estas observaciones, tenemos el siguiente corolario de la Proposición 1: Corolario 1. Para cualquier juego ordenado filtrado, existe un equilibrio de Nash en estrategias de comportamiento. ABSTRACCIONES QUE CONSERVAN EL EQUILIBRIO En esta sección, presentamos nuestra técnica principal para reducir el tamaño de los juegos. Comenzamos definiendo un árbol de señal filtrada que representa todos los movimientos aleatorios en el juego. Los bordes en negrita (es decir, los dos primeros niveles del árbol) en los árboles de juego en la Figura 1 corresponden a los árboles de señal filtrada en cada juego. Definición 4. Asociado con cada juego ordenado Γ = I, G, L, Θ, κ, γ, p, , ω, u y filtro de información F hay un árbol de señales filtradas, un árbol dirigido en el que cada nodo corresponde a algunas señales reveladas (filtradas) y las aristas corresponden a la revelación de señales específicas (filtradas). Los nodos en el árbol de señales filtradas representan el conjunto de todas las posibles señales filtradas reveladas (públicas y privadas) en algún momento en el tiempo. Las señales públicas filtradas reveladas en la ronda j corresponden a los nodos en los niveles κj comenzando en el nivel Pj−1 k=1 ` κk + nγk ´ y las señales privadas reveladas en la ronda j corresponden a los nodos en los niveles nγj comenzando en el nivel Pj k=1 κk + Pj−1 k=1 nγk. Denotamos a los hijos de un nodo x como N(x). Además, asociamos pesos a las aristas correspondientes a la probabilidad de que la arista particular sea elegida dado que su padre fue alcanzado. En muchos juegos, hay ciertas situaciones en el juego que pueden considerarse estratégicamente equivalentes a otras situaciones en el juego. Al fusionar estas situaciones, es posible llegar a un juego más pequeño estratégicamente equivalente. Las dos siguientes definiciones formalizan esta noción a través de la introducción de la relación isomórfica de juego ordenado y la transformación de abstracción isomórfica de juego ordenado. Definición 5. Dos subárboles que comienzan en los nodos internos x e y de un árbol de señal filtrada están ordenados isomórficamente en el juego si x e y tienen el mismo padre y existe una biyección f: N(x) → N(y), tal que para w ∈ N(x) y v ∈ N(y), v = f(w) implica que los pesos en las aristas (x, w) y (y, v) son iguales y los subárboles que comienzan en w y v están ordenados isomórficamente en el juego. Dos hojas (correspondientes a las señales filtradas ϑ y ϑ hasta la ronda r) están ordenadas de forma isomorfa en el juego si para todo ˜z ∈ r−1 j=1 ωj cont × ωr sobre, ur (˜z, ϑ) = ur (˜z, ϑ ). Definición 6. Sea Γ = I, G, L, Θ, κ, γ, p, , ω, u un juego ordenado y sea F un filtro de información para Γ. Sea ϑ y ϑ dos nodos donde los subárboles en el árbol de señal filtrada inducida correspondientes a los nodos ϑ y ϑ son isomorfos en el juego ordenado, y ϑ y ϑ están en el nivel Pj−1 k=1 ` κk + nγk ´ o Pj k=1 κk + Pj−1 k=1 nγk para alguna ronda j. La transformación de abstracción isomórfica del juego ordenado se da creando un nuevo filtro de información F : F j ˜αj , ˜βj i = 8 < : Fj ˜αj , ˜βj i si ˜αj , ˜βj i /∈ ϑ ∪ ϑ ϑ ∪ ϑ si ˜αj , ˜βj i ∈ ϑ ∪ ϑ . La Figura 1 muestra la transformación de abstracción isomórfica del juego ordenado aplicada dos veces a un pequeño juego de póker. El Teorema 2, nuestro resultado principal de equilibrio, muestra cómo la transformación de abstracción isomórfica del juego ordenado puede ser utilizada para calcular equilibrios de manera más rápida. Teorema 2. Sea Γ = I, G, L, Θ, κ, γ, p, , ω, u un juego ordenado y F un filtro de información para Γ. Sea F un filtro de información construido a partir de F mediante una aplicación de la transformación de abstracción isomórfica del juego ordenado. Sea σ un equilibrio de Nash del juego inducido ΓF. Si tomamos σj i,v ˜z, Fj ˜αj , ˜βj i = σ j i,v ˜z, F j ˜αj , ˜βj i , σ es un equilibrio de Nash de ΓF. Prueba. Para un juego en forma extensiva, un sistema de creencias μ asigna una probabilidad a cada nodo de decisión x tal que P x∈h μ(x) = 1 para cada conjunto de información h. Un perfil estratégico σ es secuencialmente racional en h dado el sistema de creencias μ si ui(σi, σ−i | h, μ) ≥ ui(τi, σ−i | h, μ) para todas las demás estrategias τi, donde i es el jugador que controla h. Un resultado básico [33, Proposición 9.C.1] que caracteriza los equilibrios de Nash dicta que σ es un equilibrio de Nash si y solo si existe un sistema de creencias μ tal que para cada conjunto de información h con Pr(h | σ) > 0, se cumplen las siguientes dos condiciones: (C1) σ es secuencialmente racional en h dado μ; y (C2) μ(x) = Pr(x | σ) Pr(h | σ) para todo x ∈ h. Dado que σ es un equilibrio de Nash de Γ, existe tal sistema de creencias μ para ΓF. Usando μ, construiremos un sistema de creencias μ para Γ y demostraremos que se cumplen las condiciones C1 y C2, apoyando así a σ como un equilibrio de Nash. Repara a algún jugador i ∈ I. Cada uno de los conjuntos de información en alguna ronda j corresponde a las señales filtradas Fj ˜α∗j , ˜β∗j i, historial en las primeras j − 1 rondas (z1, . . . , zj−1) ∈ j−1 k=1 ωk cont, y el historial hasta ahora en la ronda j, v ∈ V j \ Zj. Deje que ˜z = (z1, . . . , zj−1, v) represente todas las acciones de los jugadores que conducen a este conjunto de información. Por lo tanto, podemos especificar de manera única este conjunto de información utilizando la información Fj ˜α∗j , ˜β∗j i , ˜z. Cada nodo en un conjunto de información corresponde a las posibles señales privadas que los otros jugadores han recibido. Denote por ˜β algún legal (Fj (˜αj , ˜βj 1), . . . , Fj (˜αj , ˜βj i−1), Fj (˜αj , ˜βj i+1), . . . , Fj (˜αj , ˜βj n)). En otras palabras, existen (˜αj , ˜βj 1, . . . , ˜βj n) tal que (˜αj , ˜βj i ) ∈ Fj (˜α∗j , ˜β∗j i ), (˜αj , ˜βj k) ∈ Fj (˜αj , ˜βj k) para k = i, y no se repiten señales. Usando tal conjunto de señales (˜αj , ˜βj 1, . . . , ˜βj n), sea ˆβ el conjunto (F j (˜αj , ˜βj 1), . . . , F j (˜αj , ˜βj i−1), F j (˜αj , ˜βj i+1), . . . , F j (˜αj , ˜βj n). (Abusaremos de la notación y escribiremos F j −i ˆβ = ˆβ.) Ahora podemos calcular μ directamente a partir de μ : μ ˆβ | Fj ˜αj , ˜βj i , ˜z = 8 >>>>>>< >>>>>>: μ ˆβ | F j ˜αj , ˜βj i , ˜z si Fj ˜αj , ˜βj i = F j ˜αj , ˜βj i o ˆβ = ˆβ p∗ μ ˆβ | F j ˜αj , ˜βj i , ˜z si Fj ˜αj , ˜βj i = F j ˜αj , ˜βj i y ˆβ = ˆβ 164 J1 J2 J2 K1 K1 K2 K2 c b C B F B f b c b C B F B f b c b C f b B BF c b C f b B BF c b C B F B f b c b C BF B f b c b C f b B BF c b C f b B BF c b C B F B f b c b C BF B f b c b C f b B BF c b C f b B BF c b C f b B BF c b C f b B BF c b C f b B BF c b C B F B f b c b C B F B f b 0 0 0-1 -1 -1 -1 -1 -1 -1 -1-1 -1 -1 -1 -1 -1 -1 -1 -1 -1-1 -1 -1 -1 -1 -10 0 0 0 0 0 0 0 0 -1 -2 -2 -1 -2 -2 -1 -2 -2 -1 -2 -2 1 2 2 1 2 2 1 2 2 1 2 2 J1 K1 K2 J1 J2 K2 J1 J2 K1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 {{J1}, {J2}, {K1}, {K2}} {{J1,J2}, {K1}, {K2}} c b C BF B f b c b C f b B BF c b C B F B f b J1,J2 K1 K2 1 1 c b C f b B BF c b C BF B f b c b C BF B f b c b C B F B f b J1,J2 K1 K2 1 1 1 1 J1,J2 K2 J1,J2 K1 0 0 0-1 -1 -1 -1 -1 -1 -1 -2 -2 -1 -2 -2 2 2 2 2 2 2 -1 -1-1 -1 0 0 0 1 2 2 -1 -1-1 -1 0 0 0 1 2 2 c b C B F B f b -1 -10 0 0 c b B F B f b -1 -1-1 -2 -2 c b C BF B f b 0 0 0-1 -1 c b C BF B f b J1,J2 J1,J2 J1,J2K1,K2 K1,K2 K1,K2 -1 -1 1 2 2 2 2 2 2 {{J1,J2}, {K1,K2}} 1 1 1 1 1/4 1/4 1/4 1/4 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/4 1/41/2 1/3 1/3 1/3 1/32/3 1/32/3 1/2 1/2 1/3 2/3 2/3 1/3 Figura 1: GameShrink aplicado a un pequeño juego de póker de dos personas con cuatro cartas (dos Jotas y dos Reyes). Junto a cada árbol de juego se encuentra el rango del filtro de información F. Las líneas punteadas indican conjuntos de información, que están etiquetados por el jugador controlador. Los círculos abiertos son nodos de probabilidad con las probabilidades de transición indicadas. El nodo raíz es el nodo de probabilidad para la carta del jugador 1, y el siguiente nivel es para la carta del jugador 2. El pago de jugador 2 a jugador 1 se muestra debajo de cada hoja. En este ejemplo, el algoritmo reduce el árbol de juego de 53 nodos a 19 nodos, donde p∗ = Pr(ˆβ | F j (˜αj , ˜β j i )) Pr(ˆβ | F j (˜αj , ˜β j i )) . Las tres afirmaciones siguientes muestran que μ, tal como se calculó anteriormente, respalda a σ como un equilibrio de Nash. Afirmación 1. μ es un sistema de creencias válido para ΓF. Reclamo 2. Para todos los conjuntos de información h con Pr(h | σ) > 0, μ(x) = Pr(x | σ) Pr(h | σ) para todo x ∈ h. Afirmación 3. Para todos los conjuntos de información h con Pr(h | σ) > 0, σ es secuencialmente racional en h dado μ. Las pruebas de las Afirmaciones 1-3 se encuentran en una versión extendida de este artículo [13]. Por las afirmaciones 1 y 2, sabemos que se cumple la condición C2. Por la Reclamación 3, sabemos que se cumple la condición C1. Por lo tanto, σ es un equilibrio de Nash. 3.1 No trivialidad de la generalización más allá de este modelo Nuestro modelo no captura juegos secuenciales generales de información imperfecta porque está restringido de dos maneras (como se discutió anteriormente): 1) hay una estructura especial que conecta las acciones de los jugadores y las acciones de la suerte (por un lado, se asume que los jugadores observan las acciones de los demás, pero las acciones de la naturaleza pueden no ser observables públicamente), y 2) hay un orden común de señales. En esta subsección mostramos que eliminar cualquiera de estas condiciones puede invalidar nuestra técnica. Primero, demostramos un fallo al eliminar la primera suposición. Considera el juego en la Figura 2.6. Los nodos a y b están en el mismo conjunto de información, tienen el mismo nodo padre (de probabilidad), tienen subárboles isomórficos con los mismos pagos, y los nodos c y d también tienen propiedades estructurales similares. Al fusionar los subárboles que comienzan en a y b, obtenemos el juego de la derecha en la Figura 2. En este juego, la única estrategia de equilibrio de Nash del jugador 1 es jugar a la izquierda. Pero en el juego original, el jugador 1 sabe que el nodo c nunca será alcanzado, por lo que debería jugar a la derecha en ese conjunto de información. 1/4 1/4 1/4 1/4 2 2 2 1 1 1 2 1 2 3 0 3 0 -10 10 1/2 1/4 1/4 2 2 2 1 1 2 3 0 3 0 a b 2 2 2 10-10 c d Figura 2: Ejemplo que ilustra la dificultad en desarrollar una teoría de abstracciones que preserven el equilibrio para juegos generales en forma extensiva. Eliminar la segunda suposición (que las funciones de utilidad se basan en un orden común de señales) también puede provocar un fallo. Considera un juego de cartas simple de tres cartas con una baraja que contiene dos Jotas (J1 y J2) y un Rey (K), donde la función de utilidad del jugador 1 se basa en el orden 6 Agradecemos a Albert Xin Jiang por proporcionar este ejemplo. 165 K J1 ∼ J2 pero la función de utilidad del jugador 2 se basa en el orden J2 K J1. Es fácil comprobar que en el juego abstracto (donde el Jugador 1 trata a J1 y J2 como equivalentes) el equilibrio de Nash no corresponde a un equilibrio de Nash en el juego original. GAMESHRINK: UN ALGORITMO EFICIENTE PARA CALCULAR TRANSFORMACIONES DE ABSTRACCIÓN DE JUEGOS ISOMÓRFICOS ORDENADOS. Esta sección presenta un algoritmo, GameShrink, para llevar a cabo las abstracciones. Solo necesita analizar el árbol de señales discutido anteriormente, en lugar de todo el árbol de juego. Primero presentamos una subrutina que utiliza GameShrink. Es un programa dinámico para calcular la relación isomórfica del juego ordenado. Nuevamente, opera en el árbol de señales. Algoritmo 1. ¿El juego ordenado es isomórfico? (Γ, ϑ, ϑ ) 1. Si ϑ y ϑ tienen padres diferentes, entonces devolver falso. Si ϑ y ϑ son ambas hojas del árbol de señales: (a) Si ur (ϑ | ˜z) = ur (ϑ | ˜z) para todo ˜z ∈ r−1 j=1 ωj cont × ωr, entonces devolver verdadero. (b) De lo contrario, devolver falso. 3. Crear un grafo bipartito Gϑ,ϑ = (V1, V2, E) con V1 = N(ϑ) y V2 = N(ϑ). 4. Para cada v1 ∈ V1 y v2 ∈ V2: Si OrderedGameIsomorphic? (Γ, v1, v2) crea un borde (v1, v2) 5. Devuelve verdadero si Gϑ,ϑ tiene un emparejamiento perfecto; de lo contrario, devuelve falso. Al evaluar este programa dinámico de abajo hacia arriba, el Algoritmo 1 determina, en tiempo polinómico en el tamaño del árbol de señales, si un par de nodos x e y de igual profundidad están ordenados de manera isomórfica en el juego. Podemos acelerar aún más este cálculo examinando solo los nodos con el mismo padre, ya que sabemos (del paso 1) que ningún nodo con padres diferentes es isomorfo al juego ordenado. El test en el paso 2(a) se puede calcular en tiempo O(1) consultando la relación de la especificación del juego. Cada llamada a OrderedGameIsomorphic? realiza a lo sumo un cálculo de emparejamiento perfecto en un grafo bipartito con O(|Θ|) nodos y O(|Θ|2) aristas (recordemos que Θ es el conjunto de señales). Utilizando el algoritmo de Ford-Fulkerson [12] para encontrar un emparejamiento maximal, esto toma tiempo O(|Θ|3). Sea S el número máximo de señales posiblemente reveladas en el juego (por ejemplo, en Rhode Island Holdem, S = 4 porque cada uno de los dos jugadores tiene una carta en la mano y además hay dos cartas en la mesa). El número de nodos, n, en el árbol de señal es O(|Θ|S). El programa dinámico visita cada nodo en el árbol de señales, con cada visita requiriendo O(|Θ|2) llamadas a la rutina OrderedGameIsomorphic?. Por lo tanto, se necesita O(|Θ|S |Θ|3 |Θ|2 ) = O(|Θ|S+5 ) tiempo para calcular la relación isomórfica del juego ordenado completo. Si bien esto es exponencial en el número de señales reveladas, ahora mostramos que es polinómico en el tamaño del árbol de señales, y por lo tanto polinómico en el tamaño del árbol de juego. Agradecemos a una persona anónima por este ejemplo, ya que el árbol de señales es más pequeño que el árbol de juego. El número de nodos en el árbol de señal es n = 1 + ΣX i=1 ΣY j=1 (|Θ| − j + 1) (Cada término en la suma corresponde al número de nodos en una profundidad específica del árbol). El número de hojas es SY j=1 (|Θ| − j + 1) = |Θ| S ! Sí, que es una cota inferior en el número de nodos. Para |Θ| grande podemos usar la relación `n k ´ ∼ nk k! para obtener |Θ| S ! Sí! ∼ „ |Θ|S S! « S! = |Θ|S y por lo tanto el número de hojas en el árbol de señal es Ω(|Θ|S ). Por lo tanto, O(|Θ|S+5 ) = O(n|Θ|5 ), lo cual demuestra que realmente podemos calcular la relación isomórfica del juego ordenado en tiempo polinómico en el número de nodos, n, del árbol de señales. El algoritmo a menudo se ejecuta en tiempo (y espacio) sublineal en el tamaño del árbol de juego porque el árbol de señal es significativamente más pequeño que el árbol de juego en la mayoría de los juegos no triviales. (Tenga en cuenta que la entrada al algoritmo no es un árbol de juego explícito, sino una especificación de las reglas, por lo que el algoritmo no necesita leer el árbol de juego). Ver la Figura 1. En general, si un juego ordenado tiene r rondas, y cada juego de etapa de rondas tiene al menos b hojas no terminales, entonces el tamaño del árbol de señales es a lo sumo 1 br del tamaño del árbol de juego. Por ejemplo, en Rhode Island Holdem, el árbol de juego tiene 3.1 mil millones de nodos, mientras que el árbol de señales solo tiene 6,632,705. Dado el procedimiento OrderedGameIsomorphic? para determinar isomorfismos de juegos ordenados en un juego ordenado, estamos listos para presentar el algoritmo principal, GameShrink. Algoritmo 2. GameShrink (Γ) 1. 

GameShrink (Γ) 1. Inicialice F como el filtro identidad para Γ. 2. Para j de 1 a r: Para cada par de nodos hermanos ϑ, ϑ en el nivel Pj−1 k=1 ` κk + nγk ´ o Pj k=1 κk + Pj−1 k=1 nγk en el árbol de señal filtrada (de acuerdo con F): Si OrderedGameIsomorphic? (Γ, ϑ, ϑ), entonces Fj (ϑ) ← Fj (ϑ) ← Fj (ϑ) ∪ Fj (ϑ). 3. Salida F. Dado como entrada un juego ordenado Γ, GameShrink aplica las ideas de reducción presentadas anteriormente de la manera más agresiva posible. Una vez que termina, no hay nodos contractibles (ya que compara cada par de nodos en cada nivel del árbol de señales), y produce el filtro de información correspondiente F. La corrección de GameShrink se sigue de una aplicación repetida del Teorema 2. Por lo tanto, tenemos el siguiente resultado: Teorema 3. GameShrink encuentra todos los isomorfismos de juegos ordenados y aplica las transformaciones de abstracción isomórfica de juegos asociadas. Además, para cualquier equilibrio de Nash, σ, del juego abstracto, el perfil estratégico construido para el juego original a partir de σ es un equilibrio de Nash. El factor dominante en el tiempo de ejecución de GameShrink se encuentra en la r-ésima iteración del bucle principal. Hay como máximo 166 nodos `|Θ| S ´ S! en este nivel, donde nuevamente tomamos S como el número máximo de señales posiblemente reveladas en el juego. Por lo tanto, el bucle interno se ejecuta O „`|Θ| S ´ S! 2 « veces. Como se discute en la siguiente subsección, utilizamos una estructura de datos de unión-búsqueda para representar el filtro de información F. Cada iteración del bucle interno posiblemente realiza una operación de unión en la estructura de datos; realizar M operaciones en una estructura de unión-búsqueda que contiene N elementos toma un tiempo amortizado de O(α(M, N)) por operación, donde α(M, N) es la función inversa de Ackermann [1, 49] (que crece extremadamente lentamente). Por lo tanto, el tiempo total para GameShrink es O(2^n). Por la desigualdad `n k ´ ≤ nk k! , esto es O ` (|Θ|S )2 α ` (|Θ|S )2 , |Θ|S ´´ . Nuevamente, aunque esto es exponencial en S, es aproximadamente O(n2), donde n es el número de nodos en el árbol de señales. Además, GameShrink tiende a ejecutarse en tiempo y espacio sublineales en el tamaño del árbol de juego porque el árbol de señales es significativamente más pequeño que el árbol de juego en la mayoría de los juegos no triviales, como se discutió anteriormente. 4.1 Mejoras de eficiencia Diseñamos varias técnicas de mejora de velocidad para GameShrink, y todas están incorporadas en nuestra implementación. Una técnica es el uso de la estructura de datos de unión-búsqueda para almacenar la información del filtro F. Esta estructura de datos utiliza tiempo casi lineal en el número de operaciones [49]. Inicialmente, cada nodo en el árbol de señalización es su propio conjunto (esto corresponde al filtro de información de identidad); cuando dos nodos se contraen, se unen en un nuevo conjunto. Al finalizar, las señales filtradas para el juego abstracto corresponden exactamente a los conjuntos disjuntos en la estructura de datos. Este es un método eficiente para registrar las contracciones dentro del árbol de juego, y los requisitos de memoria son lineales solo en el tamaño del árbol de señales. Determinar si dos nodos están ordenados de forma isomorfa en un juego requiere que determinemos si un grafo bipartito tiene un emparejamiento perfecto. Podemos eliminar algunos de estos cálculos utilizando condiciones necesarias fáciles de verificar para que se cumpla la relación isomórfica del juego ordenado. Una de esas condiciones es verificar que los nodos tengan el mismo número de oportunidades de ser clasificados como más altos, más bajos y iguales que los oponentes. Podemos precalcular estas frecuencias para cada nodo del árbol de juego. Esto acelera considerablemente GameShrink, y podemos aprovechar esta base de datos en múltiples ejecuciones del algoritmo (por ejemplo, al probar diferentes niveles de abstracción; ver la siguiente sección). Los índices de esta base de datos dependen de las señales privadas y públicas, pero no del orden en que fueron reveladas, por lo que dos nodos pueden tener la misma entrada de base de datos correspondiente. Esto hace que la base de datos sea significativamente más compacta. (Por ejemplo, en Texas Holdem, la base de datos se reduce por un factor de `50 3 ´`47 1 ´`46 1 ´ / `50 5 ´ = 20.) Almacenamos los histogramas en una base de datos bidimensional. La primera dimensión está indexada por las señales privadas, la segunda por las señales públicas. El problema de calcular el índice en (cualquiera) una de las dimensiones es exactamente el problema de calcular una biyección entre todos los subconjuntos de tamaño r de un conjunto de tamaño n e enteros en ˆ 0, . . . , `n r ´ − 1 ˜. Calculamos esto de manera eficiente utilizando el orden colexicográfico de los subconjuntos [6]. Sea {c1, . . . , cr}, ci ∈ {0, . . . , n − 1}, el conjunto de r señales y suponga que ci < ci+1. Calculamos un índice único para este conjunto de señales de la siguiente manera: índice(c1, . . . , cr) = Π i=1 `ci i ´ . 5. MÉTODOS DE APROXIMACIÓN Algunos juegos son demasiado grandes para calcular un equilibrio exacto, incluso después de utilizar la técnica de abstracción presentada. Esta sección discute técnicas generales para calcular perfiles de estrategia aproximadamente óptimos. Para un juego de dos jugadores, siempre podemos evaluar el rendimiento en el peor de los casos de una estrategia, proporcionando así una evaluación objetiva de la fortaleza de la estrategia. Para ilustrar esto, supongamos que conocemos la estrategia planeada del jugador 2 para algún juego. Podemos entonces fijar las probabilidades de las acciones del jugador 2 en el árbol de juego como si fueran movimientos aleatorios. Entonces, el jugador 1 se enfrenta a un problema de decisión de un solo agente, que puede resolverse de abajo hacia arriba, maximizando la ganancia esperada en cada nodo. Por lo tanto, podemos determinar objetivamente el rendimiento esperado en el peor de los casos de la estrategia del jugador 2. Esto será muy útil cuando queramos evaluar qué tan bien se desempeña una estrategia dada cuando sabemos que no es una estrategia de equilibrio. (Una variación de esta técnica también puede aplicarse en juegos de n personas donde solo se mantienen fijas las estrategias de un jugador). Esta técnica proporciona garantías ex post sobre el rendimiento en el peor de los casos de una estrategia, y puede ser utilizada independientemente del método que se utilice para calcular las estrategias. 5.1 Aproximaciones del espacio de estados Al modificar ligeramente GameShrink, podemos obtener un algoritmo que produce árboles de juego aún más pequeños, a expensas de perder las garantías de equilibrio de Teorema 2. En lugar de requerir que los pagos en los nodos terminales coincidan exactamente, podemos en su lugar calcular una penalización que aumenta a medida que la diferencia en utilidad entre dos nodos aumenta. Hay muchas formas en las que la función de penalización podría ser definida e implementada. Una posibilidad es crear pesos en los bordes en los grafos bipartitos utilizados en el Algoritmo 1, y luego en lugar de requerir emparejamientos perfectos en el grafo no ponderado, requeriríamos emparejamientos perfectos con bajo costo (es decir, considerar dos nodos como isomorfos de juego ordenado si el grafo bipartito correspondiente tiene un emparejamiento perfecto con un costo por debajo de cierto umbral). Por lo tanto, con este umbral como parámetro, tenemos un control para ajustar que en un extremo (umbral = 0) produce una abstracción óptima y en el otro extremo (umbral = ∞) produce un juego altamente abstracto (esto, de hecho, restringiría a los jugadores a ignorar todas las señales, pero aún observando las acciones). Este botón también genera un algoritmo en cualquier momento. Se pueden resolver versiones cada vez menos abstractas del juego y evaluar la calidad de la solución en cada iteración utilizando el método ex post discutido anteriormente. 5.2 Aproximaciones algorítmicas En el caso de juegos de suma cero de dos jugadores, el cálculo del equilibrio puede modelarse como un programa lineal (PL), que a su vez puede resolverse utilizando el método simplex. Este enfoque tiene características inherentes que podemos aprovechar para obtener propiedades deseables en el contexto de resolver juegos. En la PL, las soluciones primales corresponden a las estrategias del jugador 2, y las soluciones duales corresponden a las estrategias del jugador 1. Hay dos versiones del método simplex: el simplex primal y el simplex dual. El simplex primal mantiene la viabilidad primal y avanza encontrando soluciones primales cada vez mejores hasta que el vector de solución dual sea viable, momento en el que se alcanza la optimalidad. De manera análoga, el método simplex dual mantiene la factibilidad dual y avanza encontrando soluciones duales cada vez mejores hasta que el vector de solución primal sea factible. (Se puede pensar en el método simplex dual como correr el método simplex primal en el problema dual). Por lo tanto, los métodos simplex primal y dual sirven como algoritmos en cualquier momento (para una abstracción dada) para los jugadores 2 y 1, respectivamente. En cualquier momento, pueden generar las mejores estrategias encontradas hasta el momento. Además, para cualquier solución factible del PL, podemos obtener límites sobre la calidad de las estrategias al examinar las soluciones primal y dual. (Cuando se utiliza el método simplex primal, las soluciones duales se pueden leer en el tableau del PL). Cada solución factible del dual produce una cota superior sobre el valor óptimo del primal, y viceversa [9, p. 57]. Por lo tanto, sin necesidad de realizar más cálculos, obtenemos límites inferiores sobre la utilidad esperada de la estrategia de cada agente contra el peor oponente posible de ese agente. Un problema con el método simplex es que no es un algoritmo primal-dual, es decir, no mantiene la factibilidad primal y dual a lo largo de su ejecución. (De hecho, solo obtiene la factibilidad primal y dual al final de la ejecución). Por el contrario, existen métodos de puntos interiores para la programación lineal que mantienen la factibilidad primal y dual durante toda la ejecución. Por ejemplo, muchos algoritmos de seguimiento de trayectorias de puntos interiores tienen esta propiedad [55, Cap. 5]. Observamos que al ejecutar un método de programación lineal de este tipo se obtiene un método para encontrar -equilibrios (es decir, perfiles de estrategia en los que ningún agente puede aumentar su utilidad esperada más que al desviarse). Un umbral también puede ser utilizado como criterio de terminación para utilizar el método como un algoritmo en cualquier momento. Además, los métodos de puntos interiores en esta clase tienen un tiempo de ejecución en el peor de los casos de tiempo polinómico, a diferencia del algoritmo simplex, que requiere exponencialmente muchos pasos en el peor de los casos. 6. Investigaciones RELACIONADAS Se han introducido funciones que transforman juegos en forma extensiva [50, 11]. A diferencia de nuestro trabajo, esos enfoques no eran para hacer el juego más pequeño y fácil de resolver. El resultado principal es que un juego se puede derivar de otro mediante una secuencia de esas transformaciones si y solo si los juegos tienen la misma forma normal pura reducida. La forma normal reducida pura es la forma extensiva del juego representada como un juego en forma normal donde se eliminan los duplicados de estrategias puras (es decir, aquellas con pagos idénticos) y los jugadores básicamente seleccionan clases de equivalencia de estrategias [27]. Una extensión de ese trabajo muestra un resultado similar, pero para transformaciones ligeramente diferentes y juegos en forma normal reducida mixta [21]. Existen tratamientos modernos de este trabajo previo sobre transformaciones de juegos [38, Cap. 6], [10]. La reciente noción de isomorfismo débil en juegos de forma extensiva [7] está relacionada con nuestra noción de isomorfismo de juegos restringidos. La motivación de ese trabajo era justificar conceptos de solución argumentando que son invariantes con respecto a transformaciones isomórficas. De hecho, el autor muestra, entre otras cosas, que muchos conceptos de solución, incluyendo Nash, perfecto, perfecto en subjuegos y equilibrio secuencial, son invariantes con respecto a isomorfismos débiles. Sin embargo, esa definición requiere que los juegos que se van a probar para el isomorfismo débil sean del mismo tamaño. Nuestro enfoque es totalmente diferente: encontramos juegos más pequeños estratégicamente equivalentes. Además, su artículo no proporciona algoritmos. Las técnicas de abstracción han sido utilizadas en la investigación de inteligencia artificial anteriormente. A diferencia de nuestro trabajo, la mayoría (pero no todos) de la investigación que involucra abstracción ha sido para problemas de un solo agente (por ejemplo, [20, 32]). Además, el uso de la abstracción generalmente conduce a soluciones subóptimas, a diferencia de las técnicas presentadas en este documento, que producen soluciones óptimas. Una excepción notable es el uso de la abstracción para calcular estrategias óptimas para el juego de Sprouts [2]. Sin embargo, una diferencia significativa con nuestro trabajo es que Sprouts es un juego de información perfecta. Uno de los primeros trabajos de investigación en utilizar la abstracción en entornos multiagente fue el desarrollo de la búsqueda de particiones, que es el algoritmo detrás de GIB, el primer jugador de bridge de computadora de nivel experto en el mundo [17, 18]. A diferencia de otros algoritmos de búsqueda de árboles de juego que almacenan una posición de juego particular en cada nodo del árbol de búsqueda, la búsqueda por particiones almacena grupos de posiciones que son similares. (Típicamente, la similitud entre dos posiciones de juego se calcula ignorando los componentes menos importantes de cada posición de juego y luego comprobando si las posiciones abstractas son similares, en algún sentido definido por expertos en un dominio específico). La búsqueda por partición puede llevar a mejoras sustanciales de velocidad sobre la búsqueda alfa-beta. Sin embargo, no está basado en teoría de juegos (no considera conjuntos de información en el árbol de juego), y por lo tanto no resuelve el equilibrio de un juego de información imperfecta, como el póker. Otra diferencia es que la abstracción está definida por un humano experto mientras que nuestras abstracciones se determinan automáticamente. Se ha realizado investigación sobre el uso de la abstracción en juegos de información imperfecta. Principalmente, Billings et al [4] describen una abstracción construida manualmente para el póker Texas Holdem, e incluyen resultados prometedores contra jugadores expertos. Sin embargo, este enfoque tiene inconvenientes significativos. Primero, está altamente especializado para Texas Holdem. Segundo, se utilizó una gran cantidad de conocimiento experto y esfuerzo en la construcción de la abstracción. Tercero, la abstracción no preserva el equilibrio: incluso si se aplica a un juego más pequeño, es posible que no genere un equilibrio teórico del juego. Las ideas prometedoras para la abstracción en el contexto de juegos en forma extensiva general han sido descritas en un resumen extendido [39], pero hasta donde sabemos, no han sido completamente desarrolladas. 7. CONCLUSIONES Y DISCUSIÓN Introdujimos la transformación de abstracción isomórfica del juego ordenado y presentamos un algoritmo, GameShrink, para abstraer el juego utilizando exhaustivamente el isomorfismo. Demostramos que en juegos con señales ordenadas, cualquier equilibrio de Nash en el juego abstracto más pequeño se mapea directamente a un equilibrio de Nash en el juego original. La complejidad de GameShrink es ˜O(n2), donde n es el número de nodos en el árbol de señales. No es más grande que el árbol de juego, y en juegos no triviales es drásticamente más pequeño, por lo que GameShrink tiene complejidad temporal y espacial sublineal en 8 Bridge también es un juego de información imperfecta, y la búsqueda de particiones tampoco encuentra el equilibrio para ese juego. En su lugar, la búsqueda de particiones se utiliza en conjunto con muestreo estadístico para simular la incertidumbre en el puente. También existen otros programas de puente que utilizan técnicas de búsqueda para juegos de información perfecta en conjunto con muestreo estadístico y abstracción definida por expertos [48]. Técnicas (no relacionadas con la teoría de juegos) como estas son poco probables de ser competitivas en el póker debido a la mayor importancia del ocultamiento de información y el faroleo, 168 el tamaño del árbol de juego. Usando GameShrink, encontramos un equilibrio minimax para Rhode Island Holdem, un juego de póker con 3.1 mil millones de nodos en el árbol del juego, más de cuatro órdenes de magnitud que en el mayor juego de póker resuelto previamente. Para mejorar aún más la escalabilidad, introdujimos una variante de aproximación de GameShrink, que puede ser utilizada como un algoritmo en cualquier momento al variar un parámetro que controla la grosería de la abstracción. También discutimos cómo (en un juego de suma cero de dos jugadores), la programación lineal puede ser utilizada en cualquier momento para generar estrategias aproximadamente óptimas de calidad creciente. El método también proporciona límites sobre la suboptimalidad de las estrategias resultantes. Actualmente estamos trabajando en utilizar estas técnicas para el póker Texas Holdem de límite para 2 jugadores a escala completa, un juego de cartas muy popular cuyo árbol de juego tiene alrededor de 1018 nodos. El tamaño del árbol de juego nos ha obligado a utilizar la versión de aproximación de GameShrink (así como la abstracción basada en rondas) [16, 15]. 8. REFERENCIAS [1] W. Ackermann. Al enfoque de Hilbert para la construcción de los números reales. Matemáticas. Annalen, 99:118-133, 1928. [2] D. Applegate, G. Jacobson y D. Sleator. Análisis computarizado de brotes. Informe técnico CMU-CS-91-144, 1991. [3] R. Bellman y D. Blackwell. Algunos juegos de dos personas que implican el engaño. PNAS, 35:600-605, 1949. [4] D. Billings, N. Burch, A. Davidson, R. Holte, J. Schaeffer, T. Schauenberg, y D. Szafron. Aproximando estrategias óptimas de teoría de juegos para el póker a gran escala. En IJCAI, 2003. [5] D. Billings, A. Davidson, J. Schaeffer y D. Szafron. El desafío del póker. Inteligencia Artificial, 134:201-240, 2002. [6] B. Bollobás. Combinatoria. Cambridge University Press, 1986. [7] A. Casajus. 

Editorial de la Universidad de Cambridge, 1986. [7] A. Casajus. Isomorfismo débil de juegos extensivos. Ciencias Sociales Matemáticas, 46:267-290, 2003. [8] X. Chen y X. Deng. Resolviendo la complejidad del equilibrio de Nash de 2 jugadores. ECCC, Informe No. 150, 2005. [9] V. Chvátal. Programación Lineal. W. H. Freeman & Co., 1983. [10] B. P. de Bruin. 

W. H. Freeman & Co., 1983. [10] B. P. de Bruin. Transformaciones de juegos y equivalencia de juegos. Nota técnica x-1999-01, Universidad de Ámsterdam, Instituto de Lógica, Lenguaje y Computación, 1999. [11] S. Elmes y P. J. Reny. Sobre la equivalencia estratégica de juegos en forma extensiva. Revista de Teoría Económica, 62:1-23, 1994. [12] L. R. Ford, Jr. y D. R. Fulkerson. Flujos en redes. Princeton University Press, 1962. [13] A. Gilpin y T. Sandholm. Encontrar equilibrios en juegos secuenciales grandes de información imperfecta. Informe técnico CMU-CS-05-158, Universidad Carnegie Mellon, 2005. [14] A. Gilpin y T. Sandholm. Póker Texas Hold'em óptimo de Rhode Island. En AAAI, páginas 1684-1685, Pittsburgh, PA, EE. UU., 2005. [15] A. Gilpin y T. Sandholm. Un jugador competitivo de póker Texas Holdem a través de abstracción automatizada y cálculo de equilibrio en tiempo real. Mimeo, 2006. [16] A. Gilpin y T. Sandholm. Un jugador de póker Texas Holdem basado en abstracción automatizada y cálculo de equilibrio en tiempo real. En AAMAS, Hakodate, Japón, 2006. [17] M. L. Ginsberg. Búsqueda de particiones. En AAAI, páginas 228-233, Portland, Oregón, 1996. [18] M. L. Ginsberg. GIB: Pasos hacia un programa de juego de bridge de nivel experto. En IJCAI, Estocolmo, Suecia, 1999. [19] S. Govindan y R. Wilson. Un método de Newton global para calcular equilibrios de Nash. Rev. Econ. Teoría, 110:65-86, 2003. [20] C. A. Knoblock. Generando automáticamente abstracciones para la planificación. Inteligencia Artificial, 68(2):243-302, 1994. [21] E. Kohlberg y J.-F. Mertens. Sobre la estabilidad estratégica de los equilibrios. Econometrica, 54:1003-1037, 1986. [22] D. Koller y N. Megiddo. La complejidad de los juegos de suma cero de dos personas en forma extensiva. Juegos y Comportamiento Económico, 4(4):528-552, Oct. 1992. [23] D. Koller y N. Megiddo. Encontrar estrategias mixtas con soportes pequeños en juegos de forma extensiva. Revista Internacional de Teoría de Juegos, 25:73-92, 1996. [24] D. Koller, N. Megiddo y B. von Stengel. Cálculo eficiente de equilibrios para juegos extensivos de dos personas. Juegos y Comportamiento Económico, 14(2):247-259, 1996. [25] D. Koller y A. Pfeffer. Representaciones y soluciones para problemas de teoría de juegos. Inteligencia Artificial, 94(1):167-215, julio de 1997. [26] D. M. Kreps y R. Wilson. Equilibrios secuenciales. Econometrica, 50(4):863-894, 1982. [27] H. W. Kuhn.
Econometrica, 50(4):863-894, 1982. [27] H. W. Kuhn. Juegos extensos. PNAS, 36:570-576, 1950. [28] H. W. Kuhn. 

PNAS, 36:570-576, 1950. [28] H. W. Kuhn. Un póker simplificado para dos personas. En Contribuciones a la Teoría de Juegos, volumen 1 de los Anales de Estudios de Matemáticas, 24, páginas 97-103. Prensa de la Universidad de Princeton, 1950. [29] H. W. Kuhn. Juegos extensivos y el problema de la información. En Contribuciones a la Teoría de Juegos, volumen 2 de los Anales de Estudios de Matemáticas, 28, páginas 193-216. Princeton University Press, 1953. [30] C. Lemke y J. Howson. Puntos de equilibrio de juegos bimatrix. Revista de la Sociedad de Matemáticas Industriales y Aplicadas, 12:413-423, 1964. [31] R. Lipton, E. Markakis y A. Mehta. Jugando juegos grandes utilizando estrategias simples. En ACM-EC, páginas 36-41, 2003. [32] C.-L. Liu y M. Wellman. Abstracción de espacio de estados para la evaluación en cualquier momento de redes bayesianas. Boletín de SIGART, 7(2):50-57, 1996. [33] A. Mas-Colell, M. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, 1995. [34] R. D. McKelvey y A. McLennan. Cálculo de equilibrios en juegos finitos. En el Manual de Economía Computacional, volumen 1, páginas 87-142. Elsevier, 1996. [35] P. B. Miltersen y T. B. Sørensen. Calculando equilibrios secuenciales para juegos de dos jugadores. En SODA, páginas 107-116, 2006. [36] J. Nash. Puntos de equilibrio en juegos de n personas. Proc. de la Academia Nacional de Ciencias, 36:48-49, 1950. [37] J. F. Nash y L. S. Shapley. Un juego de póker sencillo para tres personas. En Contribuciones a la Teoría de Juegos, volumen 1, páginas 105-116. Princeton University Press, 1950. [38] A. Perea. 

Prensa de la Universidad de Princeton, 1950. [38] A. Perea. Racionalidad en juegos de forma extensiva. Kluwer Academic Publishers, 2001. [39] A. Pfeffer, D. Koller y K. Takusagawa. Aproximaciones de espacio de estados para juegos en forma extensiva, julio de 2000. Conferencia presentada en el Primer Congreso Internacional de la Sociedad de Teoría de Juegos, Bilbao, España. [40] R. Porter, E. Nudelman y Y. Shoham. Métodos de búsqueda simples para encontrar un equilibrio de Nash. En AAAI, páginas 664-669, San José, CA, EE. UU., 2004. [41] I. Romanovskii. Reducción de un juego con memoria completa a un juego de matriz. Matemáticas Soviéticas, 3:678-681, 1962. [42] T. Sandholm y A. Gilpin. Secuencias de ofertas de tómalo o déjalo: Subastas casi óptimas sin revelación completa de la valoración. En AAMAS, Hakodate, Japón, 2006. [43] T. Sandholm, A. Gilpin y V. Conitzer. Métodos de programación entera mixta para encontrar equilibrios de Nash. En AAAI, páginas 495-501, Pittsburgh, PA, EE. UU., 2005. [44] R. Savani y B. von Stengel. Exponencialmente muchos pasos para encontrar un equilibrio de Nash en un juego de bimatrix. En FOCS, páginas 258-267, 2004. [45] R. Selten. Tratamiento teórico del modelo de oligopolio con inercia en la demanda. Revista de Ciencias Políticas, 12:301-324, 1965. [46] R. Selten. Estabilidad evolutiva en juegos extensivos de dos personas - corrección y desarrollo adicional. Ciencias Sociales Matemáticas, 16:223-266, 1988. [47] J. Shi y M. Littman. Métodos de abstracción para el póker teórico de juegos. En Computadoras y Juegos, páginas 333-345. Springer-Verlag, 2001. [48] S. J. J. Smith, D. S. Nau y T. Throop. Bridge informático: Una gran victoria para la planificación de IA. Revista de Inteligencia Artificial, 19(2):93-105, 1998. [49] R. E. Tarjan. Eficiencia de un algoritmo de unión de conjuntos bueno pero no lineal. Revista de la ACM, 22(2):215-225, 1975. [50] F. Thompson. Equivalencia de juegos en forma extensiva. Memorando RM-759 de RAND, The RAND Corporation, enero de 1952. [51] J. von Neumann y O. Morgenstern. Teoría de juegos y comportamiento económico. Princeton University Press, 1947. [52] B. von Stengel. 

Prensa de la Universidad de Princeton, 1947. [52] B. von Stengel. Cálculo eficiente de estrategias de comportamiento. Juegos y Comportamiento Económico, 14(2):220-246, 1996. [53] B. von Stengel. Calculando equilibrios para juegos de dos personas. En el Manual de Teoría de Juegos, volumen 3. Holanda del Norte, Ámsterdam, 2002. [54] R. Wilson. Calculando los equilibrios de juegos de dos personas a partir de la forma extensiva. Ciencia de la Gestión, 18(7):448-460, 1972. [55] S. J. Wright. Métodos de Puntos Interiores Primal-Dual. SIAM, 1997. 169