PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.
Investigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.
Morgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160