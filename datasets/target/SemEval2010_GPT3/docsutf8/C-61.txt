Asignación de autoridad en juegos distribuidos de múltiples jugadores basados en proxy Sudhir Aggarwal Justin Christofoli Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL {sudhir, christof}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Laboratorios Bell, Holmdel, NJ {sarit, sampath}@bell-labs.com RESUMEN Presentamos una arquitectura de juegos basada en proxy y la asignación de autoridad dentro de esta arquitectura que puede llevar a una mejor experiencia de juego en juegos en línea de múltiples jugadores masivos. La arquitectura de juego propuesta consiste en clientes de juego distribuidos que se conectan a proxies de juego (llamados proxies de comunicación) que reenvían mensajes relacionados con el juego desde los clientes a uno o más servidores de juego. A diferencia de las arquitecturas basadas en proxy propuestas en la literatura, donde los proxies replican todo el estado del juego, los proxies de comunicación en la arquitectura propuesta admiten clientes que están en proximidad a ellos en la red física y mantienen información sobre porciones seleccionadas del espacio de juego que son relevantes solo para los clientes que respaldan. Utilizando esta arquitectura, proponemos un mecanismo de asignación de autoridad que divide la autoridad para decidir el resultado de diferentes acciones/eventos que ocurren dentro del juego entre el cliente y los servidores, en función de cada acción/evento. Mostramos que tal división de autoridad conduce a una experiencia de juego más fluida al implementar este mecanismo en un juego en línea multijugador masivo llamado RPGQuest. Además, sostenemos que las técnicas de detección de trampas pueden implementarse fácilmente en los proxies de comunicación si se les informa sobre los mecanismos de juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Juegos, Rendimiento 1. En los Juegos en Línea Multijugador Masivos (MMOG), los clientes del juego que se encuentran distribuidos por Internet se conectan a un servidor de juego para interactuar con otros clientes y formar parte del juego. En las arquitecturas actuales, estas interacciones son directas en el sentido de que los clientes del juego y los servidores intercambian mensajes de juego entre sí. Además, los MMOGs actuales delegan toda la autoridad al servidor del juego para tomar decisiones sobre los resultados relacionados con las acciones que los clientes del juego realizan y también para decidir sobre el resultado de otros eventos relacionados con el juego. Esta autoridad centralizada se ha implementado con la afirmación de que mejora la seguridad y consistencia requeridas en un entorno de juegos. Varios trabajos han demostrado el efecto de la latencia de red en los juegos multijugador distribuidos [1, 2, 3, 4]. Se ha demostrado que la latencia de red tiene un impacto real en la experiencia práctica de jugar videojuegos [3, 5]. Algunos tipos de juegos pueden funcionar bastante bien incluso en presencia de grandes retrasos. Por ejemplo, [4] muestra que en un RPG moderno llamado Everquest 2, el punto de quiebre del juego al agregar latencia artificial fue de 1250ms. Esto se debe al hecho de que el sistema de combate utilizado en Everquest 2 se basa en colas y tiene una interacción muy baja. Por ejemplo, un jugador encola 4 o 5 hechizos que desea lanzar, cada uno de estos hechizos tarda de 1 a 2 segundos en realizarse, lo que le da al servidor tiempo suficiente para validar estas acciones. Pero hay otros juegos como los juegos de disparos en primera persona que se mantienen estables incluso en presencia de latencias de red moderadas [3, 5]. Se han propuesto técnicas de compensación de latencia para aliviar el efecto de la latencia [1, 6, 7], pero es evidente que si los MMOGs van a aumentar en interactividad y velocidad, se tendrán que desarrollar más arquitecturas que aborden la capacidad de respuesta, precisión y consistencia del estado del juego. En este artículo, proponemos dos características importantes que harían que el juego dentro de los MMOGs fuera más receptivo para el movimiento y escalable. Primero, proponemos que las arquitecturas basadas en servidores centralizados se vuelvan jerárquicas mediante la introducción de proxies de comunicación para que las actualizaciones de juegos realizadas por los clientes que son sensibles al tiempo, como el movimiento, puedan distribuirse de manera más eficiente a otros jugadores dentro de su espacio de juego. Segundo, proponemos que la asignación de autoridad en términos de quién toma la decisión sobre las acciones del cliente, como recoger objetos y golpear, y las colisiones entre jugadores, se distribuya entre los clientes y los servidores para distribuir la carga informática lejos del servidor central. Para avanzar hacia juegos en red en tiempo real más complejos, creemos que las definiciones de autoridad deben ser refinadas. La mayoría de los MMOGs actualmente implementados tienen servidores de juego que tienen casi autoridad absoluta. Sostenemos que no hay una única visión coherente del espacio de juego virtual que se pueda mantener en ningún componente dentro de una red que tenga una latencia significativa, como la que muchos jugadores de MMOG experimentarían. Creemos que en la mayoría de los casos, el cliente con la visión más precisa de una entidad es el más adecuado para tomar decisiones para esa entidad cuando la causalidad de esa acción no afectará inmediatamente a otros jugadores. En este artículo definimos lo que significa tener autoridad en el contexto de eventos y objetos en un espacio de juego virtual. Luego mostramos los beneficios de delegar la autoridad para diferentes acciones y eventos de juego entre los clientes y el servidor. En nuestro modelo, el espacio de juego consiste en clientes de juego (que representan a los jugadores) y objetos que controlan. Dividimos las acciones del cliente y los eventos del juego (a los que nos referiremos colectivamente como eventos) como colisiones, impactos, etc., en tres categorías diferentes: a) eventos para los cuales el cliente del juego tiene autoridad absoluta, b) eventos para los cuales el servidor del juego tiene autoridad absoluta, y c) eventos para los cuales la autoridad cambia dinámicamente del cliente al servidor y viceversa. Dependiendo de quién tenga la autoridad, esa entidad tomará decisiones sobre los eventos que ocurran dentro de un espacio de juego. Proponemos que la autoridad para todas las decisiones que conciernen a un único jugador u objeto en el juego, que no afectan a los otros jugadores u objetos, ni son afectadas por las acciones de otros jugadores, sea delegada al cliente de juego de ese jugador. Estos tipos de decisiones incluirían la detección de colisiones con objetos estáticos dentro del espacio de juego virtual y la detección de impactos con balas de trayectoria lineal (cuya trayectoria es fija y no cambia con el tiempo) disparadas por otros jugadores. La autoridad para decisiones que podrían verse afectadas por dos o más jugadores debería delegarse al servidor central imparcial, en algunos casos, para garantizar que no ocurran conflictos y en otros casos puede delegarse a los clientes responsables de esos jugadores. Por ejemplo, la detección de colisiones de dos jugadores que chocan entre sí y la detección de impactos de proyectiles no lineales (que cambian de trayectoria con el tiempo) deben ser delegadas al servidor. La decisión sobre eventos como la recogida de objetos (por ejemplo, recoger objetos en un juego para acumular puntos) debería ser delegada a un servidor si hay varios jugadores en las cercanías de un objeto y cualquiera de los jugadores podría tener éxito en recoger el objeto; para la disputa de recogida de objetos donde el cliente se da cuenta de que ningún otro jugador, excepto su propio jugador, está dentro de un cierto rango del objeto, el cliente podría ser delegado con la responsabilidad de reclamar el objeto. La decisión del cliente siempre puede ser verificada con precisión por el servidor. En resumen, argumentamos que si bien los modelos de autoridad actuales que solo delegan la responsabilidad al servidor para tomar decisiones autoritativas sobre eventos son más seguros que permitir a los clientes tomar las decisiones, estos tipos de modelos añaden retrasos no deseados a eventos que podrían ser decididos por los clientes sin introducir ninguna inconsistencia en el juego. A medida que los juegos en red se vuelvan más complejos, nuestra arquitectura se volverá más aplicable. Esta arquitectura es aplicable para juegos multijugador masivos donde la velocidad y precisión del juego son una preocupación importante, mientras que la consistencia entre los estados de juego de los jugadores sigue siendo deseada. Proponemos que se implemente un mecanismo de asignación de autoridad mixta, como el descrito anteriormente, en MMOGs de alta interacción. Nuestro artículo tiene las siguientes contribuciones. Primero proponemos una arquitectura que utiliza proxies de comunicación para permitir que los clientes se conecten al servidor del juego. Un proxy de comunicación en la arquitectura propuesta mantiene información solo sobre las partes del espacio de juego que son relevantes para los clientes conectados a él y es capaz de procesar la información de movimiento de objetos y jugadores dentro de estas partes. Además, es capaz de transmitir esta información en múltiples direcciones solo a un subconjunto relevante de otros proxies de comunicación. Estas funcionalidades de un proxy de comunicación conducen a una disminución en la latencia de la actualización de eventos y, posteriormente, a una mejor experiencia de juego. Segundo, proponemos un mecanismo de asignación de autoridad mixta como se describe arriba que mejora la experiencia de juego. Tercero, implementamos el mecanismo propuesto de asignación de autoridad mixta dentro de un MMOG llamado RPGQuest [8] para validar su viabilidad dentro de los MMOGs. En la Sección 2, describimos con más detalle la arquitectura del juego basada en proxy e ilustramos sus ventajas. En la Sección 3, proporcionamos una descripción genérica del mecanismo de asignación de autoridad mixta y discutimos cómo mejora la experiencia de juego. En la Sección 4, demostramos la viabilidad de implementar el mecanismo propuesto de asignación de autoridad mixta dentro de los MMOGs existentes al describir una implementación de prueba de concepto dentro de un MMOG existente llamado RPGQuest. La sección 5 discute el trabajo relacionado. En la Sección 6, presentamos nuestras conclusiones y discutimos el trabajo futuro. 2. ARQUITECTURA DE JUEGO BASADA EN PROXY Los Juegos en Línea Multijugador Masivos (MMOGs) suelen consistir en un gran espacio de juego en el que los jugadores y diferentes objetos del juego residen, se mueven e interactúan entre sí. La información sobre todo el espacio de juego podría ser almacenada en un único servidor central al que nos referiríamos como una Arquitectura de Servidor Central. Pero para aliviar la alta demanda en el procesamiento para manejar la gran población de jugadores y los objetos en el juego en tiempo real, normalmente se implementa un MMOG utilizando una arquitectura de servidor distribuido donde el espacio de juego se subdivide aún más en regiones para que cada región tenga un número relativamente menor de jugadores y objetos que pueden ser manejados por un solo servidor. En otras palabras, las diferentes regiones de juego son alojadas por diferentes servidores de forma distribuida. Cuando un jugador se mueve de una región de juego a otra adyacente, el jugador debe comunicarse con un servidor diferente (al que estaba comunicándose actualmente) que aloje la nueva región. Los servidores se comunican entre sí para transferir un jugador o un objeto de una región a otra. En este modelo, el jugador en la máquina cliente debe establecer múltiples sesiones de juego con diferentes servidores para poder moverse por todo el espacio de juego. Proponemos una arquitectura basada en un proxy de comunicación donde un jugador se conecta a un proxy (geográficamente) cercano en lugar de conectarse a un servidor central en el caso de una arquitectura de servidor central o a uno de los servidores en caso de una arquitectura de servidor distribuido. En la arquitectura propuesta, los jugadores que están cerca geográficamente se unen a un proxy en particular. El proxy luego se conecta a uno o más servidores de juegos, según sea necesario por el conjunto de jugadores que se conectan a él y mantiene sesiones de transporte persistentes con estos servidores. Esto alivia el problema de que cada jugador tenga que conectarse directamente a múltiples servidores de juegos, lo que puede agregar un retraso adicional en la configuración de la conexión. La introducción de proxies de comunicación también mitiga la sobrecarga de un gran número de sesiones de transporte que deben ser gestionadas y reduce el ancho de banda de red requerido [9] y el procesamiento en los servidores de juegos tanto en arquitecturas de servidor central como distribuido. Con arquitecturas de servidores centrales, los proxies de comunicación reducen la carga en el servidor al no requerir que el servidor termine las sesiones de transporte persistentes de cada uno de los clientes. Con arquitecturas de servidores distribuidos, además, los proxies de comunicación eliminan la necesidad de que los clientes mantengan sesiones de transporte persistentes con cada uno de los servidores. La Figura 1 muestra la arquitectura propuesta. Figura 1: Arquitectura del entorno de juego. Ten en cuenta que los intermediarios de comunicación no necesitan ser conscientes del juego. El proxy aloja a varios jugadores e informa a los servidores qué jugadores están alojados por el proxy en cuestión. También hay que tener en cuenta que los jugadores alojados por un proxy pueden no estar en el mismo espacio de juego. Es decir, un proxy aloja jugadores que están geográficamente cerca de él, pero los propios jugadores pueden residir en diferentes partes del espacio de juego. El proxy se comunica con los servidores responsables de mantener los espacios de juego suscritos por los diferentes jugadores. Los proxies se comunican entre sí de manera peer-to-peer. La capacidad de respuesta del juego se puede mejorar para actualizaciones que no necesitan esperar a ser procesadas por una autoridad central. De esta manera, la información sobre los jugadores puede ser difundida más rápido antes de que el servidor del juego llegue a conocerla. Esto definitivamente mejora la capacidad de respuesta del juego. Sin embargo, ignora la coherencia que es fundamental en los MMORPGs. La noción de que una arquitectura como esta aún puede mantener consistencia temporal se discutirá en detalle en la Sección 3. La Figura 2 muestra un ejemplo del principio de funcionamiento de la arquitectura propuesta. Suponga que el espacio de juego está dividido en 9 regiones y hay tres servidores responsables de gestionar las regiones. El servidor S1 posee las regiones 1 y 2, S2 gestiona 4, 5, 7 y 8, y S3 es responsable de 3, 6 y 9. Figura 2: Un ejemplo. Hay cuatro proxies de comunicación colocados en ubicaciones geográficamente distantes. Los jugadores a, b, c se unen al proxy P1, el proxy P2 aloja a los jugadores d, e, f, los jugadores g, h están con el proxy P3, mientras que los jugadores i, j, k, l están con el proxy P4. Debajo de cada jugador, la figura muestra en qué región del juego se encuentra actualmente el jugador. Por ejemplo, los jugadores a, b, c están en las regiones 1, 2, 6, respectivamente. Por lo tanto, el proxy P1 debe comunicarse con los servidores S1 y S3. El lector puede verificar el resto de los enlaces entre los proxies y los servidores. Los jugadores pueden moverse dentro de la región y entre regiones. El movimiento del jugador dentro de una región será rastreado por el proxy que aloja al jugador y esta información de movimiento (por ejemplo, las nuevas coordenadas del jugador) se transmitirá en multicast a un subconjunto de otros proxies de comunicación relevantes directamente. Al mismo tiempo, esta información será enviada al servidor responsable de esa región con la indicación de que este movimiento ya ha sido comunicado a todos los demás proxies de comunicación relevantes (para que el servidor no tenga que retransmitir esta información a todos los proxies). Por ejemplo, si el jugador a se mueve dentro de la región 1, esta información será comunicada por el proxy P1 al servidor S1 y se transmitirá por multidifusión a los proxies P3 y P4. Ten en cuenta que los proxies que no mantienen información de estado sobre esta región en este momento (porque no tienen clientes dentro de esa región) como P2 no necesitan recibir esta información de movimiento. Si un jugador está en el límite de una región y se mueve a una nueva región, hay dos posibilidades. La primera posibilidad es que el proxy que aloja al jugador pueda identificar la región a la que se está moviendo el jugador (basándose en la información de trayectoria) porque también está manteniendo información de estado sobre la nueva región en ese momento. En este caso, el proxy puede actualizar la información de movimiento directamente en los otros proxies de comunicación relevantes y también enviar información al servidor correspondiente informando del movimiento (esto puede requerir transferencia entre servidores como describiremos). Considera el escenario donde el jugador A se encuentra en el límite de la región 1 y el proxy P1 puede identificar que el jugador se está moviendo hacia la región 2. Dado que el proxy P1 actualmente está manteniendo información de estado sobre la región 2, puede informar a todos los otros proxies de comunicación relevantes (en este ejemplo, ningún otro proxy mantiene información sobre la región 2 en este momento, por lo que no es necesario enviar ninguna actualización a ninguno de los otros proxies) sobre este movimiento y luego informar al servidor de forma independiente. En este caso particular, el servidor S1 también es responsable de la región 2, por lo que no sería necesario realizar transferencias entre servidores. Ahora considera otro escenario en el que el jugador j se mueve de la región 9 a la región 8 y que el proxy P4 es capaz de identificar este movimiento. Nuevamente, debido a que el proxy P4 mantiene información de estado sobre la región 8, puede informar a cualquier otro proxy de comunicación relevante (de nuevo, ninguno en este ejemplo) sobre este movimiento. Pero ahora, las regiones 9 y 8 son gestionadas por servidores diferentes (los servidores S3 y S2 respectivamente) y por lo tanto se necesita una transición entre estos servidores. Proponemos que en este escenario particular, la transferencia sea gestionada por el proxy P4 mismo. Cuando el proxy envía una actualización de movimiento al servidor S3 (informando al servidor que el jugador se está moviendo fuera de su región), también enviaría un mensaje al servidor S2 informándole de la presencia y ubicación del jugador en una de sus regiones. En los escenarios intra-región e inter-región descritos anteriormente, el proxy es capaz de gestionar la información relacionada con el movimiento, actualizar solo a los proxies de comunicación relevantes sobre el movimiento, actualizar los servidores con el movimiento y permitir la transferencia de un jugador entre los servidores si es necesario. De esta manera, el proxy realiza actualizaciones de movimiento sin involucrar de ninguna manera a los servidores en esta función crítica en tiempo real, acelerando así el juego y mejorando la experiencia de juego para los jugadores. Consideramos esto la ruta rápida para la actualización de movimiento. Visualizamos que los proxies sean simplemente proxies de comunicación en el sentido de que no conocen el funcionamiento de juegos específicos. Simplemente procesan información de movimiento de jugadores y objetos y comunican esta información a los otros proxies y los servidores. Si los proxies se vuelven más inteligentes y entienden más la lógica del juego, es posible que puedan verificar rápidamente las afirmaciones hechas por los clientes y mitigar el fraude. Los servidores podrían realizar la misma funcionalidad pero con más retraso. Incluso sin ser conscientes de la lógica del juego, los proxies pueden proporcionar funcionalidades adicionales como marcar con la hora los mensajes para hacer la experiencia de juego más precisa [10] y justa [11]. La segunda posibilidad que se debe considerar es cuando los jugadores se mueven entre regiones. Es posible que un jugador se mueva de una región a otra pero el proxy que está alojando al jugador no pueda determinar la región a la que se está moviendo, a) el proxy no mantiene información de estado sobre todas las regiones a las que el jugador podría potencialmente moverse, o b) el proxy no puede determinar a qué región puede moverse el jugador (incluso si mantiene información de estado sobre todas estas regiones). En este caso, proponemos que el proxy no sea responsable de tomar la decisión de movimiento, sino que en su lugar comunique la indicación de movimiento al servidor responsable de la región en la que se encuentra actualmente el jugador. El servidor luego tomará la decisión de movimiento y luego a) informará a todos los proxies, incluido el proxy que aloja al jugador, y b) iniciará la transferencia con otro servidor si el jugador se mueve a una región gestionada por otro servidor. Consideramos que este es el proceso lento para la actualización del movimiento, ya que los servidores deben participar en determinar la nueva posición del jugador. En el ejemplo, suponga que el jugador a se mueve de la región 1 a la región 4. El proxy P1 no mantiene información de estado sobre la región 4 y, por lo tanto, pasaría la información de movimiento al servidor S1. El servidor identificará que el jugador se ha movido a la región 4 e informará al proxy P1, así como al proxy P2 (que es el único otro proxy que mantiene información sobre la región 4 en este momento). El servidor S1 también iniciará una transferencia de jugador a con el servidor S2. El proxy P1 ahora comenzará a mantener información de estado sobre la región 4 porque uno de sus jugadores alojados, el jugador a, se ha trasladado a esta región. Lo hará solicitando y recibiendo la información del estado actual sobre la región 4 del servidor S2, que es responsable de esta región. Por lo tanto, una arquitectura de proxy nos permite aprovechar actualizaciones de movimiento más rápidas a través de la vía rápida a través de un proxy si y cuando sea posible, en contraposición a las arquitecturas convencionales basadas en servidores que siempre tienen que utilizar la vía lenta a través del servidor para las actualizaciones de movimiento. Al mantener selectivamente la información relevante del estado del juego regional en los proxies, podemos lograr esta capacidad en nuestra arquitectura sin necesidad de mantener el estado completo del juego en cada proxy. ASIGNACIÓN DE AUTORIDAD A medida que se juega un MMOG, los jugadores y los objetos del juego que forman parte del mismo cambian continuamente de estado. Por ejemplo, consideremos a un jugador que posee un tanque en un juego de batalla. Basado en la acción del jugador, el tanque cambia su posición en el espacio de juego, la cantidad de municiones que contiene el tanque cambia a medida que dispara a otros tanques, el tanque recoge bonificaciones de potencia de fuego basadas en impactos exitosos, etc. Del mismo modo, los objetos en el campo de batalla, como banderas, edificios, etc., cambian de estado cuando una bandera es recogida por un jugador (es decir, un tanque) o un edificio es destruido al dispararle. Es decir, se debe tomar alguna decisión sobre el estado de cada jugador y objeto a medida que avanza el juego. Ten en cuenta que el estado de un jugador y/o objeto puede contener varios parámetros (por ejemplo, posición, cantidad de munición, almacenamiento de combustible, puntos recolectados, etc.), y si alguno de los parámetros cambia, el estado del jugador/objeto cambia. En un juego basado en cliente-servidor, el servidor controla a todos los jugadores y los objetos. Cuando un jugador en una máquina cliente realiza un movimiento, el movimiento se transmite al servidor a través de la red. El servidor luego analiza la jugada, y si la jugada es válida, cambia el estado del jugador en el servidor e informa al cliente del cambio. El cliente posteriormente actualiza el estado del jugador y renderiza al jugador en la nueva ubicación. En este caso, la autoridad para cambiar el estado del jugador reside completamente en el servidor y el cliente simplemente sigue las instrucciones que el servidor le indica. La mayoría de los juegos de disparos en primera persona (FPS) y de rol (RPG) actuales entran en esta categoría. En los juegos de disparos en primera persona actuales, al igual que en los juegos de rol, el cliente no es de confianza. Todos los movimientos y acciones que realiza son validados. Si un cliente detecta que ha impactado a otro jugador con una bala, procede asumiendo que es un impacto. Mientras tanto, se envía una actualización al servidor y el servidor enviará un mensaje confirmando o negando si el jugador fue alcanzado. Si el jugador remoto no fue alcanzado, entonces el cliente sabrá que en realidad no realizó el disparo. Si logra acertar, también se enviará una actualización desde el servidor a los otros clientes informándoles que el otro jugador fue alcanzado. Una diferencia que ocurre en algunos RPGs es que utilizan programas de cliente muy simples. Algunos RPG no mantienen información de estado en el cliente y, por lo tanto, no pueden predecir nada, como los impactos en el cliente. La información de estado no se mantiene porque el cliente no es de confianza para ello. En los juegos de rol, un jugador tramposo con un cliente de juego hackeado puede utilizar la información del estado almacenada en el cliente para obtener una ventaja y encontrar cosas como tesoros ocultos o monstruos acechando en la esquina. Esta es una razón por la cual la mayoría de los MMORPGs no envían mucha información de estado al cliente y hacen que el juego sea menos receptivo y tenga una jugabilidad con menos interacción que los juegos de disparos en primera persona. En un juego de igual a igual, cada par controla al jugador y objeto que posee. Cuando un jugador realiza un movimiento, la máquina analiza el movimiento y, si es válido, cambia el estado del jugador y lo coloca en una nueva posición. Después, el propietario de pares informa a todos los demás pares sobre el nuevo estado del jugador y el resto de los pares actualizan el estado del jugador. En este escenario, la autoridad para cambiar el estado del jugador se le otorga al par propietario y todos los demás pares simplemente siguen al propietario. Por ejemplo, Battle Zone Flag (BzFlag) es un juego multijugador cliente-servidor donde el cliente tiene toda la autoridad para tomar decisiones. Fue construido principalmente pensando en el juego en LAN y el engaño como una idea secundaria. Los clientes en BzFlag son completamente autoritarios y cuando detectan que fueron alcanzados por una bala, envían una actualización al servidor que simplemente reenvía el mensaje a todos los demás jugadores. El servidor no realiza ningún tipo de validación. Cada uno de los dos enfoques tradicionales anteriores tiene su propio conjunto de ventajas y desventajas. El primer enfoque, al que nos referiremos de ahora en adelante como servidor autoritario, utiliza un método centralizado para asignar autoridad. Si bien un enfoque centralizado puede mantener el estado del juego (es decir, el estado de todos los jugadores y objetos) consistente en cualquier número de máquinas cliente, sufre de una respuesta retrasada en el juego, ya que cualquier movimiento que un jugador en la máquina cliente realice debe pasar por un retraso de ida y vuelta al servidor antes de que pueda tener efecto en la pantalla de los clientes. Además del retraso de ida y vuelta, también hay un retraso en la cola al procesar la solicitud de cambio de estado en el servidor. Esto puede resultar en un retraso adicional en el procesamiento, y también puede traer problemas graves de escalabilidad si hay un gran número de clientes jugando el juego. Una ventaja definitiva del enfoque autoritario del servidor es que puede detectar fácilmente si un cliente está haciendo trampa y tomar medidas apropiadas para prevenir el fraude. El enfoque de igual a igual, en adelante referido como cliente autoritario, puede hacer que los juegos sean muy receptivos. Sin embargo, puede hacer que el estado del juego sea inconsistente para algunos jugadores y se debe realizar un desempate (o retroceso) para devolver el juego a un estado consistente. Ni el desempate ni la reversión son características deseables de los juegos en línea. Por ejemplo, supongamos que para un juego, el objetivo de cada jugador es recolectar tantas banderas como sea posible del espacio del juego (por ejemplo, BzFlag. Cuando dos jugadores en proximidad intentan recoger la misma bandera al mismo tiempo, dependiendo del algoritmo utilizado en el lado del cliente, ambos clientes pueden determinar que son el ganador, aunque en realidad solo un jugador puede recoger la bandera. Ambos jugadores verán en su pantalla que es el ganador. Esto hace que el estado del juego sea inconsistente. Las formas de recuperarse de esta inconsistencia son dar la bandera a un solo jugador (usando alguna regla de desempate) o retroceder el juego para que los jugadores puedan intentarlo de nuevo. Ninguno de estos dos enfoques es una experiencia agradable para los juegos en línea. Otro problema con el enfoque autoritario del cliente es el de hacer trampa por parte de los clientes, ya que no hay una verificación cruzada de la validación de los cambios de estado autorizados por el cliente propietario. Proponemos utilizar un enfoque híbrido para asignar la autoridad dinámicamente entre el cliente y el servidor. Es decir, asignamos la autoridad al cliente para hacer que el juego responda, y utilizamos la autoridad de los servidores solo cuando las decisiones autoritativas individuales de los clientes puedan hacer que el estado del juego sea inconsistente. Al trasladar la autoridad de las actualizaciones críticas de tiempo al cliente, evitamos el retraso adicional causado al requerir que el servidor valide estas actualizaciones. Por ejemplo, en el juego de recoger banderas, a los clientes se les dará la autoridad para recoger banderas solo cuando otros jugadores no estén dentro de un rango en el que podrían recoger una bandera inmediatamente. Solo cuando dos o más jugadores estén cerca, de modo que más de un jugador pueda afirmar haber recogido una bandera, la autoridad para el movimiento y la recogida de la bandera pasaría al servidor central para que el estado del juego no se vuelva inconsistente. Creemos que en un espacio de juego grande donde un jugador se encuentra a menudo en un área muy abierta y escasamente poblada, como las que se ven a menudo en el juego Second Life [13], esta arquitectura híbrida sería muy beneficiosa debido a los largos períodos en los que el cliente tendría autoridad para enviar actualizaciones de movimiento por sí mismo. Esto tiene dos ventajas sobre el enfoque de autoridad central, distribuye la carga de procesamiento a los clientes para la mayoría de los eventos y permite un juego más receptivo que no necesita esperar en un servidor para validación. Creemos que nuestra noción de autoridad puede ser utilizada para desarrollar un modelo de estado globalmente consistente de la evolución de un juego. Fundamentalmente, el estado consistente del sistema es aquel que está definido por el servidor. Sin embargo, si la autoridad local se delega al cliente, en este caso, el estado del cliente se superpone al estado del servidor para determinar el estado global correcto. Por ejemplo, si el cliente es autoritario con respecto al movimiento de un jugador, entonces la trayectoria del jugador es la verdadera trayectoria y debe reemplazar la vista del servidor de la trayectoria de los jugadores. Ten en cuenta que esto podría ser problemático y llevar a inconsistencia temporal solo si, por ejemplo, dos o más entidades se están moviendo en la misma región y pueden interactuar entre sí. En esta situación, la autoridad del cliente debe revertir al servidor y luego el servidor tomaría decisiones. Por lo tanto, el cliente solo es autoritario en situaciones donde no hay potencial para interactuar inminentemente con otros jugadores. Creemos que en los MMOGs complejos, al permitir un movimiento más rápido, seguirá siendo posible que exista autoridad local durante largos períodos de tiempo de juego. Ten en cuenta que también podría ser posible minimizar las ocurrencias del problema del Hombre Muerto Disparando descrito en [14]. Esto podría lograrse permitiendo que el cliente sea autoritario para más acciones, como la muerte de sus propios jugadores, y evitando que otros jugadores tomen decisiones preventivas basadas en un jugador remoto. Una razón por la cual la arquitectura basada en cliente-servidor ha ganado popularidad es debido a la creencia de que la ruta más rápida hacia los otros clientes es a través del servidor. Si bien esto puede ser cierto, nuestro objetivo es crear una nueva arquitectura donde las decisiones no siempre tengan que tomarse en el servidor del juego y la ruta más rápida hacia un cliente sea en realidad a través de un proxy de comunicación ubicado cerca del cliente. Es decir, la distancia más corta en nuestra arquitectura no es a través del servidor de juegos sino a través del proxy de comunicación. Después de que un cliente realiza una acción como un movimiento, la distribuirá simultáneamente directamente a los clientes y al servidor del juego a través del proxy de comunicaciones. Observamos que nuestra arquitectura, sin embargo, no es práctica para un juego en el que los jugadores configuran sus propios servidores de manera ad-hoc y no tienen acceso a proxies en los diferentes proveedores de servicios de Internet. Esta arquitectura de proxy y autoridad distribuida solo puede ser utilizada en su máximo potencial cuando los proxies pueden ser colocados en lugares estratégicos dentro de los principales proveedores de servicios de Internet y distribuidos de manera uniforme geográficamente. Nuestra arquitectura de juego no asume que el cliente no es de confianza. Estamos diseñando nuestra arquitectura basándonos en el hecho de que habrá suficientes mecanismos de disuasión y detección de trampas presentes para que sea tanto indeseable como muy difícil hacer trampa [15]. En nuestro enfoque propuesto, podemos hacer que los juegos sean resistentes al fraude utilizando la arquitectura basada en proxy cuando se toman decisiones autoritativas del cliente. Para lograr esto, los proxies deben ser conscientes del juego para que las decisiones tomadas por un cliente puedan ser verificadas por un proxy al que se conecta el cliente. Por ejemplo, supongamos que en un juego un avión controlado por un cliente se mueve en el espacio del juego. No es posible que el avión atraviese un edificio sin sufrir daños. En un modo de cliente autoritario, es posible que el cliente haga trampa al maniobrar el avión a través de un edificio y afirmar que el avión no sufrió daños. Sin embargo, cuando dicho movimiento es publicado por el cliente, el proxy, al ser consciente del espacio de juego en el que se encuentra el avión, puede verificar rápidamente que el cliente ha abusado de la autoridad y luego puede bloquear dicho movimiento. Esto nos permite distribuir la autoridad para tomar decisiones sobre los clientes. En la siguiente sección utilizamos un juego multijugador llamado RPGQuest para implementar diferentes esquemas de autoridad y discutir nuestra experiencia con la implementación. Nuestra implementación muestra la viabilidad de nuestra solución propuesta. EXPERIENCIA DE IMPLEMENTACIÓN Hemos experimentado con el mecanismo de asignación de autoridad descrito en la última sección al implementar los mecanismos en un juego llamado RPGQuest. Una captura de pantalla de este juego se muestra en la Figura 3. El propósito de la implementación es probar su viabilidad en un juego real. RPGQuest es un juego básico en primera persona donde el jugador puede moverse en un entorno tridimensional. Los objetos se colocan dentro del mundo del juego y los jugadores ganan puntos por cada objeto que se recolecta. Los clientes del juego se conectan a un servidor de juego que permite que muchos jugadores coexistan en el mismo mundo de juego. La funcionalidad básica de este juego es representativa de los juegos en línea actuales de disparos en primera persona y de rol. El juego utiliza la API gráfica DirectX 8 y la API de red DirectPlay. En esta sección discutiremos las tres versiones diferentes del juego con las que experimentamos. Figura 3: El juego RPGQuest. La primera versión del juego, que es la implementación original de RPGQuest, fue creada con un servidor completamente autoritario y un cliente no autoritario. La autoridad otorgada al servidor incluye decisiones sobre cuándo un jugador choca con objetos estáticos y otros jugadores, y cuándo un jugador recoge un objeto. Esta versión del juego funciona bien hasta una latencia de ida y vuelta de 100ms entre el cliente y el servidor. Hay poco retraso entre el momento en que el jugador choca contra una pared y el momento en que el servidor corrige la posición del jugador. Sin embargo, a medida que se induce más latencia entre el cliente y el servidor, el juego se vuelve cada vez más difícil de jugar. Con el aumento de la latencia, los mensajes provenientes del servidor corrigiendo al jugador cuando choca contra una pared no se reciben lo suficientemente rápido. Esto hace que el jugador pase a través de la pared mientras espera a que el servidor resuelva la colisión. Al estudiar el código fuente de la versión original del juego RPGQuest, hay un retraso sustancial que es inevitable cada vez que una acción debe ser validada por el servidor. Cuando se envía una actualización de movimiento al servidor, el cliente debe esperar luego el tiempo de ida y vuelta, más algún tiempo de procesamiento en el servidor para recibir su posición validada o corregida. Esto es claramente inaceptable en cualquier juego donde el movimiento u otra información de estado que cambia rápidamente debe ser validada y transmitida a los otros clientes rápidamente. Para solucionar este problema, desarrollamos una segunda versión del juego, la cual otorga toda la autoridad al cliente. Al cliente se le delegó la autoridad para validar su propio movimiento y la autoridad para recoger objetos sin validación del servidor. En esta versión del juego, cuando un jugador se mueve por el espacio del juego, el cliente valida que la nueva posición del jugador no se intersecte con ninguna pared u objeto estático. Una actualización de posición es enviada al servidor, el cual luego reenvía inmediatamente la actualización a los otros clientes dentro de la región. La actualización no tiene que pasar por ningún procesamiento o validación adicional. Este modelo de juego de autoridad completa otorgada al cliente es beneficioso en cuanto al movimiento. Cuando se inducen latencias de 100 ms en adelante en el enlace entre el cliente y el servidor, el juego sigue siendo jugable ya que los aspectos críticos en tiempo del juego como el movimiento no tienen que esperar una respuesta del servidor. Cuando un jugador choca contra una pared, la colisión se procesa de forma local y no es necesario esperar a que el servidor resuelva la colisión. Aunque la experiencia de juego en cuanto a la capacidad de respuesta mejora cuando la autoridad de movimiento se le da al cliente, todavía hay aspectos de los juegos que no se benefician de este enfoque. La más importante de estas es la consistencia. Aunque acciones como el movimiento son críticas en cuanto al tiempo, otras acciones no son tan críticas en cuanto al tiempo, sino que requieren consistencia entre los estados del jugador. Un ejemplo de un aspecto del juego que requiere consistencia es recoger objetos que solo deben ser poseídos por un único jugador. En nuestra versión autoritativa del cliente de RPGQuest, los clientes envían sus propias actualizaciones a todos los demás jugadores cada vez que recogen un objeto. De nuestros tests nos hemos dado cuenta de que este es un problema porque cuando hay una cantidad realista de latencia entre el cliente y el servidor, es posible que dos jugadores recojan el mismo objeto al mismo tiempo. Cuando dos jugadores intentan recoger un objeto en momentos físicos cercanos, la actualización enviada por el jugador que recogió el objeto primero no llegará al segundo jugador a tiempo para que vea que el objeto ya ha sido reclamado. Los dos jugadores ahora pensarán que son dueños del objeto. Por eso es necesario que un servidor siga siendo autoritario en esta situación y mantenga la consistencia en todos los jugadores. Estas dos versiones del juego RPGQuest nos han mostrado por qué es necesario mezclar los dos modelos absolutos de autoridad. Es mejor otorgar autoridad al cliente para cambiar rápidamente acciones como el movimiento. No es deseable tener que esperar la validación del servidor en un movimiento que podría cambiar antes de que se reciba la respuesta. A veces también es necesario priorizar la coherencia sobre la eficiencia en aspectos del juego que no pueden tolerar ninguna inconsistencia, como la propiedad de objetos. Creemos que a medida que aumenta la interactividad de los juegos, será necesario nuestro modelo de autoridad mixta que no depende de la validación del servidor. Para probar los beneficios y demostrar la viabilidad de nuestra arquitectura de autoridad mixta, desarrollamos una tercera versión del juego RPGQuest que distribuía la autoridad para diferentes acciones entre el cliente y el servidor. En esta versión, en aras de la coherencia, el servidor se mantuvo como autoritario para decidir quién recogía un objeto. Al cliente se le dio plena autoridad para enviar actualizaciones de posición a otros clientes y verificar su propia posición sin necesidad de verificar sus actualizaciones con el servidor. Cuando el jugador intenta mover su avatar, el cliente verifica que el movimiento no lo hará atravesar una pared. Una actualización de posición es enviada al servidor, el cual simplemente la reenvía a los otros clientes dentro de la región. Esto elimina cualquier retraso adicional en el procesamiento que ocurriría en el servidor y también es un medio más preciso de verificación, ya que el cliente tiene una visión más precisa de su propio estado que el servidor. Esta versión del juego RPGQuest, donde la autoridad se distribuye entre el cliente y el servidor, es una mejora con respecto a la versión de autoridad del servidor. El cliente no experimenta demoras al esperar una actualización de su propia posición y otros clientes no tienen que esperar en el servidor para verificar la actualización. Las inconsistencias donde dos clientes pueden recoger el mismo objeto en la arquitectura autoritativa del cliente no están presentes en esta versión del cliente. Sin embargo, los beneficios de la autoridad mixta no se verán realmente hasta que se implemente nuestro proxy de comunicación en el juego. Con la adición del proxy de comunicación, después de que el cliente verifique sus propias actualizaciones de posición, podrá enviar la actualización a todos los clientes dentro de su región a través de un enlace de baja latencia en lugar de tener que pasar primero por el servidor de juego, que posiblemente esté en una ubicación muy remota. La codificación de las diferentes versiones del juego fue muy sencilla. La complejidad del cliente aumentó muy ligeramente en los modelos cliente autoritativo e híbrido. Los clientes originales sin inteligencia artificial de RPGQuest conocen la posición de otros jugadores; no es solo una captura de pantalla enviada desde el servidor. El servidor actualiza a cada cliente con la posición de todos los clientes cercanos. Los clientes menos sofisticados utilizan la predicción del lado del cliente para rellenar los espacios entre las actualizaciones que reciben. El único procesamiento adicional que el cliente debe hacer en la arquitectura híbrida es comparar su posición actual con las posiciones de todos los objetos (paredes, cajas, etc.) en su área. Esto obviamente significa que cada cliente deberá haber descargado previamente las ubicaciones de todos los objetos estáticos dentro de su región actual. 5. TRABAJO RELACIONADO Se ha observado que, además de la latencia, los requisitos de ancho de banda también dictan el tipo de arquitectura de juegos que se debe utilizar. En [16], se estudian diferentes tipos de arquitecturas en cuanto a eficiencias de ancho de banda y latencia. Se señala que las arquitecturas de Servidor Central no son escalables debido a los requisitos de ancho de banda en el servidor, pero los costos adicionales de las verificaciones de consistencia son limitados ya que se realizan en el servidor. Una arquitectura Peer-to-Peer, por otro lado, es escalable pero tiene un sobrecoste significativo para las comprobaciones de consistencia, ya que estas son necesarias en cada jugador. El documento propone una arquitectura híbrida que es Peer-to-Peer en términos de intercambio de mensajes (y por lo tanto es escalable), donde se utiliza un Servidor Central para realizar comprobaciones de consistencia fuera de línea (mitigando así la sobrecarga de comprobación de consistencia). El artículo proporciona un ejemplo de implementación de BZFlag, que es un juego peer-to-peer modificado para transferir toda la autoridad a un servidor central. En esencia, este documento aboga por una arquitectura de autoridad basada en el servidor incluso para juegos peer-to-peer, pero no considera la división de autoridad entre un cliente y un servidor para minimizar la latencia que podría afectar la experiencia de juego, incluso con el tipo de latencia encontrada en juegos basados en servidor (donde toda la autoridad está en el servidor). También existe trabajo previo que ha sugerido que se utilicen arquitecturas basadas en proxy para aliviar el problema de latencia y además utilizar proxies para proporcionar control de congestión y mecanismos a prueba de trampas en juegos multijugador distribuidos [17]. En [18], se presenta una arquitectura de servidor proxy en red que tiene como objetivo mejorar la escalabilidad de los juegos multijugador y reducir la latencia en la transmisión de datos entre el servidor y el cliente. El objetivo principal de este trabajo es mejorar la escalabilidad de los juegos de disparos en primera persona (FPS) y de rol (RPG). El objetivo adicional es mejorar la capacidad de respuesta de los MMOGs proporcionando comunicaciones de baja latencia entre el cliente y el servidor. La arquitectura utiliza servidores proxy interconectados que tienen una vista completa del estado global del juego. Los servidores proxy se encuentran en varios proveedores de servicios de Internet diferentes. Se menciona en este trabajo que dividir el espacio de juego entre varios servidores de juegos, como el modelo federado presentado en [19], es ineficiente para un flujo de juego relativamente rápido y que la arquitectura propuesta alivia este problema porque los usuarios no tienen que conectarse a un servidor diferente cada vez que cruzan el límite del servidor. Esta arquitectura todavía requiere que todos los proxies estén al tanto del estado general del juego en todo el espacio de juego, a diferencia de nuestro trabajo, donde requerimos que los proxies mantengan solo información parcial del estado sobre el espacio de juego. Las arquitecturas de agentes basadas en fidelidad han sido propuestas en [20, 21]. Estas obras proponen una arquitectura cliente-servidor distribuida para simulaciones interactivas distribuidas donde diferentes servidores son responsables de diferentes partes del espacio de juego. Cuando un objeto se mueve de una parte a otra, se produce una transferencia de un servidor a otro. Aunque estos trabajos proponen una arquitectura donde diferentes porciones del espacio de simulación son gestionadas por diferentes servidores, no abordan el problema de disminuir el ancho de banda requerido a través del uso de proxies de comunicación. Nuestro trabajo difiere de los trabajos previos discutidos anteriormente al proponer a) una arquitectura basada en proxy distribuido para disminuir los requisitos de ancho de banda en los clientes y servidores sin requerir que los proxies mantengan información de estado sobre todo el espacio de juego, b) una técnica de asignación de autoridad dinámica para reducir la latencia (realizando comprobaciones de consistencia localmente en el cliente siempre que sea posible) al dividir la autoridad entre los clientes y servidores por objeto, y c) proponiendo que la detección de trampas puede integrarse en los proxies si se les proporciona más información sobre el juego específico en lugar de utilizarlos puramente como proxies de comunicación (aunque esta idea aún no se ha implementado y forma parte de nuestro trabajo futuro). CONCLUSIONES Y TRABAJO FUTURO En este artículo, primero propusimos una arquitectura basada en proxy para MMOGs que permite que los MMOGs se escalen a un gran número de usuarios al mitigar la necesidad de mantener un gran número de sesiones de transporte y disminuir tanto la sobrecarga de ancho de banda como la latencia de la actualización de eventos. Segundo, propusimos un mecanismo de asignación de autoridad mixta que divide la autoridad para tomar decisiones sobre acciones y eventos dentro del juego entre los clientes y el servidor, y argumentamos cómo dicha asignación de autoridad conduce a una mejor experiencia de juego sin sacrificar la consistencia del juego. Tercero, para validar la viabilidad del mecanismo de asignación de autoridad mixta, lo implementamos dentro de un MMOG llamado RPGQuest y describimos nuestra experiencia de implementación. En trabajos futuros, proponemos implementar la arquitectura de proxy de comunicaciones descrita en este documento e integrar el mecanismo de autoridad mixta dentro de esta arquitectura. Proponemos evaluar los beneficios de la arquitectura basada en proxy en términos de escalabilidad, precisión y capacidad de respuesta. También planeamos implementar una versión del juego RPGQuest con asignación dinámica de autoridad para permitir a los jugadores recoger objetos cuando no hay otros jugadores cerca. Como se discutió anteriormente, esto permitirá un juego más eficiente y receptivo en ciertas situaciones y aliviará parte de la carga de procesamiento del servidor. Además, dado que se deposita tanta confianza en los clientes de nuestra arquitectura, será necesario integrar en la arquitectura muchos de los esquemas de detección de trampas que se han propuesto en la literatura. Software como Punkbuster [22] y un sistema de reputación como los propuestos por [23] y [15] serían fundamentales para el funcionamiento de una arquitectura como la nuestra, en la que se deposita mucha confianza en el cliente. Proponemos además hacer que los intermediarios en nuestra arquitectura sean más conscientes del juego para que los mecanismos de detección de trampas puedan ser incorporados directamente en los intermediarios. 7. REFERENCIAS [1] Y. W. Bernier. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos 01, 2001. [2] Lothar Pantel y Lars C. Wolf. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En NOSSDAV 02: Actas del 12º taller internacional sobre soporte de redes y sistemas operativos para audio y video digital, páginas 23-29, Nueva York, NY, EE. UU., 2002. ACM Press. [3] G. Armitage. 

ACM Press. [3] G. Armitage. Sensibilidad de los jugadores de Quake3 a la latencia de red. En Proc. de IMW2001, Sesión de Pósters del Taller, noviembre de 2001. http://www.geocities.com/gj armitage/q3/quake-results.html. [4] Tobias Fritsch, Hartmut Ritter y Jochen Schiller. El efecto de la latencia y las limitaciones de red en los MMORPG: un estudio de campo de EverQuest2. En NetGames 05: Actas del 4º taller de ACM SIGCOMM sobre soporte de red y sistema para juegos, páginas 1-9, Nueva York, NY, EE. UU., 2005. ACM Press. [5] Tom Beigbeder, Rory Coughlan, Corey Lusher, John Plunkett, Emmanuel Agu y Mark Claypool. Los efectos de la pérdida y la latencia en el rendimiento del usuario en Unreal Tournament 2003. En NetGames 04: Actas del 3er taller de ACM SIGCOMM sobre soporte de red y sistema para juegos, páginas 144-151, Nueva York, NY, EE. UU., 2004. ACM Press. [6] Y. Lin, K. Guo y S. Paul. Sync-MS: Servicio de Mensajería Sincronizada para Juegos Distribuidos Multijugador en Tiempo Real. En Proc. de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), Noviembre de 2002. [7] Katherine Guo, Sarit Mukherjee, Sampath Rangarajan y Sanjoy Paul. Un marco de intercambio de mensajes justo para juegos multijugador distribuidos. En NetGames 03: Actas del 2º taller sobre soporte de red y sistema para juegos, páginas 29-41, Nueva York, NY, EE. UU., 2003. ACM Press. [8] T. Barron. 

ACM Press. [8] T. Barron. Programación de juegos multijugador, capítulos 16-17, páginas 672-731. Serie de Desarrollo de Juegos de Prima Techs. Prima Publishing, 2001. 8 El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 [9] Carsten Griwodz y P˚al Halvorsen. La diversión de usar TCP para un MMORPG. En NOSSDAV 06: Actas del Taller Internacional sobre Soporte de Redes y Sistemas Operativos para Audio y Video Digital, Nueva York, NY, EE. UU., 2006. ACM Press. [10] Sudhir Aggarwal, Hemant Banavar, Amit Khandelwal, Sarit Mukherjee y Sampath Rangarajan. Precisión en juegos multijugador distribuidos basados en cálculos de navegación muerta. En NetGames 04: Actas del 3er taller de ACM SIGCOMM sobre soporte de red y sistema para juegos, páginas 161-165, Nueva York, NY, EE. UU., 2004. ACM Press. [11] Sudhir Aggarwal, Hemant Banavar, Sarit Mukherjee y Sampath Rangarajan. Equidad en juegos multijugador distribuidos basados en cálculo de rumbo muerto. En NetGames 05: Actas del 4º taller de ACM SIGCOMM sobre soporte de red y sistema para juegos, páginas 1-10, Nueva York, NY, EE. UU., 2005. ACM Press. [12] Riker, T. et al. Bzflag. http://www.bzflag.org, 2000-2006. [13] Linden Lab. 

Bzflag. http://www.bzflag.org, 2000-2006. [13] Linden Lab. Segunda vida. http://secondlife.com, 2003. [14] Martin Mauve. Cómo evitar que un hombre muerto dispare. En IDMS 00: Actas del 7º Taller Internacional sobre Sistemas Multimedia Distribuidos Interactivos y Servicios de Telecomunicaciones, páginas 199-204, Londres, Reino Unido, 2000. Springer-Verlag. [15] Max Skibinsky.
Springer-Verlag. [15] Max Skibinsky. Desarrollo de juegos multijugador masivos 2, capítulo La búsqueda de la escala sagrada Parte 2: Continuo P2P, páginas 355-373. Charles River Media, 2005. [16] Joseph D. Pellegrino y Constantinos Dovrolis. Requisito de ancho de banda y consistencia de estado en tres arquitecturas de juegos multijugador. En NetGames 03: Actas del 2º taller sobre soporte de red y sistema para juegos, páginas 52-59, Nueva York, NY, EE. UU., 2003. ACM Press. [17] M. Mauve, J. Widmer y S. Fischer. Un sistema de proxy genérico para juegos de computadora en red. En Actas del Taller sobre Juegos en Red, Netgames 2002, abril de 2002. [18] S. Gorlatch, J. Muller, S. Fischer y M. Mauve. Una arquitectura de red de servidores proxy para juegos de computadora en tiempo real. En Euor-Par 2004 Procesamiento Paralelo: 10ª Conferencia Internacional EURO-PAR, agosto-septiembre de 2004. [19] H. Hazeyama, T. Limura y Y. Kadobayashi. Federación Zonificada de Servidores de Juegos: Un Enfoque Peer-to-Peer para Juegos Multijugador en Línea Escalables. En Proc. del Taller de ACM sobre Juegos en Red, Netgames 2004, agosto-septiembre de 2004. [20] B. Kelly y S. Aggarwal. Un marco para una arquitectura de agente basada en fidelidad para simulación interactiva distribuida. En Actas del 14º Taller sobre Normas para la Simulación Interactiva Distribuida, páginas 541-546, marzo de 1996. [21] S. Aggarwal y B. Kelly. Estructuración jerárquica para simulación interactiva distribuida. En Proc. 13º Taller sobre Normas para la Simulación Interactiva Distribuida, páginas 125-132, septiembre de 1995. [22] Even Balance, Inc. Punkbuster. http://www.evenbalance.com/, 2001-2006. [23] Y. Wang y J. Vassileva. Modelo de Confianza y Reputación en Redes Peer-to-Peer. En la Tercera Conferencia Internacional sobre Computación Peer-to-Peer, 2003. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006.