En los últimos años, las redes superpuestas se han convertido en una alternativa efectiva a la multidifusión IP para una comunicación eficiente de punto a multipunto a través de Internet. Normalmente, los nodos se autoorganizan con el objetivo de formar un árbol de superposición eficiente, que cumpla con los objetivos de rendimiento sin sobrecargar la red subyacente. En este documento, nos enfocamos en la distribución de datos de alta velocidad desde una única fuente a un gran número de receptores. Las aplicaciones incluyen transferencias de archivos grandes y transmisión de multimedia en tiempo real. Para estas aplicaciones, sostenemos que una malla superpuesta, en lugar de un árbol, puede ofrecer fundamentalmente mayor ancho de banda y fiabilidad en comparación con las estructuras de árbol típicas. Este documento presenta Bullet, un algoritmo escalable y distribuido que permite a los nodos distribuidos a lo largo de Internet autoorganizarse en una malla superpuesta de alta capacidad de ancho de banda. Construimos Bullet en torno a la idea de que los datos deben distribuirse de manera disjunta en puntos estratégicos de la red. Los receptores de balas individuales son responsables de localizar y recuperar los datos de múltiples puntos en paralelo. Las principales contribuciones de este trabajo incluyen: i) un algoritmo que envía datos a diferentes puntos en la superposición de manera que cualquier objeto de datos tenga la misma probabilidad de aparecer en cualquier nodo, ii) un algoritmo escalable y descentralizado que permite a los nodos localizar y recuperar elementos de datos faltantes, y iii) una implementación completa y evaluación de Bullet ejecutándose a través de Internet y en un entorno de emulación a gran escala revela mejoras de ancho de banda de hasta un factor dos bajo una variedad de circunstancias. Además, encontramos que, en comparación con las soluciones basadas en árboles, Bullet reduce la necesidad de realizar sondas de ancho de banda costosas. En un árbol, es crítico que el padre de un nodo entregue una alta tasa de datos de aplicación a cada hijo. En Bullet, sin embargo, los nodos reciben datos de múltiples fuentes de forma simultánea en paralelo, por lo que es menos importante localizar una única fuente capaz de mantener una alta tasa de transmisión. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos; H.4.3 [Aplicaciones de Sistemas de Información]: Aplicaciones de Comunicaciones Términos Generales Experimentación, Gestión, Rendimiento 1. INTRODUCCIÓN En este documento, consideramos el siguiente problema general. Dado un emisor y un gran conjunto de receptores interesados distribuidos en Internet, ¿cómo podemos maximizar la cantidad de ancho de banda entregado a los receptores? Nuestro dominio de problemas incluye la distribución de software o video y la transmisión de multimedia en tiempo real. Tradicionalmente, la multidifusión IP nativa ha sido el método preferido para entregar contenido a un conjunto de receptores de manera escalable. Sin embargo, una serie de consideraciones, incluyendo la escala, la fiabilidad y el control de congestión, han limitado la implementación a gran escala de la multidifusión IP. Aunque todos estos problemas fueran abordados, IP multicast no considera el ancho de banda al construir su árbol de distribución. Más recientemente, las superposiciones han surgido como una alternativa prometedora al multicast para la entrega eficiente de datos de punto a multipunto en la red. Las estructuras de superposición típicas intentan imitar la estructura de los árboles de enrutamiento multicast. En la multidifusión de capa de red, sin embargo, los nodos interiores consisten en enrutadores de alta velocidad con potencia de procesamiento limitada y extensibilidad. Por otro lado, las superposiciones utilizan nodos interiores en el árbol de superposición como extremos de host programables (y por lo tanto extensibles), con estos hosts actuando como repetidores para múltiples hijos a lo largo del árbol. Las superposiciones han demostrado un gran potencial para aplicaciones de estilo de multidifusión. Sin embargo, sostenemos que una estructura de árbol tiene limitaciones fundamentales tanto para la multidifusión de alta velocidad de banda ancha como para la alta confiabilidad. Una dificultad con los árboles es que el ancho de banda está garantizado de disminuir monótonamente al moverse hacia abajo en el árbol. Cualquier pérdida en lo alto del árbol reducirá el ancho de banda disponible para los receptores más abajo en el árbol. Se han propuesto varias técnicas para recuperarse de pérdidas y, por lo tanto, mejorar el ancho de banda disponible en un árbol superpuesto [2, 6]. Sin embargo, fundamentalmente, el ancho de banda disponible para cualquier host está limitado por el ancho de banda disponible de su único padre en el árbol. Por lo tanto, nuestro trabajo parte de la premisa de que el modelo de difusión de datos de multidifusión de alta velocidad debería ser reexaminado. En lugar de enviar copias idénticas del mismo flujo de datos a todos los nodos en un árbol y diseñar un mecanismo escalable para recuperarse de pérdidas, proponemos que los participantes en una superposición de multidifusión cooperen para transmitir estratégicamente conjuntos de datos disjuntos a varios puntos en la red. Aquí, el remitente divide los datos en bloques secuenciales. Los bloques se subdividen aún más en objetos individuales que a su vez se transmiten a diferentes puntos en la red. Los nodos aún reciben un conjunto de objetos de sus padres, pero luego son responsables de localizar pares que contengan objetos de datos faltantes. Utilizamos un algoritmo distribuido que tiene como objetivo distribuir uniformemente la disponibilidad de los elementos de datos entre todos los participantes de la superposición. De esta manera, evitamos el problema de localizar el último objeto, que puede estar disponible solo en algunos nodos. Una hipótesis de este trabajo es que, en comparación con un árbol, este modelo resultará en un mayor aprovechamiento del ancho de banda al utilizar el ancho de banda de descargas paralelas simultáneas de múltiples fuentes en lugar de un solo padre, y una mayor fiabilidad al recuperar datos de múltiples pares, lo que reduce el daño potencial de una falla en un solo nodo. Para ilustrar el comportamiento de Bullets, considera una superposición de tres nodos simple con una raíz R y dos hijos A y B. R tiene 1 Mbps de ancho de banda disponible (amigable con TCP) para cada uno de A y B. Sin embargo, también hay 1 Mbps de ancho de banda disponible entre A y B. En este ejemplo, Bullet transmitiría un conjunto disjunto de datos a 1 Mbps a cada uno de A y B. A y B entonces descubrirían de forma independiente la disponibilidad de datos disjuntos en el par remoto y comenzarían a transmitirse datos entre sí, logrando efectivamente una velocidad de recuperación de 2 Mbps. Por otro lado, cualquier árbol de superposición está limitado a entregar como máximo 1 Mbps incluso con una técnica escalable para recuperar datos perdidos. Cualquier solución para lograr el modelo anterior debe mantener una serie de propiedades. Primero, debe ser amigable con TCP [15]. Ningún flujo debe consumir más de su parte justa del ancho de banda del cuello de botella y cada flujo debe responder a las señales de congestión (pérdidas) reduciendo su tasa de transmisión. Segundo, debe imponer una baja sobrecarga de control. Existen muchas posibles fuentes de dichos costos adicionales, incluyendo la búsqueda de ancho de banda disponible entre nodos, la localización de nodos apropiados para emparejar con la recuperación de datos y la recepción redundante de los mismos objetos de datos desde múltiples fuentes. Tercero, el algoritmo debe ser descentralizado y escalable para miles de participantes. Ningún nodo debería estar obligado a aprender o mantener conocimiento global, como la membresía global de grupos o el conjunto de objetos de datos actualmente disponibles en todos los nodos. Finalmente, el enfoque debe ser robusto ante fallos individuales. Por ejemplo, el fallo de un solo nodo solo debería resultar en una reducción temporal en el ancho de banda entregado a un pequeño subconjunto de participantes; ningún fallo individual debería resultar en la pérdida completa de datos para una fracción significativa de nodos, como podría ser el caso en un fallo de un solo nodo en lo alto de un árbol de superposición de multidifusión. En este contexto, este artículo presenta el diseño y la evaluación de Bullet, un algoritmo para construir una malla superpuesta que intenta mantener las propiedades mencionadas anteriormente. Los nodos de bala comienzan autoorganizándose en un árbol de superposición, que puede ser construido por cualquiera de una serie de técnicas existentes [1, 18, 21, 24, 34]. Cada nodo Bullet, comenzando por la raíz del árbol subyacente, luego transmite un conjunto disjunto de datos a cada uno de sus hijos, con el objetivo de mantener una representatividad uniforme de cada elemento de datos entre todos los participantes. El nivel de desvinculación se determina por el ancho de banda disponible para cada uno de sus hijos. Bullet luego emplea un algoritmo escalable y eficiente para permitir a los nodos localizar rápidamente múltiples pares capaces de transmitir los elementos de datos faltantes al nodo. Por lo tanto, Bullet superpone una malla de alta capacidad de ancho de banda sobre un árbol de superposición arbitrario. Dependiendo del tipo de datos que se estén transmitiendo, Bullet puede emplear opcionalmente una variedad de esquemas de codificación, como por ejemplo códigos de borrado [7, 26, 25] o Codificación de Múltiples Descripciones (MDC) [17], para difundir eficientemente datos, adaptarse a anchos de banda variables y recuperarse de pérdidas. Finalmente, utilizamos TFRC [15] para transferir datos tanto hacia abajo en el árbol de superposición como entre pares. Esto garantiza que toda la superposición se comporte de manera amigable con la congestión, ajustando su velocidad de transmisión de forma individual para cada conexión según las condiciones de red prevalecientes. Uno de los beneficios importantes de nuestro enfoque es que el ancho de banda entregado por la malla Bullet es en cierta medida independiente del ancho de banda disponible a través del árbol de superposición subyacente. Una limitación significativa para construir árboles de superposición de alta capacidad de ancho de banda es el sobrecoste asociado con el protocolo de construcción del árbol. En estos árboles, es crítico que cada participante localice a un padre mediante sondeos con un alto nivel de ancho de banda disponible, ya que recibe datos de una única fuente (su padre). Por lo tanto, incluso una vez que el árbol está construido, los nodos deben seguir sondeando para adaptarse a las condiciones de red que cambian dinámicamente. Si bien la exploración del ancho de banda es un área activa de investigación [20, 35], los resultados precisos generalmente requieren la transferencia de una gran cantidad de datos para tener confianza en los resultados. Nuestro enfoque con Bullet permite a los receptores obtener un ancho de banda alto en conjunto utilizando transferencias individuales de pares distribuidos en todo el sistema. Por lo tanto, en Bullet, el ancho de banda disponible de cada par individual es mucho menos importante que en cualquier árbol optimizado en ancho de banda. Además, todo el ancho de banda que normalmente se consumiría sondeando el ancho de banda puede ser reasignado para transmitir datos a través de la malla Bullet. Hemos completado un prototipo de Bullet funcionando sobre un conjunto de árboles superpuestos. Nuestra evaluación de una superposición de 1000 nodos que se ejecuta en una amplia variedad de topologías de red emuladas de 20,000 nodos muestra que Bullet puede ofrecer hasta el doble del ancho de banda de un árbol optimizado para el ancho de banda (utilizando un algoritmo fuera de línea e información de topología de red global), manteniéndose siempre amigable con TCP. También desplegamos nuestro prototipo en la plataforma de pruebas de área extensa PlanetLab [31]. Para estas ejecuciones en vivo por Internet, encontramos que Bullet puede ofrecer mejoras comparables en el rendimiento del ancho de banda. En ambos casos, el costo de mantenimiento de la malla de balas y la localización de los datos disjuntos apropiados está limitado a 30 Kbps por nodo, lo cual es aceptable para nuestros escenarios de alta escala y ancho de banda objetivo. El resto de este documento está organizado de la siguiente manera. La sección 2 presenta los componentes del sistema Bullets, incluyendo RanSub, entrega de contenido informada y TFRC. La sección 3 detalla Bullet, un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. La sección 4 evalúa el rendimiento de Bullets para una variedad de topologías de red y lo compara con técnicas de multidifusión existentes. La sección 5 sitúa nuestro trabajo en el contexto de esfuerzos relacionados y la sección 6 presenta nuestras conclusiones. COMPONENTES DEL SISTEMA Nuestro enfoque en la difusión de datos de alta velocidad se centra en las técnicas representadas en la Figura 1. Primero, dividimos la secuencia de datos objetivo en bloques que luego se subdividen en objetos individuales (generalmente del tamaño de un paquete). Dependiendo de los requisitos de las aplicaciones objetivo, los objetos pueden ser codificados [17, 26] para hacer más eficiente la recuperación de datos. A continuación, difundimos intencionalmente objetos disjuntos 283 S A C. Flujo de datos original: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC para determinar el ancho de banda disponible D E 1 2 5 1 3 4 Figura 1: Vista general de la operación de Bullets. a diferentes clientes a una velocidad determinada por el ancho de banda disponible para cada cliente. Utilizamos el protocolo TFRC basado en ecuaciones para comunicarnos entre todos los nodos en la superposición de manera receptiva a la congestión y amigable con TCP. Dadas las técnicas anteriores, los datos se distribuyen a lo largo del árbol de superposición a una velocidad acorde con el ancho de banda disponible en el árbol de superposición. Nuestro objetivo general, sin embargo, es proporcionar más ancho de banda del que estaría disponible a través de cualquier árbol. Por lo tanto, en este punto, los nodos requieren una técnica escalable para localizar y recuperar datos disjuntos de sus pares. En esencia, estos enlaces perpendiculares a través de la superposición forman una malla para aumentar el ancho de banda disponible a través del árbol. En la Figura 1, el nodo D solo tiene ancho de banda suficiente para recibir 3 objetos por unidad de tiempo de su padre. Sin embargo, es capaz de localizar a dos pares, C y E, que pueden transmitir objetos de datos faltantes, en este ejemplo aumentando el ancho de banda entregado de 3 objetos por unidad de tiempo a 6 objetos de datos por unidad de tiempo. Localizar pares remotos adecuados no puede requerir un estado global o comunicación global. Por lo tanto, proponemos la difusión periódica de subconjuntos cambiantes y uniformemente aleatorios del estado global a cada nodo de superposición una vez por período de tiempo configurable. Este subconjunto aleatorio contiene tickets resumidos de los objetos disponibles en un subconjunto de los nodos en el sistema. Cada nodo utiliza esta información para solicitar objetos de datos a nodos remotos que tienen una divergencia significativa en la membresía de objetos. Luego intenta establecer una serie de estas relaciones de interconexión con el objetivo de minimizar la superposición en los objetos recibidos de cada par y maximizar el ancho de banda útil total entregado a él. En el resto de esta sección, proporcionamos una breve introducción sobre cada una de las técnicas que empleamos como bloques fundamentales para nuestro trabajo. La sección 3 presenta los detalles de toda la arquitectura de Bullet. 2.1 Codificación de Datos Dependiendo del tipo de datos que se distribuyan a través del sistema, una serie de esquemas de codificación de datos pueden mejorar la eficiencia del sistema. Por ejemplo, si se está distribuyendo datos multimedia a un conjunto de receptores heterogéneos con ancho de banda variable, MDC [17] permite que los receptores obtengan diferentes subconjuntos de los datos y aún así mantengan un flujo multimedia utilizable. Para la difusión de un archivo grande entre un conjunto de receptores, los códigos de borrado permiten a los receptores no centrarse en recuperar cada paquete de datos transmitido. Más bien, después de obtener un número mínimo de paquetes de umbral, los receptores pueden decodificar la secuencia original de datos. Por supuesto, Bullet es adaptable a una variedad de otros esquemas de codificación o incluso al esquema de codificación nulo, donde la secuencia de datos original se transmite de la mejor manera posible a través del sistema. En este artículo, nos enfocamos en los beneficios de una clase especial de códigos correctores de errores utilizados para implementar el enfoque de fuente digital [7]. Los códigos de tornado redundantes [26] se crean realizando operaciones XOR en un número seleccionado de paquetes de datos originales, y luego se transmiten junto con los paquetes de datos originales. Los códigos de tornado requieren que cualquier (1+ )k paquetes recibidos correctamente reconstruyan los k paquetes de datos originales, con un sobrecosto de recepción típicamente bajo ( ) de 0.03 − 0.05. A cambio, proporcionan tiempos de codificación y decodificación significativamente más rápidos. Además, el algoritmo de decodificación puede ejecutarse en tiempo real, y el proceso de reconstrucción puede comenzar tan pronto como haya llegado un número suficiente de paquetes. Los códigos de tornado requieren un factor de estiramiento predeterminado (n/k, donde n es el número total de paquetes codificados) y su tiempo de codificación es proporcional a n. Los códigos LT [25] eliminan estas dos limitaciones, manteniendo un bajo sobrecosto de recepción de 0.05. Para abordar el desafío de localizar contenido disjunto dentro del sistema, utilizamos RanSub [24], un enfoque escalable para distribuir subconjuntos aleatorios uniformes cambiantes del estado global a todos los nodos de un árbol de superposición. RanSub asume la presencia de algún mecanismo escalable para construir y mantener eficientemente el árbol subyacente. Un número de tales técnicas se describen en [1, 18, 21, 24, 34]. RanSub distribuye subconjuntos aleatorios de nodos participantes en todo el árbol utilizando mensajes de recopilación y distribución. Recopilar mensajes comienza en las hojas y se propaga hacia arriba en el árbol, dejando estado en cada nodo a lo largo del camino hacia la raíz. Distribuir mensajes comienza en la raíz y viaja hacia abajo en el árbol, utilizando la información dejada en los nodos durante la ronda de recolección anterior para distribuir subconjuntos aleatorios uniformemente a todos los participantes. Utilizando los mensajes de recolección y distribución, RanSub distribuye un subconjunto aleatorio de participantes a cada nodo una vez por época. El límite inferior en la longitud de un período está determinado por el tiempo que tarda en propagarse los datos hacia arriba y luego hacia abajo del árbol, o aproximadamente el doble de la altura del árbol. Para árboles construidos adecuadamente, la longitud mínima de la época aumentará con el logaritmo del número de participantes, aunque esto no es necesario para la corrección. Como parte del mensaje de distribución, cada participante envía un subconjunto uniformemente aleatorio de nodos remotos, llamado conjunto de distribución, hacia sus hijos. Los contenidos del conjunto distribuido se construyen utilizando el conjunto recopilado durante la fase de recopilación anterior. Durante esta fase, cada participante envía un conjunto colectivo que consiste en un subconjunto aleatorio de sus nodos descendientes hacia arriba en el árbol hasta la raíz junto con una estimación de su número total de descendientes. Después de que la raíz recibe todos los conjuntos recolectados y la fase de recolección se completa, la fase de distribución comienza de nuevo en una nueva época. Una de las características clave de RanSub es la operación compacta. Este es el proceso utilizado para garantizar que la membresía en un conjunto colectivo propagado por un nodo a su padre sea tanto aleatoria como representativa de manera uniforme de todos los miembros del subárbol enraizado en ese nodo. Compact toma múltiples subconjuntos de tamaño fijo y la población total representada por cada subconjunto como entrada, y genera un nuevo subconjunto de tamaño fijo. La CSC 284 = {Cs}, CSD = {Ds}, CSF = {Fs}, CSG = {Gs}, CSB = {Bs, Cs, Ds}, CSE = {Es, Fs, Gs} B C E D GF B C A E D GF DSE = {As, Bs, Cs, Ds}, DSB = {As, Es, Fs, Gs}, DSG = {As, Bs, Cs, Ds, Es, Fs}, DSD = {As, Bs, Cs, Es, Fs, Gs}, DSF = {As, Bs, Cs, Ds, Es, Gs}, DSC = {As, Bs, Ds, Es, Fs, Gs} Figura 2: Este ejemplo muestra las dos fases del protocolo RanSub que ocurren en un época. La fase de recolección se muestra a la izquierda, donde los conjuntos de recolección están viajando hacia arriba en la superposición hasta la raíz. La fase de distribución a la derecha muestra los conjuntos distribuidos viajando por la superposición hacia los nodos hoja. Los miembros del conjunto resultante son representantes uniformemente aleatorios de los miembros del subconjunto de entrada. RanSub ofrece varias formas de construir conjuntos distribuidos. Para nuestro sistema, elegimos la opción RanSub-no descendientes. En este caso, cada nodo recibe un subconjunto aleatorio que consiste en todos los nodos excluyendo a sus descendientes. Esto es apropiado para nuestra estructura de descarga donde se espera que los descendientes tengan menos contenido que un nodo ancestro en la mayoría de los casos. Un padre crea conjuntos de distribución de RanSub-no descendientes para cada hijo al compactar conjuntos de recolección de los hermanos de ese hijo y su propio conjunto de distribución. El resultado es un conjunto distribuido que contiene un subconjunto aleatorio que representa todos los nodos en el árbol excepto aquellos enraizados en ese hijo en particular. Representamos un ejemplo del proceso de recolección y distribución de RanSubs en la Figura 2. En la figura, AS representa el estado del nodo A. 2.3 Técnicas de entrega de contenido informadas Suponiendo que podemos habilitar a un nodo para localizar un par con contenido disjunto utilizando RanSub, necesitamos un método para conciliar las diferencias en los datos. Además, necesitamos un método eficiente en ancho de banda con baja carga computacional. Decidimos implementar las técnicas de reconciliación aproximada propuestas en [6] para estas tareas en Bullet. Para describir el contenido, los nodos mantienen conjuntos de trabajo. El conjunto de trabajo contiene números de secuencia de paquetes que han sido recibidos con éxito por cada nodo durante un cierto período de tiempo. Necesitamos la capacidad de discernir rápidamente la similitud entre los conjuntos de trabajo de dos nodos y decidir si una reconciliación detallada es beneficiosa. Los tickets de resumen, o bocetos min-wise, cumplen con este propósito. La idea principal es crear un boleto de resumen que sea una muestra aleatoria imparcial del conjunto de trabajo. Un boleto de resumen es una matriz de tamaño fijo pequeño. Cada entrada en este arreglo es mantenida por una función de permutación específica. El objetivo es que cada entrada esté poblada por el elemento con el valor permutado más pequeño. Para insertar un nuevo elemento en el resumen del ticket, aplicamos las funciones de permutación en orden y actualizamos los valores del arreglo según corresponda. La función de permutación se puede considerar como una función hash especializada. La elección de las funciones de permutación es importante, ya que la calidad del boleto resumen depende directamente de las propiedades de aleatoriedad de las funciones de permutación. Dado que requerimos que tengan un bajo costo computacional, utilizamos funciones de permutación simples, como Pj(x) = (ax+b)mod|U|, donde U es el tamaño del universo (dependiendo del esquema de codificación de datos). Para calcular la similitud entre dos conjuntos de trabajo, calculamos el número de entradas de boletos resumen que tienen el mismo valor, y lo dividimos por el número total de entradas en los boletos resumen. La Figura 3 muestra la forma en que las funciones de permutación se utilizan para poblar el boleto resumen. 12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Boleto resumen minminmin 10 2 Figura 3: Ejemplo que muestra la construcción de un boleto resumen de muestra a partir del conjunto de trabajo. Para realizar una reconciliación aproximada de granularidad fina, un par A envía su resumen a un par B y espera recibir paquetes que no estén descritos en el resumen. Para este propósito, utilizamos un filtro de Bloom [4], un arreglo de bits de tamaño m con k funciones hash asociadas independientes. Un elemento s del conjunto de claves recibidas S = {s0, s1, . . . , sn−1} se inserta en el filtro calculando los valores hash h0, h1, . . . , hk−1 de s y estableciendo los bits en el array que corresponden a los valores hash. Para verificar si un elemento x está en el filtro de Bloom, lo hasheamos usando las funciones de hash y comprobamos si todas las posiciones en el arreglo de bits están establecidas. Si al menos uno no está establecido, sabemos que el filtro de Bloom no contiene x. Cuando se utilizan filtros de Bloom, la inserción de diferentes elementos podría hacer que todas las posiciones en el arreglo de bits correspondientes a un elemento que no está en el conjunto sean distintas de cero. En este caso, tenemos un falso positivo. Por lo tanto, es posible que el par B no envíe un paquete al par A aunque A lo esté esperando. Por otro lado, un nodo nunca enviará un paquete que esté descrito en el filtro de Bloom, es decir, no hay falsos negativos. La probabilidad de obtener un falso positivo pf en la consulta de membresía se puede expresar como una función de la razón m n y el número de funciones hash k: pf = (1 − e−kn/m )k. Por lo tanto, podemos elegir el tamaño del filtro de Bloom y el número de funciones hash que producirán una proporción deseada de falsos positivos. Control de tasa amigable con TCP Aunque la mayoría del tráfico en Internet hoy en día es mejor servido por TCP, las aplicaciones que requieren una tasa de envío suave y que tienen una mayor tolerancia a la pérdida a menudo encuentran que la reacción de TCP ante un solo paquete perdido es innecesariamente severa. El Control de Tasa Amigable con TCP, o TFRC, se enfoca en aplicaciones de transmisión multimedia unicast que requieren respuestas menos drásticas a pérdidas de paquetes individuales [15]. TCP reduce a la mitad la tasa de envío tan pronto como se detecta una pérdida de paquetes. Alternativamente, TFRC es un protocolo de control de congestión basado en ecuaciones que se basa en eventos de pérdida, los cuales consisten en la caída de múltiples paquetes dentro de un tiempo de ida y vuelta. A diferencia de TCP, el objetivo de TFRC no es encontrar y utilizar todo el ancho de banda disponible, sino mantener una tasa de envío relativamente constante y seguir siendo sensible a la congestión. Para garantizar la equidad con TCP, TFRC utiliza la función de respuesta que describe la tasa de envío en estado estable de TCP para determinar la tasa de transmisión en TFRC. La fórmula de la función de respuesta TCP [27] utilizada en TFRC para describir la tasa de envío es: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) Esta es la expresión de la tasa de envío T en bytes/segundo, como función del tiempo de ida y vuelta R en segundos, tasa de eventos de pérdida p, tamaño del paquete s en bytes y valor de retransmisión TCP tRT O en segundos. Los emisores y receptores de TFRC deben cooperar para lograr una tasa de transmisión fluida. El remitente es responsable de calcular la estimación del tiempo de ida y vuelta ponderado R entre el remitente y el receptor, así como de determinar un valor de tiempo de espera de retransmisión razonable tRT O. En la mayoría de los casos, el uso de la fórmula simple tRT O = 4R proporciona la equidad necesaria con TCP. El remitente también es responsable de ajustar la tasa de envío T en respuesta a los nuevos valores de la tasa de eventos de pérdida p reportados por el receptor. El remitente obtiene una nueva medida para la tasa de eventos de pérdida cada vez que recibe un paquete de retroalimentación del receptor. Hasta que se informa de la primera pérdida, el remitente duplica su tasa de transmisión cada vez que recibe retroalimentación, tal como lo hace TCP durante la fase de inicio lento. El papel principal del receptor es enviar retroalimentación al emisor una vez por tiempo de ida y vuelta y calcular la tasa de eventos de pérdida incluida en los paquetes de retroalimentación. Para obtener la tasa de eventos de pérdida, el receptor mantiene un arreglo de intervalos de pérdida que contiene valores de los últimos ocho intervalos de pérdida. Un intervalo de pérdida se define como el número de paquetes recibidos correctamente entre dos eventos de pérdida. La matriz se actualiza continuamente a medida que se detectan pérdidas. Se calcula un promedio ponderado basado en la suma de los valores del intervalo de pérdida, y el inverso de la suma es la tasa de eventos de pérdida reportada, p. Al implementar Bullet, utilizamos una versión no confiable de TFRC. Queríamos un protocolo de transporte que fuera consciente de la congestión y amigable con TCP. Los paquetes perdidos se recuperaban más fácilmente de otras fuentes en lugar de esperar una retransmisión del remitente inicial. Por lo tanto, eliminamos las retransmisiones de TFRC. Además, TFRC no busca agresivamente el ancho de banda recién disponible como lo hace TCP, una característica deseable en un árbol superpuesto donde puede haber múltiples flujos competidores compartiendo los mismos enlaces. Por ejemplo, si un nodo hoja en el árbol intentara buscar agresivamente nuevo ancho de banda, podría crear congestión hasta la raíz del árbol. Al utilizar TFRC pudimos evitar estos escenarios. BULLET Bullet es un sistema eficiente de distribución de datos para aplicaciones intensivas en ancho de banda. Si bien muchos algoritmos actuales de distribución de redes superpuestas utilizan un árbol de distribución para enviar datos desde la raíz del árbol a todos los demás nodos, Bullet coloca una malla encima de un árbol de red original para aumentar el ancho de banda general a todos los nodos en el árbol. Por lo tanto, cada nodo recibe un flujo principal de su padre en el árbol y algunos flujos perpendiculares de pares seleccionados en la superposición. Esto tiene un impacto significativo en el ancho de banda cuando un solo nodo en la superposición no puede proporcionar un ancho de banda adecuado a un nodo receptor. Bullet requiere un árbol de superposición subyacente para que RanSub entregue subconjuntos aleatorios del estado de los participantes a los nodos en la superposición, informándoles de un conjunto de nodos que pueden ser buenos candidatos para recuperar datos no disponibles de ninguno de los pares actuales y el padre de los nodos. Si bien también utilizamos el árbol subyacente para la transmisión de línea base, esto no es crítico para la capacidad de Bullets de entregar datos de manera eficiente a los nodos en la superposición. Como resultado, Bullet es capaz de funcionar encima de prácticamente cualquier árbol de superposición. En nuestros experimentos, hemos ejecutado Bullet sobre árboles aleatorios y optimizados en ancho de banda creados sin conexión (con conocimiento topológico global). Bullet se registra en el árbol de superposición subyacente para que se le informe cuando la superposición cambie a medida que los nodos entran y salen o realizan transformaciones de rendimiento en la superposición. Al igual que con las superposiciones de transmisión de árboles, Bullet puede utilizar transportes estándar como TCP y UDP, así como nuestra implementación de TFRC. Para el resto de este documento, asumimos el uso de TFRC ya que nos enfocamos principalmente en la transmisión de contenido de alta velocidad de banda ancha y no requerimos entrega confiable o en orden. Para simplificar, asumimos que los paquetes se originan en la raíz del árbol y están etiquetados con números de secuencia crecientes. Cada nodo que recibe un paquete opcionalmente lo reenviará a cada uno de sus hijos, dependiendo de una serie de factores relacionados con el ancho de banda del hijo y su posición relativa en el árbol. 3.1 Encontrar pares de superposición RanSub entrega periódicamente subconjuntos de nodos seleccionados de forma uniformemente aleatoria a cada participante en la superposición. Los receptores de balas utilizan estas listas para localizar pares remotos capaces de transmitir elementos de datos faltantes con un buen ancho de banda. Los mensajes de RanSub contienen un conjunto de tickets de resumen que incluyen un pequeño resumen (120 286 bytes) de los datos que contiene cada nodo. RanSub entrega subconjuntos de estos tickets resumidos a los nodos cada época configurable (5 segundos por defecto). Cada nodo en el árbol mantiene un conjunto de trabajo de los paquetes que ha recibido hasta el momento, indexados por números de secuencia. Los nodos asocian cada conjunto de trabajo con un filtro de Bloom que mantiene un resumen de los paquetes recibidos hasta el momento. Dado que el filtro de Bloom no excede un tamaño específico (m) y nos gustaría limitar la tasa de falsos positivos, Bullet limpia periódicamente el filtro de Bloom eliminando los números de secuencia más bajos de él. Esto nos permite evitar que la población del filtro de Bloom n crezca a una tasa ilimitada. El efecto neto es que un nodo intentará recuperar paquetes durante un tiempo finito dependiendo de la tasa de llegada de paquetes. De manera similar, Bullet elimina los elementos antiguos que no son necesarios para la reconstrucción de datos de su conjunto de trabajo y ticket de resumen. Utilizamos las fases de recolección y distribución de RanSub para llevar los tickets de resumen de balas arriba y abajo del árbol. En nuestra implementación actual, utilizamos un tamaño de conjunto de 10 tickets de resumen, lo que permite que cada recolección y distribución se ajuste bien dentro del tamaño de un paquete IP no fragmentado. Aunque Bullet admite tamaños de conjunto más grandes, esperamos que este parámetro sea ajustable a las necesidades específicas de las aplicaciones. En la práctica, nuestro tamaño predeterminado de 10 produce resultados favorables para una variedad de superposiciones y topologías de red. En esencia, durante una época un nodo recibe una vista parcial resumida del estado de los sistemas en ese momento. Al recibir un subconjunto aleatorio en cada época, un nodo Bullet puede optar por conectarse con el nodo que tenga la proporción de similitud más baja en comparación con su propio resumen de ticket. Esto se hace solo cuando el nodo tiene suficiente espacio en su lista de remitentes para aceptar otro remitente (los remitentes con un rendimiento deficiente son eliminados de la lista de remitentes actual, como se describe en la sección 3.4). Una vez que un nodo ha elegido el mejor nodo, le envía una solicitud de emparejamiento que contiene el filtro de Bloom de los nodos solicitantes. Una solicitud así es aceptada por el remitente potencial si tiene suficiente espacio en su lista de receptores para el receptor entrante. De lo contrario, la solicitud de envío es rechazada (se crea espacio periódicamente en las listas de receptores como se describe más detalladamente en la sección 3.4). 3.2 Recuperación de Datos de Pares Suponiendo que tenga espacio para el nuevo par, un destinatario de la solicitud de emparejamiento instala el filtro de Bloom recibido y transmitirá periódicamente claves no presentes en el filtro de Bloom al nodo solicitante. El nodo solicitante actualizará sus filtros de Bloom instalados en cada uno de sus pares de envío periódicamente. Junto con el filtro nuevo, un nodo receptor también asignará una porción del espacio de secuencia a cada uno de sus emisores. De esta manera, un nodo puede reducir la probabilidad de que dos pares transmitan simultáneamente la misma clave, desperdiciando recursos de red. Un nodo divide el espacio de secuencia en su conjunto de trabajo actual entre cada uno de sus emisores de manera uniforme. Como se ilustra en la Figura 4, un receptor de Bullet ve el espacio de datos como una matriz de secuencias de paquetes que contienen s filas, donde s es su número actual de pares emisores. Un receptor actualiza periódicamente (cada 5 segundos por defecto) a cada emisor con su filtro de Bloom actual y el rango de secuencias cubierto en su filtro de Bloom. Esto identifica el rango de paquetes que el receptor está actualmente interesado en recuperar. Con el tiempo, este rango se desplaza como se muestra en la Figura 4-b). Además, el nodo receptor asigna a cada remitente una fila de la matriz, etiquetada mod. Un remitente reenviará paquetes a b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Remitentes = 7Mod = 2 Bajo Alto Tiempo 00000000000000000000000000000000001111111111111111111111111111111111 Figura 4: Un receptor de balas visualiza los datos como una matriz de paquetes secuenciados con filas iguales al número de remitentes pares que tiene actualmente. Solicita datos dentro del rango (Bajo, Alto) de números de secuencia basados en lo que ha recibido. a) El receptor solicita una fila específica en la matriz de secuencias de cada remitente. b) A medida que recibe más datos, el rango de secuencias avanza y el receptor solicita filas diferentes de los remitentes que tienen un número de secuencia x tal que x módulo s es igual al número de módulo. De esta manera, los receptores se registran para recibir datos disjuntos de sus pares emisores. Al especificar rangos y filas de matriz, es poco probable que un receptor reciba elementos de datos duplicados, lo que resultaría en un desperdicio de ancho de banda. Sin embargo, puede recibirse un paquete duplicado cuando un nodo padre recupera un paquete de uno de sus pares y lo retransmite a sus hijos (y descendientes). En este caso, un descendiente recibiría el paquete fuera de orden y es posible que ya lo haya recuperado de uno de sus pares. En la práctica, esta recepción derrochadora de paquetes duplicados es tolerable; menos del 10% de todos los paquetes recibidos son duplicados en nuestros experimentos. 3.3 Haciendo los Datos Disjuntos Ahora proporcionamos detalles de los mecanismos de Bullets para aumentar la facilidad con la que los nodos pueden encontrar datos disjuntos no proporcionados por los padres. Operamos bajo la premisa de que el principal desafío en la recuperación de paquetes de datos perdidos transmitidos a través de un árbol de distribución superpuesto radica en encontrar el nodo par que almacena los datos a recuperar. Muchos sistemas adoptan un enfoque jerárquico para este problema, propagando las solicitudes de reparación hacia arriba en el árbol de distribución hasta que la solicitud pueda ser satisfecha. Esto conduce en última instancia a problemas de escalabilidad en niveles superiores de la jerarquía, especialmente cuando los enlaces superpuestos tienen limitaciones de ancho de banda. Por otro lado, Bullet intenta recuperar datos perdidos de cualquier nodo no descendiente, no solo de ancestros, aumentando así la escalabilidad general del sistema. En los árboles de distribución de superposición tradicionales, los paquetes se pierden debido al transporte de transmisión y/o la red. Los nodos intentan transmitir datos tan rápido como sea posible a cada hijo y básicamente no tienen control sobre qué partes de la transmisión de datos son descartadas por el transporte o la red. Como resultado, el subsistema de transmisión en continuo no tiene control sobre cuántos nodos en el sistema finalmente recibirán una porción particular de los datos. Si pocos nodos reciben un rango particular de paquetes, recuperar estas piezas de datos se vuelve más difícil, requiriendo costos de comunicación aumentados y generando problemas de escalabilidad. Por el contrario, los nodos Bullet son conscientes del ancho de banda alcanzable para cada uno de sus hijos utilizando el transporte subyacente. Si un niño no puede recibir la tasa de transmisión que recibe el padre, el padre decide conscientemente qué parte del flujo de datos enviar al niño restringido. Además, dado que los nodos recuperan datos de participantes elegidos de forma uniforme al azar del conjunto de no descendientes, es ventajoso hacer que cada paquete transmitido sea recuperable aproximadamente por el mismo número de nodos participantes. Es decir, dado un subconjunto de nodos pares elegidos al azar, es igualmente probable que cada nodo tenga un paquete de datos en particular. Aunque no se demuestra explícitamente aquí, creemos que este enfoque maximiza la probabilidad de que se pueda recuperar un paquete de datos perdido, independientemente de cuál sea el paquete perdido. Con este fin, Bullet distribuye los paquetes entrantes entre uno o más nodos con la esperanza de que el número esperado de nodos que reciben cada paquete sea aproximadamente el mismo. Un nodo p mantiene para cada hijo, i, un factor limitante y de envío, lfi y sfi. Estos factores determinan la proporción de la tasa de datos recibidos por ps que se reenviará a cada hijo. El factor de envío sfi es la porción del flujo principal (tasa) que cada hijo debería poseer basado en el número de descendientes que el hijo tenga. Cuanto más descendientes tenga un niño, mayor debería ser la porción de datos recibidos que posea. El factor limitante LFI representa la proporción de la tasa de origen más allá del factor de envío que cada hijo puede manejar. Por ejemplo, un niño con un solo descendiente, pero con un ancho de banda alto tendría un factor de envío bajo, pero un factor limitante muy alto. Aunque el niño es responsable de poseer una pequeña parte de los datos recibidos, en realidad puede recibir una gran parte de ellos. Debido a que RanSub recopila los recuentos de descendientes di para cada hijo i, Bullet simplemente realiza una llamada a RanSub al enviar datos para determinar los factores de envío actuales de sus hijos. Para cada niño i de un total de k, establecemos el factor de envío como: sfi = diÈk j=1 dj. Además, un nodo rastrea los datos transmitidos con éxito a través del transporte. Es decir, los sockets de transporte de datos de bala son no bloqueantes; las transmisiones exitosas son intentos de envío que son aceptados por el transporte no bloqueante. Si el transporte se bloqueara en un envío (es decir, la transmisión del paquete excedería la parte justa amigable con TCP de los recursos de red), el envío falla y se cuenta como un intento de envío fallido. Cuando un paquete de datos es recibido por un padre, calcula la proporción del flujo total de datos que ha sido enviado a cada hijo, hasta el momento, en esta época. Luego asigna la propiedad del paquete actual al hijo con la proporción de envío más alejada de su sfi, como se ilustra en la Figura 5. Habiendo elegido el objetivo de un paquete en particular, el padre intenta reenviar el paquete al hijo. Si el envío no tiene éxito, el nodo debe encontrar un hijo alternativo para hacerse cargo del paquete. Esto ocurre cuando el ancho de banda de un niño no es adecuado para cumplir con sus responsabilidades basadas en sus descendientes (sfi). Para compensar, el nodo intenta encontrar de manera determinista un hijo que pueda hacerse cargo del paquete (como lo demuestra su transporte al aceptar el paquete). El resultado neto es que los niños con un ancho de banda más que adecuado poseerán más de su parte de paquetes que aquellos con un ancho de banda insuficiente. En caso de que ningún niño pueda aceptar un paquete, este debe ser descartado, correspondiendo al caso en el que la suma de todos los anchos de banda de los niños es insuficiente para servir a los recibidos para cada niño en children { if ( (child->sent / total_sent) < child->sending_factor) target_child = child; } if (!senddata( target_child->addr, msg, size, key)) { // envío exitoso target_child->sent++; target_child->child_filter.insert(got_key); sent_packet = 1; } para cada niño en children { should_send = 0; if (!sent_packet) // transferencia de propiedad should_send = 1; else // prueba de ancho de banda disponible if ( key % (1.0/child->limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child->addr, msg, size, key)) { if (!sent_packet) // recibí la propiedad child->sent++; else increase(child->limiting_factor); child->child_filter.insert(got_key); sent_packet = 1; } else // envío fallido if (sent_packet) // era para ancho de banda extra decrease(child->limiting_factor); } } Figura 5: Código pseudo para la rutina de envío de datos desvinculados de balas. Aunque hace que los datos sean más difíciles de recuperar, Bullet todavía permite la recuperación de dichos datos a sus hijos. El nodo emisor almacenará en caché el paquete de datos y lo servirá a sus pares solicitantes. Este proceso permite a sus hijos potencialmente recuperar el paquete de uno de sus propios pares, a quien podría estar disponible ancho de banda adicional. Una vez que un paquete ha sido enviado con éxito al niño propietario, el nodo intenta enviar el paquete a todos los otros niños dependiendo de los factores limitantes lfi. Para cada niño i, un nodo intenta reenviar el paquete de manera determinista si la secuencia de paquetes módulo 1/lfi es cero. Básicamente, esto identifica qué fracción de paquetes de la corriente de datos recibida debe ser reenviada a cada hijo para aprovechar el ancho de banda disponible para cada uno. Si la transmisión del paquete es exitosa, el LFI se incrementa de manera que se envíe un paquete adicional por época. Si la transmisión falla, el lfi se reduce en la misma cantidad. Esto permite que los factores limitantes de los niños se ajusten continuamente en respuesta a las condiciones cambiantes de la red. Es importante darse cuenta de que al mantener factores limitantes, estamos utilizando básicamente la retroalimentación de los niños (observando su comportamiento de transporte) para determinar los mejores datos a dejar de enviar durante los momentos en que un niño no puede manejar todo el flujo de datos del padre. En un extremo, si la suma de los anchos de banda de los niños no es suficiente para recibir todo el flujo principal, cada niño recibirá un flujo de datos completamente disjunto de los paquetes que posee. En el otro extremo, si cada 288 niños tienen un ancho de banda amplio, recibirán todo el flujo principal ya que cada lfi se establecería en 1.0. En el caso general, nuestra estrategia de propiedad intenta hacer que los datos sean disjuntos entre los subárboles hijos con la premisa rectora de que, tanto como sea posible, el número esperado de nodos que reciben un paquete sea el mismo en todos los paquetes. 3.4 Mejorando la Malla de Balas Bullet permite un número máximo de relaciones de pares. Es decir, un nodo puede tener hasta un cierto número de receptores y un cierto número de emisores (cada uno por defecto es 10 en nuestra implementación). Una serie de consideraciones pueden hacer que las relaciones de interconexión actuales no sean óptimas en un momento dado: i) la naturaleza probabilística de RanSub significa que un nodo puede no haber estado expuesto a un par apropiado de manera suficiente, ii) los receptores eligen a sus pares de manera codiciosa, y iii) las condiciones de la red están cambiando constantemente. Por ejemplo, un nodo emisor puede terminar siendo incapaz de proporcionar a otro nodo con datos muy útiles (no duplicados). En tal caso, sería ventajoso eliminar a ese remitente como par y encontrar otro par que ofrezca una mejor utilidad. Cada nodo evalúa periódicamente (cada pocos epochs de RanSub) el rendimiento del ancho de banda que está recibiendo de sus pares emisores. Un nodo eliminará a un par si está enviando demasiados paquetes duplicados en comparación con el número total de paquetes recibidos. Este umbral está configurado por defecto en un 50%. Si no se encuentra un remitente tan derrochador, un nodo eliminará al remitente que le esté entregando la menor cantidad de datos útiles. Reemplazará a este remitente con otro candidato a remitente, reservando esencialmente un espacio de prueba en su lista de remitentes. De esta manera, nos aseguramos de mantener a los remitentes más destacados hasta el momento y eliminaremos a los remitentes cuyo rendimiento empeore con las condiciones cambiantes de la red. Del mismo modo, un emisor de balas evaluará periódicamente a sus receptores. Cada receptor actualiza a los emisores sobre el ancho de banda total recibido. El remitente, al conocer la cantidad de datos que ha enviado a cada receptor, puede determinar cuál receptor se está beneficiando menos al conectarse con este remitente. Esto corresponde al receptor adquiriendo la menor porción de su ancho de banda a través de este emisor. El remitente deja caer este receptor, creando un espacio vacío para algún otro receptor de prueba. Esto es similar al concepto de destetes presentado en [24]. 4. EVALUACIÓN Hemos evaluado el rendimiento de Bullets en entornos reales de Internet, así como en el marco de emulación IP ModelNet [37]. Si bien la mayoría de nuestros experimentos utilizan ModelNet, también informamos sobre nuestra experiencia con Bullet en la plataforma de pruebas de Internet PlanetLab [31]. Además, hemos implementado una serie de árboles de red superpuestos subyacentes sobre los cuales Bullet puede ejecutarse. Debido a que Bullet funciona bien sobre un árbol de superposición creado aleatoriamente, presentamos resultados con Bullet ejecutándose sobre dicho árbol en comparación con un algoritmo de árbol de ancho de banda de cuello de botella codicioso fuera de línea que utiliza información topológica global descrita en la Sección 4.1. Todas nuestras implementaciones aprovechan una infraestructura común de desarrollo llamada MACEDON [33] que permite la especificación de algoritmos de superposición en un lenguaje específico de dominio simple. Permite reutilizar la mayoría de las funcionalidades comunes en estos sistemas distribuidos, incluyendo infraestructuras de sondeo, gestión de hilos, paso de mensajes y entorno de depuración. Como resultado, creemos que nuestras comparaciones muestran diferencias algorítmicas cualitativas en lugar de complejidades de implementación. Nuestra implementación de la lógica principal de Bullet consta de menos de 1000 líneas de código en esta infraestructura. Nuestros experimentos de ModelNet utilizan 50 Pentium4 de 2Ghz ejecutando Linux 2.4.20 e interconectados con conmutadores Ethernet de 100 Mbps y 1 Gbps. Para la mayoría de estos experimentos, multiplicamos mil instancias (participantes superpuestos) de nuestras aplicaciones superpuestas en los 50 nodos Linux (20 por máquina). En ModelNet, las transmisiones de paquetes se enrutan a través de emuladores responsables de emular con precisión el retraso de salto en salto, el ancho de banda y la congestión de una topología de red. En nuestras evaluaciones, utilizamos cuatro Pentium IIIs de 1.4Ghz ejecutando FreeBSD-4.7 como emuladores. Esta plataforma admite aproximadamente 2-3 Gbps de comunicación simultánea agregada entre los hosts finales. Para la mayoría de nuestros experimentos de ModelNet, utilizamos topologías generadas por INET de 20,000 nodos [10]. Asignamos aleatoriamente nuestros nodos participantes para que actúen como clientes conectados a nodos de un grado en la topología. Seleccionamos al azar a uno de estos participantes para que actúe como la fuente del flujo de datos. Los retardos de propagación en la topología de red se calculan en función de la ubicación relativa de los nodos de red en el plano por INET. Basándonos en la clasificación en [8], clasificamos los enlaces de red como Cliente-Stub, Stub-Stub, Transit-Stub y Transit-Transit dependiendo de su ubicación en la red. Restringimos el ancho de banda topológico al establecer el ancho de banda para cada enlace dependiendo de su tipo. Cada tipo de enlace tiene un rango de ancho de banda asociado del cual se elige el ancho de banda de forma uniforme al azar. Al cambiar estos rangos, variamos las restricciones de ancho de banda en nuestras topologías. Para nuestros experimentos, creamos tres rangos diferentes correspondientes a anchos de banda bajos, medios y altos en relación con nuestras tasas de transmisión típicas de 600-1000 Kbps especificadas en la Tabla 1. Si bien los resultados presentados de ModelNet se limitan a dos topologías con diferentes restricciones de ancho de banda, los resultados de experimentos con topologías adicionales muestran un comportamiento cualitativamente similar. No implementamos ningún esquema de codificación particular para nuestros experimentos. Más bien, asumimos que cada número de secuencia especifica directamente un bloque de datos particular y el desplazamiento del bloque para cada paquete, o estamos distribuyendo datos dentro del mismo bloque para los códigos LT, por ejemplo, al distribuir un archivo. 4.1 Árbol de ancho de banda de cuello de botella sin conexión. Uno de nuestros objetivos es determinar el rendimiento de Bullets en relación con el mejor árbol optimizado de ancho de banda posible para una topología de red dada. Esto nos permite cuantificar las posibles mejoras de una malla superpuesta construida usando Bullet en relación con el mejor árbol posible. Aunque aún no lo hemos demostrado, creemos que este problema es NP-duro. Por lo tanto, en esta sección presentamos un algoritmo codicioso simple fuera de línea para determinar la conectividad de un árbol que probablemente entregue un alto nivel de ancho de banda. En la práctica, no tenemos conocimiento de ningún algoritmo en línea escalable que pueda ofrecer el ancho de banda de un algoritmo sin conexión. Al mismo tiempo, los árboles construidos por nuestro algoritmo tienden a ser largos y delgados, lo que los hace menos resilientes a fallos e inapropiados para aplicaciones sensibles al retraso (como la transmisión multimedia). Además de cualquier comparación de rendimiento, una malla de balas tiene una profundidad mucho menor que el árbol de cuello de botella y es más resistente a fallos, como se discute en la Sección 4.6. 289 Clasificación de topología Cliente-Stub Stub-Stub Transit-Stub Transit-Transit Baja banda ancha 300-600 500-1000 1000-2000 2000-4000 Banda ancha media 800-2800 1000-4000 1000-4000 5000-10000 Banda ancha alta 1600-5600 2000-8000 2000-8000 10000-20000 Tabla 1: Rangos de ancho de banda para tipos de enlaces utilizados en nuestras topologías expresados en Kbps. Específicamente, consideramos el siguiente problema: dado un conocimiento completo de la topología (latencias de enlace individuales, ancho de banda y tasas de pérdida de paquetes), ¿cuál es el árbol de superposición que proporcionará el mayor ancho de banda a un conjunto de nodos de superposición predeterminados? Suponemos que el rendimiento del enlace de superposición más lento (el enlace cuello de botella) determina el rendimiento de todo el árbol. Por lo tanto, estamos tratando de encontrar el árbol de superposición dirigido con el enlace de cuello de botella máximo. En consecuencia, nos referimos a este problema como el árbol de cuello de botella máximo superpuesto (OMBT). En un caso simplificado, asumiendo que la congestión solo existe en los enlaces de acceso y no hay enlaces con pérdida, existe un algoritmo óptimo [23]. En el caso más general de contención en cualquier enlace físico, y cuando se permite que el sistema elija la ruta de enrutamiento entre los dos puntos finales, se sabe que este problema es NP-duro [12], incluso en ausencia de pérdidas de enlace. Para los propósitos de este documento, nuestro objetivo es determinar un buen árbol de transmisión en capas que proporcione a cada participante de la capa una cantidad sustancial de ancho de banda, evitando al mismo tiempo enlaces de capa con altas tasas de pérdida de extremo a extremo. Hacemos las siguientes suposiciones: 1. La ruta de enrutamiento entre dos participantes de la superposición es fija. Esto modela de cerca el modelo de red de superposición existente con IP para enrutamiento unicast. 2. El árbol de superposición utilizará conexiones unicast amigables con TCP para transferir datos punto a punto. 3. En ausencia de otros flujos, podemos estimar el rendimiento de un flujo amigable con TCP utilizando una fórmula de estado estable [27]. 4. Cuando varios flujos comparten el mismo enlace de cuello de botella, cada flujo puede alcanzar un rendimiento de como máximo c n, donde c es la capacidad física del enlace. Dadas estas suposiciones, nos enfocamos en estimar el rendimiento disponible entre dos participantes en la superposición. Empezamos calculando el rendimiento utilizando la fórmula de estado estable. Luego enrutamos el flujo en la red y consideramos los enlaces físicos uno a uno. En cada enlace físico, calculamos la cuota justa para cada uno de los flujos en competencia. El rendimiento de un enlace de superposición se aproxima entonces por el mínimo de las cuotas justas a lo largo de la ruta de enrutamiento y la tasa de fórmula. Si algún flujo no requiere la misma parte del enlace cuello de botella que otros flujos competidores (es decir, su rendimiento podría estar limitado por pérdidas en otro lugar de la red), entonces los otros flujos podrían terminar con una parte mayor de la que calculamos. No tenemos en cuenta esto, ya que el objetivo principal de esta estimación es simplemente evitar enlaces físicos con pérdida y altamente congestionados. Más formalmente, definimos el problema de la siguiente manera: Árbol de Máximo Cuello de Botella Superpuesto (OMBT). Dado una red física representada como un grafo G = (V, E), un conjunto de participantes de la superposición P ⊂ V, un nodo fuente (s ∈ P), ancho de banda B : E → R+, tasa de pérdida L : E → [0, 1], retardo de propagación D : E → R+ de cada enlace, conjunto de posibles enlaces de superposición O = {(v, w) | v, w ∈ P, v = w}, tabla de enrutamiento RT : O × E → {0, 1}, encontrar el árbol de superposición T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P existe un camino ov = s ❀ v) que maximiza min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) donde f(o) es la tasa de envío en estado estable de TCP, calculada a partir del tiempo de ida y vuelta d(o) = Èe∈o d(e) + Èe∈o d(e) (dado el enlace de superposición o = (v, w), o = (w, v)), y la tasa de pérdida l(o) = 1 − Ée∈o (1 − l(e)). Escribimos e ∈ o para expresar que el enlace e está incluido en la ruta de enrutamiento os (RT(o, e) = 1). Suponiendo que podemos estimar el rendimiento de un flujo, procedemos a formular un algoritmo OMBT codicioso. Este algoritmo no es óptimo, pero se encontró que un enfoque similar funcionaba bien [12]. Nuestro algoritmo es similar a la Heurística de la Ruta Más Ancha (WPH) [12], y más generalmente al algoritmo del Árbol de Expansión Mínima de Prim [32]. Durante su ejecución, mantenemos el conjunto de nodos ya presentes en el árbol y el conjunto de nodos restantes. Para hacer crecer el árbol, consideramos todos los enlaces superpuestos que van desde los nodos en el árbol hacia los nodos restantes. Seleccionamos ávidamente el nodo con el enlace de superposición de mayor rendimiento. El uso de este enlace de superposición podría hacer que enrutemos el tráfico sobre enlaces físicos atravesados por otros flujos de árbol. Dado que no volvemos a examinar el rendimiento de los nodos que ya están en el árbol, podrían terminar conectándose al árbol con enlaces superpuestos más lentos de lo estimado inicialmente. Sin embargo, al adjuntar el nodo con el ancho de banda residual más alto en cada paso, esperamos disminuir los efectos de compartir enlaces físicos después del hecho. Con las topologías sintéticas que utilizamos para nuestro entorno de emulación, no hemos encontrado que esta inexactitud afecte gravemente la calidad del árbol. 4.2 Bala vs. Transmisión. Hemos implementado una aplicación de transmisión simple que es capaz de transmitir datos sobre cualquier árbol especificado. En nuestra implementación, podemos transmitir datos a través de árboles superpuestos utilizando UDP, TFRC o TCP. La Figura 6 muestra el ancho de banda promedio que cada uno de los 1000 nodos recibe a medida que avanza el tiempo en el eje x. En este ejemplo, utilizamos TFRC para transmitir 600 Kbps a través de nuestro árbol de ancho de banda de cuello de botella fuera de línea y un árbol aleatorio (otros árboles aleatorios muestran un comportamiento cualitativamente similar). En estos experimentos, la transmisión comienza 100 segundos después de cada ejecución. Mientras que el árbol aleatorio ofrece un ancho de banda logrado de menos de 100 Kbps, nuestro algoritmo de superposición fuera de línea proporciona aproximadamente 400 Kbps de datos. Para este experimento, los anchos de banda se establecieron en el rango medio de la Tabla 1. Creemos que cualquier algoritmo de árbol de superposición de ancho de banda en línea con restricciones de grado mostraría un comportamiento similar (o inferior) a nuestro árbol de superposición optimizado de ancho de banda290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Árbol de ancho de banda cuello de botella Árbol aleatorio Figura 6: Ancho de banda logrado con el tiempo para la transmisión TFRC sobre el árbol de ancho de banda cuello de botella y un árbol aleatorio. Por lo tanto, el objetivo de Bullets es superar este límite de ancho de banda permitiendo la recepción perpendicular de datos y utilizando flujos de datos disjuntos en un intento de igualar o superar el rendimiento de nuestro algoritmo sin conexión. Para evaluar la capacidad de Bullet de superar el ancho de banda alcanzable a través de superposiciones de distribución en árbol, comparamos Bullet funcionando sobre un árbol de superposición aleatorio con el comportamiento de transmisión mostrado en la Figura 6. La Figura 7 muestra el ancho de banda promedio recibido por cada nodo (etiquetado como Total útil) con desviación estándar. El gráfico también representa la cantidad total de datos recibidos y la cantidad de datos que un nodo recibe de su padre. Para esta topología y configuración de ancho de banda, Bullet logró alcanzar un ancho de banda promedio de 500 Kbps, cinco veces más que el logrado por el árbol aleatorio y más de un 25% superior al algoritmo de ancho de banda de cuello de botella fuera de línea. Además, el ancho de banda total (incluyendo datos redundantes) recibido por cada nodo es solo ligeramente mayor que el contenido útil, lo que significa que Bullet puede lograr un alto ancho de banda mientras desperdicia pocos recursos de red. El uso de TFRC por parte de Bullets en este ejemplo garantiza que la superposición sea amigable con TCP en todo momento. El sobrecoste de control promedio por nodo es aproximadamente de 30 Kbps. Al rastrear ciertos paquetes a medida que se mueven a través del sistema, podemos adquirir estimaciones de estrés de enlace de nuestro sistema. Aunque el estrés del enlace puede ser diferente para cada paquete, ya que cada uno puede tomar un camino diferente a través de la malla superpuesta, promediamos el estrés del enlace debido a cada paquete rastreado. Para este experimento, Bullet tiene un estrés promedio de enlace de aproximadamente 1.5 con un estrés máximo absoluto de enlace de 22. La desviación estándar en la mayoría de nuestras ejecuciones es bastante alta debido al ancho de banda limitado asignado aleatoriamente a algunos enlaces Cliente-Stub y Stub-Stub. Creemos que esto es consistente con el comportamiento real en Internet, donde los clientes tienen una conectividad de red muy variada. Se muestra una porción de tiempo en la Figura 8 que representa la función de distribución acumulada (CDF) de los anchos de banda instantáneos que recibe cada nodo. El gráfico muestra que pocos nodos de clientes reciben ancho de banda insuficiente a pesar de estar limitados por el ancho de banda. La distribución aumenta bruscamente a partir de aproximadamente 500 Kbps. La gran mayoría de los nodos reciben un flujo de 500-600 Kbps. Hemos evaluado Bullet bajo una serie de restricciones de ancho de banda para determinar cómo se desempeña Bullet en relación con el ancho de banda disponible de la topología subyacente. La Tabla 1 describe los ajustes de ancho de banda representativos para nuestra velocidad de transmisión de 600 Kbps. La intención de estos ajustes es mostrar un escenario donde hay más que suficiente ancho de banda disponible para alcanzar una tasa objetivo incluso con la transmisión tradicional en árbol, un ejemplo donde es ligeramente insuficiente y otro en el que el ancho de banda disponible está bastante restringido. La Figura 9 muestra los anchos de banda logrados para Bullet y el árbol de ancho de banda de cuello de botella a lo largo del tiempo generado a partir de topologías con anchos de banda en cada rango. En todos nuestros experimentos, Bullet supera al árbol de ancho de banda de cuello de botella en un factor de hasta el 100%, dependiendo de cuánto ancho de banda esté restringido en la topología subyacente. En un extremo, teniendo un ancho de banda más que suficiente, tanto Bullet como el árbol de ancho de banda de cuello de botella pueden transmitir a la velocidad solicitada (600 Kbps en nuestro ejemplo). En el otro extremo, las topologías altamente restringidas permiten a Bullet alcanzar el doble del ancho de banda alcanzable a través del árbol de ancho de banda de cuello de botella. Para todas las demás topologías, los beneficios de Bullets se encuentran en algún punto intermedio. En nuestro ejemplo, Bullet funcionando en nuestra topología de ancho de banda limitado es capaz de superar al árbol de ancho de banda de cuello de botella en un factor del 25%. Además, queremos enfatizar que creemos que sería extremadamente difícil para cualquier algoritmo basado en árboles en línea superar el ancho de banda alcanzable por nuestro algoritmo de cuello de botella sin conexión que utiliza información topológica global. Por ejemplo, construimos un árbol de superposición de optimización de ancho de banda simple basado en Overcast [21]. Los árboles construidos dinámicamente resultantes nunca lograron más del 75% del ancho de banda de nuestro propio algoritmo sin conexión. La capacidad de Crear Balas de Datos Disjuntas para entregar niveles altos de ancho de banda a los nodos depende de su estrategia de transmisión disjunta. Es decir, cuando el ancho de banda para un niño está limitado, Bullet intenta enviar las porciones correctas de datos para facilitar la recuperación de los datos perdidos. Un nodo padre de tipo Bullet envía diferentes datos a sus hijos con la esperanza de que cada elemento de datos esté fácilmente disponible para los nodos distribuidos en todo su subárbol. Lo hace asignando la propiedad de los objetos de datos a los hijos de una manera que hace que el número esperado de nodos que contienen un objeto de datos particular sea igual para todos los objetos de datos que transmite. La Figura 10 muestra el ancho de banda resultante a lo largo del tiempo para la estrategia no disjunta en la que un nodo (y más importante aún, la raíz del árbol) intenta enviar todos los datos a cada uno de sus hijos (sujeto a pérdidas independientes en los enlaces individuales de los hijos). Debido a que los transportes de los niños limitan la velocidad de envío en cada padre, algunos datos se envían inherentemente de forma disjunta (por casualidad). Al no elegir explícitamente qué datos enviar a su hijo, este enfoque priva a Bullet del 25% de su capacidad de ancho de banda, en comparación con el caso en que se habilita nuestra estrategia de conjuntos disjuntos en la Figura 7. 4.4 Enfoques Epidémicos En esta sección, exploramos cómo Bullet se compara con enfoques de diseminación de datos que utilizan alguna forma de enrutamiento epidémico. Implementamos una forma de chismorreo, donde un nodo reenvía paquetes no duplicados a un número aleatorio de nodos en su vista local. Esta técnica no utiliza un árbol para la difusión, y es similar a lpbcast [14] (recientemente mejorado para incorporar la recuperación de objetos de datos [13]). No distribuimos paquetes cada T segundos; en su lugar, los reenviamos tan pronto como llegan. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Ancho de banda (Kbps) Tiempo (s) Total bruto Total útil Desde el padre Figura 10: Ancho de banda logrado con el tiempo utilizando transmisión de datos no disjunta. También implementamos un enfoque similar a pbcast [2] para recuperar datos faltantes de un árbol de distribución de datos. La idea aquí es que se espera que los nodos obtengan la mayor parte de sus datos de su padre. Los nodos intentan recuperar los elementos de datos faltantes a través de la difusión con pares aleatorios. En lugar de utilizar el chismorreo con un número fijo de rondas para cada paquete, utilizamos la anti-entropía con un filtro de Bloom FIFO para intentar localizar pares que tengan cualquier dato faltante localmente. Para que nuestra evaluación sea conservadora, asumimos que los nodos que utilizan el chisme y la recuperación de anti-entropía pueden mantener la membresía completa del grupo. Aunque esto podría ser difícil en la práctica, asumimos que RanSub [24] también podría aplicarse a estas ideas, específicamente en el caso de la recuperación de la anti-entropía que emplea un árbol subyacente. Además, también permitimos que ambas técnicas reutilicen otros aspectos de nuestra implementación: filtros de Bloom, transporte TFRC, etc. Para reducir el número de paquetes duplicados, utilizamos menos pares en cada ronda (5) que Bullet (10). Para nuestra configuración, encontramos experimentalmente que 5 pares resulta en el mejor rendimiento con el menor sobrecosto. En nuestros experimentos, aumentar el número de pares no mejoró el ancho de banda promedio logrado en todo el sistema. Para permitir que TFRC tenga suficiente tiempo para aumentar a la tasa de envío amigable con TCP apropiada, establecimos la duración del período de recuperación de la entropía negativa en 20 segundos. Para estos experimentos, utilizamos una topología INET de 5000 nodos sin pérdidas explícitas de enlaces físicos. Establecemos los anchos de banda de enlace de acuerdo con el rango medio de la Tabla 1, y asignamos aleatoriamente 100 participantes de superposición. La raíz elegida al azar transmite a 900 Kbps (sobre un árbol aleatorio para Bullet y un árbol codicioso para la recuperación de la anti-entropía), o envía paquetes a esa velocidad a nodos elegidos al azar para el gossiping. La Figura 11 muestra el ancho de banda resultante a lo largo del tiempo logrado por Bullet y los dos enfoques epidémicos. Como se esperaba, Bullet se acerca a proporcionar el ancho de banda objetivo a todos los participantes, logrando aproximadamente un 60 por ciento más que el chismorreo y la transmisión con anti-entropía. Las dos técnicas epidémicas envían un número excesivo de duplicados, reduciendo efectivamente el ancho de banda útil proporcionado a cada nodo. Más importante aún, ambos enfoques asignan igual importancia a otros pares, independientemente de la banda disponible y la proporción de similitud. Por otro lado, Bullet establece conexiones a largo plazo con pares que proporcionan un buen ancho de banda y contenido disjunto, y evita la mayoría de los duplicados solicitando datos disjuntos de los pares de cada nodo. 4.5 Bullet en una Red con Pérdida Para evaluar el rendimiento de Bullet bajo condiciones de red más propensas a pérdidas, hemos modificado nuestras topologías de 20,000 nodos utilizadas en experimentos anteriores para incluir pérdidas aleatorias de paquetes. ModelNet permite la especificación de una tasa de pérdida de paquetes en la descripción de un enlace de red. Nuestro objetivo al modificar estas tasas de pérdida es simular el comportamiento de encolamiento cuando la red está bajo carga debido al tráfico de red de fondo. Para lograr este comportamiento, primero modificamos todos los enlaces no transitivos en cada topología para tener una tasa de pérdida de paquetes elegida de forma aleatoria uniforme entre [0, 0.003], lo que resulta en una tasa máxima de pérdida del 0.3%. Los enlaces de tránsito también se modifican, pero con una tasa máxima de pérdida del 0.1%. Similar al enfoque en [28], designamos aleatoriamente el 5% de los enlaces en las topologías como sobrecargados y establecimos sus tasas de pérdida de manera uniformemente aleatoria entre [0.05, 0.1], lo que resultó en una tasa máxima de pérdida de paquetes del 10%. La Figura 12 muestra los anchos de banda logrados para la transmisión en Bullet y utilizando nuestro árbol de ancho de banda de cuello de botella codicioso fuera de línea. Debido a que las pérdidas afectan negativamente el ancho de banda alcanzable a través del transporte amigable con TCP y dado que los anchos de banda disminuyen estrictamente de forma monótona en un árbol de transmisión, los algoritmos basados en árboles funcionan considerablemente peor que Bullet cuando se utilizan en una red con pérdidas. En todos los casos, Bullet proporciona al menos el doble de ancho de banda que el árbol de ancho de banda de cuello de botella. Además, las pérdidas en la topología de ancho de banda bajo básicamente impiden que el árbol de ancho de banda de cuello de botella entregue datos, un artefacto que se evita con Bullet. 4.6 Rendimiento ante fallos En esta sección, discutimos el comportamiento de Bullet frente a la falla de nodos. A diferencia de los árboles de distribución de transmisión en continuo que deben detectar rápidamente y realizar transformaciones en el árbol para superar fallos, la resistencia al fallo de Bullets se basa en su capacidad para mantener un nivel más alto de ancho de banda logrado gracias a la transmisión perpendicular (entre pares). Mientras que todos los nodos bajo un nodo fallido en un árbol de distribución experimentarán una interrupción temporal en el servicio, los nodos de Bullet pueden compensar esto recibiendo datos de pares durante toda la interrupción. Debido a que Bullet, y, más importante aún, RanSub hacen uso de una superposición de árbol subyacente, parte de las propiedades de recuperación de fallos de Bullet dependerán del comportamiento de recuperación de fallos del árbol subyacente. Para los propósitos de esta discusión, simplemente asumimos el escenario más desfavorable donde un árbol subyacente no tiene recuperación de fallos. En nuestros experimentos de fallos, fallamos a uno de los hijos de la raíz (con 110 de los 1000 nodos totales como descendientes) 250 segundos después de que se inicie la transmisión de datos. Al fallar uno de los hijos de la raíz, podemos mostrar el rendimiento en el peor caso de Bullets bajo una falla de un solo nodo. En nuestro primer escenario, desactivamos la detección de fallos en RanSub para que después de que ocurra un fallo, los nodos de Bullet soliciten datos solo a sus pares actuales. Es decir, en este punto, RanSub deja de funcionar y no se crean nuevas relaciones entre pares durante el resto de la ejecución. La Figura 13 muestra el ancho de banda alcanzado por las balas a lo largo del tiempo para este caso. Mientras la tasa promedio alcanzada disminuye de 500 Kbps a 350 Kbps, la mayoría de los nodos (incluidos los descendientes del hijo raíz fallido) logran recuperar una gran parte de la tasa de datos. A continuación, habilitamos la detección de fallos de RanSub que reconoce un fallo en un nodo cuando un epoch de RanSub ha durado más de lo máximo predeterminado (5 segundos para esta prueba). En este caso, la raíz simplemente inicia la siguiente fase de distribución al expirar el tiempo de RanSub. El resultado neto es que los nodos que no son descendientes del nodo fallido seguirán recibiendo subconjuntos aleatorios actualizados que les permitirán conectarse con los nodos apropiados que reflejen las nuevas condiciones de la red. Como se muestra en la Figura 14, la falla causa una interrupción insignificante en el rendimiento. Con la detección de fallos de RanSub habilitada, los nodos aprenden rápidamente de otros nodos de los cuales recibir datos. Una vez que se completa dicha recuperación, los descendientes del nodo fallido utilizan sus relaciones de pares ya establecidas para compensar el fallo de sus ancestros. Por lo tanto, dado que Bullet es una malla superpuesta, sus características de confiabilidad superan con creces las de los árboles de distribución superpuesta típicos. 4.7 PlanetLab Esta sección contiene resultados de la implementación de Bullet en la red de prueba de área amplia PlanetLab [31]. Para 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 13: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y sin recuperación de RanSub. 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Ancho de banda (Kbps) Tiempo (s) Ancho de banda recibido Total útil Del padre Figura 14: Ancho de banda a lo largo del tiempo con una falla de nodo en el peor caso y recuperación de RanSub habilitada. En nuestro primer experimento, elegimos 47 nodos para nuestra implementación, sin que dos máquinas fueran desplegadas en el mismo sitio. Dado que actualmente hay un ancho de banda amplio disponible en toda la superposición de PlanetLab (una característica que no necesariamente es representativa de Internet en general), diseñamos este experimento para demostrar que Bullet puede lograr un ancho de banda más alto que un árbol de superposición cuando la fuente está restringida, por ejemplo, en casos de congestión en su enlace de acceso saliente, o de sobrecarga por una multitud repentina. Lo hicimos eligiendo una raíz en Europa conectada a PlanetLab con un ancho de banda bastante bajo. El nodo que seleccionamos estaba en Italia (cs.unibo.it) y teníamos otros 10 nodos de superposición en Europa. Sin un conocimiento global de la topología en PlanetLab (y en Internet), por supuesto, no podemos producir nuestro árbol de ancho de banda de cuello de botella codicioso para comparación. Corrimos Bullet sobre un árbol de superposición aleatorio durante 300 segundos mientras intentábamos transmitir a una velocidad de 1.5 Mbps. Esperamos 50 segundos antes de comenzar a transmitir datos para permitir que los nodos se unieran con éxito al árbol. Comparamos el rendimiento de Bullet con la transmisión de datos a través de múltiples árboles hechos a mano. La Figura 15 muestra nuestros resultados para dos árboles de este tipo. El buen árbol tiene todos los nodos en Europa ubicados en lo alto del árbol, cerca de la raíz. Utilizamos pathload [20] para medir el ancho de banda (Kbps) en el tiempo (s) de 0 200 400 600 800 1000 1200 0 50 100 150 200 250 para las transmisiones de Bullet y TFRC sobre diferentes árboles en PlanetLab con una raíz en Europa. Los nodos con mediciones de ancho de banda alto fueron colocados cerca de la raíz. En este caso, podemos alcanzar un ancho de banda de aproximadamente 300 Kbps. El peor árbol fue creado al establecer los hijos de las raíces como los tres nodos con las peores características de ancho de banda desde la raíz, según lo medido por pathload. Todos los niveles subsiguientes en el árbol fueron establecidos de esta manera. Para hacer una comparación, reemplazamos todos los nodos en Europa de nuestra topología con nodos en los Estados Unidos, creando una topología que solo incluía nodos estadounidenses con características de ancho de banda alto. Como se esperaba, Bullet pudo alcanzar la velocidad completa de 1.5 Mbps en este caso. Un árbol bien construido sobre esta topología de alta capacidad de ancho de banda produjo ligeramente menos de 1.5 Mbps, verificando que nuestro enfoque no sacrifica el rendimiento en condiciones de alto ancho de banda y mejora el rendimiento en escenarios de ancho de banda limitado. TRABAJO RELACIONADO Snoeren et al. [36] utilizan una malla superpuesta para lograr la entrega confiable y oportuna de datos críticos para la misión. En este sistema, cada nodo elige n padres de los cuales recibir flujos de paquetes duplicados. Dado que su principal énfasis es la fiabilidad, el sistema no intenta mejorar el ancho de banda entregado a los participantes de la superposición enviando datos disjuntos en cada nivel. Además, durante la recuperación de un fallo del padre, se limita la elección de padres de un enrutador superpuesto a nodos con un número de nivel menor que su propio número de nivel. El poder de las descargas perpendiculares se ilustra quizás mejor en Kazaa [22], la popular red de intercambio de archivos peer-to-peer. Los nodos de Kazaa están organizados en una estructura escalable y jerárquica. Los usuarios individuales buscan el contenido deseado en la estructura y proceden a descargar simultáneamente piezas potencialmente disjuntas de nodos que ya lo tienen. Dado que Kazaa no aborda el modelo de comunicación de multidifusión, una gran fracción de usuarios descargando el mismo archivo consumiría más ancho de banda que los nodos organizados en la estructura de superposición Bullet. Kazaa no utiliza codificación de borrado; por lo tanto, puede llevar bastante tiempo localizar los últimos pocos bytes. BitTorrent de 294 bits es otro ejemplo de un sistema de distribución de archivos actualmente desplegado en Internet. Utiliza rastreadores que dirigen a los descargadores a subconjuntos aleatorios de máquinas que ya tienen partes del archivo. El rastreador plantea un límite de escalabilidad, ya que actualiza continuamente la distribución del archivo en todo el sistema. Reducir la tasa de comunicación del rastreador podría afectar el rendimiento general del sistema, ya que la información podría estar desactualizada. Además, BitTorrent no emplea ninguna estrategia para difundir datos en diferentes regiones de la red, lo que potencialmente dificulta la recuperación de datos según los patrones de acceso de los clientes. Similar a Bullet, BitTorrent incorpora la noción de estrangular en cada nodo con el objetivo de identificar receptores que se benefician más al descargar de esa fuente en particular. FastReplica [11] aborda el problema de la distribución confiable y eficiente de archivos en redes de distribución de contenido (CDNs). En el algoritmo básico, los nodos se organizan en grupos de tamaño fijo (n), con información completa de la membresía del grupo en cada nodo. Para distribuir el archivo, un nodo lo divide en n porciones de tamaño igual, envía las porciones a otros miembros del grupo e instruye a descargar las piezas faltantes en paralelo de otros miembros del grupo. Dado que solo se transmite una porción fija del archivo a lo largo de cada uno de los enlaces superpuestos, el impacto de la congestión es menor que en el caso de la distribución en árbol. Sin embargo, dado que trata todos los caminos por igual, FastReplica no aprovecha al máximo los enlaces de superposición de alta velocidad en el sistema. Dado que requiere lógica de almacenamiento y reenvío de archivos en cada nivel de la jerarquía necesaria para escalar el sistema, puede que no sea aplicable a transmisiones de alta velocidad de banda ancha. Existen numerosos protocolos que tienen como objetivo añadir fiabilidad a la multidifusión de IP. En Scalable Reliable Multicast (SRM) [16], los nodos envían solicitudes de retransmisión de paquetes perdidos mediante multicast. Dos técnicas intentan mejorar la escalabilidad de este enfoque: la elección probabilística de tiempos de retransmisión y la organización de receptores en grupos jerárquicos locales de recuperación. Sin embargo, es difícil encontrar valores de temporizador apropiados y configuraciones de alcance local (a través del campo TTL) para una amplia gama de topologías, número de receptores, etc., incluso cuando se utilizan técnicas adaptativas. Un estudio reciente [2] muestra que el SRM puede tener un sobrecosto significativo debido a las solicitudes de retransmisión. Bullet está estrechamente relacionado con los esfuerzos que utilizan técnicas de propagación de datos epidémicos para recuperarse de pérdidas en el árbol de multidifusión IP no confiable. En pbcast [2], un nodo tiene membresía global de grupo y elige periódicamente un subconjunto aleatorio de pares para enviar un resumen de los paquetes recibidos. Un nodo que recibe el resumen responde al remitente con los paquetes faltantes en un orden de último en entrar, primero en salir. Lbpcast [14] aborda los problemas de escalabilidad de pbcasts (asociados con el conocimiento global) construyendo, de manera descentralizada, una vista parcial de la membresía del grupo en cada nodo. El tamaño promedio de las vistas está diseñado para permitir que un mensaje llegue a todos los participantes con alta probabilidad. Dado que lbpcast no requiere un árbol subyacente para la distribución de datos y se basa en el modelo de push-gossiping, su sobrecarga de red puede ser bastante alta. En comparación con los esfuerzos de multicast confiable, Bullet se comporta favorablemente en términos de sobrecarga de red porque los nodos no solicitan ciegamente retransmisiones a sus pares. En cambio, Bullet utiliza las vistas resumidas que obtiene a través de RanSub para guiar sus acciones hacia nodos con contenido disjunto. Además, un nodo Bullet divide la carga de retransmisión entre todos sus pares. Observamos que los nodos pbcast contienen un mecanismo para limitar la velocidad de retransmisión de paquetes y enviar diferentes paquetes en respuesta al mismo resumen. Sin embargo, esto no garantiza que los paquetes recibidos en paralelo de múltiples pares no sean duplicados. Más importante aún, los métodos de recuperación de multidifusión están limitados por el ancho de banda a través del árbol, mientras que Bullet se esfuerza por proporcionar más ancho de banda a todos los receptores al hacer que los datos estén deliberadamente disjuntos en todo el árbol. Narada [19] construye una malla optimizada para el retraso que interconecta todos los nodos participantes y mide activamente el ancho de banda disponible en los enlaces de la superposición. Luego ejecuta un protocolo de enrutamiento estándar sobre la malla de superposición para construir árboles de reenvío utilizando cada nodo como posible origen. Los nodos de Narada mantienen un conocimiento global sobre todos los participantes del grupo, limitando la escalabilidad del sistema a varios decenas de nodos. Además, el ancho de banda disponible a través de un árbol de Narada sigue estando limitado al ancho de banda disponible de cada padre. Por otro lado, el objetivo fundamental de Bullet es aumentar el ancho de banda mediante la descarga de datos disjuntos de múltiples pares. Overcast [21] es un ejemplo de un algoritmo de construcción de árbol de superposición eficiente en ancho de banda. En este sistema, todos los nodos se unen en la raíz y migran hacia abajo hasta el punto en el árbol donde aún pueden mantener un nivel mínimo de ancho de banda. Se espera que Bullet sea más resistente a las salidas de nodos que cualquier árbol, incluido Overcast. En lugar de que un nodo espere para recibir los datos que le faltan de un nuevo padre, un nodo puede comenzar a recibir datos de sus pares perpendiculares. Esta transición es fluida, ya que el nodo que se desconecta de su padre comenzará a solicitar más paquetes faltantes a sus pares durante la ronda estándar de actualización de sus filtros. El tiempo de convergencia nublado está limitado por sondas a hermanos inmediatos y ancestros. Bullet es capaz de proporcionar aproximadamente un ancho de banda objetivo sin tener un árbol completamente convergido. En paralelo a nuestro propio trabajo, SplitStream [9] también tiene como objetivo lograr una difusión de datos de alta velocidad. Opera dividiendo el flujo de multidifusión en k franjas, transmitiendo cada franja a lo largo de un árbol de multidifusión separado construido utilizando Scribe [34]. El objetivo principal del mecanismo de construcción de árboles es que cada nodo sea un nodo intermedio en como máximo un árbol (observando tanto las restricciones de ancho de banda de entrada como de salida de nodos), reduciendo así el impacto de la salida repentina de un solo nodo en el resto del sistema. El procedimiento de unión puede potencialmente sacrificar la disyunción de nodos internos lograda por Scribe. Quizás más importante aún, SplitStream asume que hay suficiente ancho de banda disponible para transportar cada franja en cada enlace del árbol, incluidos los enlaces entre la fuente de datos y las raíces de los árboles de franjas individuales elegidos de forma independiente por Scribe. Hasta cierto punto, Bullet y SplitStream son complementarios. Por ejemplo, Bullet podría correr sobre cada una de las franjas para maximizar el ancho de banda entregado a cada nodo a lo largo de cada franja. CoopNet [29] considera la transmisión de contenido en vivo en un entorno de pares, sujeto a una alta rotación de nodos. En consecuencia, el sistema favorece la resiliencia sobre la eficiencia de la red. Utiliza un enfoque centralizado para construir árboles de nodos disjuntos (similar a SplitStream) de manera aleatoria o determinista, e incluye un marco de adaptación MDC [17] basado en retroalimentación escalable de receptores que intenta maximizar la relación señal-ruido percibida por los receptores. En el caso de la transmisión bajo demanda, CoopNet [30] aborda el problema de la multitud instantánea en el servidor central redirigiendo a los clientes entrantes a un número fijo de nodos que previamente han recuperado porciones del mismo contenido. En comparación con CoopNet, Bullet proporciona a los nodos un subconjunto uniformemente aleatorio de la distribución de archivos en todo el sistema. 6. CONCLUSIONES Normalmente, la transmisión de datos en superposición de alta capacidad se realiza a través de un árbol de distribución. En este artículo, argumentamos que, de hecho, una malla superpuesta es capaz de proporcionar un ancho de banda fundamentalmente mayor. Por supuesto, se deben superar una serie de desafíos difíciles para garantizar que los nodos en la malla no reciban repetidamente los mismos datos de sus pares. Este documento presenta el diseño e implementación de Bullet, un algoritmo de construcción de superposición escalable y eficiente que supera este desafío para ofrecer mejoras significativas en el ancho de banda en comparación con las estructuras de árbol tradicionales. Específicamente, este artículo hace las siguientes contribuciones: • Presentamos el diseño y análisis de Bullet, un algoritmo de construcción de superposición que crea una malla sobre cualquier árbol de distribución y permite a los participantes de la superposición lograr un mayor rendimiento de ancho de banda que la transmisión de datos tradicional. Como beneficio relacionado, eliminamos la sobrecarga necesaria para sondear el ancho de banda disponible en las técnicas tradicionales de construcción de árboles distribuidos. • Proporcionamos una técnica para recuperar datos faltantes de pares de manera escalable y eficiente. RanSub difunde periódicamente resúmenes de conjuntos de datos recibidos por un subconjunto global de participantes que cambia de forma uniformemente aleatoria. • Proponemos un mecanismo para hacer que los datos sean disjuntos y luego distribuirlos de manera uniforme, de modo que la probabilidad de encontrar un par que contenga datos faltantes sea igual para todos los nodos. • Una evaluación a gran escala de 1000 participantes de superposición que se ejecutan en una topología de red de 20,000 nodos emulada, así como experimentación en la plataforma de pruebas de Internet PlanetLab, muestra que Bullet, ejecutándose sobre un árbol aleatorio, puede lograr el doble de rendimiento que la transmisión sobre un árbol de ancho de banda tradicional. Agradecimientos Nos gustaría agradecer a David Becker por su ayuda invaluable con nuestros experimentos en ModelNet y a Ken Yocum por su ayuda con las optimizaciones de emulación en ModelNet. Además, agradecemos a nuestra guía Barbara Liskov y a nuestros revisores anónimos que proporcionaron excelentes comentarios. 7. REFERENCIAS [1] Suman Banerjee, Bobby Bhattacharjee y Christopher Kommareddy. Multidifusión en la capa de aplicación escalable. En Actas de ACM SIGCOMM, agosto de 2002. [2] Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu y Yaron Minsky. Multidifusión bimodal. ACM Transaction on Computer Systems, 17(2), mayo de 1999. [3] Bittorrent. http://bitconjurer.org/BitTorrent. [4] Burton Bloom. Compensaciones de Espacio/Tiempo en Codificación Hash con Errores Permitidos. Comunicación de ACM, 13(7):422-426, julio de 1970. [5] Andrei Broder. Sobre la semejanza y contención de documentos. En Actas de Compresión y Complejidad de Secuencias (SEQUENCES97), 1997. [6] John W. Byers, Jeffrey Considine, Michael Mitzenmacher y Stanislav Rost. Entrega de contenido informada a través de redes superpuestas adaptativas. En Actas de ACM SIGCOMM, agosto de 2002. [7] John W. Byers, Michael Luby, Michael Mitzenmacher y Ashutosh Rege. Un enfoque de fuente digital para la distribución confiable de datos a granel. En SIGCOMM, páginas 56-67, 1998. [8] Ken Calvert, Matt Doar y Ellen W. Zegura. Modelado de la topología de Internet. Revista de Comunicaciones del IEEE, junio de 1997. [9] Miguel Castro, Peter Druschel, Anne-Marie Kermarrec, Animesh Nandi, Antony Rowstron y Atul Singh. Splitstream: Distribución de contenido de alta velocidad en entornos cooperativos. En Actas del 19º Simposio de Principios de Sistemas Operativos de la ACM, octubre de 2003. [10] Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker y Walter Willinger. Hacia la captura de topologías de Internet a nivel AS representativas. En Actas de ACM SIGMETRICS, junio de 2002. [11] Ludmila Cherkasova y Jangwon Lee. FastReplica: Distribución eficiente de archivos grandes dentro de redes de entrega de contenido. En el 4º Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [12] Reuven Cohen y Gideon Kaempfer. Un enfoque basado en Unicast para la transmisión de Multicast. En INFOCOM, páginas 440-448, 2001. [13] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. Para aparecer en ACM Transactions on Computer Systems. [14] Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne-Marie Kermarrec y Petr Kouznetsov. Transmisión probabilística ligera. En Actas de la Conferencia Internacional sobre Sistemas y Redes Confiables (DSN), 2001. [15] Sally Floyd, Mark Handley, Jitendra Padhye y Jorg Widmer. Control de congestión basado en ecuaciones para aplicaciones unicast. En SIGCOMM 2000, páginas 43-56, Estocolmo, Suecia, agosto de 2000. [16] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven McCanne y Lixia Zhang. Un marco de transmisión multicast confiable para sesiones livianas y enmarcado a nivel de aplicación. IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal.
Traducción: IEEE/ACM Transactions on Networking, 5(6):784-803, 1997. [17] Vivek K Goyal. Codificación de múltiples descripciones: la compresión se encuentra con la red. Revista de Procesamiento de Señales del IEEE, páginas 74-93, mayo de 2001. [18] Yang hua Chu, Sanjay Rao y Hui Zhang. Un caso a favor de la multidifusión en el sistema final. En Actas de la Conferencia Internacional ACM Sigmetrics 2000 sobre Medición y Modelado de Sistemas Informáticos, junio de 2000. [19] Yang hua Chu, Sanjay G. Rao, Srinivasan Seshan y Hui Zhang. Habilitando aplicaciones de conferencia en Internet utilizando una arquitectura de multidifusión superpuesta. En Actas de ACM SIGCOMM, agosto de 2001. [20] Manish Jain y Constantinos Dovrolis. Ancho de banda disponible de extremo a extremo: Metodología de medición, dinámica y relación con el rendimiento de TCP. En Actas de SIGCOMM 2002, Nueva York, 19-23 de agosto de 2002. [21] John Jannotti, David K. Gifford, Kirk L. Johnson, M. Frans Kaashoek y Jr. James W. OToole. Nublado: Multidifusión confiable con una red superpuesta. En Actas del Diseño e Implementación de Sistemas Operativos (OSDI), octubre de 2000. [22] Escritorio de medios de Kazaa. http://www.kazaa.com. [23] Min Sik Kim, Simon S. Lam y Dong-Young Lee. 296 Árbol de Distribución Óptimo para Medios de Transmisión en Internet. Informe técnico TR-02-48, Departamento de Ciencias de la Computación, Universidad de Texas en Austin, septiembre de 2002. [24] Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud y Amin Vahdat. Utilizando subconjuntos aleatorios para construir servicios de red escalables. En Actas del Simposio USENIX sobre Tecnologías y Sistemas de Internet, marzo de 2003. [25] Michael Luby. Códigos LT. En el 43º Simposio Anual de la IEEE sobre Fundamentos de la Ciencia de la Computación, 2002. [26] Michael G. Luby, Michael Mitzenmacher, M. Amin Shokrollahi, Daniel A. Spielman y Volker Stemann. Códigos Prácticos Resistentes a Pérdidas. En Actas del 29º Simposio Anual de la ACM sobre la Teoría de la Computación (STOC 97), páginas 150-159, Nueva York, mayo de 1997. Asociación para la Maquinaria Computacional. [27] Jitedra Padhye, Victor Firoiu, Don Towsley y Jim Krusoe. Modelado del rendimiento de TCP: Un modelo simple y su validación empírica. En la conferencia ACM SIGCOMM 98 sobre aplicaciones, tecnologías, arquitecturas y protocolos para la comunicación informática, páginas 303-314, Vancouver, CA, 1998. [28] Venkata N. Padmanabhan, Lili Qiu y Helen J. Wang. Inferencia basada en el servidor de la pérdida de enlaces de Internet. En Actas de IEEE Infocom, San Francisco, CA, EE. UU., 2003. [29] Venkata N. Padmanabhan, Helen J. Wang y Philip A. Chou. Transmisión entre pares resiliente. En Actas de la 11ª ICNP, Atlanta, Georgia, EE. UU., 2003. [30] Venkata N. Padmanabhan, Helen J. Wang, Philip A. Chou y Kunwadee Sripanidkulchai. Distribución de contenido de medios en streaming utilizando redes cooperativas. En ACM/IEEE NOSSDAV, 2002. [31] Larry Peterson, Tom Anderson, David Culler y Timothy Roscoe. Un plan para introducir tecnología disruptiva en Internet. En Actas de ACM HotNets-I, octubre de 2002. [32] R. C. Prim. Redes de conexión más cortas y algunas generalizaciones. En la Revista Técnica de Bell Systems, páginas 1389-1401, noviembre de 1957. [33] Adolfo Rodríguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c y Amin Vahdat. MACEDON: Metodología para la Creación Automática, Evaluación y Diseño de Redes Superpuestas. Informe técnico CS-2003-09, Universidad de Duke, julio de 2003. [34] Antony Rowstron, Anne-Marie Kermarrec, Miguel Castro y Peter Druschel. SCRIBE: El diseño de una infraestructura de notificación de eventos a gran escala. En el Tercer Taller Internacional sobre Comunicación de Grupo en Red, noviembre de 2001. [35] Stefan Savage. Sting: Una herramienta de medición de red basada en TCP. En Actas del 2º Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS-99), páginas 71-80, Berkeley, CA, 11-14 de octubre de 1999. Asociación USENIX. [36] Alex C. Snoeren, Kenneth Conley y David K. Gifford. Enrutamiento de contenido basado en malla utilizando XML. En Actas del 18º Simposio de Principios de Sistemas Operativos de la ACM (SOSP 01), octubre de 2001. [37] Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase y David Becker. Escalabilidad y precisión en un emulador de red a gran escala. En Actas del 5º Simposio sobre Diseño e Implementación de Sistemas Operativos (OSDI), diciembre de 2002. 297